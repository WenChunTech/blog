[{"categories":["Python"],"content":"opencv实现抠图和裁剪 ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:0:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"1. 抠图 步骤: 加载图像 转换图像格式(BGR –\u003e HSV) 设置阈值 通过阈值提取部分区域 显示图片 关于HSV可参考：HSL和HSV色彩空间 - 维基百科，自由的百科全书 (wikipedia.org) window_name = 'hsv' img = cv2.imread(r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\") # 设置高低阈值 hsv_low = np.array([0, 0, 0]) hsv_high = np.array([134, 255, 138]) # 将BGR转为HSV dst = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 通过HSV的高低阈值，提取图像部分区域 mask_img = cv2.inRange(dst, hsv_low, hsv_high) # 进行与位运算 img_ = cv2.bitwise_and(img, img, mask=mask_img) cv2.imshow(window_name, img_) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:1:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"2. 裁剪图片 步骤 加载图像 设置鼠标事件 - 鼠标左键单击画点\r- 鼠标右键单击闭合所画的点\r- 鼠标右键双击填充 # 触发鼠标移动事件 # cv2.CV_EVENT_MOUSEMOVE # 触发左键抬起事件 # cv2.CV_EVENT_LBUTTONUP # 触发右键按下事件 # cv2.CV_EVENT_RBUTTONDOWN # 触发右键抬起事件 # cv2.CV_EVENT_RBUTTONUP # 触发左键双击事件 # cv2.CV_EVENT_LBUTTONDBLCLK # 触发右键双击事件 # cv2.CV_EVENT_RBUTTONDBLCLK coordinates = [] window_name = 'draw' def on_mouse_callback(event, x, y, flag, param): # 左键点击,画点 if event == cv2.EVENT_LBUTTONDOWN: xy = f'{x},{y}' coordinates.append((x, y)) cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1) cv2.putText(img, xy, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness=1) cv2.imshow(window_name, img) # 右键单击，画不规则图形 elif event == cv2.EVENT_RBUTTONDOWN: pts = np.array(coordinates, np.int32) # 顶点集 #顶点坐标转为rowsx1x2, row为顶点数 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (255, 255, 255), 2) cv2.imshow(window_name, img) # 右键双击，填充颜色 elif event == cv2.EVENT_RBUTTONDBLCLK: area = np.array(coordinates) # 可以绘制多个图形 cv2.fillPoly(img, [area], (255, 255, 255)) # 绘制凸多边形 # cv2.fillConvexPoly(img, area, (255, 255, 255)) cv2.imshow(window_name, img) coordinates.clear() cv2.namedWindow(window_name) cv2.setMouseCallback(window_name, on_mouse_callback) cv2.imshow(window_name, img) cv2.waitKey(0) cv2.destroyAllWindows() Rust版opencv实现抠图 Cargo.toml [dependencies] opencv = { version = \"0.71\" } src/main.rs use opencv::{ core::{bitwise_and, in_range, Vector, CV_8UC3}, highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, imgproc::{cvt_color, COLOR_BGR2HSV}, prelude::*, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img = imread( r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\", ImreadModes::IMREAD_COLOR as i32, )?; unsafe { let mut lowerb = Vector::from_slice(\u0026[0, 0, 0u8]); let mut upperb = Vector::from_slice(\u0026[134, 255, 138u8]); let mut dst = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut mask_img = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut result = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; cvt_color(\u0026img, \u0026mut dst, COLOR_BGR2HSV, 0)?; in_range(\u0026img, \u0026mut lowerb, \u0026mut upperb, \u0026mut mask_img)?; bitwise_and(\u0026img, \u0026img, \u0026mut result, \u0026mask_img)?; imshow(\"winname\", \u0026result)?; } wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:2:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Rust"],"content":"Rust中使用opencv 因为在macos和linux上安装比较简单，这里只介绍windows上的安装 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:0:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"安装环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 安装opencv 下载地址：Releases - OpenCV 选择windows平台，下载后默认安装即可 设置环境变量 OPENCV_INCLUDE_PATHS OPENCV_LINK_LIBS OPENCV_LINK_PATHS 注意：opencv_world460这个不是固定的，需要根据下载的具体版本设置，我的版本中位于D:\\development\\opencv\\build\\x64\\vc15\\bin目录 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 安装LLVM 下载地址：Releases · llvm/llvm-project (github.com) 根据需要安装32位或者64位，有些版本可能没有这2个选项，可以选择以前的版本，没必要选择最新的版本。下载后默认安装即可，注意需要在添加LLVM到环境变量中 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"简单使用 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 确保安装了Rust环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 新建项目 cargo new opencv-rust-test ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"3. 配置Cargo.toml文件 [dependencies] opencv = { version = \"0.71\" } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:3","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"4. 将opencv_world460.dll文件拷贝到项目根目录(重要！！！) 如果opencv_world460.dll路径添加到环境变量中，应该就不需要将文件拷贝(没有实际测试) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:4","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"5. 编写代码测试环境是否正常 src/main.rs use opencv::{ highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img_path = r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\"; let img = imread(img_path, ImreadModes::IMREAD_COLOR as i32)?; imshow(\"winname\", \u0026img)?; wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:5","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"6. 运行测试 # 使用cargo命令运行看看是否正常显示图片 cargo run ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:6","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"7. 报错解决 主要参考官方文档： twistedfall/opencv-rust: Rust bindings for OpenCV 3 \u0026 4 (github.com) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:7","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Linux"],"content":"管道 ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:0:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"匿名管道(Pipe) 特点 半双工 只能用于具有亲缘关系进程(父子，兄弟) 可以视作特殊文件，读写可以使用write，read函数 #include\"stdio.h\" #include\"unistd.h\" // https://learnku.com/articles/44477 // **特点** // 1. 半双工 // 2. 只能用于具有亲缘关系进程(父子，兄弟) // 3. 可以视作特殊文件，读写可以使用write，read函数 int main() { int fd[2]; pid_t pid; char buf[32]; //创建管道 if (pipe(fd) \u003c 0) { printf(\"Create Pipe Error \\n\"); } //创建子进程 if ((pid = fork()) \u003c 0) { printf(\"Fork Error \\n\"); } else if (pid \u003e 0) { close(fd[0]); // 关闭父进程读端 write(fd[1], \"hello world\", 8); //父进程写端写入 } else { close(fd[1]); // 关闭子进程写端 read(fd[0], buf, 8); // 子进程读取父进程消息 printf(\"Child Recv Msg: %s\", buf); } } ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:1:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"命名管道(FIFO) 特点 和匿名管道不同，FIFO可以在无关进程间通信 FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 fifo_read.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"errno.h\" #include\"fcntl.h\" #include\"sys/stat.h\" int main() { int fd; int len; char buf[1024]; if (mkfifo(\"/home\", 0666) \u003c 0 \u0026\u0026 errno != EEXIST) { perror(\"Create FIFO Failed\"); } if ((fd = open(\"/home\", O_RDONLY)) \u003c 0) { perror(\"Open FIFO Failed\"); exit(1); } while ((len = read(fd, buf, 1024)) \u003e 0) { printf(\"Read Message: %s\", buf); } close(fd); return 0; } fifo_write.c #include\"stdio.h\" #include\"unistd.h\" #include\"stdlib.h\" #include\"fcntl.h\" // O_WRONLY #include\"sys/stat.h\" #include\"time.h\" // ## 命名管道(FIFO) // ** 特点** // 1. 和匿名管道不同，FIFO可以在无关进程间通信 // 2. FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 int main() { int fd; int n, i; char buf[1024]; time_t tp; printf(\"Parent Process PID:\", getpid()); if ((fd = open(\"/home\", O_WRONLY)) \u003c 0) { // 写模式打开FIFO perror(\"Open FIFO Failed\"); exit(1); } for (i = 0; i \u003c 10; ++i) { time(\u0026tp);// 当前系统时间 n = sprintf(buf, \"Process %d's time is %s\", getpid(), ctime(\u0026tp)); printf(\"Send message: %s\", buf); // 写入数据到FIFO中 if (write(fd, buf, n + 1) \u003c 0) { perror(\"Write FIFO Failed\"); close(fd); exit(1); } sleep(1); } close(fd); return 0; } 消息队列 特点 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。 msg_client.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // key值不变，要么确保ftok()的文件不被删除，要么不用ftok()，指定一个固定的key值。 // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } printf(\"Message Queue - Client key is: %d.\\n\", key); // 打开消息队列 if ((msqid = msgget(key, IPC_CREAT | 0777)) == -1) { perror(\"msgget error\"); exit(1); } // 打印消息队列ID和进程ID printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); // 添加消息，类型为888 msg.mtype = 888; sprintf(msg.mtext, \"hello, I'm client %d\", getpid()); //msgid是由msgget函数返回的消息队列标识符。 // __msgp是一个指向准备发送消息的指针，消息的数据结构却有一定的要求， // 指针msg_ptr所指向的消息结构一定要是以一个**长整型**成员变量开始的结构体，接收函数将用这个成员来确定消息的类型 msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); // msgrcv函数type参数有以下几种可能： // type == 0，返回队列中的第一个消息； // type \u003e 0，返回队列中消息类型为 type 的第一个消息； // type \u003c 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。 // 读取类型为999的消息 msgrcv(msqid, \u0026msg, 256, 999, 0); printf(\"Client: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Client: receive msg.mtype is: %d.\\n\", msg.mtype); } msg_server.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } // 打印key值 printf(\"Message Queue - Server key is: %d.\\n\", key); // 创建消息队列 if ((msqid = msgget(key, IPC_CREAT | 0700)) == -1) { perror(\"msgget error\"); exit(1); } printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); for (;;) { // 返回类型为888的第一个消息 msgrcv(msqid, \u0026msg, 256, 888, 0); printf(\"Server: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Server: receive msg.mtype is: %d.\\n\", msg.mtype); msg.mtype = 999; sprintf(msg.mtext, \"hello, I'm server %d\", getpid()); msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); } return 0; } 信号量 特点 是一个计数器 用于实现进程间互斥和同步,不是存储进程间通信数据 示例 #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/sem.h\" union semun { int val; struct semid_ds* buf; unsigned short* array; }; int init_sem(int sem_id, int value) { union semun tmp; tmp.val = value; if (semctl(sem_id, 0, SETVAL, tmp) == -1) { perror(\"Init Semaphore Error\"); return -1; } return 0; } // p操作 // 若信号量值为1，获取资源并将信号值置为-1 // 若信号量值为0，进程挂起等待 int sem_p(int sem_id) { struct sembuf sbuf; sbuf.sem_num = 0; // 序号 sbuf.sem_op = -1; // 操作 sbuf.sem_flg = SEM_UNDO; if (semop(sem_id, \u0026sbuf, 1) == -1) { perror(\"P operation Error\"); return -","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:2:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Python"],"content":"索引 import pandas as pd import numpy as np df = pd.DataFrame(np.arange(50).reshape(-1, 5), columns=list('abcde')) # 根据列标签索引 df['a'] # 或者 df.loc[:,'a'] # 根据列索引 df.iloc[:, 0] # df['a'] == df.loc[:,'a'] == df.iloc[:, 0] 计算 # 所有元素乘法 df * 10 # 指定列相乘 # 注意：不会在原地修改，需要重新赋值 df['a'] = df['a'] * 10 # 指定位置操作 df.iloc[0,3] = 100 # 也可以指定多列操作，生成新列 df['e'] = df['a'] * df['b'] 合并 df_new = pd.DataFrame(np.arange(200, 230).reshape(-1, 2), columns=['z','x']) # 注意：这里因为2个DataFrame行索引没有冲突，索引这里没有问题。 # axis 为0时以行合并(可以是实现数据追加)，为1时以列合并 pd.concat([df, df_new], axis=1) # 当下面的df的行索引不连续时，df_new就会缺少一些行的数据 df = df[df.loc[:, 'a'] % 100 == 0] pd.concat([df, df_new], axis=1) # 如果当出现上面一种情况，而又不想丢掉df_new的数据时可以使用重新索引的方法 df = df.reset_index(drop=True) pd.concat([df, df_new], axis=1) 追加数据 # 不能这样追加，需要列标签相对应 df.append([1, 3, 5, 3,5]) # 新Dataframe需要和df标签对应 new_row = pd.DataFrame(np.full((1,4), 5), columns=list('abcd')) df.append(new_row) # 也可以这样 # pd.concat([df, new_row], axis=0) Apply 使用 # 当Dateframe中不再是存数字时，就不能根据直接对列进行操作生成新列，有些时候还含有复杂的条件判断，这时候既可以使用apply函数 # 注意当新加列时需要设置axis=1 df['f'] = df[['b','c']].apply(lambda x: x[0]*100 if x[0] % 2 == 0 else x[1] - 100, axis=1) 排序 # 根据索引排序,axis=0代表行，axis=1代表列 df.sort_index() # 根据值排序,可根据多个值排序 df.sort_values(by=['a']) # 如果Dataframe含有重复列，重复列的数据又不相同，但又想按值排序，可以参考下面 # 比如说2，4列名相同，想按照第2列的值排序 # sort_col_values = df.iloc[:, 2].to_numpy() # sort_indexs = sort_col_values.argsort() # df = df.iloc[:, sort_indexs] 去重 # 使用函数drop_duplicates，其中subset指定要去重的列名，不能写列索引，即指定的相同列才进行去重，默认按照所有列相同去重，keep参数可以指定保留first，last。inplace选择是否修改原Dataframe # df.drop_duplicates(subset=[], keep='first', inplace=False) # 当Dataframe有重复列名，重复列名数据不相同时，可以将Dataframe拆分，再进行去重，去重后再合并 # 例如：2，4列名重复，需要按照1，2列去重 # 拆分 front = df.iloc[:, :2] back = df.iloc[:, 2:] # 去重 front.drop_duplicates(subset=['a', 'b'], keep='first', inplace=True) back = back.iloc[front.index, :] # 合并,这里能保证行索引能一一对应，所以不用重建索引也行。当时也可以选择重建索引 pd.concat([front, back], axis=1) 字符串操作 在pandas中可以针对需要操作列方便的使用字符串的所有函数 # 举例： # 注意：这里的replace方法默认使用正则表达式，可以添加regex=False来关闭 df['a'].str.replace(regex=False) 分组和聚合 # 对指定列进行聚合计算，agg会返回分组结果，并且列数据为聚合操作后的结果 # 使用以下访问生成聚合结果 lang = df.groupby(by='姓名').agg({'语文': 'sum'}) math = df.groupby(by='姓名').agg({'数学': 'sum'}) english = df.groupby(by='姓名').agg({'英语': 'sum'}) # pd.concat([lang, math, english], axis=1) # 以上等于下面这行。 # df.groupby(by='姓名').sum() # 如果要对不同列进行不同聚合操作，可以使用以下方法： df = df.groupby(by='姓名').agg({'语文': 'sum', '姓名': 'count'}) # 注意：如果使用以上方法会出现重复列，那就需要重命名列名 df = df.rename({'姓名': 'count'}, axis=1) # 使用transform返回DataFrame # df['count'] = df.groupby(by='姓名')['数学'].transform('sum') 读取和保存 # 读取csv提供了许多使用的选项，比如可以指定分隔符，读取部分数据，跳过表头，指定列名读取 # 参考：https://www.gairuo.com/p/pandas-read-csv pd.read_csv( filepath_or_buffer: 'FilePathOrBuffer', sep=\u003cno_default\u003e, delimiter=None, header='infer', names=\u003cno_default\u003e, index_col=None, usecols=None, squeeze=False, prefix=\u003cno_default\u003e, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None, ) # 读取excel # 参考https://www.gairuo.com/p/pandas-read-excel pd.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=Fa","date":"2022-11-12","objectID":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["pandas"],"title":"Pandas使用小结","uri":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["Numpy","Python"],"content":"Numpy 排序函数 numpy.sort(a, axis=-1, kind=None, order=None) 参数: a : 要排序的数组； axis ： 按什么轴进行排序，默认按最后一个轴进行排序； kind ：排序方法，默认是快速排序(不稳定)，可选参数有:{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’} order : 当数组定义了字段属性时，可以按照某个属性进行排序； numpy.argsort(a, axis=-1, kind=None, order=None):numpy.argsort 函数用于将数组排序后，返回数组元素从小到大依次排序的所有元素索引 参数: a : 要排序的数组 axis ： 按什么轴进行排序，默认按最后一个轴进行排序 kind ：排序方法，默认是快速排序 order : 当数组定义了字段属性时，可以按照某个属性进行排序 排序后索引解释： 比如说第一行排序后的结果为：[1, 0, 2] 表示原数组索引为 1 的数现在变为 0，原索引为 0 变为 1，原索引为 2 保持不变,即[0, 1, 2] -\u003e [1, 0, 2] numpy.lexsort(keys, axis=-1): numpy.lexsort 函数用于按照多个条件（键）进行排序，返回排序后索引。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 参数: keys ：序列或元组，要排序的不同的列 axis ：指定次排序的轴(默认为-1，即最后一个轴) 注意：根据数组的 shape 维数指定次排序轴，也就是说如果是二维数组只能设置为 0，因为 1 是著排序轴。如果 shape 为(2,3,5),则 axis 可指定为 0 或者 1 根据行和列排序 ","date":"2022-11-05","objectID":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/:0:0","tags":["numpy","sort"],"title":"Numpy使用排序","uri":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/"},{"categories":["Rust","Openssl","Crypto"],"content":"AES 加密算法 AES(Advanced Encryption Standard)，全称：高级加密标准，是一种最常见的对称加密算法 ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"配置 Rust Toml 文件 [dependencies] openssl = { version = \"0.10\", features = [\"vendored\"] } ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"示例代码 use openssl::symm::{Cipher, Crypter, Mode}; fn main() { let key = \"061cecfd897548208c76c04b6e7fb\".as_bytes(); let crypto_word: \u0026mut Vec\u003cu8\u003e = \u0026mut \"keyword\".as_bytes().to_vec(); let block_size = Cipher::aes_128_cbc().block_size(); // 添加填充 pkcs7_padding(crypto_word, block_size); let mut output = vec![0; 1024]; // 取16位密钥 let mut encrypter = Crypter::new(Cipher::aes_128_ecb(), Mode::Encrypt, \u0026key[..16], None).unwrap(); match encrypter.update(\u0026f, \u0026mut output) { Ok(size) =\u003e { eprintln!(\"size is: {size}\"); println!(\"{:?}\", \u0026output[..size]); println!(\"{:02x?}\", \u0026output[..size]); // 转换为16进制 } Err(_) =\u003e {} }; } fn pkcs7_padding(data: \u0026mut Vec\u003cu8\u003e, block_size: usize) { let padding_num = block_size - data.len() % block_size; let padding = padding_num as u8; data.append(\u0026mut [padding].repeat(padding_num)); } 参考链接： AES 加解密-CBC ECB - 独孤剑—宇枫 - 博客园 (cnblogs.com) AES 加密(3)：AES 加密模式与填充 - 知乎 (zhihu.com) ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["教程"],"content":"安装镜像 下载地址： https://ubuntu.com/download/raspberry-pi 刷入镜像到SD卡 刷入后需要重新拔插SD卡 找到system-boot盘符盘符下network-config文件 根据实际情况修改wifi配置 version: 2 ethernets: eth0: dhcp4: true optional: true #wifis: # wlan0: # dhcp4: true # optional: true # access-points: # myhomewifi: # password: \"S3kr1t\" # myworkwifi: # password: \"correct battery horse staple\" # workssid: # auth: # key-management: eap # method: peap # identity: \"me@example.com\" # password: \"passw0rd\" # ca-certificate: /etc/my_ca.pem 开机查找wifi 查找树莓派ip地址可用方法： 登录路由器后台查看连接设备中树莓派IP 使用Advanced_IP_Scanner软件 连接ssh 初始用户名和密码都是：ubuntu ssh ubuntu@ip 注意：第一次登陆会强制要求修改密码，修改后再次登录即可，密码也不能太短 换源 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改文件内容为: deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-backports main restricted universe multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security multiverse 更新 sudo apt update sudo apt upgrade -y 参考链接： 树莓派折腾记（一）– 安装系统（Ubuntu Server 20.04.1） | 修行的技术阁 (mrxiuxing.com) ","date":"2022-10-24","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/:0:0","tags":["raspberry"],"title":"树莓派安装Ubutnu无显示器网络初次开机","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/"},{"categories":["教程"],"content":"Hugo博客从零到发布 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:0:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"1. 安装 安装hugo: 下载地址：https://github.com/gohugoio/hugo/releases/tag/v0.104.3 注意： 有些主题需要下载extended版本 安装git： 下载地址：https://git-scm.com/ ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:1:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"2. 配置远程仓库，并新建一个空项目(不需要README.md文件)，名字一般和站点名相同 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:2:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 本地部署 新建站点并配置git hugo new site your_site_name # 下载你需要的主题的压缩包放到theme目录下或者使用`git submodule`拉取，例： git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt # 根据主题文档配置config.toml文件，如果只有一个主题可直接在项目根目录下的config.toml文件配置 # 0. 当本地可以正常预览站点时运行，hugo命令打包，生成静态文件 # 1. 使用git初始化站点 # 2. 添加远程仓库 git remote add origin remtoe_url # 3. 拉取远程 # 4. 提交当前代码 # 4. 新建分支(例如：release)，命令如下： git switch -c release # 或者 git checkout -b release # 5. 合并主分支分支public目录到当前分支，命令如下： git checkout master public/** # 6. 移动public下所有内容到项目根目录下，例如： mv public/* . # 7. 再提交当前分支内容 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:3:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 推送到远程 # 使用git推送到远程仓库 git switch master git push -u origin master git switch release git push -u origin release # 将远程仓库默认分支设置为release ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:4:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"4. 使用cloudflare发布 注册一个cloudflare账号：https://dash.cloudflare.com/ 点击Pages，选择创建项目下连接到Git，然后根据需要配置相应信息 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:5:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"}]