[{"categories":["Golang"],"content":"Golang内存模型 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:0:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"介绍 Golang内存模型是Golang程序员必须了解的一个重要概念，它定义了Golang程序中的内存访问规则，保证了Golang程序的正确性。Golang内存模型是基于happens-before关系的，happens-before关系是一个偏序关系，它定义了程序中事件的顺序关系。在Golang内存模型中，happens-before关系定义了内存访问的顺序关系，保证了Golang程序的正确性。 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"happens-before关系 happens-before是很多语言都拥有的一个术语，定义通常是：假设A和B表示一个多线程的程序执行的两个操作。如果A happens-before B，那么A操作对内存的影响 将对执行B的线程(且执行B之前)可见。 它有几个特点： A happens-before B并不意味着A在B之前发生 A在B之前发生并不意味着A happens-before B 具有传递性：如果A happens-before B，B happens-before C，那么A happens-before C 注意：happens-before并不是指时序关系，并不是说A happens-before B就表示操作A在操作B之前发生，它就是一个术语，就像光年不是时间单位一样 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"happens-before关系在Golang中的场景定义 如果操作A和B在相同的线程中执行，并且A操作的声明在B之前，那么A happens-before B。（这条规则基本上大部分语言都适用） 初始化：main.init happens-before main.main goroutine：如果操作A是一个goroutine的创建操作，操作B是对应goroutine的启动操作，那么A happens-before B。 goroutine：如果操作A是一个goroutine的启动操作，操作B是对应goroutine的销毁操作，那么A happens-before B。 channel：如果 ch 是一个 buffered channel，则 ch\u003c-val(写) happens-before val \u003c- ch(读) channel: 如果 ch 是一个 buffered channel 则 close(ch) happens-before val \u003c- ch(读) \u0026 val == isZero(val) channel: 如果 ch 是一个 unbuffered channel 则，val\u003c-ch(读) happens-before ch\u003c-val(写) once: f() 在 once.Do(f)中的调用 happens-before once.Do(f)的返回 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:3:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"实例 package main var a string var done bool func setup() { a = \"hello, world\" done = true } func main() { go setup() for !done { } print(a) } 问：上面的代码会输出什么？\r1. 第一种情况：输出hello, world\r2. 第三种情况：输出空字符串\r3. 第二种情况：死循环\r","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:4:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"参考链接 https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html https://go.cyub.vip/concurrency/memory-model/ https://research.swtch.com/plmm https://go.dev/ref/mem https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/mem/ ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:5:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Debian","Btrfs"],"content":"Debian Sid配置Btrfs文件系统 ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"安装Debian Testing 安装时选择Advanced options -\u003e Expert install 当提示“设置用户和密码”时，不允许以 root 身份登录。这样我们的用户将被自动设置在“sudo”组中。 其他选择和正常安装一样，直到到达Partition disks(磁盘分区)界面，选择手动分区 选择gpt 创建一个EFI分区，大小为512M，文件系统为EFI System Partition 创建一个/boot分区，大小为1024M，文件系统为ext4（如果需要加密则创建此分区） 剩下的空间创建一个根分区，文件系统为btrfs，分区完成。 当询问是否要返回并创建 SWAP 分区时，选择“否”，我们不需要磁盘上的 SWAP 分区，因为我们将使用 ZRAM 进行 SWAP 在选择Install the base system之前，按alt+ctrl+F2(笔记本可能是： alt+ctrl+fn+F2)切换到tty2，执行以下命令 df umount /target/boot/efi/ # 可选 umount /target/boot/ umount /target/ # 根据df命令选择对应的分区 mount /dev/sda2 /mnt cd /mnt mv @rootfs @ # 创建其他子卷 btrfs su cr @snapshots btrfs su cr @home btrfs su cr @opt btrfs su cr @log btrfs su cr @cache btrfs su cr @crash btrfs su cr @tmp btrfs su cr @spool btrfs su cr @images btrfs su cr @containers # GNOME related subvolumes，如果不使用GNOME则不需要，在安装gnome桌面前不能挂载此2个子卷，否则会出现fstab挂载错误 btrfs su cr @AccountsService btrfs su cr @gdm # 挂载子卷 mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@ /dev/mapper/sda2 /target # 创建其他子卷挂载目录 cd /target mkdir -p .snapshots mkdir -p home mkdir -p opt mkdir -p var/log mkdir -p var/cache mkdir -p var/crash mkdir -p var/tmp mkdir -p var/spool mkdir -p var/lib/libvirt/images mkdir -p var/lib/containers # 如果不安装GNOME则不需要此步骤 mkdir -p var/lib/AccountsService mkdir -p var/lib/gdm3 # 挂载子卷到指定目录 mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@snapshots /dev/mapper/sda2 /target/.snapshots mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@home /dev/mapper/sda2 /target/home mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@home /dev/mapper/sda2 /target/opt mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@log /dev/mapper/sda2 /target/var/log mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@cache /dev/mapper/sda2 /target/var/cache mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@crash /dev/mapper/sda2 /target/var/crash mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@tmp /dev/mapper/sda2 /target/var/tmp mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@spool /dev/mapper/sda2 /target/var/spool mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@images /dev/mapper/sda2 /target/var/lib/libvirt/images mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@containers /dev/mapper/sda2 /target/var/lib/containers # 下面两个步骤先不执行，等安装GNOME桌面后再执行 # mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@AccountsService /dev/mapper/sda2 /target/var/lib/AccountsService # mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@gdm /dev/mapper/sda2 /target/var/lib/gdm3 # 再挂载BOOT分区，EFI分区 # mount /dev/sda2 boot mount /dev/sda1 boot/efi # 持久化挂载 nano etc/fstab /dev/mapper/$VOLUME_GROUP / btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@ 0 0 /dev/mapper/$VOLUME_GROUP /.snapshots btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@snapshots 0 0 /dev/mapper/$VOLUME_GROUP /home btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@home 0 0 /dev/mapper/$VOLUME_GROUP /opt btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@opt 0 0 /dev/mapper/$VOLUME_GROUP /var/log btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@log 0 0 /dev/mapper/$VOLUME_GROUP /var/cache btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@cache 0 0 /dev/mapper/$VOLUME_GROUP /var/crash btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@crash 0 0 /dev/mapper/$VOLUME_GROUP /var/tmp btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@tmp 0 0 /dev/mapper/$VOLUME_GROUP /var/spool btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@spool 0 0 /dev/mapper/$VOLUME_GROUP /var/lib/libvirt/images btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@images 0 0 /","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"配置ZRAM 执行命令安装zram sudo apt update \u0026\u0026 sudo apt upgrade sudo apt install zram-tools 更改配置文件sudo nano /etc/default/zramswap将ALGORITHM改为zstd，将SIZE改为8192(即8GB)的内存大小 ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"配置Snapper 安装工具 sudo apt install snapper inotify-tools git make 执行配置 # 因为snapper创建配置时会在当前执行目录下面一个.snapshots子卷和.snapshots目录，而我们希望将/.snapshots挂载到@shapshots子卷，所以需要先卸载@shapshots子卷 cd sudo umount /.snapshots sudo rm -rf .snapshots # 创建配置 sudo snapper -c root create-config / # 删除snapper自己创建/.snapshots子卷,并将/.snapshots挂载到@snapshots子卷 sudo btrfs subvolume delete /.snapshots sudo mkdir /.snapshots sudo mount -av 配置Snapper自动快照 关闭开机快照 sudo systemctl disable snapper-boot.timer 关闭timeline快照 sudo snapper -c root set-config 'TIMELINE_CREATE=no' 开启apt pre/post快照,并优化打印信息 snapper会自动开启apt pre/post快照，但是默认打印命令不够详细，可以通过以下命令优化 3.1 修改/etc/apt/apt.conf.d/80snapper文件内容为 # https://gist.github.com/imthenachoman/f722f6d08dfb404fed2a3b2d83263118 # https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=770938 DPkg::Pre-Invoke { \"/path/to/dpkg-pre-post-snapper.sh pre\"; }; DPkg::Post-Invoke { \"/path/to/dpkg-pre-post-snapper.sh post\"; }; 3.2 创建/path/to/dpkg-pre-post-snapper.sh文件内容为 #!/bin/bash # this script is an enhancement of https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=770938 # we need to work up the process tree to find the apt command that triggered the call to this script # get the initial PID PID=$$ # find the apt command by working up the process tree # loop until # - PID is empty # - PID is 1 # - or PID command is apt while [[ -n \"$PID\" \u0026\u0026 \"$PID\" != \"1\" \u0026\u0026 \"$(ps -ho comm \"${PID}\")\" != \"apt\" ]] ; do # the current PID is not the apt command so go up one by getting the parent PID of hte current PID PID=$(ps -ho ppid \"$PID\" | xargs) done SNAPPER_DESCRIPTION=\"apt\" # assuming we found the apt command, get the full args if [[ \"$(ps -ho comm \"${PID}\")\" = \"apt\" ]] ; then SNAPPER_DESCRIPTION=\"$(ps -ho args \"${PID}\")\" fi # main event # source /etc/default/snapper if it exists if [ -e /etc/default/snapper ] ; then . /etc/default/snapper fi # what action are we taking if [ \"$1\" = \"pre\" ] ; then # pre, so take a pre snapshot # if snapper is installed # and if snapper snapshots are not being disabled using the DISABLE_APT_SNAPSHOT variable # and if /etc/snapper/configs/root exists if [ -x /usr/bin/snapper ] \u0026\u0026 [ ! x$DISABLE_APT_SNAPSHOT = 'xyes' ] \u0026\u0026 [ -e /etc/snapper/configs/root ] ; then # delete any lingering temp files rm -f /var/tmp/snapper-apt || true # create a snapshot # and save the snapshot number for reference later snapper create -d \"${SNAPPER_DESCRIPTION}\" -c number -t pre -p \u003e /var/tmp/snapper-apt || true # clean up snapper snapper cleanup number || true fi elif [ \"$1\" = \"post\" ] ; then # post, so take a post snapshot # if snapper is installed # and if snapper snapshots are not being disabled using the DISABLE_APT_SNAPSHOT variable # and if the temp file with the snapshot number from the pre snapshot exists if [ -x /usr/bin/snapper ] \u0026\u0026 [ ! x$DISABLE_APT_SNAPSHOT = 'xyes' ] \u0026\u0026 [ -e /var/tmp/snapper-apt ] then # take a post snapshot and link it to the # of the pre snapshot snapper create -d \"${SNAPPER_DESCRIPTION}\" -c number -t post --pre-number=`cat /var/tmp/snapper-apt` || true # clean up snapper snapper cleanup number || true fi fi 配置sudo使用snapper使用权限 sudo snapper -c root set-config 'ALLOW_GROUPS=sudo' 'SYNC_ACL=yes' 配置GRUB-BTRFS 5.1 安装 GRUB-BTRFS在Debian上不可用,所以需要编译安装 cd git clone https://github.com/Antynea/grub-btrfs.git cd grub-btrfs sudo make install 5.2 配置 # To start the daemon run: sudo systemctl start grub-btrfsd # To activate it during system startup, run: sudo systemctl enable grub-btrfsd 5.3 下载的grub-btrfs代码可以清除了 cd .. sudo rm -rf grub-btrfs/ grub-btrfs可以在GRUB中显示当前系统中的所有快照,如果系统出问题了,可以从grub选择之前正常的快照回滚到可以正常启动的系统 ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"安装Gnome桌面 sudo apt install gnome-core ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:4:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["kotlin"],"content":"Kotlin程序设计初级篇 注意： 在开始学习之前，推荐各位小伙伴有一定的编程语言基础，前置课程：《JavaSE 教程》或《C 语言程序设计》如果没有其他语言的基础，在学习Kotlin时会非常吃力，这门语言语法糖多到爆炸。 Kotlin是一种现代但已经成熟的编程语言，旨在让开发人员更快乐。它简洁、安全、可与Java和其他语言互操作，并提供了许多在多个平台之间重用代码的方法。它由JetBrains公司于2011年设计和开发，并在2016年正式发布。Kotlin旨在解决Java语言在编码效率和代码质量方面存在的问题，并且与Java语言完全兼容。Kotlin通过简化语法、提供更强大的功能以及减少样板代码的编写，使得开发者能够更高效地编写清晰、简洁而又安全的代码。 Kotlin语言名字的来源是基于一个古老斯拉夫部落的名字。JetBrains开发Kotlin的初衷是为了在Android开发上取代Java，并且作为一门通用的编程语言。Kotlin通过减少样板代码和增加现代化的语言特性，提供了更好的工具和库来简化Android应用开发。由于Kotlin的设计理念和特性吸引了广泛的开发者关注，它也迅速被接受并得到了广泛的使用。现在，Kotlin已成为一门流行的编程语言，被许多开发者用于Android应用开发、服务器端开发以及其他领域的软件开发中。 官方网站：https://www.jetbrains.com/opensource/kotlin/ Kotlin 是一种现代化的静态类型编程语言，具有以下优势： 与Java互操作性强：Kotlin 可以与现有的 Java 代码无缝地互操作，允许开发者在现有的项目中逐步采用 Kotlin，而不需要重写整个项目。这使得 Kotlin 成为 Android 应用开发的理想选择。 简洁易读：Kotlin 的语法简洁并具有更好的可读性，减少了样板代码的编写。相比 Java，Kotlin 可以使用更少的代码来实现同样的功能，从而提高开发效率。 空安全性：Kotlin 对空值进行了更好的处理。在 Kotlin 中，变量默认是非空的，如果需要使用可能为空的值，需要显式声明类型为可空。这有助于减少空指针异常的发生。 函数式编程支持：Kotlin 支持函数式编程的特性，如高阶函数、lambda 表达式和函数式编程的集合操作等。这些特性可以让开发者编写更简洁、可维护的代码，并提高代码的表达能力。 扩展函数：Kotlin 允许开发者为某个类添加新的方法，而不需要修改该类的源代码。这种扩展函数的特性可以为开发者提供更灵活的方式来扩展现有的类库。 协程支持：Kotlin 引入了协程（coroutine）机制，使得异步操作更易于管理和编写。通过使用协程，开发者可以使用顺序的方式编写并发代码，并避免了回调地狱的问题。 总的来说，Kotlin 是一门功能丰富、可读性高、与 Java 无缝互操作的编程语言，适用于 Android、Web 后端开发等多种场景。 正是因为Kotlin与Java的高度兼容性，再加上简洁、安全、互操作性强等特点，让Kotlin一度成为Android开发的官方指定语言。并且随着时代的发展，现在它不仅仅可以开发安卓应用程序，也可以开发iOS程序，甚至开发Java后端、开发桌面应用程序等。其简洁高效的语法也受到一众开发者追捧。 从下节课开始，我们就来正式学习一下Kotlin语言，Kotlin，启动！ ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:0:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"走进新语言 欢迎大家进入到Kotlin程序设计的学习中，我们将从开发环境配置开始，为各位小伙伴讲解。 编程语言可以被视为人与计算机之间进行交流的方式。它是一种用于编写计算机程序的形式化语言，用于描述计算机任务的操作步骤、算法和数据结构。简单来说，就是以计算机能听懂的语言告诉计算机我们要做什么，然后让计算机来做我们想做的事情，从而解决我们生活中各种各样的问题。 编程语言可以分为多种类型，包括低级语言和高级语言。低级语言（如汇编语言）与计算机硬件更接近，对计算机底层操作进行更精细的控制，但编写和理解起来较为复杂。高级语言（如Java、Python等）则更加易读、易写，并提供了更高层次的抽象，使得程序员能够更专注于问题的解决和算法的设计。而我们这里要学习的Kotlin语言，也属于高级语言的一种，能够使用我们人类更容易理解的语法来编写程序。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"开发环境配置 要开发Kotlin程序，我们首先需要安装Java环境，我们一般使用Kotlin都是在JVM平台上进行开发（Kotlin同样可以开发系统原生程序、JavaScript程序、安卓程序、iOS程序等）因为Java支持跨平台，能在编译后再任意平台上运行，因此，我们将JVM环境中学习Kotlin程序的开发，接下来我们要安装两个环境： Java 8 环境 Kotlin 1.9.0 环境 首先我们来安装Java 8 环境，这里我们需要去下载JDK，这里推荐安装免费的ZuluJDK：https://www.azul.com/downloads/?version=java-8-lts\u0026package=jdk 在这里选择自己的操作系统对应的安装包： 比如Windows下，我们就选择.msi的安装包即可（MacOS、Linux下同样选择对应的即可） 下载完成后，我们直接双击安装： **注意，这里不建议各位小伙伴去修改安装的位置！**新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。 剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以） 我们直接输入java命令即可： 如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。 输入java -version可以查看当前安装的JDK版本： 只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。 接着是Kotlin 1.9.0 环境，我们需要前往：https://github.com/JetBrains/kotlin/releases 下载最新的Kotlin编译器并进行安装： 这里我们可以直接解压然后拖入到刚刚Java安装的同级目录下，我这里是 C:\\Program Files 文件夹，也可以自定义位置，但是不推荐，因为很多小伙伴配环境直接配到自闭。 然后我们需要手动配置一下环境变量，打开系统环境变量配置： 添加路径 C:\\Program Files\\kotlinc\\bin 到Path环境变量下即可，然后我们依然打开CMD查看是否安装成功，输入kotlinc -version来查看安装情况： 这样我们就完成了所有环境的安装，我们可以来体验一下编写并且编译运行一个简单的Kotlin程序，我们新建一个文本文档，命名为Main.txt（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容： fun main() { println(\"Hello, World!\") } 现在看不懂代码没关系，直接用就行，我们后面会一点一点讲解的。 编辑好之后，保存退出，接着我们将文件的后缀名称修改为.kt这是Java源程序文件的后缀名称： 此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径： 我们使用cd命令先进入到这个目录下： 要编译一个Kotlin程序，我们需要使用kotlinc命令来进行，将我们的程序编译为jar包，并包含Kotlin的运行时依赖： kotlinc Main.kt -include-runtime -d Main.jar 执行后，可以看到目录下多出来了一个.jar文件，这是一个打包好的标准Java程序： 接着我们就可以将其交给JVM运行了，我们直接使用java -jar命令即可： 可以看到打印了一个 Hello World! 字样，这样我们的第一个Kotlin程序就成功运行了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"IDEA安装与使用 前面我们介绍了Kotlin开发环境的安装以及成功编译运行了我们的第一个Kotlin应用程序。 但是我们发现，如果我们以后都使用记事本来进行Kotlin程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：IntelliJ IDEA（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好） IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。 下载地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE 我们直接点击下载即可，注意要下载下面的社区版，不要下载到终极版了： 这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，功能更强大，体验更友好） 下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！ 这里勾选一下创建桌面快捷方式就行： 安装完成后，我们直接打开就可以了： 此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可： 我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了： 如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题，我们还可以在下面的设置中开启新UI以及更换各种字体、字体大小等个性化内容。 如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下： 接下来，我们来看看如何使用IDEA编写Kotlin程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目： 此时来到创建页面： 名称： 你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。 位置： 项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。 语言： IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。 构建系统： 在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。 JDK： 就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦） 当然，如果JDK这里没有自动识别到，那么就手动添加一下： 没问题之后，我们直接创建项目： 进入之后，可以看到已经自动帮助我们创建好了一个kt源文件，跟我们之前的例子是一样的。要编译运行我们的Kotlin程序，只需要直接点击左边的三角形（启动按钮）即可： 点击之后，会在下方自动开始构建： 完成之后，就可以在控制台看到输出的内容了： 我们可以看到新增加了一个out目录，这里面就是刚刚编译好的.class文件，这种文件是Java的字节码文件，可以直接运行在JVM中： IDEA非常强大，即使是编译之后的字节码文件，也可以反编译回原代码的样子： 如果我们想写一个新的Kotlin项目，可以退出当前项目重新创建： 此时项目列表中就有我们刚刚创建的Java项目了： 如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习： 会有一个专门的引导教程项目，来教你如何使用各项功能： 熟悉了IDEA的使用之后，下节课我们就可以正式地开始学习Kotlin语言的语法了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"程序代码基本结构 还记得我们之前使用的示例代码吗？ fun main() { println(\"Hello World!\") } 这段代码要实现的功能很简单，就是将 Hello World 这段文本信息输出到控制台。 在编写代码时，注意需要区分大小写，Kotlin语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错： 只要源代码中存在报错的地方，就无法正常完成编译得到字节码文件，强行运行会提示构建失败： 注意这里包括的花括号是成对出现的，并且一一对应。 所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是： fun main() { } 可以看到外面使用花括号前添加了fun main()，这是我们整个程序的入口点，我们的Kotlin程序也是从这里开始从上往下执行的。而其中的println语句就是用于打印其括号中包裹的文本，我们可以看到这个文本信息使用了\"\"进行囊括，否则会报错： println(\"Hello World!\") 这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上。 比如下面的代码，我们就可以实现先打印Hello World!，然后再打印 KFC vivo 50 到控制台： fun main() { println(\"Hello World!\") println(\"KFC vivo 50\") } 效果如下： 注意我们上面编写的打印语句其实是函数的调用（后续会进行讲解）不能写到同一行中，否则编译器会认为是同一句代码，同样会导致编译不通过： 如果实在要写到同一行，那么我们需要在上一句代码最后添加;来表示上一段的结束： 再比如下面的代码： 这里我们尝试在中途换行或是添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意换行或是添加没必要的空格。注意随意换行和空格仅限于可分割区域，比如println本身是一个函数的完整名称，这就不能从中间直接断开，否则语义就完全不一样了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"程序注释编写 我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思： 但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。 这种情况，我们就需要告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了： 添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了： 那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记： 多行可以使用/*和*/的组合来囊括需要编写的注释内容。 当然还有一种方式就是使用/**来进行更加详细的文档注释： 这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。 这样，我们编写Kotlin程序的基本规则就讲解完毕了，从下一个小节开始，我们将先给各位小伙伴介绍我们的基本数据类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"变量与基本类型 我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。那么，什么是变量呢？我们在数学中其实已经学习过变量了： 变量，指值可以变的量。变量以非数字的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。 比如一个公式 x + 2 = 6 此时x就是一个变量，变量往往代表着某个值，比如这里的x就代表的是4这个值。在Kotlin中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的，在程序中，我们也可以使用变量，并且变量具有类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"计算机中的二进制表示（选学） 进入到变量的学习之前，我们需要先补充一下计算机的底层知识，否则各位小伙伴后面听起来会很困难。 在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。 注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。 十进制的7 -\u003e 在二进制中为 111 = 2^2 + 2^1 + 2^0 现在有4个bit位，最大能够表示多大的数字呢？ 最小：0000 =\u003e 0 最大：1111 =\u003e 23+22+21+20 =\u003e 8 + 4 + 2 + 1 = 15 在Kotlin中，无论是小数还是整数，他们可以带有符号，因此，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）： 最小：1111 =\u003e -(22+21+2^0) =\u003e -7 最大：0111 =\u003e +(22+21+2^0) =\u003e +7 =\u003e 7 现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例： 1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！） 我们得创造一种更好的表示方式！于是我们引入了反码： 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法： 1+(-1) = 0001 + 1110 = 1111 =\u003e -0 （直接相加，这样就简单多了！） 思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下： 正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8） 对补码再求一次补码就可得该补码对应的原码。 比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。 所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算： 1+(-1) = 0001 + 1111 = (1)0000 =\u003e +0 （现在无论你怎么算，也不会有-0了！） 所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Kotlin使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"变量的声明与使用 要声明一个变量，我们需要使用以下格式： var [变量名称] : [数据类型] 这里的数据类型我们会在下节课开始逐步讲解，比如整数就是Int类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像x一样，这个名称我们可以随便起一个，但是注意要满足以下要求： 标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。 变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。 不能有空格、@、#、+、-、/ 等符号。 应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。 不可以是 true 和 false。 不能与Kotlin语言的关键字或是基本数据类型重名 当然各位小伙伴没必要刻意去进行记忆有哪些关键字，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如： 深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。 比如现在我们想要定义一个整数（Int）类型的变量a，那么就可以这样编写： fun main() { var a : Int } 但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量： fun main() { var a : Int = 10 } 不过由于变量在一开始就被赋值为10这个整数，此时类型是确定的，Kotlin的编译器非常聪明，它支持自动推断类型，这里会自动将变量a的类型推断为Int类型，我们可以直接省略掉后面的Int类型： fun main() { var a = 10 } 或者我们可以在使用时再对其进行赋值： fun main() { var a : Int a = 10 } 是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台： fun main() { var a = 10 println(a) } 变量的值也可以在中途进行修改： fun main() { var a = 666 a = 777 println(a) //这里打印得到的就是777 } 变量的值也可以直接指定为其他变量的值： fun main() { var a = 10 var b = a //直接让b等于a，那么a的值就会给到b println(b) //这里输出的就是10了 } 我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）： fun main() { var a = 9 //a初始值为9 a = a + 1 //a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧 println(a) //最后得到的结果就是10了 } 对于那些只读的变量，我们可以将其表示为一个常量，使用val关键字： fun main() { val a = 666 //使用val关键字，表示这是一个常量 a = 777; //常量的值不允许发生修改 } 编译时得到报错： 常量的值只有第一次赋值可以修改，其他任何情况下都不行： fun main() { val a: Int a = 777; } 至此，声明变量和常量我们就介绍完毕了，下一部分我们将介绍常见的一些数据类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数字类型介绍 前面我们了解了如何创建变量，并进行使用，但是我们知道，不同的数据往往对应着不同的类型，比如整数我们使用的就是Int，而这一部分我们将学习更多的基本数据类型。 Kotlin提供了一组表示数字的内置类型，对于整数，有四种不同大小的类型，因此，值范围： 类型 大小（位） 最小值 最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-2^31) 2,147,483,647（2^31-1） Long 64 -9,223,372,036,854,775,808 (-2^63) 9,223,372,036,854,775,807（2^63 - 1） 为什么不同的数据类型有着值范围呢？这是因为我们的计算机底层是采用0和1表示数据的，并且数据的表示位数有限，我们以二进制来计算，就像下面这样： 1 + 1 = 10 可能很多小伙伴会好奇，为什么1 + 1得到的结果是数字十？这是因为二进制中只有0和1，因此只要满二就进一，所以就变成这样的结果了，如果各位是初次学习，可能会不太好理解。 这里以上面的8位大小的Byte类型为例，在计算机底层存储数据时，只有8个bit位（一个bit位就可以表示一个0或1）来存储它，那么它能表示的最大值和最小值就是： 00000000 ~ 11111111 转换为十进制就是 0 ~ 255 不过为了能够表示负数，计算机一般使用补码进行表示，所以，上面的最小值和最大值就变成了-128 ~ 127了。 默认情况下，我们使用的常量数字都是Int类型，除非它的大小已经超出Int类型能够表示的最大范围，在超出Int类型可以表示的最大范围之后，默认为Long类型： val one = 1 // Int val threeBillion = 3000000000 // Long val oneLong = 1L // 我们也可以在数字后面添加大写字母L来表示这是一个Long类型的数值 val oneByte: Byte = 1 //Int类型数据也可以在符合其他类型范围时自动转换 对于一些比较长的数字，我们可能需要使用类似于分隔符一类的东西来方便我们计数，比如： 银行往往把1000000000这种长数字记为1,000,000,000，这样看起来会更直观 在Kotlin中也可以像这样去编写： val a = 1_000_000_000 数字类型不仅可以写成十进制，也可以以十六进制或是二进制表示（Kotlin不支持八进制表示）只需要添加对应的前缀即可，比如一个十六进制数据： val a = 0xAF 因为十六进制中大于等于十的数据没有对应的阿拉伯数字可以表示，所以在计算机中就以ABCDEF来替代这无法表示的6个数字。并且我们需要在数字前面添加0x表示这是16进制的数字，接下来是2进制： val a = 0b1001 //0b前缀表示二进制数据，后面的1010对应着十进制的9 除了整数类型外，Kotlin还为无符号整数提供以下类型： UByte：一个无符号8位整数，范围从0到255 UShort：无符号16位整数，范围从0到65535 UInt：一个无符号32位整数，范围从0到2^32 - 1 ULong：一个无符号64位整数，范围从0到2^64 - 1 为了使无符号整数更易于使用，Kotlin同样提供了用后缀标记，该后缀表示无符号类型（类似于上面的Long类型添加L字母） 使用u或U字母作为后缀表示无符号整数。而具体的类型是根据前面变量的类型确定的，如果变量没有提供类型，编译器将根据数字的大小使用UInt或ULong： val b: UByte = 1u // UByte类型, 由变量提供的类型 val s: UShort = 1u // UShort类型, 由变量提供的类型 val l: ULong = 1u // ULong类型, 由变量提供的类型 val a1 = 42u // UInt类型，根据数字大小自动推断得到 val a2 = 0xFFFF_FFFF_FFFFu // ULong类型，根据数字大小自动推断得到 uL和UL可以将文字直接标记为无符号Long类型： val a = 1UL // ULong类型，直接使用后缀标记 对于小数来说，Kotlin提供符合IEEE 754标准的浮点类型Float和Double，Float为IEEE 754标准中的单精度数据，而`Double位标准中的双精度数据，对于单双精度，本质上就是能够表示的小数位精度，双精度比单精度的小数精度更高。 这些类型的大小不同，并为不同精度的浮点数提供存储： 类型 大小（位） 符号与尾数位数 阶码位数 小数位数 Float 32 24 8 6-7 Double 64 53 11 15-16 我们也可以直接创建小数类型的Double和Float变量，小数部分与整数部分由一个小数点（.）隔开，编译器默认情况下会将所有的小数自动推断为推断Double类型： val pi = 3.1415 // 默认推断为Double类型 val one: Double = 1 // 这种写法是错误的，因为1不是小数，无法编译通过 val one: Double = 1.0 // 但是这种写法就是对的，因为这样表示就是小数，即使小数位是0 由于默认是Double类型，如果我们要明确指定值为Float类型，那么需要添加后缀f或F，并且由于精度问题，如果该值包含超过6-7位小数，则会丢失一部分精度： val e = 2.7182818284 // Double类型的数值 val e: Float = 2.7182818284f // 这里表示为Float会导致精度折损，得到2.7182817 与其他一些语言不同，Kotlin中的数字类型没有隐式转换的操作，例如，一个Double类型的变量无法将其值赋值给Int类型变量： 如果需要将一个整数转换为小数，我们会在后面学习函数之后再给各位小伙伴讲解如何调用函数进行显示类型转换。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数字类型的运算 Kotlin支持数学上标准的算术运算集，例如：+，-，*，/，% 并且这些运算符都是通过运算符重载实现的具体功能，我们会在后续的章节中讲解Kotlin的运算符重载机制，这里各位小伙伴就当做是普通的运算操作即可。 Kotlin支持运算符重载，运算符重载是一种允许程序员重新定义运算符的语言特性，通过运算符重载，您可以为自定义的类或数据类型定义一些特定操作的行为。 其中加减乘除操作这里就不做介绍了，而%符号用于取余操作，也就是计算前面的数整除后面的数得到的余数： println(1 + 2) //计算1加上2的结果 println(2_500_000_000L - 1L) //计算2500000000减去1的结果 println(3.14 * 2.71) //计算3.14与2.71的乘积 println(10.0 / 3) //计算10除以3得到的结果 println(10 / 3) //10除以3得到的余数为1 以上运算都比较简单，但是注意在除法运算中，只有两个操作数中出现小数，除法的结果才是小数，如果两个操作数都是整数，那么得到的结果也是整数，并且直接丢失小数位（不会四舍五入） println(5 / 2) //结果是2，而不是2.5 同样的，除了直接使用字面量来进行运算，我们也可以将定义的变量参与到运算中： fun main() { val a = 10 println(a / 2) } 注意，在Kotlin中不同的算数运算符，它们的优先级也不一样： println(1 + 2 * 3) 在数学中，乘法运算的优先级比加法运算更高，因此我们需要先计算乘法，再计算加法，而在Kotlin中是一样的，乘法和除法运算符的优先级是高于加法运算符的，所以说上面算出来的结果是7，同样的，我们数学中使用括号来提升某些运算的优先级，在Kotlin中同样可以，比如： println((1 + 1) * 3) //使用小括号来强制提升优先级 有些时候，我们可能想要让某个变量的值增加一定数值，比如下面这样： var a = 10 a = a + 9 //让a等于a+9的结果 对于这种让变量本身加减乘除某个值的情况，可以使用赋值运算符简化： a += 9 //等价于 a = a + 9 a /= 9 //等价于 a = a / 9 a %= 2 //等价于 a = a % 2 如果我们只是希望某个变量自增或自减1，那么我们可以像这样去写： fun main() { var a = 10 a++ //使用两个++表示自增1 println(a) //打印得到11 a-- //使用两个--表示自减1 } 不过，这个双++符号，可以放在变量的前后，都能实现自增操作： var a = 10 ++a //最终效果等价于a++ 但是他们有一个本质区别，就是++在前面，a是先自增再得到结果，而++在后面，是a先得到结果，再进行自增，比如： fun main() { var a = 10 println(a++) //这里++在后面，打印a的值依然是10，但是结束之后a的值就变成11了 println(++a) //这里++在前面，打印a的值是这里先自增之后的结果，就是12了 } 对于新手来说，这个很容易搞混，所以说一定要记清楚。 Kotlin提供了一组整数的位运算操作，可以直接在二进制层面上与数字表示的位进行操作，不过只适用于Int和Long类型的数据： shl(bits)– 有符号左移 shr(bits)– 有符号右移 ushr(bits)– 无符号右移 and(bits)– 按位与 or(bits)– 按位或 xor(bits)– 按位异或 inv()– 取反 这里我们从按位与开始讲解，比如下面的两个数： fun main() { val a = 9 val b = 3 val c = a and b //进行按位与运算 println(c) } 按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0： a = 9 = 1001 b = 3 = 0011 c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0） 同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1： fun main() { val a = 9 val b = 3 val c = a or b println(c) } a = 9 = 1001 b = 3 = 0011 c =11= 1011（只要上下有一个是1或者都是1，那结果就是1） 按位异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况： a = 9 = 1001 b = 3 = 0011 c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0） 按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1： 127 = 01111111 -128 = 10000000 所以说计算的结果就是-128了。 除了以上的四个运算符之外，还有位移运算符，比如： fun main() { val c = 1 shl 2 //shl表示左移运算 println(c) } 1 = 00000001 4 = 00000100（左移两位之后，1跑到前面去了，尾部使用0填充，此时就是4） 我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用*进行乘2的运算之外，我们也可以使用左移操作来完成。 同样的，右移操作就是向右移动每一位咯： fun main() { val c = 8 shr 2 //shr表示右移运算 println(c) } 跟上面一样，右移操作可以快速进行除以2的计算。对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响： fun main() { val c = -8 shr 2 //这里得到的依然是个负数 println(c) } 我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动： fun main() { val c = -1 ushr 1 //无符号右移是ushr，移动会直接考虑符号位 println(c) } 比如： -1 = 11111111 11111111 11111111 11111111 右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位） 此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移操作。 最后我们再总结一下不同运算符的优先级，对应的优先级从上往下依次减弱： 一元运算符：例如 ++、–、+、-、!、~ 乘法和除法运算符：*、/、% 加法和减法运算符：+、- 位移运算符：shl、shr、ushr 按位与运算符：and 按位或运算符：or 按位异或运算符：xor 逻辑运算符：\u0026\u0026、|| 比较运算符：\u003e、\u003e=、\u003c、\u003c=、==、!= 区间运算符：.. 赋值运算符：=、+=、-=、*=、/=、%= 当然，这里列出的部分运算符各位小伙伴可能还没有遇到，不过在后续的学习中，我们会慢慢认识的，届时各位小伙伴可以回顾一下这里。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"布尔类型介绍 布尔类型是Kotlin中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态： true - 真 false - 假 布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true） val a: Boolean = true 如果给一个其他的值，会无法编译通过： 布尔值除了可以直接赋值得到，也可以通过一些关系运算得到，常见的关系运算有大于、小于以及等于，所有的关系运算在下方： 判断两个数是否相等：a == b和a != b 判断数之间大小：a \u003c b，a \u003e b，a \u003c= b，a \u003e= b 判断数是否在指定范围中：a..b，x in a..b，x !in a..b 比如我们想判断变量a和变量b的值是否相同： fun main() { val a = 10 val b = 8 println(a == b) //判断a是否等于b（注意等号要写两个，因为单等号为赋值运算） println(a \u003e= b) //判断a是否大于等于b println(a \u003c b) //判断a是否小于b val c: Boolean = a != b //判断a是否不等于b并将结果赋值给变量c } 可以看到，通过逻辑运算得到的结果，都是true或false，也就是我们这里学习的Boolean类型值。在Kotlin中，我们为了快速判断某个数是否在一个区间内，可以直接使用 a..b 来表示一个数学上[a, b]这样的闭区间，比如我们这里要判断变量a的值是否在1~10之间： fun main() { val a = 10 println(a in 1..10) //这里1..10表示1~10这个闭区间，使用in关键字来进行判断 println(a in 1..\u003c10) //这里1..\u003c10表示1~10这个前闭后开区间，使用in关键字来进行判断 println(a !in 1..10) //相反的，使用!in判断是否不在这个区间 } 对于Boolean类型的变量之间，也有一些逻辑运算符用于进行组合条件判断： ||– 逻辑或运算 \u0026\u0026– 逻辑与运算 !– 取反运算 其中取反运算最好理解，它可以让true变成false，false变为true，比如： fun main() { val a = 10 val b = 20 val c = a \u003e b //这里很明显c应该为false println(!c) //这里进行了取反操作并打印，那么结果就是true了 } 对于逻辑与和逻辑或运算，我们可以像这样去使用： fun main() { val a = 10 val b = 0 println(100 \u003e= a \u0026\u0026 b \u003e= 60) //我们可以使用与运算符连接两个判断表达式，只有两边都为true结果才是true println(100 \u003e= a || b \u003e= 60) //我们可以使用或运算符连接两个判断表达式，只要两边任意一个为true结果就是true } 与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，而或运算就是要求两边只要有一边为真，结果就是真，除非两边同时为false，那么就没戏了。 不过需要注意的是，在与运算中，第一个判断表达式得到了false之后，此时不会再继续运行第二个表达式，而是直接得到结果false（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）同样的，或运算下当发现第一个判断表达式为true时，也不会继续向后执行了，因为结果已经是顶真了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"字符类型介绍 字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）字符由Char类型表示，字符值用单引号：'1'囊括： val c: Char = 'A' println(c) 注意，字符只能表示一单个字符，我们之前遇到的字符串跟字符不一样，关于字符串我们会在下节课进行介绍。 我们打印出来的也是单个字符： 那么可能会有小伙伴好奇，字符类型在计算机底层是怎么进行存储的呢？实际上每个字符在计算机中都会对应一个字符码，首先我们需要介绍ASCII码： 比如我们的英文字母A要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，我们可以使用.code来获取某个字符对应的ASCII码，比如下面这样： fun main() { val c: Char = 'A' println(c.code) //这里就会打印字符对应的ASCII码 } 得到结果为： 字符型占据2个字节的空间用于存放数据： char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535 不过，这里的字符表里面不就128个字符吗，那char干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文，这时，我们就需要扩展字符集了。 Unicode是一个用于表示文本字符的标准字符集。它包含了世界上几乎所有的已知字符，包括不同国家和地区的字母、数字、标点符号、符号图形以及特殊的控制字符。 与Unicode不同，ASCII（American Standard Code for Information Interchange）是一个只包含128个字符的字符集。它最初是为了在计算机系统中传输基本英语字符而设计的。ASCII字符集包含了常见的拉丁字母、数字、标点符号以及一些特殊字符。 Unicode采用了一个更加广泛的字符编码方案，包括了不同的字符集编码，比如UTF-8和UTF-16等。UTF-8是一种可变长度的编码方案，它可以用来表示Unicode中的任意字符，且向后兼容ASCII字符集。而UTF-16则是一种固定长度的编码方案，它使用两个字节来表示一个Unicode字符。 与ASCII相比，Unicode的主要优势在于它能够表示各种不同的语言和字符，而不仅仅限于英语字符。这使得Unicode成为全球通用的字符编码标准，为不同国家和地区的语言提供了统一的编码方式。 所以，一个Char就能表示几乎所有国家语言的字符，这样就很方便了。 接着我们来介绍一下转译字符，对于一些我们平时很难直接通过键盘或是输入法打出来的字符，比如一些特殊符号： 这些符号我们没办法直接打出来，但是现在我们又想要表示它们，该怎么做呢？我们可以使用转义来将这些字符对应的Unicode编码转换为对应的字符，只需要在前面加上\\u即可，比如✓这个符号： fun main() { val c = '\\u2713' //符号✓对应的Unicode编码为10003，这里需要转换为16进制表示，结果为0x2713 println(c) } 除了能像这样表示一个特殊字符，我们也可以使用一些其他的转义字符来表示各种东西： \\t – 选项卡 \\b – 退格 \\n – 换行（LF） \\r – 回车（CR） \\' – 单引号 \\\" – 双引号 \\\\ –反斜杠 \\$ – 美元符号 这些转义字符都是为了防止在特殊情况下无法表示某些字符，而给我们的替代方案，后续各位小伙伴在使用时可以回来参考一下。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"字符串类型介绍 字符串类是一个比较特殊的类型，它用于保存字符串。我们知道，基本类型Char可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列，它的类型名称为String。 字符串通常由双引号\"\"囊括，它可以表示一整串字符： val str: String = \"Hello World\" 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。 如果我们需要再字符串中换行，需要用到转义字符，字符串中同样支持使用转义字符： fun main() { val text = \"Hello\\nWorld\" println(text) } 不过，字符串只能写一行，有时候有点不太够用，可能我们想要打印多行文本，我们除了用\\n转义字符来换行之外，也可以直接使用三个双引号\"\"\"来表示一个原始字符串，但是原始字符串无法使用转义字符： fun main() { val text = \"\"\" 这是第一行 这第二行 别\\n了，没用 真牛逼啊，这功能隔壁Java15才有 \"\"\" println(text) } 效果如下： 可以看到确实是够原始的，把我代码里面的缩进都给打印出来了，这样肯定不是我们希望的样子，我们希望的仅仅是一个简单换行而已，那这里该怎么去处理呢？后面我们在讲解函数之后，会额外补充这里的内容。 有时候为了方便，我们可以将不同的字符串拼接使用： fun main() { val str1 = \"Hello\" val str2 = \"World\" val str = str1 + str2 println(str) //使用 + 来拼接两个字符串，得到的结果就是两个字符串合在一起的结果 } 字符串除了和字符串拼接之外，也可以和其他类型进行拼接： fun main() { val a = 10 val text = \"这是拼接的值\" + a println(text) //打印出来就是与其他类型的拼接结果 } 但是我们需要注意字符串拼接的顺序，只能由字符串拼接其他类型，如果是其他类型拼接字符串，可能会出现问题： 但是现在我们就是希望其他类型的数据拼在最前面，这里应该怎么做呢？我们可以使用字符串模版来完成： fun main() { val a = 10 val text = \"这是拼接的值$a\" //这里的$为模版表达式，可以直接将后面跟着的变量或表达式以字符串形式替换到这个位置 println(text) } 如果要添加到前面： val text = \"$a 这是拼接的值\" //注意这里$a之后必须空格，否则会把后面的整个字符串认为这个变量的名字 出现这种情况除了用空格去解决之外，我们也可以添加一个花括号： val text = \"${a}这是拼接的值\" //添加花括号就可以消除歧义了 val text = \"${a \u003e 0}这是拼接的值\" //花括号中也可以写成表达式 由于美元符用于模版表达式了，所以说如果我们希望在字符串中仅仅表示$这个字符，那么我们需要用到转义： val text = \"\\$这是美元符\" //普通字符串直接使用\\$表示 //原始字符串要套个娃 val str = \"\"\" ${'$'}这是美元符 \"\"\" 至此，关于Kotlin的变量与基本类型的内容我们就暂时告一段落了，不过在后面学习了更多知识后，我们还会回顾这些基本类型，了解他们的更多用法，并且认识我们唯一没有在这一部分介绍的数组类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"流程控制 经过前面的学习，我们知道，程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。 在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断，以及实现流程控制。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"选择结构（if-else） 某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下if语句： if (条件判断) 判断成功执行的代码; if的小括号中需要我们传入一个Boolean类型的结果，可以是一个Boolean变量，也可以是一个判断语句，反正只能接受true和false两种结果，比如下面的这个例子： fun main() { val a = 10 if(a == 12) //只有当a判断等于12时，才会执行下面的打印语句 println(\"Hello World!\") println(\"我是后续的语句\") //if只会对紧跟着的一行代码生效，后续的内容无效 } if会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起，使用花括号囊括）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的，就像下面这样： fun main() { val a = 15 if (a \u003e 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 println(\"a大于10\") println(\"a的值为：$a\") } println(\"我是外层\") } 如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句： fun main() { val a = 15 if (a \u003e 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 println(\"a大于10\") println(\"a的值为：$a\") } else { //当判断不成功时，会执行else代码块中的代码 println(\"a小于10\") println(\"a的值为：$a\") } println(\"我是外层\") } if-else语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。 那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成： fun main() { val score = 2 if (score \u003e= 90) //90分以上才是优秀 println(\"优秀\") else if (score \u003e= 70) //当上一级if判断失败时，会继续判断这一级 println(\"良好\") else if (score \u003e= 60) println(\"及格\") else //当之前所有的if都判断失败时，才会进入到最后的else语句中 println(\"不及格\") } 当然，if分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套： fun main() { val score = 2 if (score \u003c 60) { //先判断不及格 if (score \u003e 30) //在内层再嵌套一个if语句进行进一步的判断 println(\"学习C++\") else println(\"学习Java\") } } 除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用if来进行各种条件判断了。 除了直接执行语句之外，我们也可以将if和else用作结果判断，比如： fun main() { val score = 2 //这里判断socre是否大于60，是就得到Yes，否就得到No，并且可以直接赋值给变量 val res = if (score \u003e 60) \"Yes\" else \"No\" } 这类似于其他语言，如Java和C中的三元运算，不过Kotlin中没有那样的三元运算符，只能使用上面的表达式，对于多行代码块的情况，默认最后一行作为返回的结果： fun main() { val score = 2 val res = if (score \u003e 60) { println(\"不错啊期末没挂科\") \"Yes\" //代码块默认最后一行作为返回结果 } else { println(\"不会有人Java期末还要挂科吧\") \"No\" } } 注意，如果需要这种返回结果的表达式，那么必须要存在else分支，否则不满足条件岂不是没结果了？ ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"选择结构（when） 前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用when语句来实现，它更适用于多分支的情况： when定义具有多个分支的条件表达式。它类似于类似Java和C语言中的switch语句，它简单的形式看起来像这样： when (目标) { 匹配值1 -\u003e 代码... //我们需要传入一个目标，比如变量，或是计算表达式等 匹配值2 -\u003e 代码... //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 else -\u003e { 代码... //如果以上条件都不满足，就进入else中（可以没有），类似于之前的if-elseif-else } } 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级： fun main() { val c = 'A' when (c) { 'A' -\u003e println(\"去尖子班！准备冲刺985大学！\") 'B' -\u003e println(\"去平行班！准备冲刺一本！\") 'C' -\u003e println(\"去职高深造。\") } } 如果将when用作表达式，则else分支必须存在，除非编译器能推断出所有可能的情况都包含分支条件，比如下面的例子： fun main() { val c = 'A' val numericValue = when (c) { 'B' -\u003e 0 'A' -\u003e 1 else -\u003e 2 //还有其他情况，这里必须添加else，不然其他情况岂不是没返回的东西？ } } 以下情况就可以不需要else语句： fun main() { val c = true val numericValue = when (c) { false -\u003e 0 true -\u003e 1 // 由于Boolean只具备真和假条件，这里的'else' 就不再强制要求 // 这同样适用于比如枚举类等 } } 在when语句中，遇到以下情况，携带else分支是必须的： when分支中仅有一个Boolean类型、枚举 或 密封，以及用于判断的目标变量是可空的情况（后面会讲解） when分支没有包括该判断目标的所有可能的值。 有时候我们可能希望某些值都属于同一个情况，可以使用逗号将其条件组合成一行： when (x) { 0, 1 -\u003e print(\"x == 0 or x == 1\") else -\u003e print(\"otherwise\") } 我们也可以使用任意表达式（不仅仅是常量）作为分支条件，比如之前的if-else案例中我们判断学生成绩： fun main() { val score = 10 val grade = when(score) { //使用in判断目标变量值是否在指定范围内 in 100..90 -\u003e \"优秀\" in 89..80 -\u003e \"良好\" in 79..70 -\u003e \"及格\" in 69..60 -\u003e \"牛逼\" else -\u003e \"不及格\" } } 包括我们之后学习的类型判断is表达式、函数调用等，都可以在这里作为分支条件。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"循环结构（for） 通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。 我们在某些时候，可能需要批量执行某些代码： fun main() { println(\"大烟杆嘴里塞，我只抽第五代\") //把这句话给我打印三遍 println(\"大烟杆嘴里塞，我只抽第五代\") println(\"大烟杆嘴里塞，我只抽第五代\") } 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？ 现在，要解决这种问题，我们可以使用for循环语句来多次执行： for (遍历出来的单个目标变量 in 可遍历目标) 循环体 这里的可遍历目标有很多，比如： 数组 区间 任何实现了运算符重载函数iterator的类 这里我们只学习了区间，我们来看看如何使用，比如我们要打印一段话3遍： fun main() { for (i in 1..3) //这里直接写入1..3表示1~3这个区间 println(\"大烟杆嘴里塞，我只抽第五代：$i\") } 打印结果为： 可以看到，每一次遍历出来的变量i，其实就是每次遍历的下一个目标，比如这里是1..3的区间，那么得到的依次就是1、2、3这三个结果了，唯一需要注意的是，这里的i是局部的，只在for循环内部可用（包括嵌套的内部）并不是整个main中都可以使用： 默认情况下，每一轮循环都会向后+1，我们也可以自由控制每一轮增加多少，也就是步长： fun main() { for (i in 1..10 step 2) { println(i) } } 这样，打印出来的数据会按照步长进行增长： 那如果我们需要从10到1倒着进行遍历呢？我们可以将..替换为downTo来使用： fun main() { for (i in 10 downTo 1) { println(i) //这里得到的就是10到1倒着排列的范围了 } } 我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值： 调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug） 调试开始时，我们可以看到程序在断点位置暂停了： 此时我们可以观察到当前的变量i的值，也可以直接在下方的调试窗口中查看： 随着循环的进行，i的值也会逐渐自增。 和之前的if一样，for循环同样支持嵌套使用： fun main() { for (i in 0..2) //外层循环执行3次 for (j in 0..2) //内层循环也执行3次 println(\"外层$i，内层$j\") } 上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。 我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字： for (i in 0..2) { if (i == 1) continue //比如我们希望当i等于1时跳过这一轮，不执行后面的打印 println(\"在这么冷的天\") println(\"当前i的值为：$i\") } 我们可以使用continue关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行continue进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。 在某些情况下，我们可能希望提前结束循环： fun main() { for (i in 0..2) { if (i == 1) break //我们希望当i等于1时提前结束 println(\"伞兵一号卢本伟准备就绪！\") println(\"当前i的值为：$i\") } } 我们可以使用break关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。 虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）： fun main() { for (i in 1..3) { for (j in 1..3) { if (i == j) continue //当i == j时加速循环 println(\"$i, $j\") } } } 这里的continue加速的对象并不是外层的for，而是离它最近的内层for循环，break也是同样的规则： fun main() { for (i in 1..3) { for (j in 1..3) { if (i == j) break //当i == j时终止循环 println(\"$i, $j\") } } } 那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记： fun main() { outer@ for (i in 1..3) { //在循环语句前，添加 标签@ 来进行标记 inner@ for (j in 1..3) { if (i == j) break@outer //break后紧跟要结束的循环标记，当i == j时终止外层循环 println(\"$i, $j\") } } } 关于for语句的更多用法，我们会在后续的学习中继续认识。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"循环结构（while） 前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们给一个可遍历的目标，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如： while(循环条件) 循环体; 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。 fun main() { var i = 100 //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i \u003e 0) { //现在唯一知道的是循环条件，只要大于0那么就可以继续除 println(i) i /= 2 //每次循环都除以2 } } 上面的这种情况就非常适合使用while循环。 和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用： fun main() { var i = 100 while (i \u003e 0) { if (i \u003c 10) break println(i) i /= 2 } } 我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句： fun main() { var i = 0 //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 do { //无论满不满足循环条件，先执行循环体里面的内容 println(\"Hello World!\") i++ } while (i \u003c 10) //再做判断，如果判断成功，开启下一轮循环，否则结束 } Kotlin程序设计中级篇 我们在前面已经学习了Kotlin程序设计的基础篇，本章我们将继续介绍更多Kotlin特性，以及面向对象编程。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"函数 其实函数我们在一开始就在使用了： fun main() { println(\"Hello World\") } 我们程序的入口点就是main函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不过这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的println也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数： println(\"Hello World!\"); //直接通过 函数名称(参数...) 的形式调用函数 那么，函数的具体定义是什么呢？ 函数是完成特定任务的独立程序代码单元。 其实简单来说，函数是为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况： fun main() { var a = 10 println(\"H\") //比如下面这三行代码就是我们要做的任务 println(\"A\") a += 10 if (a \u003e 20) { println(\"H\") //这里我们还需要执行这个任务 println(\"A\") a += 10 } when (a) { 30 -\u003e { println(\"H\") //这里又要执行这个任务 println(\"A\") a += 10 } } } 我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？ 这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。 我们来看看，如何创建和使用函数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"创建和使用函数 Kotlin函数使用fun关键字声明： fun 函数名称([函数参数...]): 返回值类型 { //函数体 } 其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，我们同样可以将函数返回的结果赋值给变量或是参与运算等等，当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以不填，我们先从最简单的开始： //这个函数用于打印一段文本 fun hello(): Unit { //本质上应该是返回Unit类型，这个类型表示空，类似于Java中的void，默认情况下可以省略 println(\"PHP是世界上最好的语言.kt\") } 我们要调用这个函数也很简单，只需要像下面这样就可以了： fun main() { hello() //调用函数只需使用 函数名() 即可 } 不过，有些时候，我们可能需要外部传入一些参数来使用，比如： fun say(message: String){ //在定义函数时，可以将参数写到 println(\"我说：$message\") } 这里我们在函数的小括号中填入的就是形式参数，这代表调用函数时需要传入的数据，比如这里就是我们要打印的字符串，而实际在调用函数时，填入的内容就是实际参数： fun main() { //在调用带参数的函数时，必须填写实参，否则无法编译通过 //这里填入的内容就是实际参数 say(\"你干嘛\") //也可以将变量作为实际参数传入 val str: String = \"哎哟\" say(str) } 还有一些时候，我们的函数可能需要返回一个计算的结果给调用者，我们也可以设定函数的返回值： //这个函数用于计算两个Int数之和 fun sum(a: Int, b: Int) : Int { return a + b //使用return语句将结果返回 } 带返回值的函数，调用之后得到的返回值，可以由变量接收，或是直接作为其他函数的参数： fun main() { var result = sum(1, 2) //获取函数返回值 println(result) println(sum(2, 4)) //直接打印函数返回值 } 注意这个return关键字在执行之后，是不会继续执行之后的内容的： fun main() { println(test(-2)) println(test(10)) } fun test(i: Int): String{ if(i \u003e 0) return \"Hello\" println(\"继续\") return \"World\" //如果满足上面条件，在执行return之后，后续无论有没有执行完，都不会再往下了 } 有些时候，我们也可以设计一些参数带有默认值的函数，如果在调用函数时不填入参数，那么就使用我们一开始设置好的默认值作为实际传入的参数： fun main() { test() //调用函数时，如果对应参数有默认值，可以不填 } fun test(text: String = \"我是默认值\"){ println(text) } 在调用函数时，我们可以手动指定传入的参数对应的是哪一个形式参数： fun main() { test(b = 3) //这里如果只想填写第二个参数b，我们可以直接指定吧实参给到哪一个形参 test(3) //这种情况就是只填入第一个实参 } fun test(a: Int = 6, b: Int = 10): Int { return a + b } 对于一些内容比较简单的函数，比如上面仅仅是计算两个参数的和，我们可以直接省略掉花括号，像这样编写： fun test(a: Int = 6, b: Int = 10): Int = a + b //函数的结果直接缩减为 = a + b 效果跟之前是一样的 fun test(a: Int = 6, b: Int = 10) = a + b //返回类型可以自动推断，这里可以吧返回类型省掉 这里还需要注意一下，函数的形式参数默认情况下为常量，无法进行修改，只能使用： 比较奇葩的是，函数内部也可以定义函数： fun outer(){ fun inner(){ //函数内部定义的函数，无限套娃 } } 函数内的函数作用域是受限的，我们只能在函数内部使用： fun outer(){ fun inner(){ } inner() } 内部函数可以访问外部函数中的变量： fun outer(){ val a = 10; fun inner(){ println(a) } } 最后，我们不能同时编写多个同名函数，这会导致冲突： 但是，如果多个同名函数的参数不一致，是允许的： fun test() = println(\"A\") fun test(str: String) = println(\"B\") //参数列表不一致 我们在调用这个函数时，编译器会根据我们传入的实参自动匹配使用的函数是哪一个： ... fun main() { test(\"\") //结果为B } 以上适用于形参列表不同的情况，如果仅仅是返回值类型不同的情况，同样是不允许的： 像这种编写同名但不同参数的函数，我们称为函数的重载。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"再谈变量 前面我们学习了如何使用变量，只不过当时我们仅仅是在main函数中使用的局部变量，我们也可以将变量的作用域进行提升，将其直接变成一个顶级定义： var str: String = \"尊嘟假嘟\" //跟定义函数一样，直接写在Kt文件中 fun main() { ... } 此时，这个变量可以被所有的函数使用： var str: String = \"尊嘟假嘟\" fun main() = println(str) //作用域的提升，使得变量可以被随意使用 fun test() = println(str) 以上也只是对变量的一些简单使用，现在变量的作用域被提升到顶层，它可以具有更多的一些特性，那么，我们就再来重新认识一下变量，声明一个变量的完整语法如下： var \u003cpropertyName\u003e[: \u003cPropertyType\u003e] [= \u003cproperty_initializer\u003e] [\u003cgetter\u003e] [\u003csetter\u003e] 前面的我们知道，但是这个getter和setter是个什么鬼？对于这种顶层定义的变量（包括后面类中会用到的成员属性变量）可以具这两个可选的函数，它们本质上是一个get和set函数： getter：用于获取这个变量的值，默认情况下直接返回当前这个变量的值 setter：用于修改这个变量的值，默认情况下直接对这个变量的值进行修改 我们在使用这种全局变量时，对于变量的获取和设定，本质上都是通过其getter和setter函数来完成的，只不过默认情况下不需要我们去编写，程序编译之后，有点像这样的结果： var name: String = \"小明\" fun getName() : String { //编译时自动生成了对应变量的get函数 return this.name } fun setName(name: String) { //编译时自动生成了set函数 this.name = name; } 而对于其使用，在编译之后，会变成这样： fun main() { println(getName()) //获取name时本质上是调用getName函数 } 是不是感觉好神奇，一个变量都能搞这么多花样，这其实是为了后续多态的一些性质而设计的（下一章讲解） 可以看到，在默认情况下，变量的获取就是直接返回，设置就是直接修改，不过有些时候我们可能希望修改这些变量获取或修改时执行的操作，我们可以手动编写： var str: String = \"尊嘟假嘟\" get() = field + field //使用filed代表当前这个变量(字段)的值，这里返回值拼接的结果 这里使用的field准确的说应该是Kotlin提供的\"后备字段\"，因为我们使用getter和setter本质上替代了原有的获取和修改方式，使其变得更像是函数的调用，因此，为了能够继续像之前使用一个变量那样去操作它本身，就有了这个后备字段。 最后得到的就是： 甚至还可以写成这样，在获取的时候执行一些操作： var str: String = \"尊嘟假嘟\" get() { println(\"获取变量的值：\") //获取的时候打印一段文本 return field + \"666\" } fun main() = println(str) 同样的，设置的时候也可以自定义： var str: String = \"尊嘟假嘟\" get() = field + field set(value) { //这里的value就是给过来的值 println(\"设置变量的值\") field = value //注意，对于val类型的变量，没有set函数，因为不可变 } 因此，一个变量有些时候可能会写成这样： val str get() = \"你干嘛\" 当然，默认情况下其实没有必要去重写get和set除非特殊需求。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"递归函数 我们前面学习了如何调用函数，实际上函数自己也可以调用自己。 fun test(){ test() //我自己调用自己 } 肯定会有小伙伴疑问，函数自己调用自己有什么意义？反而还会导致函数无限的调用下去，无穷无尽，确实，如果不加限制地让函数自己调用自己： 就会出现这种爆栈的情况，这是因为程序的内存是有限的，不可能无限制的继续调用下去，因此，在自我调用到一定的深度时，会被强制终止。所以说这玩意有啥用呢？如果我们对递归函数加以一些限制，或许会有意想不到的发现： fun main() { test(5) //计算0-5的和 } //这个函数实现了计算0-n的和的功能 fun test(n: Int): Int{ if(n \u003c= 0) return 0 //当n等于0的时候就不再向下，而是直接返回0 return n + test(n - 1) //n不为0就返回当前的n加上test参数n-1的和 } 这个函数最终调用起来就像这样： test(5) = 5 + test(4) = 5 + 4 + test(3) = … = 5 + 4 + 3 + 2 + 1 + 0 可以看到，只要合理使用递归函数，加以一定的结束条件，反而能够让我们以非常简洁的形式实现一个需要循环来完成的操作。 我们可以再来看一个案例： 斐波那契数列是一个非常经典的数列，它的定义是：前两个数是1和1，之后的每个数都是前两个数的和。 斐波那契数列的前几个数字依次是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … 对于求解斐波那契数列第N个数这类问题，我们也可以使用递归来实现： fun main() { println(fib(5)) } fun fib(n: Int): Int{ if(n \u003c= 2) return 1 //我们知道前两个一定是1，所以直接返回 return fib(n - 1) + fib(n - 2) //当前fib(n)的结果就是前两个结果之和，直接递归继续找 } 是不是感觉递归函数非常神奇？它甚至可以解决一些动态规划问题、一些分治算法等。 不过，这种函数的效率就非常低了，相比循环来说，使用递归解决斐波那契问题，时间复杂度会呈指数倍增长，且n大于20时基本可以说很卡了（可以想象一下，每一个fib(n)都会分两个出去，实际上这个中间存在大量重复的计算） 那么，有没有办法可以将这种尾部作为返回值进行递归的操作优化一下呢？我们可以使用tailrec关键字来实现： tailrec fun test(n: Int, sum: Int = 0): Int { if(n \u003c= 0) return sum //到底时返回累加的结果 return test(n - 1, sum + n) //不断累加 } 实际上在编译之后，会变成这样： 可以看到它变成了一个普通的循环操作，这也是编译器的功劳，同样的，对于斐波那契数列： tailrec fun fib(n: Int, prev: Int = 0, next: Int = 1): Int { return if (n == 0) prev else fib(n - 1, next, prev + next) //从0和1开始不断向后，直到n为0就返回 } ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"实用库函数介绍 Kotlin为我们内置了大量实用的库函数，我们可以使用这些库函数来快速完成某些操作。 比如我们前面使用的println就是Kotlin提供的库函数，我们可以使用这个函数快速进行数据打印： fun main() { println(\"Hello World\") //这里其实就是在调用函数，传入了一个String类型的参数 } 那既然现在有输出，能不能让用户输入，然后我们来读取呢？ fun main() { val text = readln() println(\"读取到用户输入：$text\") } 我们可以在控制台输入一段文本，然后回车结束： Kotlin提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。 import kotlin.math.* //我们需要使用import来引入某些库，这样才能使用库函数 fun main() { 1.0.pow(4.0) //我们可以使用pow方法直接计算a的b次方 abs(-1); //abs方法可以求绝对值 max(19, 20); //快速取两个数的最大值 min(2, 4); //快速取最小值 sqrt(9.0); //求一个数的算术平方根 } 当然，三角函数肯定也是安排上了的： fun main() { //这里我们可以直接使用库中预设好的PI sin(PI / 2); //求π/2的正弦值，这里我们可以使用预置的PI进行计算 cos(PI); //求π的余弦值 tan(PI / 4); //求π/4的正切值 asin(1.0); //三角函数的反函数也是有的，这里是求arcsin1的值 acos(1.0); atan(0.0); } 可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果： fun main() { println(sin(Math.PI)); } 正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是： 1.2246467991473532×10−161.2246467991473532×10−16 其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。 我们也可以计算对数函数： fun main() { ln(E) //e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e log10(100.0) //10为底的对数函数 log2(8.0) //2为底的对数函数 //利用换底公式，我们可以弄出来任何我们想求的对数函数 val a = ln(4.0) / ln(2.0) //这里是求以2为底4的对数，log(2)4 = ln4 / ln2 println(a) } 还有一些比较特殊的计算： fun main() { ceil(4.5) //通过使用ceil来向上取整 floor(5.6) //通过使用floor来向下取整 } 向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"高阶函数与lambda表达式 注意： 这一部分比较难理解，如果看不懂可以后面回来看。 Kotlin中的函数属于一等公民，它支持很多高级特性，甚至可以被存储在变量中，可以作为参数传递给其他高阶函数并从中返回，就想使用普通变量一样。 为了实现这一特性，Kotlin作为一种静态类型的编程语言，使用了一系列函数类型来表示函数，并提供了一套特殊的语言结构，例如lambda表达式。 那么这里说的高阶函数是什么，lambda表达式又是什么呢？ 正是得益于函数可以作为变量的值进行存储，因此，如果一个函数接收另一个函数作为参数，或者返回值的类型就是一个函数，那么该函数称为高阶函数。 要声明函数类型，需要按照以下规则： 所有函数类型都有一个括号，并在括号中填写参数类型列表和一个返回类型，比如：(A, B) -\u003e C 表示一个函数类型，该类型表示接受类型A和B的两个参数并返回类型C的值的函数。参数类型列表可为空的，比如() -\u003e A，注意，即使是Unit返回类型也不能省略。 我们可以像下面这样编写： //典型的函数类型 (参数...) -\u003e 类型 小括号中间是一个剪头一样的符号，然后最后是返回类型 var func0: (Int) -\u003e Unit //这里的 (Int) -\u003e Unit 表示这个变量存储的是一个有一个int参数并且没有返回值的函数 var func1: (Double, Double) -\u003e String //同理，代表两个Double参数返回String类型的函数 同样的，作为函数的参数也可以像这样表示： fun test(other: (Int) -\u003e String){ } 函数类型的变量，我们可以将其当做一个普通的函数进行调用： fun test(other: (Int) -\u003e String){ println(other(1)) //这里提供的函数接受一个Int参数返回string，那么我们可以像普通函数一样传入参数调用它 } 由于函数可以接受函数作为参数，所以说你看到这样的套娃场景也不奇怪： var func: (Int) -\u003e ((String) -\u003e Double) 不过这样写可能有些时候不太优雅，我们可以为类型起别名来缩短名称： typealias HelloWorld = (String) -\u003e Double fun main() { var func: HelloWorld } 那么，函数类型我们知道如何表示了，如何具体表示一个函数呢？我们前面都是通过fun来声明函数： fun test(str: String): Int { return 666 } 而现在我们的变量也可以直接表示这个函数： fun main() { //这个变量表示的也是(String) -\u003e Int这种类型的函数 var func: (String) -\u003e Int = ::test //使用双冒号来引用一个现成的函数（包括我们后续会学习的成员函数、构造函数等） } //这个函数正好与上面的变量表示的函数类型一致 fun test(str: String): Int { return 666 } 除了引用现成的函数之外，我们也可以使用匿名函数，这是一种没有名称的函数： fun main() { val func: (String) -\u003e Int = fun(str: String): Int { //这里写了fun关键字后，并没有编写函数名称，这种函数就是匿名函数，因为在这里也不需要什么名字，只需要参数列表函数体 println(\"这是传入的内容$str\") return 666 } } 匿名函数除了没名字之外，其他的用法跟函数是一样的。 最后，我们来看看今天的重量级嘉宾，不要小看了Kotlin的语法，我们也可以使用Lambda表达式来表示一个函数实例： fun main() { var func: (String) -\u003e Int = { //一个Lambda表达式只需要直接在花括号中编写函数体即可 println(\"这是传入的参数$it\") //默认情况下，如果函数只有一个参数，我们可以使用it代表传入的参数 666 //跟之前的if表达式一样，默认最后一行为返回值 } func(\"HelloWorld!\") } 是不是感觉特别简便？ 对于参数有多个的情况，我们也可以这样进行编写： fun main() { val func: (String, String) -\u003e Unit = { a, b -\u003e //我们需要手动添加两个参数这里的形参名称，不然没法用他两 println(\"这是传入的参数$a, 第二个参数$b\") //直接使用上面的形参即可 } val func2: (String, String) -\u003e Unit = { _, b -\u003e println(\"这是传入的第二个参数$b\") //假如这里不使用第一个参数，也可以使用_下划线来表示不使用 } func(\"Hello\", \"World\") } 是不是感觉玩的非常高级？还有更高级的在后面呢！ 我们接着来看，如果我们现在想要调用一个高阶函数，最直接的方式就是下面这样： fun main() { val func: (Int) -\u003e String = { \"收到的参数为$it\" } test(func) } fun test(func: (Int) -\u003e String) { println(func(66)) } 当然我们也可以直接把一个Lambda作为参数传入作为实际参数使用： fun main() { test({ \"收到的参数为$it\" }) } 不过这样还不够简洁，在Kotlin中，如果函数的最后一个形式参数是一个函数类型，可以直接写在括号后面，就像下面这样： test() { \"收到的参数为$it\" } 由于小括号里面此时没有其他参数了，还能继续省，直接把小括号也给干掉： test { \"收到的参数为$it\" } //干脆连小括号都省了，这语法真的绝 当然，如果在这之前有其他的参数，只能写成这样了： fun main() { test(1) { \"收到的参数为$it\" } } //这里两个参数，前面还有一个int类型参数，但是同样的最后一个参数是函数类型 fun test(i: Int, func: (Int) -\u003e String) { println(func(66)) } 这种语法也被称为 尾随lambda表达式，能省的东西都省了，不过只有在最后一个参数是函数类型的情况下才可以，如果不是最后一位，就没办法做到尾随了。 最后需要特别注意的是，在Lambda中没有办法直接使用return语句返回结果，而是需要用到之前我们学习流程控制时用到的标签： fun main() { val func: (Int) -\u003e String = test@{ //比如这里判断到it大于10就提前返回结果 if(it \u003e 10) return@test \"我是提前返回的结果\" println(\"我是正常情况\") \"收到的参数为$it\" } test(func) } fun test(func: (Int) -\u003e String) { println(func(66)) } 如果是函数调用的尾随lambda表达式，默认的标签名字就是函数的名字： fun main() { testName { //默认使用函数名称 if(it \u003e 10) return@testName \"我是提前返回的结果\" println(\"我是正常情况\") \"收到的参数为$it\" } } fun testName(func: (Int) -\u003e String) { println(func(66)) } 不过，为什么要这么麻烦呢，还要打标签才能返回，这不多此一举么？这个问题我们会在下一节内联函数中进行讲解。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"内联函数 使用高阶函数会可能会影响运行时的性能：每个函数都是一个对象，而且函数内可以访问一些局部变量，但是这可能会在内存分配（用于函数对象和类）和虚拟调用时造成额外开销。 为了优化性能，开销可以通过内联Lambda表达式来消除。使用inline关键字会影响函数本身和传递给它的lambdas，它能够让方法的调用在编译时，直接替换为方法的执行代码，什么意思呢？比如下面这段代码： fun main() { test() } //添加inline表示内联函数 inline fun test(){ println(\"这是一个内联函数\") println(\"这是一个内联函数\") println(\"这是一个内联函数\") } 由于test函数是内联函数，在编译之后，会原封不动地把代码搬过去： fun main() { println(\"这是一个内联函数\") //这里是test函数第一行，直接搬过来 println(\"这是一个内联函数\") println(\"这是一个内联函数\") } 同样的，如果是一个高阶函数，效果那就更好了： fun main() { test { println(\"打印：$it\") } } //添加inline表示内联函数 inline fun test(func: (String) -\u003e Unit){ println(\"这是一个内联函数\") func(\"HelloWorld\") } 由于test函数是内联的高阶函数，在编译之后，不仅会原封不动地把代码搬过去，还会自动将传入的函数参数贴到调用的位置： fun main() { println(\"这是一个内联函数\") //这里是test函数第一行 val it = \"HelloWorld\" //这里是函数内传入的参数 println(\"打印：$it\") //第二行是调用传入的函数，自动贴过来 } 内联会导致编译出来的代码变多，但是同样的换来了性能上的提升，不过这种操作仅对于高阶函数有显著效果，普通函数实际上完全没有内联的必要，也提升不了多少性能。 注意，内联函数中的函数形参，无法作为值给到变量，只能调用： 同样的，由于内联，导致代码被直接搬运，所以Lambda中的return语句可以不带标签，这种情况会导致直接返回： fun main() { test { return } //内联高阶函数的Lambda参数可以直接写return不指定标签 println(\"调用上面方法之后\") } inline fun test(func: (String) -\u003e Unit){ func(\"HelloWorld\") println(\"调用内联函数之后\") } 上述代码的运行结果就是，直接结束，两句println都不会打印，这种情况被称为非局部返回。 回到上一节最后我们提出的问题，实际上，在Kotlin中Lambda表达式支持一个叫做\"标签返回\"（labeled return）的特性，这使得你能够从一个Lambda表达式中返回一个值给外围函数，而不是简单地返回给Lambda表达式所在的最近的封闭函数，就像下面这样： fun main() { test { return@main } //标签可以直接指定为外层函数名称main来提前终止整个外部函数 println(\"调用上面方法之后\") } inline fun test(func: (String) -\u003e Unit){ func(\"HelloWorld\") println(\"调用内联函数之后\") } 效果跟上面是完全一样的，为了避免这种情况，我们也可以像之前一样将标签写为@test来防止非局部返回。 fun main() { test { return@test } //这样就只会使test返回，而不会影响到外部函数了 println(\"调用上面方法之后\") } 有些时候，可能一个内联的高阶函数中存在好几个函数参数，但是我们希望其中的某一个函数参数不使用内联，能够跟之前一样随意当做变量使用： fun main() { test({ println(\"我是一号：$it\") }, { println(\"我是二号：$it\") }) } //在不需要内联的函数形参上添加noinline关键字，来防止此函数的调用内联 inline fun test(func: (String) -\u003e Unit, noinline func2: (Int) -\u003e Unit){ println(\"这是一个内联函数\") func(\"HelloWorld\") var a = func2 //这样就不会报错，但是不会内联了 func2(666) } 最后编译出来的结果，类似于： fun main() { println(\"这是一个内联函数\") val it = \"HelloWorld\" println(\"打印：$it\") //第二个参数由于不是内联，这里依然作为Lambda使用 val func2: (Int) -\u003e Unit = { println(\"我是二号：$it\") } func2(666) } 由于目前知识的学习还不太够，函数我们只能先暂时告一段落，在后续的学习中我们会继续认识更多函数的特性。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类与对象 在之前，我们一直在使用顶层定义： val a = 20 //直接在kt文件中定义变量 fun message() { //直接在kt文件中定义函数 println(\"我是测试方法\") } 而学习了类之后，这些内容也可以定义到类中，作为类的属性存在。 类的概念我们在生活中其实已经听说过很多了。 人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。 对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。 所以说，类就是抽象概念的人，而对象，就是具体的某一个人。 A：是谁拿走了我的手机？ B：是个人。（某一个类型） A：我还知道是个人呢，具体是谁呢？ B：是XXX。（具体某个对象） 而在Kotlin中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象，像这种编程方式，我们称为面向对象编程，我们除了去使用Kotlin给我们提供的类型之外，我们也可以使用自己定义的类。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的定义与对象创建 前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。 Kotlin中的类使用关键字class声明，我们可以直接在默认的Main.kt文件中编写： class Student { //在没有任何内容时，花括号可以省略 } 我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。 除了直接在某个.kt文件中直接编写之外，为了规范，我们一般将一个类单独创建一个文件，我们可以右键src目录： 这里选择新建，然后选择Kotlin类/文件选项，然后创建一个类： 文件创建完成后，默认也会为我们生成类的定义，并且类名称与创建的类文件是一模一样的： 这是一个非常简单的类，但是肯定远远不够。 既然是学生类，那么肯定有学生相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？我们需要指定类的构造函数，构造函数也是函数的一种，但是它是专用于对象的创建，Kotlin中的类可以添加一个主构造函数和一个或多个次要构造函数。主构造函数是类定义的一部分，像下面这样编写： class Student constructor(name: String, age: Int) { //比如学生有name和age属性，那么我们可以在类名后面constructor的括号中编写，并用逗号隔开 //这里跟定义变量差不多，也是变量名称:类型，这些作为类的成员属性，后续可以在类中使用 } 如果主构造函数没有任何注释或可见性修饰符，则可以省略constructor关键字，如果类中没有其他内容要写，可以直接省略花括号，最后就变成这样了： class Student(name: String, age: Int) 但是，这里仅仅是定义了构造函数的参数，这还不是类的属性，那么我们要怎么才能定义为类的属性呢？我们可以为这些属性添加var或val关键字来表示这个属性是可变还是不变的： class Student(var name: String, val age: Int) 这跟我们之前使用变量基本一致： val：不可变属性 var：可变属性 这样才算是定义了类的属性，我们也可以给这些属性设置初始值： class Student(var name: String, val age: Int = 18) //默认每个学生18岁 除了将属性添加到构造函数中，我们也可以将这些属性直接作为类的成员变量写到类中，但是这种情况必须要配一个默认值，否则无法通过编译： class Student { var name: String = \"\" //必须配一个默认值 var age: Int = 0 } 这样我们就可以不编写主构造函数也能定义属性，但是这里仍然会隐式生成一个无参的构造函数，为了构造函数能够方便地传值初始化，也可以像这样写： class Student(name: String, age: Int) { var name: String = name //通过构造函数传递过来 var age: Int = age } 当然，如果各位不希望这些属性在一开始就有初始值，而是之后某一个时刻去设定初始值，我们也可以为其添加懒加载： class Student { lateinit var name: String //懒加载的属性可以不用在一开始赋值，但是在下一次使用之前一定要先完成赋值，否则报错 var age: Int = 0 } 并且，像这样编写的类成员变量，也可以自定义对应的getter和setter属性： class Shape(var width: Int, var height: Int) { val area get() = width * height } 那么，现在我们定义了主构造函数之后，该怎么去使用它呢？ 跟我们调用普通函数一样，这里的函数名称就是类的名称，如果一个类没有编写构造函数，那么这个类默认情况下使用一个无参构造函数创建： fun main() { //我们可以直接使用 类名() 的形式创建对象 Student() } 如果是有构造函数的类，我们只需要填写需要的参数即可，调用之后，类的属性就是这里我们给进去的参数了： fun main() { //我们可以直接使用 类名(参数, 参数...) 的形式创建 Student(\"小明\", 18) } 这样，我们就成功创建出了一个名字为小明的学生类型对象，但是这个对象仅仅是创建出来还不行，我们肯定需要去使用它。 实际上，我们可以像之前使用基本类型一样，使用对象，我们也可以使用一个变量去接收生成出来的对象： fun main() { //使用Student类型的变量接收构造方法得到的对象 var stu: Student = Student(\"小明\", 18) } 有一个我们需要注意的点，这里的stu存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象。 fun main() { val p1 = Student(\"小明\", 18) val p2 = p1 } 这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在） 我们可以来测试一下： fun main() { val s1 = Student(\"小明\", 18) val s2 = s1 println(s1 === s2) //使用 === 可以判断两个变量引用的是不是同一个对象 } 但是如果我们像这样去编写： fun main() { val s1 = Student(\"小明\", 18) val s2 = Student(\"小明\", 18) //即使名字和年龄一样，但是由于这里重新创建了一次对象 println(s1 === s2) //这里比较的就不是同一个对象了 } 我们可以使用.运算符来访问对象的属性，比如我们要访问小明这个学生对象的属性： fun main() { val stu = Student(\"小明\", 18) println(\"对象的name = ${stu.name}, age = ${stu.age}\") } 获取和修改都是可以的： fun main() { val stu = Student(\"小明\", 18) stu.name = \"大明\" stu.age = 10 //由于age属性是val，所以说无法修改，只能读取 } 注意，不同对象的属性是分开独立存放的，虽然都是统一由类完成定义，但是每个对象都有一个自己的空间，修改一个对象的属性并不会影响到另一个相同类型的对象： fun main() { val stu1 = Student(\"小明\", 18) val stu2 = Student(\"小明\", 18) stu1.name = \"小红\" println(\"${stu1.name}, ${stu2.name}\") } 除了直接使用主构造函数创建对象外，我们也可以添加一些次要构造函数，比如我们的学生可以只需要一个名字就能完成创建，我们可以直接在类中编写一个次要构造函数： class Student(var name: String, val age: Int) { constructor(name: String) : this(name, 18) } 如果该类有一个主构造函数，则每个次要构造函数需要通过另一个次要构造函数直接或间接委托给主构造函数。委托到同一类的另一个构造函数是this关键字完成的： class Student(var name: String, val age: Int) { //这里可以使用constructor关键字继续声明次要构造函数 //次要构造函数中的参数仅仅是表示传入的参数，不能像主构造函数那样定义属性 //这里的this表示是当前这个类，this()就是调用当前类的构造函数 constructor(name: String) : this(name, 18) //这里其实是调用主构造函数，并且参数只有name，年龄直接给个默认值18 } 如果一个类没有主构造函数，那么我们也可以直接在在类中编写次要构造函数，但是不需要主动委托一次主构造函数，他这里会隐式包含，所以说我们直接写就行了： class Student { constructor(name: String) //注意，这里的参数不是类属性，仅仅是一个形参！ } 次要构造函数和主构造函数一样，都可以用于对象的创建： fun main() { val stu1 = Student(\"小明\", 18) val stu2 = Student(\"小红\") } 并且次要构造函数可以编写自定义的函数体： open class Student { constructor(str: String) { //在使用辅助构造函数初始化对象时，会执行里面的内容 println(\"我的名字是: $str\") } } 因此，主构造函数相比次要（辅助）构造函数： 主构造函数： 可以直接在主构造函数中定义类属性，使用更方便，但是主构造函数只能存在一个，并且无法编写函数体，只有为类属性做初始化赋值的效果。 辅助（次要）构造函数： 可以存在多个，并且可以自定义函数体，但是无法像主构造函数那样定义类属性，并且当类具有主构造函数时，所有次要构造函数必须直接或间接地调用主构造函数。 Kotlin语言本身比较灵活，类中并不是一定需要主构造函数，全部写辅助构造函数","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"对象的初始化 在对象创建时，我们可能需要做一些初始化工作，我们可以使用初始化代码块来完成，初始化代码块使用init关键字来完成。假如我们希望对象在创建的时候，如果年龄不足18岁，那么就设定为18岁： class Student(var name: String, var age: Int) { //由于主构造函数无法编写函数体 //因此我们可以在init的花括号中编写初始化代码 //注意这段初始化代码块，是在上面的类属性被赋值之后才执行的，所以说能拿到已经赋值的age属性 init { println(\"我是初始化操作\") if(age \u003c 18) age = 18 println(\"初始化操作结束\") } } 这样，我们在创建对象的时候，就会在创建的时候自动执行初始化代码块里面的代码： fun main() { val stu = Student(\"小明\", 15) println(stu.age) } 可以看到初始化操作开始执行了： 初始化操作不仅仅可以有一个，也可以有很多个： class Student { //注意，多个初始化操作时，从上往下按顺序执行 init { println(\"我是一号初始化操作\") } init { println(\"我是二号初始化操作\") } } 对于将成员属性写到类中的情况，同样是按照顺序向下执行，比如： 因为成员变量a是在初始化代码块的后面才初始化的，这里会报错。 如果一个类具有次要构造函数，那么我们也可以直接在次要构造函数中编写一些初始化代码： class Student(var name: String, var age: Int) { constructor(name: String) : this(name, 18) { println(\"我是次要构造函数中的语句\") } } 当我们使用对应的次要构造函数时，就会执行次要构造函数中的初始化代码了。 这里需要注意一下，次要构造函数实际上需要先执行主构造函数，而在执行主构造函数时，会优先将之前我们讲解的初始化代码块执行，比如下面的代码： class Student(var name: String, var age: Int) { init { println(\"我是初始化代码块\") } constructor(name: String) : this(name, 18) { println(\"我是次要构造函数\") } } 无论是有主构造函数还是没有主构造函数（会生成一个默认的无参构造函数）都会先执行。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的成员函数 现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。 而对象也可以做出一些行为，我们可以通过定义函数来实现，类的函数和我们之前编写的函数有一些区别，它是属于这个类的，我们之前使用的函数都是直接编写在Kt文件中，它们都是顶级函数。 class Student(var name: String, var age: Int) { //这个函用于跟大家打招呼 fun hello(){ println(\"大家好啊\") } } 要使用类的成员函数，我们只能通过对象来进行调用： fun main() { val stu = Student(\"小明\", 18) //调用类中的成员方法，同样使用.运算符即可 stu.hello() //让小明这个对象给大家打招呼 } 是不是稍微有一些体会了？好像真的是我们在让对象执行一个动作一样。在类的成员函数中，我们可以直接访问当前类对象中的一些属性，比如我们这里的用户名和年龄： class Student(var name: String, var age: Int) { fun hello(){ println(\"大家好啊，我叫$name，今年${age}岁了\") } } 注意，这里我们访问的name和age属性，是当前这个对象的name和age属性。比如： fun main() { val stu = Student(\"小明\", 18) stu.hello() //让小明这个对象给大家打招呼 val stu2 = Student(\"小红\", 17) stu2.hello() //让小红这个对象给大家打招呼 } 注意，下面这种情况，我们需要特殊处理： class Student(var name: String, var age: Int) { //此时函数的参数也有一个name变量，而类的成员也有一个name属性 fun hello(name: String){ //这里得到的name是哪一个？ println(\"大家好啊，我叫$name，今年${age}岁了\") } } 如果函数中的变量存在歧义，那么优先使用作用域最近的一个，比如函数形参的name作用域更近，那么这里的name拿到的一个是形参name，而不是类的成员属性name。 如果我们需要获取的是类中的成员属性，需要使用this关键字来表示当前类： fun hello(name: String){ //使用this关键字表示当前对象，这样就可以指定这里是类中的this了 println(\"大家好啊，我叫${this.name}，今年${age}岁了\") } 默认情况下，如果作用域不冲突，使用类中属性this可以省略。 在类中，我们同样可以定义多个同名但不同参数的函数实现重载： class Student(private var name: String, private var age: Int) { fun hello() = println(\"大家好啊，我叫${this.name}，今年${age}岁了\") fun hello(gender: String) = println(\"大家好啊，我叫${this.name}，今年${age}岁了，性别${gender}\") } 实际上类中的函数使用起来跟我们之前定义的大差不差，只不过多了更多用法而已。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"再谈基本类型 在Kotlin中，万物皆为对象，实际上我们在上一章学习的全部基本类型，都是官方为我们提供的类。 现在我们学习了类与对象的知识，就可以来重新认识一下这些基本类型，实际上这些基本类型同样是类，也具有一些属性，以及一些类中的成员函数。实际上在上一章中，我们就已经开始使用类和对象了，我们对这些基本类型的操作同样是在操作对象： fun main() { var a = 10 //这里其实是一个Int类型的对象，值为10，而a持有的是对这个Int对象的引用 var b = a //这里的b复制了对上面Int类型对象的引用 } 特别说明： 在Kotlin中，虽然编码时万物皆对象，但是在最终编译时，会根据上下文进行优化性能，大部分情况下会优先编译为Java原生基本数据类型（不是对象）而另一部分情况下才会编译为Java中的Integer包装类型。因此很容易出现以下迷惑行为： val a: Int = 12345 val b: Int = 12345 println(a === b) //true val a: Int? = 12345 val b: Int? = 12345 println(a === b) //false 各位小伙伴可以在完整学习Java和后续Kotlin内容之后再来探究这个问题。 既然这些基本类型也是类，那么肯定同样具有成员属性和成员函数，我们可以使用这些成员方法方便我们的项目开发，比如我们之前遇到的一个很麻烦的问题，不同类型的数无法相互转换： 这些时候可能我们需要将对应类型的数据转换为其他类型，那么该怎么办呢，实际上，在这些基本类型中都提供了对应类型转换成员函数，这里我们可以使用toInt来直接将Double类型的数据转换为Int类型： fun main() { var a: Int = 1.25.toInt() //使用类中的类型转换函数 } 这样就可以编译通过了。同样的，每个基本类型都有对应的类型转换函数，而且非常全面，比如Int类型： 有了这些成员函数，就大幅度方便了我们的类型转换，再比如我们常见的String类型，也有很多函数可以使用： fun main() { val a = \"HelloWorld\" //使用lowercase和uppercase可以快速将字符串中的字母进行大小写转换 println(a.lowercase()) println(a.uppercase()) } 不过需要注意的是，我们在前面就说过，字符串一旦创建就是不可变的，因此，字符串中所有的函数得到的新字符串，都是重新创建的一个新的对象，而不是在原本的字符串上进行修改。 我们继续来看看一些有意思的函数，比如我们想批量替换字符串中的某些内容： fun main() { val a = \"Hello World!\" println(a.replace(\"o\", \"a\")) } 将字符串中所有的字母o替换为a，直接使用replace函数就能直接生成替换之后的字符串了。又比如我们要判断某个字符串是否以指定文本开头： fun main() { val a = \"Hello World!\" println(a.startsWith(\"Hel\")) } 可以看到这里经过判断得到了一个Boolean类型的结果，还有很多用于判断字符串是否为空、是否有空格等等的函数： fun main() { val a = \"Hello World!\" a.isBlank() a.isEmpty() } 我们还发现，这些基本类型中有一些比较特殊的函数，比如plus函数： 这个函数在类中定义长这样： public operator fun plus(other: Long): Long 这个函数添加了一个operator关键字，这个是什么呢？这其实是运算符重载，能够自定义运算符实现的功能，我们之前使用这些数字进行运算，比如加减乘除，实际上都是这些基本类型在类中重载了运算符实现的，下一部分，我们就来介绍一下运算符重载函数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"运算符重载函数 Kotlin支持为程序中已知的运算符集提供自定义实现，这些运算符具有固定的符号表示（如+或*）以及对应的优先级，要实现运算符重载，请为相应类型提供具有对应运算符指定名称的成员函数，而当前的类对象，则直接作为对应运算符左边的操作数，如果是一元运算符（比如++自增运算符，只需要本事）则直接作为操作数参与运算。 比如，现在我们想要为我们自定义的类型支持加法运算： 我们可以直接在类定义中添加一个固定名称（名称是预设好的，不能自己想写什么写什么）的函数，这里的加法运算就是plus函数，我们直接开始编写就可以了： class Student(var name: String, var age: Int) { //注意，二元运算符必须带一个形参，表示右侧的操作数，返回值为计算出来的结果 //形参和结果可以是任意类型，我们还可以提供多次编写同名的运算符重载函数来适配不同的类型 operator fun plus(another: Student): Student{ //比如这里我们希望两个学生对象相加，得到的结果为名字相加，年龄相加的一个新学生 return Student(this.name + another.name, this.age + another.age) } } 这样，我们就成功重载了加法运算符，可以直接上手使用： fun main() { val a = Student(\"小米\", 18) val b = Student(\"华为\", 19) val c = a + b println(\"运算之后得到的新学生，名称：${c.name}，年龄：${c.age}\") } 是不是感觉很简单？只需要将我们需要的对应运算符直接重载，编写好对应的计算规则，就可以直接使用对应的运算符进行计算。 我们也可以试试看重载一些一元运算符，比如取反运算符： class Student(var name: String, var age: Int) { //比如取反操作就是把当前学生的名字反过来 operator fun not() : Student { this.name = this.name.reversed() //这里可以直接在当前对象上进行操作，然后返回当前对象 return this } } 我们来尝试使用一下： fun main() { //直接在这里使用!运算符 val a = !Student(\"小米\", 18) println(\"运算之后得到的新学生，名称：${a.name}，年龄：${a.age}\") } 最后，我们列出常见的一些运算符对应的函数名称，首先是一元运算符： 符号 对应的函数名称 +a a.unaryPlus() -a a.unaryMinus() !a a.not() a-- a.dec()+见下文 a++ a.inc()+见下文 其中inc()和dec()函数比较特殊，它们必须返回一个值，该值将分配给使用++或--操作的变量，而不是改变执行inc或dec操作的对象，意思就是执行后应该得到一个新生成的对象，然后变量的值直接引用到这个新的对象，因为Int类型就是这样的，比如a++的操作步骤如下： 将a的初始值存储到临时存储a0。 将a0.inc()的结果分配给a。 返回a0作为表达式的结果。 同样的，++a的操作步骤如下： 将a.inc()的结果分配给a。 作为表达式的结果返回a的新值。 认识完了一元运算符，我们接着来看一些基本二元运算符： 符号 对应的函数名称 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) a..\u003cb a.rangeUntil(b) 符号 对应的函数名称 a in b b.contains(a) a !in b !b.contains(a) 对于in这种运算，必须返回Boolean类型的结果。 还有一些自增简化运算符： 符号 对应的函数名称 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b) 这类运算符都是将运算结果赋值给左边的操作数，比如a = a + b等价于a += b，这种情况可能会与上面的基本操作产生歧义，比如下面的情况： class Student(var name: String, var age: Int) { //同时定义plus和plusAssign operator fun plus(another: Student) : Student { return this } operator fun plusAssign(another: Student) : Unit{ } } 可以看到，上面的函数中，plus运算符在重载之后，运算结果与当前类型是相同的，这种情况下，就会出现一个问题： plus： 算式 a = a + b 可以成立，因为返回类型相同，可以重新赋值给a plusAssign：为算式 a = a + b 的缩写，与plus的功能完全一致 此时，两个函数都匹配这里的运算符使用，编译器不知道该用哪一个了，因此就会出现歧义： 比较运算符只需要实现一个函数即可： 运算符 对应的函数名称 a \u003e b a.compareTo(b) \u003e 0 a \u003c b a.compareTo(b) \u003c 0 a \u003e= b a.compareTo(b) \u003e= 0 a \u003c= b a.compareTo(b) \u003c= 0 所有比较都会转换为compareTo函数调用，此函数返回Int值，这个值用于判断是否满足条件。 Kotlin非常强大，甚至连小括号都能重载： 运算符 对应的函数名称 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ..., i_n) a.invoke(i_1, ..., i_n) 直接使用变量名称+()来进行使用，感觉很像函数的调用，但是又不是，就很奇怪，不过确实很强大就是了。 还有一些运算符，以我们目前所学知识还无法进行讲解，后续在各位小伙伴学习之后，可以回顾一下： 运算符 对应的函数名称 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, ..., i_n] a.get(i_1, ..., i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, ..., i_n] = b a.set(i_1, ..., i_n, b) 这是索引访问运算符，使用方括号进行表示。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"中缀函数 实际上中缀函数在我们之前很多时候都有出现，比如位运算： println(i shl 1) 这里的shl并不是一个运算符，而是一段自定义的英文单词，像这种运算符是怎么做到的呢？ 这其实是中缀函数，用infix关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，Infix函数必须满足以下要求： 必须是成员函数。 只能有一个参数。 参数不能有默认值。 我们可以像下面这样编写： class Student(var name: String, var age: Int) { //这个中缀函数实现了将给定字符串与当前对象的名字拼接并返回 infix fun test(string: String) : String{ return name + string } } 我们在使用时，也非常方便，真的就像在使用一个运算符一样： fun main() { val student = Student(\"小明\", 18) println(student test \"我爱你\") } 得到的结果显而易见： 当然，我们也可以把它当做一个普通的函数进行调用，效果是完全等价的： fun main() { val student = Student(\"小明\", 18) println(student.test(\"崴泥\")) } 这里需要注意一下： 中缀函数调用的优先级低于算术运算符、类型转换和rangeTo运算符，例如以下表达式就是等效的： 1 shl 2 + 3相当于1 shl (2 + 3) 0 until n * 2相当于0 until (n * 2) xs union ys as Set\u003c*\u003e相当于xs union (ys as Set\u003c*\u003e)（类型转换会在下一章多态进行介绍） 另一方面，infix函数调用的优先级高于布尔运算符\u0026\u0026和||、is-和in-checks以及其他一些运算符的优先级。这些表达式也是等价的： a \u0026\u0026 b xor c相当于a \u0026\u0026 (b xor c) a xor b in c相当于(a xor b) in c 同时，如果需在类中使用中缀函数，必须明确函数的调用方（接收器）比如： class MyStringCollection { infix fun add(s: String) { /*...*/ } fun build() { this add \"abc\" // 正确 add(\"abc\") // 正确 //add \"abc\" // 错误: 没有指定调用方或无法隐式表达 } } 对于中缀函数的使用还是比较简单的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"空值和空类型 所有的变量除了引用一个具体的值之外，还有一种特殊的值可以使用，那就是null，它代表空值，也就是不引用任何对象。 在其他语言中，比如Java中null是一个非常常见的值，因为在某些情况下，引用类型的变量默认值就是null，这就经常会导致程序中出现一些空指针导致的异常，在Kotlin中，对空值处理是非常严格的，正常情况下，我们的变量是不能直接赋值为null的，否则会报错，无法编译通过： 这是因为所有的类型默认都是非空类型，非空类型的变量是不允许被赋值为null的，这直接在编译阶段就避免了其他语言中经常存在的空指针问题。 那么，如果我们希望某个变量在初始情况下使用null而不去引用某一个具体对象，该怎么做呢，此时我们需要将变量的类型修改为可空类型，只需在类型名称的后面添加一个?即可： fun main() { var str: String? = null } 既然现在是可空类型，那么很多问题就会出现了，比如当一个变量为null时，此时如果使用类中的一些成员方法或是获取成员属性时，会出现一些问题： 这里由于我们操作的是一个空类型，它有可能值为null，我们可以想象一下，如果一个变量不引用任何对象，此时我们又去让对象做一些事情（执行函数）这不是在搞笑吗，压根就没这个对象，难道让空气去执行操作吗？这显然是不对的，这样就会导致我们上面所说的空指针异常。 此时，为了安全，我们就需要对变量进行判断，看看其是否为null然后才能去做一些正常情况下该做的事情： fun main() { var str: String? = null //这里直接通过if语句判断str变量是否为null，如果不是才执行 if (str != null) { println(str.length) //现在就可以编译通过了 } } 可以看到，我们只要能确保某个空类型变量的值不为空，那么就可以正常执行操作。当然，实际上在这个if内部，因为已经判断不为null了，所以str被智能类型转换为非空类型，这也是Kotlin语言非常人性化的地方。 不过在有些情况下，我们可能已经非常清楚，这里的str一定不为null，即使它是一个可空类型变量，我们可以像这样做，来告诉编译器，我们这里一定是安全的，只管执行就好： fun main() { var str: String? = null //使用非空断言操作符!!.来明确不会出现null问题 println(str!!.length) } 虽然使用非空断言操作符能够进行强制操作，但是这样实际上并不安全，它同样存在安全问题，也许我们有没考虑到的情况会导致这里为null呢，也说不定吧？对于一些我们拿不定具体会不会出现null的情况，有没有更好的解决办法呢？ Kotlin为我们提供了一种更安全的空类型操作，要安全地访问可能包含null值的对象的属性，请使用安全调用运算符?.，如果对象的属性为null则安全调用运算符返回null，像下面这样： fun main() { var str: String? = null println(str?.length) } 这里的调用结果存在两种情况： 如果str为null，那么这里得到的结果就是null，并且不会正常执行后面的操作 如果str不为null，那就正常返回这里本应该得到的结果 因此，使用安全调用运算符后，如果遇到null的情况，那么这里不会正常进行原本的操作，而是直接返回null作为结果，这在有些时候非常好用，比如我们希望一个学生类型的变量在为null时就不执行对应的语句： fun main() { val stu: Student? = null stu?.hello() } 不过在有些时候，可能我们希望如果变量为null，在使用安全调用运算符时，返回一个我们自定义的结果，而不是null，这时该怎么做呢？我们可以使用Elvis运算符： fun main() { val str: String? = null //Elvis运算符 ?: 左侧为空值检测目标，右侧为检测到null时返回的结果 val len: Int = str?.length ?: 0 } 这里我们使用了Elvis运算符来判断左侧是否为null，如果左侧为null，那么这里直接得到右侧的自定义值，这个运算符长得巨像其他语言里面的三元运算符，Kotlin拿来干这事了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"解构声明 有时候，我们在使用对象时可能需要访问它们内部的一些属性： fun main() { val student = Student(\"小明\", 18) println(student.name) //访问name属性 println(student.age) } 这样看起来不太优雅，有没有更好的方式呢，比如这里能不能直接得到Student对象内部的name和age熟悉作为变量使用？当然是可以的，我们可以直接像下面这样编写： fun main() { val student = Student(\"小明\", 18) val (a, b) = student //从Student对象中将其属性解构出来，很优雅 println(\"名字: $a, 年龄: $b\") } 要让一个类的属性支持解构，我们只需添加约定的函数即可，在Kotlin中，我们可以自定义解构出来的结果，而具体如何获取，需要定义一个componentN函数并通过返回值的形式返回解构的结果： class Student(var name: String, var age: Int) { operator fun component1() = name //使用component1表示解构出来的第一个参数 operator fun component2() = age //使用component2表示解构出来的第二个参数 operator fun component3... //以此类推 } 添加用于解构的函数在之后，我们就可以使用解构操作了： val (a, b) = student //解构出来的参数按顺序就是componentN的结果了 如果我们只想要使用第二个参数，而第一个参数不需要，可以直接使用_来忽略掉： val (_, b) = student println(\"年龄: $b\") 解构同样可以用在Lambda表达式中： val func: (Student) -\u003e Unit = { (a, b) -\u003e //使用括号包括结构出来的两个参数 println(\"名字: $a, 年龄: $b\") } val func2: (Student, Int) -\u003e Unit = { (a, b), i -\u003e println(\"名字: $a, 年龄: $b\") println(i) } val func3: (Student, Int) -\u003e Unit = { (_, b), i -\u003e println(\"名字: $a, 年龄: $b\") println(i) } 解构语法在遍历集合类和数组时同样适用，我们会在后面进行讲解。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:8","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"包和导入 在之前，无论我们创建的是Kotlin源文件还是Kotlin类文件，都是在默认的包下进行的，也就是直接在kotlin/src目录创建的。 但是有些时候，我们可能希望将一些模块按功能进行归类，而不是所有的kt文件都挤在一起，这个时候我们就需要用到包了。 我们可以直接右键新建一个软件包，软件包的包名建议以域名格式进行命名，例如： com.baidu cn.itbaima 这类似于我们平时在浏览器中访问的网站地址，只不过是反过来的，这样就能很明确是哪一家公司或哪一个人制作的产品了。 这里我们随便创建一个： 我们可以将kt文件直接创建在这个包中： 所有不在默认包下kt文件，必须在顶部声明所属的包，比如这里的Test.kt就放在com.test这个包中，因此顶部必须使用package关键字进行包声明，IDEA非常智能，在创建时就自动帮助我们生成好了。我们可以继续像之前一样，编写类或是函数： package com.test var a = 20 fun message() { println(\"我是测试方法\") } class User 不过，由于现在kt文件存放在了一个明确的包中，如果我们要在这个包以外的其他地方使用，会出现一些问题： 当我们使用其他包中kt文件定义的类或函数时，会直接提示未解析的引用，这是因为默认情况下只有同包内的内容可以相互使用，而现在我们使用的是其他包中的内容，我们需要先进行导入操作： import com.test.User //使用import关键字进行导入，导入时需要输入 包名.类型/顶级函数名称 来完成 import com.test.message import com.test.a fun main() { val user = User() message() } 这样，我们在导入之后就可以正常使用了，当然，如果一个包中定义的内容太多，我们需要大量使用，也可以使用*一次性导入全部内容： import com.test.* //导入此包下的全部内容 fun main() { val user = User() message() } 实际上官方提供的库，也是来自于不同的包，但是Kotlin在默认情况下会自动导入一些包，不需要我们明确指定： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 比如我们之前用到的一些基本类型，都是在kotlin这个包中定义的。 注意：在不同的平台下，还会有更多默认导入的包，比如Java平台下，就会默认导入java.lang.*和kotlin.jvm.*这两个包。 在有些情况下，可能会出现名称冲突的情况： import com.test.message fun main() { message() //这里调用的，到底是导入的message函数，还是当前kt文件定义的函数呢？ } fun message(){ println(\"Goodbye World!\") } 结果显而易见，这里会优先使用导入的函数，而不是在当前文件中定义的同名函数。那么该如何去解决这种冲突的情况呢？我们可以使用as关键字来为导入的内容起个新的名字： import com.test.message as outer //将导入的message函数名字改为outer fun main() { message() //此时这里调用的就是下面的message函数了 } fun message(){ println(\"Goodbye World!\") } 这样就可以很好地消除存在歧义的情况了，最后总结一下，使用import关键字支持导入以下内容： 顶级函数和属性 在单例对象中声明的函数和属性（下一章介绍） 枚举常量（下一章介绍） ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:9","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"访问权限控制 有些时候，我们可能不希望别人使用我们的所有内容，比如： package com.test fun message() { println(\"我是测试方法\") } fun inner(){ //我们不希望这个函数能够在其他地方被调用 } 在上面的例子中，有一个函数是我们不希望被外部调用的，但是经过前面的学习，我们只需要使用import关键字就能直接导入，那有没有办法能够控制一下其他地方对于当前文件一些可能私有函数或是其他内容的访问呢？我们可以使用可见性控制来处理。 在类、对象、接口、构造函数和函数，以及属性上，可以为其添加 可见性修饰符 来控制其可见性，在Kotlin中有四个可见性修饰符，它们分别是：private、protected、internal和public，默认可见性是public，在使用顶级声明时，不同可见性的访问权限如下： 如果不使用可见性修饰符，则默认使用public，这意味着这里声明的内容将在任何地方可访问。 如果使用private修饰符，那么声明的内容只能在当前文件中可访问。 如果使用internal修饰符，它将在同一模块中可见（当前的项目中可以随意访问，与public没大差别，但是如果别人引用我们的项目，那么无法使用） 顶级声明不支持使用protected修饰符。 因此，在默认情况下，我们定义的内容都是可以访问的，而想要实现上面的效果，我们可以为其添加private修饰符： private fun inner(){ //我们不希望这个函数能够在其他地方被调用 } 这样，当其他地方使用时，就会报错： 在类中定义成员属性时，不同可见性的访问权限如下： private意味着该成员仅在此类中可见（包括其所有成员） protected与private的可见性类似，外部无法使用，但在子类中可以使用（子类会在下一章中介绍） internal意味着本项目中任何地方都会看到其internal成员，但是别人引用我们项目时不行。 public意味着任何地方都可以访问。 比如下面的例子： class Student(private var name: String, //name属性无法被外部访问，因为是私有的 internal var age: Int) { //age可以被外部访问，但是无法再其他项目中访问到 private constructor() : this(\"\", 10) //这个无参构造无法被外部访问，因为是私有的 } 有了访问控制，我们就可以更加明确地表示哪些内容是可以访问，而哪些是内部使用的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:10","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"封装、继承和多态 封装、继承和多态是面向对象编程的三大特性。 封装，把对象的属性和函数结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。 继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和函数，并根据实际需求扩展出新的行为。 多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的函数。 正是这三大特性，能够让我们的Kotlin程序更加生动形象。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的封装 封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个程序带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter函数来查看和设置变量。从这里开始，我们前面学习的权限访问控制就开始起作用了。 我们可以将之前的类进行改进： class Student(private var name: String, private var age: Int) { fun getName(): String = name fun getAge(): Int = age } 现在，外部需要获取一个学生对象的属性时，只能使用特定的函数进行获取，而不像之前一样可以随意访问对象的属性： fun main() { var student = Student(\"\", 1) //student.name 这样就不行了 println(student.getName()) } 这样的好处显而易见，其他地方只能拿到在内部某个成员属性引用的对象，而没办法像之前那样直接修改Student对象中某个成员属性。 同样的，如果要运行外部对对象中的属性进行修改，那么我们也可以提供对应的set函数： class Student(private var name: String, private var age: Int) { ... fun setName(name: String){ //使用set函数来修改 this.name = name } } 等等，这不就是我们之前讲的属性的getter和setter函数吗，没错，哪怕我们不手动编写，成员属性也会存在默认的。但是，除了直接赋值之外我们也可以设置更多参数才能给学生改名字： class Student(private var name: String, private var age: Int) { fun setName(name: String, upper: Boolean){ //判断是否upper来决定最终赋值的名字大写还是小写 this.name = if (upper) name.uppercase() else name.lowercase() } } 我们自己封装好的名字设置方法暴露给外部使用，而不让外部直接操作名字。 我们甚至还可以将主构造函数改成私有的，需要通过其他的构造函数来构造： class Student private constructor(private var name: String, private var age: Int) { constructor() : this(\"\", 18) } 封装思想其实就是把实现细节给隐藏了，外部只需知道这个函数是什么作用，如何去用，而无需关心实现，要用什么由类自己提供好，而不需要外面来操作类内部的东西去完成（你让我做一件事情，我自己的事情自己做，不要你来帮我安排）封装就是通过访问权限控制来实现的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的继承 前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。 在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，根据前面的访问权限等级，子类可以使用父类中所有非私有的成员。 比如说我们一开始使用的学生，那么实际上学生根据专业划分，所掌握的技能也会不同，比如体育生会运动，美术生会画画，土木生会搬砖，计算机生会因为互联网寒冬找不到工作，因此，我们可以将学生这个大类根据不同的专业进一步地细分出来： 虽然我们划分出来这么多的类，但是其本质上还是学生，也就是说学生具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。就好比大学里的学生无论什么专业都会打游戏，都会睡觉，逃课，考试抄答案，四六级过不了，只不过他们专业不同，学的的方向不一样，也就掌握了其他专业不具备的技能。 在Kotlin中，我们可以使用继承操作来实现这样的结构，默认情况下，Kotlin类是“终态”的（不能被任何类继承）要使类可继承，请用open关键字标记需要被继承的类： open class Student { //被继承的类我们称为父类 val xxx = \"学生证\" fun hello() = println(\"我会打招呼\") } 我们可以像下面这样来创建一个继承学生的类： class ArtStudent : Student() { //以调用构造函数的形式进行声明 //这个类就是Student类的子类 fun draw() = println(\"我会画画\") //子类中也可以继续编写自己独有的函数 } 类的继承可以不断向下，但是同时只能继承一个类，在Kotlin中不支持多继承，只不过套娃还是可以的： open class Student open class ArtStudent: Student() //继承了一级，相当于Student的儿子 open class SuperArtStudent: ArtStudent() //继承了两级，相当于Student的孙子 class SuperBigArtStudent: SuperArtStudent() //继承了三级，相当于Student的祖孙 当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为private，那么子类将无法访问（但是依然是继承了这个属性的）比如下面的例子： fun main() { var student = ArtStudent() student.hello() //虽然这里是ArtStudent对象，但是由于其继承的是Student，因此包含Student中的属性 student.draw() //自己的属性也可以使用 print(student.xxx) //不止函数，父类中的成员字段也是没有问题的 } 是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。这里需要特别注意一下，因为子类相当于是父类的扩展，但是依然保留父类的特性，所以说，在对象创建并初始化的时候，不仅会对子类进行初始化，也会优先对父类进行初始化： open class Student() { init { println(\"父类初始化\") } fun hello() = println(\"我会打招呼\") } class ArtStudent() : Student() { init { println(\"子类初始化\") } fun draw() = println(\"我会画画\") } 实际上这里就是在构造这个子类对象之前，调用了一次父类的构造函数，而我们用于继承指定的构造函数，就是会被调用的那一个。 因此，如果父类存在一个有参构造函数，子类同样必须在构造函数中调用： open class Student(name: String, age: Int) { fun hello() = println(\"我会打招呼\") } //子类必须适配其父类的构造函数，因为需要先对父类进行初始化 //其实就是去调用一次父类的构造函数，填入需要的参数即可，这里的参数可以是当前子类构造方法的形参，也可以是直接填写的一个参数 class ArtStudent(name: String, age: Int) : Student(name, 18) { fun draw() = println(\"我会画画\") } 如果父类存在多个构造函数，可以任选一个： open class Student() { constructor(str: String) : this() constructor(str: String, age: Int) : this() fun hello() = println(\"我会打招呼\") } class ArtStudent : Student(\"小明\", 18) { //任选一个父类构造函数即可 fun draw() = println(\"我会画画\") } 当子类只存在辅助构造函数时，需要使用super关键字来匹配父类的构造函数： open class Student { constructor(str: String) constructor(str: String, age: Int) fun hello() = println(\"我会打招呼\") } //子类不写主构造函数时，可以直接在冒号后面添加父类类名 class ArtStudent : Student { constructor(str: String) : super(str) //使用super来调用父类构造函数,super表示父类（超类） constructor(str: String, age: Int) : super(str, age) fun draw() = println(\"我会画画\") } 也可以去匹配子类中其他构造函数： class ArtStudent : Student { constructor(str: String) : this(str, 18) //也可以调用子类其他构造函数，但是其他构造函数依然要间接或直接调用父类构造函数 constructor(str: String, age: Int) : super(str, age) fun draw() = println(\"我会画画\") } 如果子类既有主构造函数，也有辅助构造函数，那么其他辅助构造函数只能直接或间接调用主构造函数： open class Student() { constructor(str: String) : this() constructor(str: String, age: Int) : this() fun hello() = println(\"我会打招呼\") } class ArtStudent() : Student() { constructor(str: String) : this() //正确，必须直接或间接调用主构造函数 constructor(str: String, age: Int) : super(str, age) //报错，不能绕过主构造函数去匹配父类构造函数 fun draw() = println(\"我会画画\") } 是不是感觉玩法太多，都眼花缭乱了？实际上只要各位小伙伴心里面清楚下面的规则，就很好理解上面这一堆写法了： 构造函数相当于是这个类初始化的最基本函数，在构造对象时一定要调用 主构造函数因为可能存在一些类的属性，所以说必须在初始化时调用，不能让这些属性初始化时没有初始值 子类因为是父类的延展，因此，子类在初始化时，必须先初始化父类，就好比每个学生都有学生证，这是属于父类的属性，如果子类在初始化时可以不去初始化父类，那岂不是美术生可以没有学生证？显然是不对的。 优先级关系：父类初始化 \u003e 子类主构造 \u003e 子类辅助构造 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"属性的覆盖 有些时候，我们可以希望子类继承父类的某些属性，但是我们可能希望去修改这些属性的默认实现。比如，美术生虽然也是学生，也会打招呼，但是可能他们打招呼的方式跟普通的学生不太一样，我们能否对打招呼这个函数的默认实现进行修改呢？ 我们可以使用override关键字来表示对于一个属性的重写（覆盖）就像这样： open class Student { //注意，跟类一样，函数必须添加open关键字才能被子类覆盖 open fun hello() = println(\"我会打招呼\") } class ArtStudent : Student() { fun draw() = println(\"我会画画\") //在子类中编写一个同名函数，并添加override关键字，我们就可以在子类中进行覆盖了，然后编写自己的实现 override fun hello() = println(\"哦哈哟\") } 覆盖之后，当我们使用子类进行打招呼时，函数会按照我们覆盖的内容执行，而不是原本的： 同样的，类的某个变量也是可以进行覆盖的： open class Student { open val test: String = \"测试\" fun hello() = println(\"我会打招呼: $test\") //这里拿到的test就会变成被覆盖掉的 } class ArtStudent : Student() { //对父类的变量进行覆盖，类型必须一样 override val test: String = \"干嘛\" fun draw() = println(\"我会画画\") } 是不是感觉很神奇？不过对于可变的变量，似乎下面这样来的更方便？ open class Student { var test: String = \"测试\" fun hello() = println(\"我会打招呼: $test\") } class ArtStudent : Student() { init { test = \"干嘛\" } fun draw() = println(\"我会画画\") } 有些时候为了方便，比如在父类中的属性，我们可以直接在子类的主构造函数中直接覆盖： open class Student { open val name: String = \"大明\" fun hello() = println(\"我会打招呼，我叫: $name\") } //在主构造函数中覆盖，也是可以的，这样会将构造时传入的值进行覆盖 class ArtStudent(override val name: String) : Student() { fun draw() = println(\"我会画画\") } fun main() { val student = ArtStudent(\"小红\") student.hello() } 虽然现在已经很方便了，但是现在又来了一个新的需求，打招呼不仅要有子类的特色，同时也要保留父类原有的实现，这个时候该怎么办呢？我们可以使用super关键字来完成： open class Student { open fun hello() = println(\"我会打招呼\") } class ArtStudent : Student() { fun draw() = println(\"我会画画\") override fun hello() { //覆盖父类函数 super.hello() //使用super.xxx来调用父类的函数实现，这里super同样表示父类 println(\"哦哈哟\") //再写自己的逻辑 } } 这样，我们在覆盖原本的函数时，也可以执行原本的实现，在一些对函数内容进行增强的常见，这种用法非常常见： 不过，由于存在我们之前讲解的的初始化顺序，下面的这种情况需要特别注意： open class Student { open val name: String = \"小明\" init { println(\"我的名字是: ${name.length}\") } //这里拿到的name实际上是还未初始化的子类name } class ArtStudent : Student() { override val name = \"大明\" } fun main() { val student = ArtStudent() } 由于父类初始化在子类之前，此时子类还未开始初始化，其覆盖的属性此时没有初始值，根据不同平台的实现，可能会出现一些问题，比如JVM平台下，没有初始化的对象引用默认为null，那么这里就会直接报空指针异常： 很神奇对吧，这里的name属性明明是一个非可空的String类型，居然还会出现null的情况报空指针，因此，对于这些使用了open关键字的属性（函数、变量等）只要是在初始化函数、构造函数中使用，IDEA都会给出警告： 我们接着来讲一个很绕的东西，在使用一些子类的时候，我们实际上可以将其当做其父类来进行使用： fun main() { val student: Student = ArtStudent() //使用Student类型的变量接收一个ArtStudent类型的对象引用 } 之所以支持这样去使用，是因为子类本身就是对父类的延伸，因此将其当做父类使用，也是没有问题的。就好比我们无论是美术生还是体育生，都可以当做学生来用，都可以送去厂里实习打螺丝，不然不给毕业证。 只不过，如果我们将一个对象作为其父类使用，那么在使用时也只能使用其父类的一些属性，就相当于我们在使用一个父类的对象： 即使我们很清楚这里引用的对象是一个美术生，但是只能当做普通学生来用，这在后面的集合类中会经常用到，因为集合类往往存在多种不同的实现，但是我们只需要关心怎么用就行了，并且为了方便更换实现，所以一般使用集合类对应的接口来作为变量的类型。 那么，如果子类重写了父类的某个函数，此时我们以父类的形式去使用，结果会怎么样？ open class Student { open fun hello() = println(\"大家好\") } class ArtStudent : Student() { override fun hello() = println(\"我姓🐴我叫🐴牛逼\") } 可以看到，虽然当做父类来使用，但是其本质是不会变的，所以说，这里执行的结果依然是子类的覆盖实现。 那么，如果项目中很多这种明明是子类但是拿来当做父类用，我们怎么去判断使用的对象到底是什么类型的呢？我们可以使用is关键字来进行类型判断，以下面的三个类为例： open class Student class ArtStudent : Student() class SportStudent : Student() 现在我们进行类型判断： fun main() { val student: Student = ArtStudent() println(student is ArtStudent) //true，因为确实是这个类型 println(student is SportStudent) //false，因为不是这个类型 println(student is Student) //true，因为是这个类型的子类 } 可以看到，使用is关键字可以精准地对类型进行判断，只要判断的对象是这个类或是这个类的子类，那么就会返回true作为结果。 如果我们明确某个变量引用的对象是什么类型，可以使用as关键字来进行强制类型转换： fun main() { val student: Student = ArtStudent() if(student is ArtStudent) { val artStudent = student as ArtStudent; artStudent.draw() //强制类型转换之后，可以直接变回原本的类型去使用 } } 不过，编译器非常智能，它可以根据当前的语境判断的类型自动进行类型转换： val student: Student = ArtStudent() if(student is ArtStudent) { student.draw() } 此时IDEA中会出现提示： 不仅仅是if判断的场景、包括when、while，以及\u0026\u0026 || 等运算符都支持智能转换，只要上下文语境符合就能做到： fun main() { val student: Student? = ArtStudent() //很明显这里是当student为ArtStudent时，根据语境直接智能转换 while (student is ArtStudent) student.draw() //很明显如果这前面已经判断为真了，那肯定是这个类型，后面也可以智能转换 if(student is ArtStudent \u0026\u0026 student.draw()) } 不仅仅是这种场景，比如我们前面讲解的可空类型，同样支持这样的智能转换： fun main() { val student: Student? = ArtStudent() student?.hello() if (student != null) //判断到如果不为null student.hello() //根据语境student智能转换为了非空Student类型 } 在处理一些可空类型时，为了防止出现异常，我们可以使用更加安全的as?运算符： fun main() { val student: Student? = ArtStudent() val artStuden","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"顶层Any类 在我们不继承任何类的情况下，实际上Kotlin会有一个默认的父类，所有的类默认情况下都是继承自Any类的。 这个类的定义如下： /** * Kotlin类继承结构中的根类. 所有Kotlin中的类都会直接或间接将Any作为父类 */ public open class Any { /** * 判断某个对象是否\"等于\"当前对象，这里同样是对运算符\"==\"的重载，而具体判断两个对象相等的操作需要由子类来定义 * 在一些特定情况下，子类在重写此函数时应该保证以下要求: * * 可反身: 对于任意非空值 `x`, 表达式 `x.equals(x)` 应该返回true * * 可交换: 对于任意非空值 `x` 和 `y`, `x.equals(y)` 当且仅当 `y.equals(x)` 返回true时返回true * * 可传递: 对于任意非空值 `x`, `y`, 和 `z`, 如果 `x.equals(y)` 和 `y.equals(z)` 都返回true, 那么 `x.equals(z)` 也应该返回真 * * 一致性: 对于任意非空值 `x` 和 `y`, 在多次调用 `x.equals(y)` 函数时，只要不修改在对象的“equals”比较中使用的信息，那么应当始终返回同样的结果 * * 永不等于空: 对于任意非空值 `x`, `x.equals(null)` 应该始终返回false */ public open operator fun equals(other: Any?): Boolean /** * 返回当前对象的哈希值，它具有以下约束: * * * 对同一对象多次调用该函数时，只要不修改对象上的equals比较中使用的信息，那么此函数就必须始终返回相同的整数 * * 如果两个对象通过`equals`函数判断为true，那么这两个对象的哈希值也应该相同 */ public open fun hashCode(): Int /** * 将此对象转换为一个字符串，具体转换为什么样子的字符串由子类自己决定 */ public open fun toString(): String } 由于默认情况下类都是继承自Any，因此Any中定义的函数也是被继承到子类中了。 首先我们来看这个equals函数，它实际上是对==这个运算符的重载，我们之前在使用一些基本类型的时候，就经常使用==来判断这些类型是否相同，比如Int类型的数据： fun main() { val a = 10 val b = 20 println(a == b) println(a.equals(b)) //跟上面的写法完全一样 } 经过前面的学习，我们知道这些基本类型本质上也是定义的类，实际上它们也是通过重写这个函数来实现这些比较操作的（一些基本类型会根据不同的平台进行编译优化，没法看源码） 我们可以看到，这个函数接受的参数类型是一个Any?类型： public open operator fun equals(other: Any?): Boolean //我们上节课说到一个子类也可以被当做父类类型的变量去使用，所以说equals判断接受的参数为了满足不同的类型变量之间进行比较，直接使用顶层Any作为参数（考虑到会用到可空类型，所以说直接用了Any?作为参数类型） 到目前为止，我们认识了Kotlin中两种相等的判断方式： 结果上 相等 (== 等价于 equals()) 引用上 相等 (=== 判断两个变量是否都是引用的同一个对象) 我们在使用equals比较两个可空对象是否相等时，就像这样： a == b 实际上会被翻译为： a?.equals(b) ?: (b === null) //a如果为null那就直接判断b是不是也为null，否则直接调用a的equals函数并让b作为参数 当然可能会有小伙伴疑问，那不等于判断呢？实际上是一样的： fun main() { val a = \"10\" val b = \"20\" println(a != b) println(!a.equals(b)) //等价于上面的写法 } 我们也可以为我们自己编写的类型重写equals函数，比如我们希望Student类型当名字和年龄相等时，就可以使用==来判断为true，我们可以像这样编写： class Student(val name: String, val age: Int) { override fun equals(other: Any?): Boolean { if(this === other) return true //如果引用的是同一个对象，肯定是true不多逼逼 if(other !is Student) return false //如果要判断的对象根本不是Student类型的，那也不用继续了 if(name != other.name) return false //判断名字是否相同 if(age != other.age) return false //判断年龄是否相同 return true //都没问题，那就是相等了 } } 此时我们已经将其比较操作重写，我们可以来试试看： fun main() { val a = Student(\"小明\", 18) val b = Student(\"小红\", 17) val c = Student(\"小明\", 18) println(a == a) //返回true因为就是自己 println(a == b) //返回false因为名字和年龄不一样 println(a == c) //返回true因为名字和年龄完全一样 } 默认情况下，如果我们不重写类的equals函数，那么会直接对等号两边的变量进行引用判断===判断是否为同一个对象。只不过，可以很清楚地看到IDEA提示我们： 实际上在我们重写类的equals函数时，根据约定，必须重写对于的hashCode函数，至于为什么，我们会在后续的集合类部分中进行介绍，这里我们暂时先不对hashCode函数进行讲解。 接着我们来看下一个，toString函数用于快速将对象转换为字符串，只不过默认情况下，会像这样： fun main() { val a = Student(\"小明\", 18) println(a.toString()) println(a) //println默认情况下会直接调用对象的toString并打印，所以跟上面是一样的 } 可以看到打印的结果是对象的类型@十六进制哈希值的形式，在某些情况下，可能我们更希望的是转换对象的一些成员属性，这样我们可以更直观的看到对象的属性具有什么值： class Student(val name: String, val age: Int) { override fun toString(): String { //直接重写toString函数 return \"Student(name='$name', age=$age)\" } } 现在得到的结果，就是我们自定义的结果了： ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"抽象类 有些情况下，我们设计的类可能仅仅是作为给其他类继承使用的类，而其本身并不需要创建任何实例对象，比如： open class Student protected constructor() { //无法构造这个父类，要求使用子类 open fun hello() = println(\"Hello World!\") } class ArtStudent: Student() { override fun hello() = println(\"原神\") //两个子类都对hello进行了实现，采用各自的方式 } class SportStudent: Student() { override fun hello() = println(\"启动\") } 可以看到，在上面这个例子中，Student类的hello函数在子类中都会被重写，所以说除非在子类中调用父类的默认实现，否则一般情况下，父类中定义的函数永远都不会被调用。 就像我们说一个学生会怎么考试一样，实际上学生怎么考试是一个抽象的概念，但是由于学生的种类繁多，美术生怎么考试和体育生怎么考试，才是具体的一个实现。所以说，我们可以将学生类进行进一步的抽象，让某些函数或字段完全由子类来实现，父类中不需要提供实现。我们可以使用abstract关键字来将一个类声明为抽象类： //使用abstract表示这个是一个抽象类 abstract class Student { abstract val type: String //抽象类中可以存在抽象成员属性 abstract fun hello() //抽象类中可以存在抽象函数 //注意抽象的属性不能为private，不然子类就没法重写了 } 当一个子类继承自抽象类时，必须要重写抽象类中定义的抽象属性和抽象函数： class ArtStudent: Student() { override val type: String = \"美术生\" override fun hello() = println(\"原神，启动！\") } 这是强制要求的，如果不进行重写将无法通过编译。同时，抽象类是不允许直接构造对象的，只能使用其子类： 当然，抽象类不仅可以具有抽象的属性，同时也具有普通类的性质，同样可以定义非抽象的属性或函数： abstract class Student { abstract val type: String abstract fun hello() fun test() = println(\"不会有人玩到大三了才开始学Java吧\") //定义非抽像属性或函数，在子类中不强制要求重写 } 同时，抽象类也可以继承自其他的类（可以是抽象类也可以是普通类） open class Test //直接继承一个普通的类 abstract class Student: Test(){ ... } 虽然抽象类可以继承一个普通的类，但是这依然不改变它是抽象类的本质，子类依然要按照上面的要求进行编写。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"接口 由于Kotlin中不存在多继承的操作，我们可以使用接口来替代。 前面我们认识了抽象类，它可以具有一些定义而不实现的内容，而接口比抽象类还要抽象，一般情况下，他只代表某个确切的功能！也就是只能包含函数或属性的定义，所有的内容只能是abstract的，它不像类那样完整。接口一般只代表某些功能的抽象，接口包含了一系列内容的定义，类可以实现这个接口，表示类支持接口代表的功能。 比如，学生具有以下功能： 打游戏 睡懒觉 逃课 考试作弊 我们可以将这一系列功能拆分成一个个的接口，然后让学生实现这些接口，来表示学生支持这些功能。 在Kotlin中，要声明接口，我们可以使用interface关键字： interface A { val x: String //接口中所有属性默认都是abstract的（可省略关键字） fun sleep() //接口中所有函数默认都是abstract的（可省略关键字） } interface B { fun game() } class Student: A, B { //接口的实现与类的继承一样，直接写到后面，多个接口用逗号隔开 override val x: String = \"测试\" //跟抽象类一样，接口中的内容是必须要实现的 override fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") override fun game() = println(\"读大学就该玩游戏玩到爽\") } 可以看到，接口相比于抽象类来说，更加的纯粹，它不像类那样可以具有什么确切的属性，一切内容都是抽象的，只能由子类来实现。 只不过，在接口中声明的属性可以是抽象的，也可以为Getter提供默认实现。在接口中声明的属性无法使用field后背字段，因此在接口中声明的Setter无法使用field进行赋值： interface A { val x: String get() = \"666\" //只能重写getter，不能直接赋值，因为默认情况下getter是返回的field的值，但是接口里不让用 } interface A { var x: String get() = \"666\" set(value) { /* 默认的setter会直接报错，因为使用了field字段 */ } } 为了应对变化多端的需求，接口也可以为函数编写默认实现： interface A { //接口中的函数可以具有默认实现，默认情况下是open的，除非private掉 fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") } 这样一看，这函数可以写默认的实现那接口似乎变得不那么抽象了？这用着感觉好像跟抽象类没啥区别啊？接口跟类的最大区别其实就是状态的保存，这从上面的成员属性我们就可以看的很清楚。 接口也可以继承自其他接口，直接获得其他接口中的定义： interface A{ fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") } interface B{ fun game() = println(\"读大学就该玩游戏玩到爽\") } interface C: A, B //接口的继承写法是一样的，并且接口继承接口是支持多继承的 class Student: C //直接获得ABC三个接口的功能 是不是感觉接口的玩法非常有意思？只不过玩的过程中，可能也会遇到一些麻烦，比如下面的这种情况： interface A{ fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") } interface B{ fun sleep() = println(\"7点起床学Java了，不能再睡了\") } class Student: A, B //由于A和B都具有sleep函数，那现在到底继承谁的呢？ 这种情况下，我们需要手动解决冲突，比如我们希望Student类采用接口B的默认实现： class Student: A, B { override fun sleep() { //手动重写sleep函数，自行决定如何处理冲突 super\u003cB\u003e.sleep() //使用super关键字然后添加尖括号指定对应接口，并手动调用接口对应函数 } } 对于接口，我们可以像之前一样，将变量的类型设定为一个接口的类型，当做某一个接口的实现来使用，同时也支持is、as等关键字进行类型判断和转换： fun main() { val a: A = Student() a.sleep() //直接当做A接口用（只能使用A接口中定义的内容） println(a is B) //判断a引用的对象是否为B接口的实现类 } 是不是感觉跟之前使用起来是差不多的？其实只要前面玩熟悉了，后面还是很简单的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的扩展 Kotlin提供了扩展类或接口的操作，而无需通过类继承或使用装饰器等设计模式，来为某个类添加一些额外的函数或是属性，我们只需要通过一个被称为扩展的特殊声明来完成。 例如，您可以从无法修改的第三方库中为类或接口编写新函数，这些函数可以像类中其他函数那样进行调用，就像它们是类中的函数一样，这种机制被称为扩展函数。还有扩展属性，允许您为现有类定义新属性。 比如我们想为String类型添加一个自定义的操作： //为官方的String类添加一个新的test函数，使其返回自定义内容 fun String.test() = \"666\" fun main() { val text = \"Hello World\" println(text.test()) //就好像String类中真的有这个函数一样 } 是不是感觉很神奇？通过这种机制，我们可以将那些第三方类不具备的功能强行进行扩展，来方便我们的操作。 注意，类的扩展是静态的，实际上并不会修改它们原本的类，也不会将新成员插入到类中，仅仅是将我们定义的功能变得可调用，使用起来就像真的有一样。同时，在编译时也会明确具体调用的扩展函数： open class Shape class Rectangle: Shape() fun Shape.getName() = \"Shape\" fun Rectangle.getName() = \"Rectangle\" //虽然这里同时扩展了父类和子类的getName函数 fun printClassName(s: Shape) { //但由于这里指定的类型是Shape，因此编译时也只会使用Shape扩展的getName函数 println(s.getName()) } fun main() { printClassName(Rectangle()) } 由于类的扩展是静态的，因此在编译出现歧义时，只会取决于形参类型。 如果是类本身就具有同名同参数的函数，那么扩展的函数将失效： class Test { fun hello() = println(\"你干嘛\") } fun Test.hello() = println(\"哎哟\") fun main() { Test().hello() //你干嘛 } 不过，我们如果通过这种方式实现函数的重载，是完全没有问题的： class Test { fun hello() = println(\"你干嘛\") } fun Test.hello(str: String) = println(str) //重载一个不同参数的同名函数 fun main() { Test().hello(\"不错\") //有效果 } 同样的，类的属性也是可以通过这种形式来扩展的，但是有一些小小的要求： 可以看到直接扩展属性是不允许的，前面我们说过，扩展并不是真的往类中添加属性，因此，扩展属性本质上也不会真的插入一个成员字段到类的定义中，这就导致并没有变量去存储我们的数据，我们只能明确定义一个getter和setter来创建扩展属性，才能让它使用起来真的像是类的属性一样： val Student.gender: String get() = \"666\" fun main() { val stu = Student() println(stu.gender) } 由于扩展属性并没有真正的变量去存储，而是使用get和set函数来实现，所以，像前面认识的field这种后备字段，就无法使用了。 还有一个需要注意的时，我们在不同包中定义的扩展属性，同样会受到访问权限控制，需要进行导入才可以使用： import com.test.gender fun main() { val stu = Student() println(stu.gender) } 除了直接在顶层定义类的扩展之外，我们也可以在一个类中定义其他类的扩展，并且在定义时可以直接使用其他类提供的属性： class A { fun hello() = \"Hello World\" } class B { fun A.test() { hello() //直接在类A的扩展函数中调用A中定义的函数 } } 像这种扩展，由于是在类中定义，因此也仅限于类内部使用，比如： class A { fun hello() = \"Hello World\" } class B (private val a: A){ private fun A.test() = hello() + \"!!!\" fun world() = println(a.test()) //只能在类中通过A的实例使用扩展函数 } fun main() = B(A()).world() 扩展属性无法访问那些本就不应该被当前作用域访问的类属性，即使它是对某个类的扩展，比如下面这种情况： 在名称发生冲突时，需要特别处理： class A { fun hello() = \"Hello World\" } class B (private val a: A){ private fun A.test() { hello() //直接使用优先匹配被扩展类中的方法 this.hello() //扩展函数中的this依然指的是被扩展的类对象 this@B.hello() //这里调用的才是下面的 } fun hello() = \"Bye World\" } 定义在类中的扩展也可以跟随类的继承结构，进行重写： open class A { open fun Student.test() = \"AAA\" fun hello() = println(Student().test()) } class B : A() { override fun Student.test() = \"BBB\" //对父类定义的扩展函数进行重写 } fun main() { A().hello() B().hello() } 局部扩展也是可以的，我们可以在某个函数里面编写扩展，但作用域仅限于当前函数： fun main() { fun String.test() = \"\" \"\".test() } 如果我们将一个扩展函数作为参数给到一个函数类型变量，那么同样需要再具体操作之前增加类型名称才可以： fun main() { //因为是对String类型的扩展函数，需要String.前缀 val func: String.() -\u003e Int = { this.length //跟上面一样，扩展函数中的this依然指的是被扩展的类对象 } println(\"sahda\".func()) //可以直接对符合类型的对象使用这个函数 func(\"Hello\") //如果是直接调用，那么必须要传入对应类型的对象作为首个参数，此时this就指向我们传入的参数 } 可以看到，此函数的类型是String.() -\u003e Int ，也就是说它是专门针对于String类型编写的扩展函数，没有参数，返回值类型为Int，并使用Lambda表达式进行赋值，同时这个函数也是属于String类型的，只能由对象调用，或是主动传入一个相同类型的对象作为参数才能直接调用。可能这里会有些绕不太好理解，需要同学们多去思考。 总结一下，扩展属性更像是针对于原本类编写的外部工具函数，而绝不是对原有类的修改。 Kotlin程序设计高级篇 在学习了前面的内容之后，相信各位小伙伴应该对Kotlin这门语言有了一些全新的认识，我们已经了解了大部分的基本内容，从本章开始，就是对我们之前所学的基本内容的进一步提升。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"泛型 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入，从泛型开始，再到我们的集合类学习，循序渐进。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"什么是泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？ 现在的问题就是，成绩可能是String类型，也可能是Int类型，如何才能更好的去存可能出现的两种类型呢？ class Score(var name: String, var id: String, var value: Any) { //因为Any是所有类型的父类，因此既可以存放Int也能存放String } fun main() { Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\") //文字和数字都可以存 Score(\"计算机操作系统\", \"EP074533\", 95) } 虽然这样看起来很不错，但是Any毕竟是所有类型的顶级父类，在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： fun main() { val score = Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\") ... val a: Int = score.value as Int //获取成绩需要进行强制类型转换 } 使用Any类型作为引用虽然可以做到任意类型存储，但是对于使用者来说，由于是Any类型，所以说并不能直接判断存储的类型到底是String还是Int，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺。 所以说这种解决办法虽然可行，但并不是最好的方案，我们需要使用一个更好的东西来实现： 泛型 泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型，Kotlin中的类可以具有类型参数： class Score\u003cT\u003e(var name: String) //这里的T就是一个待定的类型，同样是这个类具有的，我们称为泛型参数 可以看到，它相比普通的类型，仅仅多了一个\u003cT\u003e表示类型参数，那么如何使用呢？ fun main() { //在创建对象时，再来明确使用的是什么类型，同样使用尖括号填写 val score = Score\u003cInt\u003e(\"数据结构与算法\") } 既然可以做到使用时明确，那现在我们应该怎么去设计这个类呢？ class Score\u003cT\u003e(var name: String, var id: String, var value: T) //我们在定义类型参数后，T就是一个待定类型，我们可以直接将value属性的类型定义为T fun main() { val score = Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\") //在使用时，使用\u003cString\u003e来明确Score的值类型，此时value的类型也会变成String val value: String = score.value //得到的直接就是String类型的结果 } 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译，同时，如果我们这里填入的参数明确是一个String类型的值，创建时不需要指定T的类型也会自动匹配： val score = Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\") //自动匹配为String类型 而泛型类型在类内部使用时，由于无法确定具体类型，也只能当做Any类去使用： 因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象： 还有，由于泛型在创建时就已经确定，因此即使都是Score类，由于类型参数的不同也会导致不通用： 有了泛型之后，我们再来使用一些类型就非常方便了，并且泛型并不是每个类只能存在一个，我们可以一次性定义多个类型参数： class Test\u003cK, V\u003e(val key: K, val value: V) 多个不同的类型参数代表不同的类型，这些都可以在使用时明确，并且互不影响。 Kotlin还提供了下划线运算符可以自动推断类型： fun \u003cK: Comparable\u003cV\u003e, V\u003e test() { } //类型参数中第一个类型参数可以直接推断得到 fun main() { test\u003cInt, _\u003e() //由于前面的类型本身就是Comparable\u003cInt\u003e的子类，已经明确了V的类型，后面就没必要再写一次了，直接使用下划线运算符进行推断即可 } 感觉使用场景应该比较少，了解就行。 当然，不只是类，包括接口、抽象类，都是可以支持泛型的： interface Test\u003cT\u003e { } 子类在继承时，可以选择将父类的泛型参数给明确为某一类型，或是使用子类定义的泛型参数作为父类泛型参数的实参使用： abstract class A\u003cT\u003e { abstract fun test(): T } class B: A\u003cString\u003e() { //子类直接明确为String类型 override fun test(): String = \"Hello World\" //明确后所有用到泛型的地方都要变成具体类型 } abstract class C\u003cD\u003e: A\u003cD\u003e() { //子类也有泛型参数D abstract override fun test(): D } fun main() { val b = B() println(b.test()) } 除了在类上定义泛型之外，我们也可以在函数上定义： //在函数名称前添加\u003cT\u003e来增加类型参数，之后函数的返回值或是参数都可以使用这个类型 fun \u003cT\u003e test(t: T): T = t fun main() { val value: String = test(\"Hello World\") //调用函数时自动明确类型 } 甚至在使用函数类型的参数时，我们可以使用泛型来代表不确定的类型： fun \u003cT\u003e test(func: (Int) -\u003e T) : T { //只要是有类型的地方都可以用T代替 ... } fun \u003cT\u003e test2(func: T.() -\u003e Unit) { //甚至还可以是T类型的扩展函数 ... } 在这之后，我们还会遇到更多官方提供的泛型函数，尤其是下一章的数组和集合部分。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"官方高阶扩展函数 为了我们开发的便利，官方提供了一系列内置的高阶函数，大部分都是通过扩展函数形式定义，我们可以使用来简化我们的代码。 我们之前在使用时或许就已经发现了： 那么怎么依靠它们来简化我们的代码呢？比如下面的代码： class Student(var name: String, var age: Int) { fun hello() = println(\"大家好，我是$name\") } fun test(student: Student?): Student? { student?.name = \"小明\" //不优雅！！！！ student?.age = 18 student?.hello() returun student; } 由于传入的是一个可空类型，这导致我们在使用时非常不方便，每次都需要进行判断，有没有更优雅一点的方式来处理呢？ fun test(student: Student?): Student? = student?.apply { this.name = \"小明\" this.age = 18 this.hello() } 太优雅了，同样的操作，原本繁杂的调用直接简化成了简单的几句代码，真是舒服啊！ 我们来介绍一下这些函数时如何使用的，这里以apply为例，这个函数功能是简化我们对某个对象的操作并在最后返回对象本身，在Standard.kt中是这样定义的： public inline fun \u003cT\u003e T.apply(block: T.() -\u003e Unit): T { ... block() //调用我们传入的函数 return this //返回当前T类型对象本身 } 可以看到，这个函数也是以扩展函数定义的T可以代表任何类型，所有的类都可以使用这个预设的扩展函数，并且它的参数是一个T.() -\u003e Unit函数类型的，很明显这是一个高阶函数，并且最后一个参数就是函数类型，后续可以结合我们之前讲解的简化代码。 这个参数非常有意思，比如我们原来需要这样编写： fun main() { val student: Student = Student(\"小明\", 18) student.name = \"大明\" student.hello() } 我们现在可以进行代码优化： fun main() { Student(\"小明\", 18).apply { this.name = \"大明\" }.hello() } 什么鬼，怎么突然就变得这么简单了？我们一个一个来看： Student(\"小明\", 18).apply{ } //调用Apply后，我们需要传入一个Lambda表达式，也就是我们要如何操作这个对象 我们可以直接将对这个对象全部的操作搬进来，然后在一个Lambda里面就能完成，接着我们对这个对象的其他操作，可以直接在后续编写，因为返回的也是这个对象本身，所以，使用这些预设的高阶函数，在很多情况下都能省掉我们不少代码量。 这里我们来看几个比较常用的： let：用于执行一个lambda表达式并将得到的结果作为返回值返回。 //对当前对象进行操作，得到一个新的类型值并作为结果返回 public inline fun \u003cT, R\u003e T.let(block: (T) -\u003e R): R { ... return block(this) //调用我们传入的函数，并将结果作为let返回值 } also：用于执行一个lambda表达式并返回对象本身，跟apply功能一致像，但是采用的是it参数形式传递给Lambda当前对象。 //对当前对象进行操作，并返回当前对象本身 public inline fun \u003cT\u003e T.also(block: (T) -\u003e Unit): T { ... block(this) //调用我们传入的函数 return this //返回当前T类型对象本身 } run：用于执行一个lambda表达式并将得到的结果作为返回值返回，它跟let一样，使用this传递当前对象，可以看到接受的参数是一个扩展函数。 public inline fun \u003cT, R\u003e T.run(block: T.() -\u003e R): R { ... return block() } 由此可见，let和run功能相近，apply和also功能相近，只是它们传递对象方式不同，所以说这个就别搞混了。 还有一个比较好用的是，有时候我们可能需要对象满足某些条件才处理，我们可以使用takeIf来完成： public inline fun \u003cT\u003e T.takeIf(predicate: (T) -\u003e Boolean): T? { ... return if (predicate(this)) this else null //传入一个用于判断的函数，根据结果返回对象本身或是null } public inline fun \u003cT\u003e T.takeUnless(predicate: (T) -\u003e Boolean): T? { ... return if (!predicate(this)) this else null //跟上面相反 } 对于takeIf的使用就像下面这样： fun main() { val str = \"Hello World\" //判断字符串长度是否大于7，大于就返回一个重复一次的字符串，否则原样返回 val myStr = str.takeIf { it.length \u003e 7 }?.let { it + it } ?: str } 一个很复杂的工作，可能需要很多行代码才能搞定，但是现在借助这些预设的高阶扩展函数，我们就可以以更简短的代码完成。 还有一个比较有意思的： public inline fun \u003cT, R\u003e with(receiver: T, block: T.() -\u003e R): R { ... return receiver.block() //手动传入一个现有的变量，然后通过这个变量去调用传入的Lamdba } 用起来就像这样： fun main() { val str = \"Hello World\" val len = with(str) { this.length } } 除了我们上面提到的这些，其实在Standard.kt还提供了更多有意思的工具函数，由于篇幅有限，还请各位小伙伴自行探索。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"协变与逆变* 注意： 这一部分相当有难度，请务必将前面的泛型概念理解到位，否则很难继续学习。 我们在前面介绍了泛型的基本使用，实际上就是一个待定的类型，我们在使用时可以指定具体的类型，并在编译时检查类型是否匹配，保证运行时类型的安全性，就像下面这样： class Test\u003cT\u003e(var data: T) fun main() { val test1: Test\u003cString\u003e = Test(\"Hello\") val test2: Test\u003cInt\u003e = Test(10) } 一旦泛型变量类型确定，后续将一直固定使用此类型，并且不兼容其他类型： 但是现在存在这样一个问题，我们如果使用某个类型的父类呢，会不会出现类型不匹配的情况？ 可以看到，即使是Int类型的父类Number，也无法接收其子类类型的结果，这就很奇怪了，我们前面说过一个类可以被当做其父类使用（因为父类具有属性什么子类一定也有）会自动完成隐式类型转换，但是为什么到了泛型这里就不行了呢？ 为了探究这个问题，我们先从几个概念开始说起，假设Int类型是Number类型的子类，正常情况下只能子类转换为父类，泛型类型Test\u003cT\u003e存在以下几种形变： 协变 (Covariance)：因为Int是Number的子类，所以Test\u003cInt\u003e同样是Test\u003cNumber\u003e的子类，可以直接转换 逆变(Contravariance)：跟上面相反，Test\u003cNumber\u003e可以直接转换为Test\u003cInt\u003e，前置是后者的子类 抗变 (Invariant)：Test\u003cInt\u003e跟Test\u003cNumber\u003e没半毛钱关系，无法互相转换 而在Kotlin的泛型中，默认就是抗变的，即使两个类型存在父子关系，到编译器这里也不认账，但是实际上我们需要的可能是协变或是逆变，为了处理这种情况，Kotlin提供了两个关键字供我们使用： out 关键字用于标记一个类型参数作为协变，可以实现子类到父类的转换。 in 关键字用于标记一个类型参数作为逆变，可以实现父类到子类的转换。 那么该怎么使用呢，非常简单： fun main() { val test1: Test\u003cInt\u003e = Test(888) //使用out关键字使得此类型协变，可以代表Number及其子类 val test2: Test\u003cout Number\u003e = test1 //此时就可以正常接受子类Int了 } 虽然看上去非常难理解，但是简单来说，其实就是为类型添加一个可以转换子类的性质，out作用就是使类型支持协变，可以支持泛型从父类转换为子类，但是不能子类转父类，比如这里使用Any就没法成功接受。相反的，如果我们标记某个类型为in，那么这个类型就是逆变的，可以由父类向下转化： fun main() { val test1: Test\u003cAny\u003e = Test(888) //使用in关键字使得此类型逆变，可以代表Number及其父类 val test2: Test\u003cin Number\u003e = test1 //Any是Number的父类，逆变 } 用树形图展示，关系如下： 在使用这种协变或逆变类型时，具体使用的类型就变得不确定了，导致不同的界限会有不同的效果，比如下面： fun main() { //协变类型在使用时会变成上界，因为无论子类是什么，都是继承自上界类型的 val test: Test\u003cout Number\u003e = Test(888) var data: Number = test.data } fun main() { //逆变类型在使用时由于没有上界，具体使用哪个父类也不清楚，所以只能是Any?类型了 val test: Test\u003cin Number\u003e = Test(888) var data: Any? = test.data } 在使用out和in之后，类型的使用就可以更加灵活，但是这样会存在一定的安全隐患，比如下面的代码： open class A class B: A() class C: A() fun main() { val test1: Test\u003cB\u003e = Test(B()) //这里存放的都是B类型的数据 val test2: Test\u003cout A\u003e = test1 //此时test2与test1是同一个对象，但是test2是out A test2.data = C() //由于C是A的子类，按照正常情况来说可以直接用（但实际上这句会报错） val data: B = test1.data //这下搞笑了，拿到的类型应该是C，结果接收的类型是B } 为了解决这种情况，Kotlin对于out或in的类型进行了限制，比如设置了out的情况下： 属性的setter操作被限制，无法通过编译，因为这可能会导致不安全的操作发生，而in也是同理的： fun main() { val test1: Test\u003cA\u003e = Test(B()) //这里存的是B类型的对象 val test2: Test\u003cin C\u003e = test1 //直接使用in C接收得到 val data: C = test2.data //此时得到的结果应该也可以是C才对，那肯定是错的 } 因此，在使用in时，属性的getter操作被限制，会提示类型不匹配，得到的类型也是Any? 无法通过编译，同样是因为可能存在不安全的操作。不仅仅是属性，包括所有函数的参数、返回值，都会受到限制： fun main() { val test1: Test\u003cB\u003e = Test(B()) val test2: Test\u003cout A\u003e = test1 test2.test(C()) //报错，因为这里存在消费行为 } 因此，对于in和out来说，协变和逆变的属性将其限制为了生产者和消费者： 使用out修饰的泛型不能用作函数的参数，对应类型的成员变量setter也会被限制，只能当做一个生产者使用。 使用in修饰的泛型不能用作函数的返回值，对应类型的成员变量getter也会被限制，只能当做一个消费者使用。 在了解了这么多泛型的知识之后，相信各位小伙伴已经感受到泛型的巧妙而又复杂的设计了。 最后，在有些时候，我们可能并不在乎到底使用哪一个类型，我们希望一个变量可以接受任意类型的结果，而不是去定义某一个特定的上界或下界。在Kotlin泛型中，星号（*）代表了一种特殊的类型投影，可以代表任意类型： fun main() { var test: Test\u003c*\u003e = Test(888) //由于此时使用了*表示任意类型，无论类型如何变化，都可以被此变量接收 test = Test(\"Hello\") } 同样的，由于不确定具体类型，使用时只能是Any?类型，跟上面in的情况一样，这里就不做演示了，下一章我们还会继续探讨更多*的默认情况。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"泛型界限* 注意： 这一部分相当有难度，请务必将前面的泛型概念理解到位，否则很难继续学习。 前面我们介绍了协变和逆变，使得泛型的类型可以灵活变化使用，而我们在定义类的时候，在类型参数位置也可以进行限制。 比如有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，这又该怎么去实现呢？ //设定类型参数上界，必须是Number或是Number的子类 class Score\u003cT : Number\u003e(private val name: String, private val id: String, val value: T) 使用类似于继承的语法来完成类型的上界限制，定义后，使用时的具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型，否则一律报错： 在默认情况下，如果我们不指定，那么上界类型就是Any?，而现在，我们在使用时就只能将类型指定为Number的子类了。 如果我们需要设定多个上界，比如必须同时是某两个类型的子类（或接口实现）像这样多个约束设定，我们需要使用where关键字： class Score\u003cT\u003e(private val name: String, private val id: String, val value: T) where T : Comparable\u003cT\u003e, T : Number //where后跟上多个需要同时匹配的类型 fun main() { //由于Int同时实现了Comparable接口以及继承自Number，所以满足多个条件，可以使用 var score: Score\u003cInt\u003e = Score(\"数据结构与算法\", \"EP710214\", 6) } 通过设定上界，能够更加规范类的使用。 有时候为了方便，我们也可以直接在类定义的时候直接将类型参数指定为out或是in来使得其协变或逆变： interface Test\u003cout T\u003e { fun test(): T //使用T类型作为返回值 } interface Test\u003cin T\u003e { fun test(t: T) //使用T类型作为参数 } 这样我们使用时就可以实现类型自动适应： interface Test\u003cout T\u003e { fun test(): T } fun test(test: Test\u003cInt\u003e) { val a: Test\u003cNumber\u003e = test //协变 } 同样的，我们前面说了在添加in或out后会限制相应的行为来保证类型的安全性，在定义类的一些函数或属性的时候都会得到警告： 在了解了类型界限相关内容之后，我们再来看看*类型投影在不同情况下的默认类型，比如： 对于Foo\u003cout T : TUpper\u003e，其中T是与上界TUpper的协变类型参数，Foo\u003c*\u003e等价于Foo\u003cout TUpper\u003e，就像下面这样： class Test\u003cout T : Number\u003e(val data: T) //因为限制了out，因此作为生产者，这里只能使用val fun main() { val test: Test\u003c*\u003e = Test(10) //虽然使用了*表示不确定，但是由于类型参数本身存在上界 var data: Number = test.data //所以类型读取后可以直接当做上界类型Number使用 } 对于Foo\u003cin T\u003e，其中T是逆变类型参数，Foo\u003c*\u003e等价于Foo\u003cin Nothing\u003e，无法安全地将属性给到消费者消费： class Test\u003cin T\u003e { fun set(t: T) { } //因为限制了in，因此只能作为消费者，这里用函数的形式 } fun main() { val test: Test\u003c*\u003e = Test\u003cInt\u003e() test.set(10) //编译错误，set中参数类型为Nothing，不允许任何值 } 对于Foo\u003cT : TUpper\u003e，其中T是具有上界TUpper的抗变类型参数，在读取数据时Foo\u003c*\u003e等价于Foo\u003cout TUpper\u003e，写入数据时等价于Foo\u003cin Nothing\u003e，就像这样： class Test\u003cT: Number\u003e(var data: T) fun main() { val test: Test\u003c*\u003e = Test(10) var data: Number = test.data //正常通过 test.data = 10 //编译错误，Setter for 'data' is removed by type projection } 如果一个泛型类有多个类型参数，每个类型参数都可以独立使用*表示不确定，例如类型为interface Function\u003cin T, out U\u003e，您可以使用以下星形投影： Function\u003c*, String\u003e等价于Function\u003cin Nothing, String\u003e。 Function\u003cInt, *\u003e等价于Function\u003cInt, out Any?\u003e。 Function\u003c*, *\u003e等价于Function\u003cin Nothing, out Any?\u003e。 泛型的使用可以很简单也可以很复杂，想要完全把这个搞明白还是需要多练多理解才能达到。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类型擦除* 注意： 这一部分相当有难度，请务必将前面的泛型概念理解到位，否则很难继续学习。 前面我们介绍了泛型的使用，以及各种高级功能，但是实际上，泛型的类型检查仅仅只存在于编译阶段，在源代码编译之后，实际上并不会保留任何关于泛型类型的内容，这便是类型擦除。 比如下面的类型： class Test\u003cT\u003e(private var data: T) { fun test(t: T) : T { val tmp = data data = t return tmp } } 在编译时候，会自动擦除类型： class Test(private var data: Any?) { //最后还是全部变成Any?类型了 fun test(t: Any?) : Any? { val tmp = data data = t return tmp } } 如果存在上界，那么擦除后会是上界的类型： class Test\u003cT : Number\u003e(private var data: T) class Test(private var data: Number) //擦除后类型变成上界类型 由于在运行时不存在泛型的概念，因此，很多操作都是不允许的，比如类型判断： class Test\u003cT\u003e(private var data: T) { fun isType(obj: Any) : Boolean { return obj is T //编译错误，由于类型擦除，运行时根本不存在T的类型 } } 包括我们在使用这个泛型类时： fun main() { val test: Test\u003cInt\u003e = Test(10) println(test is Test\u003cDouble\u003e) //编译错误，由于类型擦除，无法判断具体的类型 println(test is Test) //编译通过，判断是不是这个类还是没问题的 } 因此，正是为了保证类型擦除之后程序能够安全运行，才有了上面这么多限制。 对于内联函数，泛型擦除的处理会有一些不同，得益于它的内联性质，内联函数的代码是在编译时期直接插入到调用处的，在编译之后具体类型必须要存在，否则会出现问题（因为类型可以明确）因此其泛型参数的具体类型信息是可用的，编译器可以使用这些信息来生成更具体的字节码。这意味着，对于内联函数的泛型参数，并不会像非内联函数那样发生类型擦除。 inline fun \u003cT\u003e test(value: T): T { val value2 : T = value return value2 } fun main() { val data: String = test(\"Hello World!\") } 内联函数编译后，类型直接保留： fun main() { val value: String = \"Hello World!\" val value2: String = value //直接以String类型变量编译到程序中 val data: String = value2 } Kotlin的内联函数还有一个功能是可以使用具化的类型参数（reified 关键字）具化类型参数允许在函数体内部检测泛型类型，因为这些类型信息会被编译器内嵌在调用点。但是，这只适用于内联函数，因为类型信息在编译时是可知的，并且实际类型会被编译到使用它们的地方，使用也很简单： //添加reified关键字具化类型参数 inline fun \u003creified T\u003e isType(value: Any): Boolean { return value is T //这样就可以在函数里面使用这个类型了 } fun main() { println(isType\u003cString\u003e(\"666\")) } 具化类型参数仅适用于内联函数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数组 前面我们介绍了泛型，它可以实现在编写代码阶段的类型检查，现在我们就可以正式进入到数组的学习当中了。 假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。 在Kotlin中，数组是Array类型的对象。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"创建数组 数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容，其中存放的每一个数据称为数组的一个元素，我们来看看如何创建一个数组，在Kotlin中有两种创建方式： 官方预设工具函数，如arrayOf()、arrayOfNulls()以及emptyArray() 使用类Array构造函数创建。 比如我们要创建一个包含5个数字的数组，那么我们可以像这样： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) //直接在arrayOf函数中添加每一个元素 这里得到的结果类型为Array，它是一个泛型类 public class Array\u003cT\u003e { //构造函数，包括数组大小、元素初始化函数 public inline constructor(size: Int, init: (Int) -\u003e T) //重载[]运算符 public operator fun get(index: Int): T public operator fun set(index: Int, value: T): Unit //当前数组大小（可以看到是val类型的，一旦确定不可修改） public val size: Int //迭代运算重载（后面讲解） public operator fun iterator(): Iterator\u003cT\u003e } 可以看到，数组本质就是一个Array类型的对象，其类型参数就是我们存储的元素类型，由于使用构造函数创建数组稍微有些复杂，我们将其放到后面进行介绍。 注意： 数组在创建完成之后，数组容量和元素类型是固定不变的，后续无法进行修改。 fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) array.size = 10 //编译错误，长度不可修改 val arr: Array\u003cString\u003e = array //编译错误，类型不匹配 } 既然现在创建好了数组，那么该如何去访问数组里面的内容呢？ fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) println(array[0]) //使用[]运算符来访问指定下标上的元素 } 由于数组存放的是一组元素，我们在访问每个元素时需要告诉程序我们要访问的是哪一个，而每个元素都有一个自己的下标地址，下标从0开始从左往右依次递增排列，比如我们要访问第一个元素那么下标就是0，第三个元素下标就是2，以此类推： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) println(\"数组中的第二个元素是${array[1]}\") } 注意，在使用数组时，我们只能访问数组可以访问的范围，如果我们获取一个范围之外的元素，会得到错误，比如当前的数组的大小是5那么也就只能包含5个元素，此时我们去访问第六个元素，显然是错误的： println(\"数组中的第六个元素是${array[5]}\") //已经超出可访问范围了 println(\"数组中的第?个元素是${array[-1]}\") //下标从0开始，怎么可能有-1呢 我们也可以使用[]修改数组中指定下标元素的值： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) array[0] = 10 //修改第一个元素的值 println(\"数组中的第一个元素是${array[0]}\") } 还有一个要注意的是，我们直接打印这个数组对象并不能得到数组里面每个元素的值，而是一堆看不懂的东西： 具体原因可以通过学习Java后进行了解，如果各位小伙伴需要打印数组中的每一个元素，我们只能一个一个打印，可以使用一个for循环语句来完成： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for (i in 0..\u003carray.size) { //从0循环到array.size前一位 println(array[i]) //每一个依次打印即可 } } 不过，在Kotlin中，这样编写并不优雅，我们有更好的方式去遍历数组中的每一个元素，在之前我们学习for循环语句时，谈到使用in来遍历一个可遍历的目标，而数组就是满足这个条件的，我们可以直接遍历它： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for (element in array) { println(element) //从第一个元素开始依次遍历，element就是每一个元素了 } } 当然，如果我们还是希望按照数组的索引进行遍历，也可以使用： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for (i in array.indices) { //indices返回的是数组的有效索引范围，这里就是0 ~ 4 println(array[i]) } 如果你想同时遍历索引和元素本身，也可以使用withIndex函数，它会生成一系列IndexedValue对象： //关于data class我们会在下一篇中讲解 public data class IndexedValue\u003cout T\u003e(public val index: Int, public val value: T) //包含元素本身和索引 在使用forin时，我们也可以对待遍历的元素进行结构操作，当然，前提是这些对象类型支持解构，比如这里的IndexedValue就支持解构，所以我们可以在遍历时直接使用解构之后的变量进行操作： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for ((index, item) in array.withIndex()) { //使用withIndex解构后可以同时遍历索引和元素 println(\"元素$item，位置: $index\") } 如果需要使用Lambda表达式快速处理里面的每一个元素，也可以使用forEach高阶函数： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) array.forEach { println(it) } //只带元素的 array.forEachIndexed { index, item -\u003e //同时带索引和元素的 println(\"元素$item，位置: $index\") } 如果只是想打印数组里面的内容，快速查看，我们可以使用： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) println(array.joinToString()) //使用joinToString将数组中的元素转换为字符串，默认使用逗号隔开：7, 3, 9, 1, 6 println(array.joinToString(\" - \", \"\u003e \", \" \u003c\")) //自定义分隔符，前后缀: \u003e 7 - 3 - 9 - 1 - 6 \u003c println(array.joinToString(limit = 1, truncated = \"...\")) //甚至可以限制数量，多余的用自定义的字符串...代替: 7, ... println(array.joinToString() { (it * it).toString() }) //自定义每一个元素转换为字符串的结果 我们接着来看一下如何使用构造函数来创建数组，首先构造函数时这样定义的： /** * size: 不必多说，数组的大小 * init: 初始化操作，这个操作会根据数组大小，循环调用传入的函数size次，并且将对应的下标作为参数，我们需要在函数中返回当前数组元素类型的结果，这样就会自动填充到数组的对应位置上 */ public inline constructor(size: Int, init: (Int) -\u003e T) 比如我们希望创建一个字符串数组： fun main() { val array: Array\u003cString\u003e = Array(5) { \"我是元素$it\" } //其中返回值为自定义的字符串，这样就会自动填充到对应位置 for (s in array) { println(s) } } 利用这种特性，我们可以快速创建一个全是同一个值的数组： val array: Array\u003cDouble\u003e = Array(5) { 1.5 } // 1.5, 1.5, 1.5, 1.5 ... 还可以快速搞一个平方数数组： val array: Array\u003cInt\u003e = Array(10) { it * it } // 0, 1, 4, 9, 16 ... 不过，其实一般情况下使用arrayOf都可以解决大部分情况了，还有它的变种，大概介绍一下： val array: Array\u003cInt\u003e = emptyArray\u003cInt\u003e() //创建容量为0的数组 val array: Array\u003cInt?\u003e = arrayOfNulls(10) //创建元素可空的数组 下一节课我们接着学习更多数组的操作。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"使用数组 现在我们已经学习了如何创建数组，实际上官方库提供了很多数组的扩展函数，方便我们对于数组的使用，我们现在就来看看吧。 对于两个数组来说，如果我们要比较它们之间是否包含相同的内容，需要使用特殊的比较函数： fun main() { val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) //两个内容相同的数组 val array2: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) println(array1 == array2) //不可以使用==来判断数组内容是否相同，不支持 println(array1.contentEquals(array2)) //需要使用扩展函数contentEquals来进行内容比较 } 要拷贝一个数组的内容并生成一个新的数组，可以： fun main() { val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) val array2: Array\u003cInt\u003e = array1.copyOf() //使用copyOf来拷贝数据内容并创建一个新的数组存储 println(array2 === array1) //false，不是同一个对象 } copyOf函数可以指定拷贝的长度或是拷贝的范围，使用更加灵活一些： val array2: Array\u003cInt?\u003e = array1.copyOf(10) //在拷贝时指定要拷贝的长度，如果小于数组长度则只保留前面一部分内容，如果大于则在末尾填充null，因此返回的类型是Int?可空 val array2: Array\u003cInt\u003e = array1.copyOfRange(1, 3) //从第二个元素开始拷贝到第四个元素前为止，共2个元素 //使用copyOfRange拷贝指定下标范围上的元素 还有一个比较类似操作，但是可以使用Range进行分割： val array1 = arrayOf(1, 2, 3, 4, 5) val array2 = array1.sliceArray(1..3) //从第二个元素到第四个元素共三个元素的数组 两个数组也可以直接拼接到一起，形成一个长度为10的新数组，按顺序拼接： val array1 = arrayOf(1, 2, 3, 4, 5) val array2 = arrayOf(6, 7, 8, 9, 10) val array3 = array1 + array2 快速查找元素肯定也是不在话下的： val array = arrayOf(13, 16, 27, 32, 38) println(array.contains(13)) //判断数组中是否包含3这个元素 println(array in 13) //跟contains函数效果一样，判断数组中是否包含3这个元素 println(array.indexOf(26)) //寻找指定元素的下标位置 println(array.binarySearch(16)) //二分搜索某个元素的下标位置（效率吊打上面那个函数，但是需要数组元素有序，具体原因可以学习数据结构与算法了解） 不过，可能会有小伙伴好奇，这里的contains函数传入的对象，是如何进行判断的？比如我要删除某一个元素，程序是如何将数组内的对象与传入的对象进行比较得出是相同的元素呢？我们来看下面这个例子： class Student(val name: String, val age: Int) fun main() { val array = arrayOf(Student(\"小明\", 18), Student(\"小红\", 17)) println(array.contains(Student(\"小明\", 18))) //结果为false } 怎么回事？我们这明明传入的是两个内容一样的对象啊，为什么是false呢？直接看源码： public operator fun \u003c@kotlin.internal.OnlyInputTypes T\u003e Array\u003cout T\u003e.contains(element: T): Boolean { return indexOf(element) \u003e= 0 //调用内部indexOf函数看看能不能找到这个元素的下标 } public fun \u003c@kotlin.internal.OnlyInputTypes T\u003e Array\u003cout T\u003e.indexOf(element: T): Int { if (element == null) { ... } else { for (index in indices) { //直接通过遍历的形式对数组内的元素一个一个进行判断 if (element == this[index]) { //可以看到，这里判断使用的是==运算符，这下就好说了 return index } } } return -1 } 我们在前面介绍过，使用==的判断实际上取决于equals函数的重写，如果要让两个对象实现我们自定义的判断，需要重写对应类型的equals函数，否则无法实现自定义比较，默认情况下判断的是两个对象是否为同一个对象，所以，我们可以尝试重写一下： class Student(val name: String, val age: Int) { override fun equals(other: Any?): Boolean { if(this === other) return true //如果引用的是同一个对象，肯定是true不多逼逼 if(other !is Student) return false //如果要判断的对象根本不是Student类型的，那也不用继续了 if(name != other.name) return false //判断名字是否相同 if(age != other.age) return false //判断年龄是否相同 return true //都没问题，那就是相等了 } } 现在得到的结果就是我们希望的样子了。 也可以快速判断和获取元素： val array = arrayOf(1, 2, 3, 4, 5) println(array.any()) //判断数组是否为空数组（容量为0） println(array.first()) //快速获取首个元素 println(array.last()) //快速获取最后一个元素 我们也可以快速将一个数组的内容进行倒序排放： val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) val array2: Array\u003cInt\u003e = array1.reversedArray() //翻转数组元素顺序，并生成新的数组 val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) array1.reverse() //直接在原数组上进行元素顺序翻转 array1.reverse(1, 3) //仅翻转指定下标范围内的元素 如果我们想要直接将数组中元素打乱，也有一个快速洗牌的函数将所有元素顺序重新随机分配： val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) array1.shuffle() //使用shuffle函数将数组中元素顺序打乱 打乱了想重新还原成有序的数组咋办？ array1.sort() //使用sort函数对数组中元素进行排序，排序规则可以自定义 array1.sort(1, 3) //仅排序指定下标范围内的元素 array1.sortDescending() //按相反顺序排序 注意，排序操作并不是任何类型上来就支持的，由于这里我们使用的是基本类型Int，它默认实现了Comparable接口，这个接口用于告诉程序我们的排序规则，所以，如果数组中的元素是未实现Comparable接口的类型，那么无法支持排序操作。 我们可以来尝试实现一下： //首先类型需要实现Comparable接口，泛型参数T填写为当前类型 class Student(private val name: String, private val age: Int) : Comparable\u003cStudent\u003e { //接口中就这样一个函数需要实现，这个是比较的核心算法，要参数是另一个需要比较的元素，然后返回值是一个Int //使用当前对象this和给定对象other进行比较，如果返回小于0的数，说明当前对象应该排在前面，反之排后面，返回0表示同样的级别 override fun compareTo(other: Student): Int = this.age - other.age override fun toString(): String = \"$name ($age)\" } 这样，我们自定义的类型就支持比较和排序了： val array1 = arrayOf(Student(\"小明\", 18), Student(\"小红\", 17)) array1.sort() 还有可以快速填充数组内容的函数： val array1 = arrayOf(1, 2, 3, 4, 5) array1.fill(10) //重新将数组内部元素全部填充为10 好了，就先介绍这么多吧，到这里也才介绍了数组操作的一半，后面到了集合类我们再来介绍更多使用的扩展函数，因为集合数组都是支持的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"可变长参数 前面我们介绍了数组的使用，不知道各位小伙伴有没有疑惑，在使用arrayOf时，里面的参数为什么可以随意填写不同数量？ arrayOf(1, 2, 3, 4, 5) arrayOf(1, 2, 3) arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9) 函数的参数数量不是固定的吗？怎么还能动态加？难道我们前面学的是假的函数？这其实是因为这个函数使用了可变长参数的原因，它可以实现同一个类型的参数任意填写： fun test(vararg strings: String) { //使用vararg关键字将参数标记为可变长参数 } fun main() { test(\"AAA\", \"BBB\", \"CCC\") //在使用时，只要是同类型的参数可以填写任意数量 } 但是需要注意的事，可变长参数在函数的形参列表里面只能存在一个，下面这几种情况： fun test(vararg strings: String, a: Int) { ... } //编译通过 fun test(a: Int, vararg strings: String) { ... } //编译通过 fun test(vararg a: Int, vararg strings: String) { ... } //编译错误，存在多个可变长参数 那么，这种可变长参数在函数中如何使用呢？我们可以将其当做一个Array来使用： fun test(vararg strings: String) { var str: Array\u003cout String\u003e = strings //在函数中得到的是一个Array\u003cout String\u003e类型的数组 } 这样一看就简单多了，可变长参数本质就是一个数组。 那么既然可变长参数是一个数组，我们可不可以直接把数组作为参数给到一个可变长参数中呢？ fun main() { val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") test(array) //编译错误，这里需要的是多个String，但是传入的类型是Array\u003cString\u003e } 这就有点不太合理了，反正都是数组为啥我不能直接传个数组进去当做实参呢，因此Kotlin给我们提供了一个扩展运算符（*）此运算符将数组的每个元素作为单个参数传递： fun main() { val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") test(*array) //编译通过，虽然看起来有点像C语言的指针 } 别急，你以为这样就结束了吗，它还可以混着用： val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") test(\"111\", *array, \"DDD\", \"EEE\") //前面后面甚至还能继续写 因此，如果我们需要将一个数组的内容复制到一个新的数组中，直接这样操作就好了： val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") val array2 = arrayOf(*array) ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"原生类型数组 在之前，我们使用了大量基本类型数组，比如Array\u003cInt\u003e、Array\u003cDouble\u003e、Array\u003cChar\u003e等等，这些包含基本类型的数组往往在编译时可以得到优化（比如JVM平台会直接编译为基本类型数组，如int[]、double[]等，可以免去装箱拆箱开销）Kotlin提供了预设的原生类型数组： 原生类型数组 相当于Java BooleanArray boolean[] ByteArray byte[] CharArray char[] DoubleArray double[] FloatArray float[] IntArray int[] LongArray long[] ShortArray short[] 这些类型与Array类型没有任何继承关系，但是它们有同样的方法属性集，使用起来区别不大，优先使用基本类型数组，可以使得程序免得到一定优化，增加效率： fun main() { //使用arrayOf的变种intArrayOf快速生成IntArray val array: IntArray = intArrayOf(7, 3, 9, 1, 6) array.forEach { println(it) } } 这些原生类型数组也有一些额外的扩展，比如快速求和： val array: IntArray = intArrayOf(7, 3, 9, 1, 6) println(array.sum()) //快速求和操作，获得数组中所有元素之和 还有求平均值之类的： val array: IntArray = intArrayOf(7, 3, 9, 1, 6) println(array.average()) //求整个数组的平均数 快速获取最大值和最小值： val array: IntArray = intArrayOf(7, 3, 9, 1, 6) println(array.min()) println(array.max()) 其他使用基本一致，这里就不多进行介绍了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"嵌套数组 有些时候，单个维度的数组似乎无法满足我们的需求。比如我们现在6个元素为一组存储，现在共需要存储4组这样的数据，我们不可能去定义4个一样的数组吧？这个时候就需要用到嵌套数组了。 存放数组的数组，相当于将维度进行了提升，比如下面的就是一个2x10的数组： 二维数组看起来更像是一个平面，同理，三维数组就是一个立方体空间，四位数组就进入到我们人类无法理解的范围了，由很多个三维组成（物理上解释或许是时间轴？） 那么像这样的多维度数组如何创建呢？这里我们以二维数组为例，三维四维同理： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) 可以看到，我们使用arrayOf去囊括多个IntArray，这样，最外层的Array相当于是保存多个IntArray的Array，也就实现了我们上面的二维数组效果了。当然像这样也是可以的： //存放9个Array\u003cInt\u003e数组的数组，其中每个Array\u003cInt\u003e的长度为4，内容为0填充 // { {0,0,0,0}, {0,0,0,0}, {0,0,0,0} ... } val arr: Array\u003cArray\u003cInt\u003e\u003e = Array(9) { Array(4) { 0 } } 嵌套数组看起来可能有些绕，但是其实仔细分析之后还是比较简单的。 我们在使用二维数组时： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) val array: IntArray = arr[0] //获取二维数组的第一个元素，得到内层存放的数组 val item: Int = array[0] //再从内存存放的数组中拿到第一个元素 所以，如果我们要获取位于整个二维矩阵左上角的第一个元素，可以像这样： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) //这里使用了两个[]运算符，第一个处理最外层数组，第二个才是对内层数组的操作 val item: Int = arr[0][0] 对于这种二维数组，如果需要遍历，我们同样可以使用for循环来完成，不过需要两层for才可以搞定： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) for (ints in arr) { //最外层遍历外层数组中存放的每一个内层数组 for (int in ints) { //内层循环遍历每一个内层数组 println(int) //得到每一个内层数组的值 } } 由于现在数组内存放的是数组，我们在比较两个嵌套数组的内容是否相同时，需要使用深度比较： fun main() { val arr1: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) val arr2: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) println(arr1.contentEquals(arr2)) //此函数只会简单比较里面的每一个元素，当里面每个元素是数组时不会再继续去比较第二层第三层等 println(arr1.contentDeepEquals(arr2)) //此函数会一直深入比较每一层，多维使用这个比较 } 这里还有一个知识误区，虽然我们使用的看起来确实类似于二维数组，但是每一个数组的长度并不需要是相同的： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 3, 4, 5), intArrayOf(2, 9)) //这里第一个数组长度为4，第二个为2 甚至类型也可以不一样： //只要内层使用Any类型，就可以接收所有类型的嵌套数组 val arr: Array\u003cArray\u003cout Any\u003e\u003e = arrayOf(arrayOf(1, 3, 4, 5), arrayOf(\"AAA\", \"BBB\")) 不过正常情况下，我们还是会按照标准的二维数组来使用，这样更加规范一些。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"集合类 前面我们学习了数组的使用，虽然数组可以很方便地存储一组数据，但是它存在诸多限制： 长度是固定的，无法扩展 无法做到在数组中像列表那样插入或者删除元素 显然，在很多情况下，数组虽然可以存储一组数据，但是它并不好用，我们需要借助更加强大的集合类来实现更多高级功能。在Kotlin中，默认提供了以下类型的集合： List： 有序的集合，通过索引访问元素，可以包含重复元素，比如电话号码：它就是一组数字，并且顺序很重要，而且数字可以重复。 Set： 不包含重复元素的集合，它更像是数学中的集合，一般情况下不维护元素顺序，例如，彩票上的数字：都是独一无二的，并且它们的顺序不重要。 Map： 是一组键值对，其中每一个键不可重复存在，每个键都映射到恰好一个值（值可以重复存在）这跟数学上的映射关系很像。它经常用于存储（员工ID -\u003e 员工具体信息）这样的结构。 所有集合类都是继承自Collection接口（Map除外）我们可以看看这个接口的定义： public interface Collection\u003cout E\u003e : Iterable\u003cE\u003e { //继承了可迭代接口（后面讲解） //集合的大小 public val size: Int //判断集合是否为空 public fun isEmpty(): Boolean //集合是否包含某个元素，可用in运算符判断 public operator fun contains(element: @UnsafeVariance E): Boolean //生成迭代器（后面讲解） override fun iterator(): Iterator\u003cE\u003e //是否包含另一个集合中所有的内容 public fun containsAll(elements: Collection\u003c@UnsafeVariance E\u003e): Boolean } 这个接口定义了集合的基本操作，以及核心属性，而由集合顶层接口衍生的不同集合类，也都有自己的定义。集合类一般都是以接口类型的变量进行使用，因为不同的集合可能存在不同的集合实现类，为了使用起来更加通用，我们往往会使用集合类的接口进行操作。 下面就让我们一个一个认识吧。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"List集合 List就像它的名字一样，就是一个列表，它存储一组有序的数据，比如我们看到的餐厅菜单，还有游戏的排行榜，每一道菜、每一个玩家都是按顺序向下排列的，并且根据情况，我们可以自由地在某个位置插入或删除一个新的元素，列表的长度也会动态发生变化，List集合就是为了这些功能而生的。 要创建一个List集合非常简单，就跟我们之前创建数组一样： fun main() { val list: MutableList\u003cString\u003e = mutableListOf(1, 2, 3, 4) //使用mutableListOf来创建一个可修改的List集合 list[0] = 10 //修改某个位置上的元素 println(list[1]) //获取某个位置上的元素 println(list) //打印出来的结果也是非常标准的: [10, 2, 3, 4] } 我们发现，使用List集合之后，很多操作其实跟数组是基本一样的，它同样可以存储一组元素，以及修改。 除了可以使用数组支持的操作之外，为了能够作为列表使用，还有很多新的操作，比如我们希望在末尾添加一个新的元素到列表中： val list = mutableListOf(1, 2, 3, 4) list.add(5) //使用add函数添加一个新的元素到列表末尾 println(list) //列表自动增长，得到[1, 2, 3, 4, 5] 我们可以在整个列表之间的任意位置插入，但是同样不能出现越界的情况： val list = mutableListOf(1, 2, 3, 4) list.add(2, 666) //将666插入到第三个元素的位置上去 既然可以插入元素，同样的也可以删除元素： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\", \"DDD\") list.removeAt(2) //使用removeAt可以删除指定位置上的元素 list.remove(\"DDD\") //使用remove可以删除指定元素 可以看到，列表相比我们传统的数组来说，完整地支持了增删改查这四个操作，使用起来也会更加方便。 当然，有些时候可能我们希望获取一个只读的列表： val list: List\u003cString\u003e = listOf(\"AAA\", \"BBB\", \"CCC\", \"DDD\") //使用listOf生成的列表是只读的 list[0] = \"XXX\" //在修改时会直接提示不支持 类似于数组，还有多种列表创建函数： val array = arrayOf(\"AAA\", null, \"CCC\", \"DDD\") val list: List\u003cString\u003e = listOfNotNull(*array) //使用listOfNotNull可以自动去除所有null的元素，再创建只读列表 val list: List\u003cString\u003e = emptyList() //返回空列表 或是使用构造函数来创建一个列表： val list: List\u003cString\u003e = List(3){ \"TZ\" } //跟数组一样，不多说了 println(list) 如果我们需要遍历一个列表，同样很简单，跟数组完全一样： val list: List\u003cString\u003e = listOf(\"AAA\", \"BBB\", \"CCC\", \"DDD\") for (s in list) { //使用forin来快速遍历数组中的每一个元素 println(s) } for ((index, item) in list.withIndex()) { println(\"元素$item, 下标: $index\") } 集合也支持加法和减法运算： fun main() { val l1 = listOf(\"AAA\", \"DDD\", \"CCC\") val l2 = listOf(\"BBB\", \"CCC\", \"EEE\") println(l1 + l2) //合并两个List的内容，顺序直接在后面拼接: [AAA, DDD, CCC, BBB, CCC, EEE] println(l1 - l2) //让前面的集合减去与后面集合存在重复内容的部分: [AAA, DDD] } 使用还是非常简单的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"Set集合 Set集合非常特殊，虽然它也可以保存一组数据，但是它不允许存在重复元素，我们无法让Set集合中同时存在两个一样的元素，这在一些需要去重的场景中非常实用，这跟数学中定义的集合非常相似。 创建一个Set集合很简单： fun main() { //使用mutableSetOf来创建一个Set集合 val set: Set\u003cString\u003e = mutableSetOf(\"AAA\", \"BBB\", \"BBB\", \"CCC\") println(set) //由于不允许出现重复元素，得到 [AAA, BBB, CCC] } 与列表一样，可以随意插入元素，元素默认在尾部插入，顺序为插入顺序： val set: MutableSet\u003cString\u003e = mutableSetOf(\"AAA\", \"DDD\", \"CCC\") set.add(\"BBB\") 不过Set默认不支持在指定位置插入元素，只能尾插，同时我们也不能通过下标去访问Set中的元素，这是因为Set底层采用的并不是线性数据结构存储，而是用了哈希表或是树形结构（感兴趣的小伙伴可以看一下另一期数据结构与算法篇教程）而内部元素的顺序则是采用的其他形式进行维护的。 不过，我们到是可以借助迭代器来获取当前顺序上的第N个元素： val set = linkedSetOf(\"AAA\", \"DDD\", \"CCC\") println(set.elementAt(1)) //elementAt是通过迭代器的遍历顺序取得对应位置的元素 有关迭代器的知识，我们放在后面进行讲解。 同时，由于Set更接近于数学上的集合概念，Kotlin为我们准备了很多集合之间的操作： val set1 = mutableSetOf(\"AAA\", \"DDD\", \"CCC\") val set2 = mutableSetOf(\"BBB\", \"CCC\", \"EEE\") println(set1 union set2) //求两个集合的并集: [AAA, DDD, CCC, BBB, EEE] Set的+运算与这个效果一样 println(set1 intersect set2) //求两个集合的交集: [CCC] println(set1 subtract set2) //求集合1在集合2中的的差集: [AAA, DDD] Set的-运算与这个效果一样 println((set1 - set2) union (set2 - set1)) //并集减去交集 虽然集合相关操作也可以应用于List集合，但是计算得到的结果始终是Set集合： fun main() { val l1 = listOf(\"AAA\", \"DDD\", \"CCC\") val l2 = listOf(\"BBB\", \"CCC\", \"EEE\") val set: Set\u003cString\u003e = l1 union l2 //得到的结果是一个Set集合 println(set) } 对于Set集合，官方也有很多预设的函数用于创建： val set = hashSetOf(\"AAA\", \"DDD\", \"BBB\") //创一个不重复且无序的Set集合 println(set) //遍历顺序并不是添加顺序: [AAA, BBB, DDD] val set = linkedSetOf(\"AAA\", \"DDD\", \"BBB\") //跟mutableSetOf一样得到一个不重复且有序的Set集合 println(set) val set1 = setOf(\"AAA\", \"DDD\", \"BBB\") //只读的Set集合 val set2 = setOfNotNull(\"AAA\", \"DDD\", \"BBB\", null) //自动过滤Null元素的Set集合 val set = sortedSetOf(\"AAA\", \"DDD\", \"BBB\") //元素自动排序的Set集合，可以自定义排序规则 val hashSet = HashSet\u003cString\u003e() //创一个不重复且无序的Set集合 val linkedHashSet = LinkedHashSet\u003cString\u003e() //跟mutableSetOf一样得到一个不重复且有序的Set集合 最后我们来讲解一个前面就买下伏笔的问题，这里我们创建了一个Student类型的Set集合： class Student(private val name: String, private val age: Int) { override fun toString(): String = \"$name ($age)\" } fun main() { val set = mutableSetOf(Student(\"小明\", 18)) set.add(Student(\"小明\", 18)) println(set) } 虽然我们插入了两个相同的数据，但是它们本质上是两个对象，只是内容相同，所以，Set中会认为它们不同，同时得到保存： 为了解决这种问题，我们之前采用的是重写equals函数来重新定义比较规则，这样就可以实现内容相同判断为同一个了： class Student(private val name: String, private val age: Int) { override fun toString(): String = \"$name ($age)\" override fun equals(other: Any?): Boolean { //跟之前一样，添加自定义的比较方式 if(this === other) return true if(other !is Student) return false if(name != other.name) return false if(age != other.age) return false return true } } 再次执行程序，我们发现似乎没什么卵用： 什么鬼，这明明都把比较规则给自定义了，怎么还是不能判断为同一个呢？我们之前难道学的是个假的吗？我们注意到类上有一个警告，提示我们没有重写了eq函数但是没有定义hashCode： 这个hashCode是什么鬼？实际上Set集合默认采用的是哈希表进行数据存储（详情请看数据结构与算法篇视频教程）而哈希表在存储数据时，需要通过一个哈希函数计算出对象的哈希值，如果两个对象的哈希值相同，那么在哈希表中就会认定为是同一个元素，如果不相同，那么会认定为不同的两个元素，因此，这里我们仅仅重写equals只能满足部分集合类的使用，而到了Set这里包括后面的Map就开始不行了。 我们可以看到，在Any类中确实定义了一个hashCode函数，这个就是用于计算对象的哈希值的： /** * 计算并返回对象的哈希值，哈希函数的计算结果需要满足以下标准: * * * 标准1: 对同一个对象调用此函数时，应该始终返回同一个哈希值，除非重写过类的equals函数，修改过比较方式 * * 标准2: 如果两个对象使用equals函数判断的结果为相同，那么它们计算得到的哈希值也应该相同 */ public open fun hashCode(): Int 在默认情况下，对象的哈希值得到的结果是对象在内存中存放的地址，以Int类型表示： println(Any().hashCode()) //结果为内存地址位置: 295530567 因此，上面两个对象由于存放在不同的地址，所以得到的哈希值肯定是不一样的，既然现在我们仅仅只是比较对象的名称和年龄是否相同，我们可以修改一下哈希函数的计算规则： class Student(private val name: String, private val age: Int) { ... override fun hashCode(): Int { var result = name.hashCode() //仅计算name和age属性的哈希值 result = 31 * result + age.hashCode() return result //这样，当name和age的哈希值与另一个对象的一致时，得到的结果就是一样的了 } } 现在再次进行操作： 所以，以后我们在重写equals函数时，为了能够适配所有的集合类，我们还需将其hashCode函数一并重写，来保证一致性。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"Map映射 Map是一个非常特殊的集合类型，它存储了一些的键值对，那么什么是键值对呢？ 可以看到，学校里面的学号对应了每一个学生，我们只需要知道某一个学生的学号，就可以快速查找这个学生的姓名、年龄、性别等信息，而Map就是为了存储这样的映射关系而存在的。 首先我们来看，如何定义一个键值对，官方为我们提供了一个非常方便的中缀函数： public infix fun \u003cA, B\u003e A.to(that: B): Pair\u003cA, B\u003e = Pair(this, that) 我们只需要指定： val pair: Pair\u003cInt, String\u003e = 10001 to \"小明\" //得到一个由学号指向学生名称的键值对 这样，我们就成功创建出了一个映射关系，但是这仅仅是单个映射，如果我们想要存储所有学生的学号映射关系，需要使用Map来实现，使用Map也非常简单： val map: MutableMap\u003cInt, Student\u003e = mutableMapOf( 10001 to Student(\"小明\", 18), 10002 to Student(\"小红\", 17), 10003 to Student(\"小刚\", 19) ) //使用mutableMapOf可以放入多个键值对，并生成一个Map对象 这样我们就成功地将所有的键值对存储在Map中了，我们接着来看看如何去访问，比如现在我们要查找指定学号的学生： val student: Student? = map[10001] //使用[]运算符通过Key查找Value 可以看到，使用方式与前面的集合类和数组非常类似，只不过访问的不再是下标，而是对应的Key。同时，这里得到的结果是一个可空类型的对象，为什么会像这样呢？ val student1: Student? = map[10001] //得到小明这个对象 val student2: Student? = map[10005] //Map中根本没有键为10005的键值对，得到的结果是null 当Map中不存在指定Key时，会直接得到null作为结果，因此我们在处理从Map返回的Value时，需要考虑空指针问题。 map.contains(1) //判断是否包含指定Key map.containsKey(1) //同上 10001 in map //同上 map.containsValue(Student(\"小明\", 18)) //判断是包含指定Value 注意： Map中的键值对存储，只能通过Key去访问Value，而不能通过Value来反向查找Key，映射关系是单向的。 我们可以直接获取到Key和Value的集合： val keys: MutableSet\u003cInt\u003e = map.keys //以Set形式存储的[10001, 10002, 10003] val value: Collection\u003cStudent\u003e = map.values //以Collection接口类型返回的 [小明 (18), 小红 (17), 小刚 (19)] 具体类型是Map的内部类实现的 遍历一个Map也很简单： map.forEach { (k, v) -\u003e println(\"键: $k, 值 $v\") } //forEach提供两个参数，key和value for (entry in map) { //使用for循环也可以直接安排，这里得到的是一个entry entry.key entry.value } for ((key, value) in map) { //也可以可以直接写成这样 println(\"键: $key, 值 $value\") } 我们再来看看如何向Map中添加新的键值对： map[10004] = Student(\"小强\", 18) //跟之前一样，直接对着赋值就行了 map.put(10004, Student(\"小强\", 18)) //使用函数也可以，跟上面效果一样 你甚至还能像这样添加： val newMap = map + (10004 to Student(\"小强\", 18)) //添加新的键值对并生成一个新的Map map += (10004 to Student(\"小强\", 18)) //直接添加键值对到当前Map里面 map += mapOf(10004 to Student(\"小强\", 18)) //或者添加其他Map到此Map中 map.putAll(mapOf(10004 to Student(\"小强\", 18))) //跟上面一样 map.putAll(setOf(10004 to Student(\"小强\", 18))) //键值对集合也可以的 不过需要注意的是，在Map中同样的Key只能存在一个，这跟Set是一样的： map[10003] = Student(\"小强\", 18) //此时Map中已经存在Key为10003的键值对了，这会导致之前的结果被覆盖 println(map) //结果为 {10001=小明 (18), 10002=小红 (17), 10003=小强 (18)} 当插入一个键值对时，如果存在相同Key会直接覆盖掉之前的键值对，我们可以通过函数的返回值来得到被覆盖的结果： val old = map.put(10003, Student(\"小强\", 18)) //put的返回值如果没有覆盖元素返回null，否则返回被覆盖的元素 println(\"被覆盖的$old\") //被覆盖的小刚 (19) 我们也可以直接移除不需要的键值对，同样是通过Key进行移除： val old = map.remove(10001) //使用remove函数移除指定键值对 println(\"被移除的$old\") 各种花式移除： map -= 10001 //等价于 map.remove(10001) map -= listOf(10001, 10002) //是的你没猜错，这个是批量移除 如果我们需要直接移除Value为某个Key的键值对，可以像这样： map.values.remove(Student(\"小明\", 18)) //直接从values中移除，会使得整个键值对被移除 val map: MutableMap\u003cInt, Student\u003e = mutableMapOf( 10001 to Student(\"小明\", 18), 10002 to Student(\"小红\", 17), 10003 to Student(\"小明\", 18) //这里存在两个一样的元素 ) map.values.remove(Student(\"小明\", 18)) //通过这种方式移除也只会移除按顺序下来的第一个 println(map) // {10002=小红 (17), 10003=小明 (18)} 有些时候，Map返回的结果是可空类型给我们造成了很多麻烦，可以通过以下方式解决： //使用getOrDefault在没有结果时返回给定的默认值 var student: Student = map.getOrDefault(10004, Student(\"小强\", 16)) //跟上面一样，只不过是使用函数式返回默认值 var student: Student = map.getOrElse(10004){ Student(\"小强\", 16) } //这个不仅能返回默认值，还能顺手把默认值给加到Map里面去，很方便 var student: Student = map.getOrPut(10004){ Student(\"小强\", 16) } println(map) //结果为 {10001=小明 (18), 10002=小红 (17), 10003=小刚 (19), 10004=小强 (16)} 有了Map之后，我们在处理一些映射关系的时候就很方便了。跟Set一样，官方也提供了多种多样的集合： val map1 = mapOf(1 to \"AAA\") //只读Map val map2 = hashMapOf(1 to \"AAA\") //不保存Key顺序的Map val map3 = linkedMapOf(1 to \"AAA\") //保存Key顺序的Map，跟mutableMapOf一样 val map4 = sortedMapOf(1 to \"AAA\") //根据排序规则自动对Key排序的Map val map5 = emptyMap\u003cInt, String\u003e() //空Map val hashMap = HashMap\u003cInt, String\u003e() //采用构造函数创建的HashMap，不保存Key顺序的Map，同map2 val linkedHashSet = LinkedHashMap\u003cInt, String\u003e() //采用构造函数创建的LinkedHashMap，保存Key顺序的Map，同map3 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"迭代器 我们在一开始提到，集合类型的顶层接口都是一个叫做Collection的接口： public interface Collection\u003cout E\u003e : Iterable\u003cE\u003e { //继承自Iterable接口 ... } 而在Iterable接口中，就定义了一个用于生成迭代器的函数： public interface Iterable\u003cout T\u003e { /** * Returns an iterator over the elements of this object. */ public operator fun iterator(): Iterator\u003cT\u003e } 不仅仅是集合类，甚至在Array类中也定义了这样的函数： public class Array\u003cT\u003e { ... /** * Creates an [Iterator] for iterating over the elements of the array. */ public operator fun iterator(): Iterator\u003cT\u003e } 迭代器是每个集合类、数组都可以生成的东西，它的作用很简单，就是用于对内容的遍历： val list = listOf(\"AAA\", \"BBB\", \"CCC\") val iterator: Iterator\u003cString\u003e = list.iterator() //通过iterator函数得到迭代器对象 那么这个迭代器该如何使用呢？先来看接口定义： public interface Iterator\u003cout T\u003e { //获取下一个待遍历元素 public operator fun next(): T //如果还有元素没有遍历，那么返回true否则返回false，而这个函数也是运算符重载函数正好对应着 for in 操作 public operator fun hasNext(): Boolean } 通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是： 一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针： 每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。 实际上迭代器的功能设计非常纯粹，就是看有没有下一个，有的话就拿出来，所以使用迭代器可以直接用一个while循环搞定： val iterator: Iterator\u003cString\u003e = list.iterator() while (iterator.hasNext()) { //使用while不断判断是否存在下一个 println(iterator.next()) //每次循环都取出一个 } 迭代器的出现，使得无论我们使用哪一种集合，都可以使用同样的方式对元素进行遍历，这统一了遍历操作的使用： fun \u003cT\u003e forEach(iterator: Iterator\u003cT\u003e) { //统一接收迭代器对象 while (iterator.hasNext()) { println(iterator.next()) } } fun main() { //现在无论什么集合/数组都可以按照统一的方式去进行处理 forEach(listOf(\"AAA\", \"BBB\", \"CCC\").iterator()) forEach(setOf(\"AAA\", \"BBB\", \"CCC\").iterator()) forEach(arrayOf(\"AAA\", \"BBB\", \"CCC\").iterator()) forEach(mapOf(1 to \"AAA\", 2 to \"BBB\",3 to \"CCC\").iterator()) } 注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。 只要是重写了operator fun iterator()函数的类型，都可以使用for..in这样的语法去进行遍历： for (s in listOf(\"AAA\", \"BBB\", \"CCC\")) { ... } 因此，数组和集合类都支持使用for循环遍历也就不奇怪了，哪怕是我们自己定义的类，只要实现这个函数都是支持的： class Test : Iterable\u003cString\u003e { //这个接口实不实现其实都无所谓 //实现这个运算符重载函数iterator是必须要的，否则不支持 override operator fun iterator(): Iterator\u003cString\u003e = TestIterator() class TestIterator: Iterator\u003cString\u003e { //自己随便写一个迭代器实现 override fun hasNext(): Boolean = true override fun next(): String = \"666\" } } fun main() { val test = Test() for (s in test) { println(s) } } 包括我们前面使用的Range语法，其本身也是一个支持生成迭代器的类： val range: IntRange = 1..3 val iterator: Iterator\u003cInt\u003e = range.iterator() 实际上，所有使用for..in语法的操作，最后都会被编译为使用迭代器的while操作： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") //编译前 for (s in list) { list.add(\"DDD\") } val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") //编译后 val iterator: Iterator\u003cString\u003e = list.iterator() while (iterator.hasNext()) { val next = iterator.next() println(next) } 是不是突然觉得有点豁然开朗？至此，我们已经完成解释清楚for..in操作的原理了。 特别的，对于List来说，它还有一个非常特殊的ListIterator迭代器： val iterator: ListIterator\u003cString\u003e = list.listIterator() //使用listIterator函数来获取ListIterator println(iterator.next()) //不仅可以正着迭代 println(iterator.nextIndex()) //还可以直接告诉你下一个迭代的是List的第几个元素 println(iterator.previous()) //还能反着来 ListIterator迭代器是普通迭代器的强化版本，它可以实现列表中元素的双向遍历，并且可以得到当前迭代的元素下标。 最后，我们再来探讨一个之前可能遇到过的问题： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") for (s in list) { //在遍历List时，不断往里面添加新的元素 list.add(\"DDD\") } 此程序运行会直接得到一个报错： 在JVM环境下，Kotlin默认不支持在迭代时修改集合里面的内容，无论是插入新的元素还是移除元素，都会触发并发修改异常。为了解决这个问题，Kotlin为所有的MutableCollection（所有非只读集合类）提供了一个特殊的用于生成MutableIterator的函数，只要我们使用的不是只读的集合类，都可以获得这个特殊的迭代器，它支持在遍历时对元素进行删除： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") val iterator: MutableIterator\u003cString\u003e = list.iterator() while (iterator.hasNext()) { iterator.next() iterator.remove() //删除当前迭代器已经遍历的最后一个元素 } 有关迭代器的相关知识就先到这里了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"集合与数组扩展操作 前面我们介绍了Kotlin提供的几个常用集合类，我们在使用这些集合类的时候，为了更加方便，官方提供了很多用于集合、数组类型的扩展操作，我们来学习一下吧，因为这些扩展操作数组和集合都可以使用，我们就尽量以List为例进行讲解。 首先是数组跟集合的联动，有些时候我们可能拿到的是一个数组对象，但是我们希望将其转换为集合类进行操作，我们可以使用数组提供的集合快速转换函数来进行转换： val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") val list: List\u003cString\u003e = array.toList() val list: MutableList\u003cString\u003e = array.toMutableList() val set: Set\u003cString\u003e = array.toSet() val set: MutableSet\u003cString\u003e = array.toMutableSet() 这样，如果我们发现数组无法满足我们对于其元素的操作，可以直接转换为集合类进行操作，方便你我。 接下来是映射操作（注意这里说的map跟我们前面说的集合Map是两个概念，别搞混了）它可以将集合类、数组的元素类型进行转换，比如我们现在有一个字符串集合，但是我们现在希望把它变成记录每一个字符串长度的Int集合，该怎么做呢？ val list = listOf(\"AAA\", \"BB\", \"CCCCC\") val lenList: List\u003cInt\u003e = list.map { it.length } //使用map函数，传入自定义的转换操作函数，就可以对元素进行转换了 我们可以利用这种操作来为里面的每一个元素添加编号： val list = listOf(\"AAA\", \"BBB\", \"CCC\") //使用mapIndexed还可以额外附带一个index参数 val mapList: List\u003cString\u003e = list.mapIndexed { index, it -\u003e \"$index.${it}\" } println(mapList) //结果 [0.AAA, 1.BBB, 2.CCC] 快速编号操作 利用映射操作，我们可以快速对集合中是元素依次进行修改，也可以对集合中的元素进行类型转换，非常方便。 对于Map类型，我们还可以单独对所有Key或是Value进行操作： val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3) println(numbersMap.mapKeys { it.key.uppercase() }) //对所有的Key进行Map操作 println(numbersMap.mapValues { it.value + it.key.length }) 我们接着来看下一个，压缩操作，它可以将当前集合元素和另一个集合中具有相同索引的元素组合起来，生成一个装满Pair的列表： val list1 = listOf(1, 2, 3) val list2 = listOf(\"AAA\", \"BBB\", \"CCC\") val pairs: List\u003cPair\u003cInt, String\u003e\u003e = list1.zip(list2) println(pairs) 利用压缩操作我们可以快速将两个List集合揉成一个Map集合： val map = mutableMapOf\u003cInt, String\u003e() map.putAll(list1.zip(list2)) println(map) //结果 {1=AAA, 2=BBB, 3=CCC} 既然能压缩还能解压： val list = listOf(1 to \"AAA\", 2 to \"BBB\", 3 to \"CCC\") //把合在一起的Pair每个元素都分开 val unzipList: Pair\u003cList\u003cInt\u003e, List\u003cString\u003e\u003e = list.unzip() //转换出来是一个存放两个List的Pair println(unzipList) 有些时候我们还可以使用另一种方式将普通集合转换为Map映射，比如associate操作： val list = listOf(\"AAA\", \"BBB\", \"CCC\") //使用associateWith快速构建以列表中每个元素为Key的Map映射 val associate: Map\u003cString, Int\u003e = list.associateWith { it.length } //提供一个函数，返回值作为生成的Map对应Key的Value println(associate) //结果 {AAA=3, BBB=3, CCC=3} 还有对应的反向操作： val list = listOf(\"AAA\", \"BBB\", \"CCC\") //使用associateBy快速构建以列表中每个元素为Value的Map映射 val associate: Map\u003cInt, String\u003e = list.associateBy { it.length } //提供一个函数，返回值作为生成的Map对应Value的Key println(associate) //结果{3=CCC}，因为上面生产出来的Key全是3，覆盖完只剩下最后一个了 如果你觉得以上两种方式都不是很灵活，你也可以自己根据情况自行构建一个Pair作为结果返回： val associate: Map\u003cString, Int\u003e = list.associate { it to it.length } //返回一个Pair 我们接着来看，对于一些嵌套集合和数组来说，有时候处理里面的数据会变得很棘手： val list = listOf(listOf(\"AAA\", \"BBB\"), listOf(\"CCC\", \"DDD\")) //现在我们想要遍历这个嵌套List中的每一个元素，需要两层for循环 list.forEach { it.forEach { item -\u003e println(item) } } 那么有没有办法能够把这个嵌套的集合内所有的集合全部拆出来，全部存在一个不嵌套的集合中呢？我们可以使用扁平化操作： val list = listOf(listOf(\"AAA\", \"BBB\"), listOf(\"CCC\", \"DDD\")) val flatten: List\u003cString\u003e = list.flatten() //使用flatten函数将嵌套集合扁平化 println(flatten) //可以看到内容自动被展平了 [AAA, BBB, CCC, DDD] 结合之前学习的映射操作，我们还可以在展平元素的同时对元素进行映射，非常适合下面这种情况： //把下面这个给展平 val list = listOf(Container(listOf(\"AAA\", \"BBB\")), Container(listOf(\"CCC\", \"DDD\"))) 可以看到，这个List很恶心，它内层存放的集合是被套在一个对象中的，更准确的说，这是一个List\u003cContainer\u003e类型的列表，但是现在我们希望的是取出里面每一个对象存储的List然后拿来展平，可以像这样： //使用flatMap函数进行操作，支持自定义获取列表然后再进行扁平化操作 val flatList: List\u003cString\u003e = list.flatMap { it.list } //通过Lambda将每一个Container映射为List println(flatList) //结果为：[AAA, BBB, CCC, DDD] 其实还有一个joinToString函数，但是前面数组部分已经讲解过了，使用方式是一样的，这里就不做介绍了。 有时候我们想要移除集合中某些不满足条件的元素，我们可以使用过滤操作来完成： val list = listOf(\"AAA\", \"BB\", \"CCC\") //使用filter来过滤不满足条件的元素，这里的意思是只保留长度大于2的字符串 val filterList: List\u003cString\u003e = list.filter { it.length \u003e 2 } println(filterList) //结果为：[AAA, CCC] val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11) //Map同样支持这样的操作 val filteredMap = numbersMap.filter { (key, value) -\u003e key.endsWith(\"1\") \u0026\u0026 value \u003e 10} println(filteredMap) 还有快速过滤所有空值的操作： val list = listOf(\"AAA\", null, \"BBB\", null) val filterList: List\u003cString\u003e = list.filterNotNull() println(filterList) //结果 [AAA, BBB] 甚至还可以快速过滤出指定类型的集合： val list = listOf(\"AAA\", Any(), \"BBB\", 123, 3.14) val filterList: List\u003cString\u003e = list.filterIsInstance\u003cString\u003e() //快速过滤出所有的String元素 println(filterList) //结果 [","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"序列 除了集合，Kotlin标准库还包含另一种类型：序列（Sequence）与集合不同，序列不包含元素，它在运行时生成元素，Sequence与Iterable接口功能相似，接口定义如下，同样只包含一个生成迭代器的函数： public interface Sequence\u003cout T\u003e { public operator fun iterator(): Iterator\u003cT\u003e } 那既然功能一样，为什么要专门搞一个序列呢？这不是多此一举吗？序列实际上是一个延迟获取数据的集合，只有需要元素时才会生产元素并提供给外部，包括所有对元素操作，并不是一次性全部处理，而是根据情况选择合适的元素进行操作。使用序列能够在处理大量数据时获得显著的性能提升。 要创建一个序列非常简单，使用generateSequence函数即可： val sequence: Sequence\u003cInt\u003e = generateSequence { println(\"生成一个新的元素\") 10 //返回值就是生成的元素 } 可以看到generateSequence得到的结果并没有在一开始执行println，因为序列的数据处理是惰性的，在我们添加 sequence.forEach { println(it) } 此时控制台才开始打印生成的Lambda函数。同样的，所有扩展操作同样是惰性的，我们可以来比较一下： val list = listOf(\"AA\", \"BBB\", \"CCC\", \"DD\", \"EEE\", \"FF\", \"GGG\", \"HH\") //以下操作用于获取前两个长度大于2的字符串，并进行小写转换操作 val result = list.filter { println(\"进行过滤操作: $it\") it.length \u003e 2 }.map { println(\"进行小写转换操作\") it.lowercase() }.take(2) 可以看到，在直接使用集合的情况下，整个工序是按照顺序在向下执行的，并且每一道工序都会对所有的元素依次进行操作，但是实际上根据我们的要求，最后只需要两个满足条件的即可，如果这个是一个数据量非常庞大的集合，会导致执行效率很低。我们现在换成序列试试看： //使用asSequence函数将集合转换为一个序列 val result = list.asSequence().filter { println(\"进行过滤操作: $it\") it.length \u003e 2 }.map { println(\"进行小写转换操作\") it.lowercase() }.take(2) println(result) //如果这句不执行，不获取元素，以上整个操作都是不会进行的 可以看到，序列根据我们的操作流程，对数据的操作也进行了优化，执行次数明显减少，并且使用序列后只有我们从序列读取数据时才会开始执行我们定义好的工序，可见，序列执行的各种操作，仅仅是记录到序列中，并没有在一开始就执行，而是需要的时候才开始获取，因此才可以做到上面这样的操作。 这与Java中的Stream非常相似。 当然，序列并不是随时随地都可以使用的，我们还是要根据实际情况决定是否要使用序列，如果在数据量特别庞大的情况下，使用序列处理会更好，但是如果数据量很小，使用序列反而会增加开销。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"特殊类型介绍 除了我们之前学习的普通class类型之外，Kotlin还为我们提供了更多种类的类型，以应对不同的情况。 这些特殊类型本质上依然是class但是存在一些限制或是特殊情况。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数据类型 对于那些只需要保存数据的类型，我们常常需要为其重写toString、equals等函数，针对于这种情况下，Kotlin为我们提供了专门的数据类，数据类不仅能像普通类一样使用，并且自带我们需要的额外成员函数，比如打印到输出、比较实例、复制实例等。 声明一个数据类非常简单： //在class前面添加data关键字表示为一个数据类 data class User(val name: String, val age: Int) 数据类声明后，编译器会根据主构造函数中声明的所有属性自动为其生成以下函数： .equals()/.hashCode() .toString()生成的字符串格式类似于\"User(name=John, age=42)\" .componentN()与按声明顺序自动生成用于解构的函数 .copy()用于对对象进行拷贝 我们可以来试试看： fun main() { val user1 = User(\"小明\", 18) val user2 = User(\"小明\", 18) println(user1) //打印出来就是格式化的字符串 User(name=小明, age=18) println(user1 == user2) //true，因为自动重写了equals函数 val (name, age) = user1 //自动添加componentN函数，因此支持解构操作 println(\"名称: $name, 年龄: $age\") } 当然，为了确保生成代码的一致性和有效性，数据类必须满足以下要求： 主构造函数中至少有一个参数。 主构造函数中的参数必须标记为val或var。 数据类不能是抽象的、开放的、密封的或内部的。 此外，数据类的成员属性生成遵循有关成员继承的以下规则： 如果数据类主体中.equals() .hashCode()或.toString()等函数存在显式（手动）实现，或者在父类中有final实现，则不会自动生成这些函数，并使用现有的实现。 data class User(val name: String, val age: Int) { //如果已经存在toString的情况下，不会自动生成 override fun toString(): String = \"我是自定义的toString\" } fun main() { val user = User(\"小明\", 18) println(user) //结果: 我是自定义的toString } 如果超类型具有open .componentN()函数并返回兼容类型，则为数据类生成相应的函数，并覆盖超类型的函数。如果由于一些关键字导致无法重父类对应的函数会导致直接报错。 abstract class AbstractUser { //此函数必须是open的，否则无法被数据类继承 open operator fun component1() = \"卢本伟牛逼\" } data class User(val name: String, val age: Int): AbstractUser() //自动覆盖掉父类的component1函数 不允许为.componentN()和.copy()函数提供显式实现。 注意，编译器会且只会根据主构造函数中定义的属性生成对应函数，如果有些时候我们不希望某些属性被添加到自动生成的函数中，我们需要手动将其移出主构造函数： data class Person(val name: String) { var age: Int = 0 //age属性不会被处理 } 此时生成的所有函数将不会再考虑age属性： fun main() { val person1 = Person(\"John\") val person2 = Person(\"John\") person1.age = 10 person2.age = 20 println(\"person1 == person2: ${person1 == person2}\") // person1 == person2: true println(\"person1 with age ${person1.age}: $person1\") // person1 年龄为 10: Person(name=John) println(\"person2 with age ${person2.age}: $person2\") // person2 年龄为 20: Person(name=John) } 数据类自带一个拷贝对象的函数，使用.copy()函数复制对象，允许您更改其一些属性，而其余的保持不变。此函数对上述User类的实现如下： data class User(val name: String, val age: Int) fun main() { val user = User(\"小明\", 18) val copyUser = user.copy() //使用拷贝函数生成一个内容完全一样的新对象 println(user == copyUser) println(user === copyUser) } 在copy函数还可以在拷贝过程中手动指定属性的值： val user = User(\"小明\", 18) println(user.copy(age = 17)) //结果为 User(name=小明, age=17) ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"枚举类型 我们知道，在Kotlin中有一个Boolean类型，它只有两种结果，要么为false要么为true，这代表它的两种状态真和假。有些时候，可能两种状态并不能满足我们的需求，比如一个交通信号灯，它具有三种状态：红灯、黄灯和绿灯。 如果我们想要存储和表示自定义的多种状态，使用枚举类型就非常合适： //在类前面添加enum表示这是一个枚举类型 enum class LightState { GREEN, YELLOW, RED //直接在枚举类内部写上所有枚举的名称，一般全部用大写字母命名 } 枚举类的值只能是我们在类中定义的那些枚举，不可以存在其他的结果，枚举类型同样也是一个普通的类，只是存在值的限制。 要使用一个枚举类的对象，可以通过类名直接获取定义好的枚举： fun main() { val state: LightState = LightState.RED //直接得到红灯 println(state.name) //自带name属性，也就是我们编写的枚举名称，这里是RED } 同样的，枚举类也可以具有成员： //同样可以定义成员变量，但是不能命名为name，因为name拿来返回枚举名称了 enum class LightState(val color: String) { GREEN(\"绿灯\"), YELLOW(\"黄灯\"), RED(\"红灯\"); //枚举在定义时也必须填写参数，如果后面还要编写成员函数之类的其他内容，还需在末尾添加分号结束 fun isGreen() = this == LightState.GREEN //定义一个函数也是没问题的 } 我们可以像普通类那样正常使用枚举类的成员： val state: LightState = LightState.RED println(\"信号灯的颜色是: ${state.color}\") println(\"信号灯是否可以通行: ${state.isGreen()}\") 枚举类型可以用于when表达式进行判断，因为它的状态是有限的： val state: LightState = LightState.RED val message: String = when(state) { LightState.RED -\u003e \"禁止通行\" LightState.YELLOW -\u003e \"减速通行\" LightState.GREEN -\u003e \"正常通行\" } println(message) //结果为: 禁止通行 在枚举类中也可以编写抽象函数，抽象函数需要由枚举自行实现： enum class LightState(val color: String) { GREEN(\"绿灯\"){ override fun test() = println(\"我是绿灯，表示可以通过\") }, YELLOW(\"黄灯\") { override fun test() = println(\"我是黄灯，是让你减速，不是让你踩油门加速过去\") }, RED(\"红灯\") { override fun test() = println(\"我是红灯，禁止通行\") }; abstract fun test() //抽象函数 } fun main() { val state: LightState = LightState.RED state.test() //调用函数: 我是红灯，禁止通行 } 如果枚举类实现了某个接口，同样可以像这样去实现： interface Message { fun test() } enum class LightState(val color: String) : Message { GREEN(\"绿灯\"){ override fun test() = println(\"我是绿灯，表示可以通过\") }, YELLOW(\"黄灯\") { override fun test() = println(\"我是黄灯，是让你减速，不是让你踩油门加速过去\") }, RED(\"红灯\") { override fun test() = println(\"我是红灯，禁止通行\") }; } enum class LightState(val color: String) : Message { GREEN(\"绿灯\"), YELLOW(\"黄灯\"), RED(\"红灯\"); override fun test() = println(\"\") } 枚举类也为我们准备了很多的函数： val state: LightState = LightState.valueOf(\"RED\") //通过valueOf函数以字符串名称的形式转换为对应名称的枚举 val state: LightState = enumValueOf\u003cLightState\u003e(\"RED\") //同上 println(state) println(state.ordinal) //枚举在第几个位置 println(state.name) //枚举名称 val entries: EnumEntries\u003cLightState\u003e = LightState.entries //一键获取全部枚举，得到的结果是EnumEntries类型的，他是List的子接口，因此可以当做List来使用 val values: Array\u003cLightState\u003e = enumValues\u003cLightState\u003e() //或者像这样以Array形式获取到所有的枚举 println(entries) ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"匿名类和伴生对象 有些时候，可能我们并不需要那种通过class关键字定义的对象，而是以匿名的形式创建一个临时使用的对象，在使用完之后就不再需要了，这种情况完全没有必要定义一个完整的类型，我们可以使用匿名类的形式去编写。 val obj = object { //使用object关键字声明一个匿名类并创建其对象，可以直接使用变量接收得到的对象 val name: String = \"\" override fun toString(): String = \"我是一个匿名类\" //匿名类默认继承于Any，可以直接重写其toString } println(obj) 可以看到，匿名类除了没名字之外，也可以定义成员，只不过这种匿名类不能定义任何构造函数，因为它是直接创建的，这种写法我们也可以叫做对象表达式。 匿名类不仅可以直接定义，也可以作为某个类的子类定义，或是某个接口的实现： interface Person { fun chat() } fun main() { val obj: Person = object : Person { //直接实现Person接口 override fun chat() = println(\"牛逼啊\") } obj.chat() //当做Person的实现类使用 } interface Person open class Human(val name: String) fun main() { val obj: Human = object : Human(\"小明\"), Person { //继承类时，同样需要调用其构造函数 override fun toString() = \"我叫$name\" //因为是子类，直接使用父类的属性也是没问题的 } println(obj) } 可以看到，平时我们无法直接实例化的接口或是抽象类，可以通过匿名类的形式得到一个实例化对象。 我们再来看下面这种情况： interface KRunnable { fun invoke() //此类型是一个接口且只包含一个函数 } 根据我们上面学习的用法，如果我们想要使用其匿名类，可以像这样编写： fun main() { val runnable = object : KRunnable { //使用匿名类的形式编写KRunnable的实现类对象 override fun invoke() { println(\"我是函数invoke的实现\") } } runnable.invoke() } 特别的，对于只存在一个抽象函数的接口称为函数式接口或单一抽象方法（SAM）接口，函数式接口可以有N个非抽象成员，但是只能有一个抽象成员。对于函数式接口，可以使用我们前面介绍的Lambda表达式来使代码更简洁： fun interface KRunnable { //在接口声明前面添加fun关键字 fun invoke() } ... fun main() { val runnable = KRunnable { //支持使用Lambda替换 println(\"我是函数invoke的实现\") } runnable.invoke() } 我们再来看下面这种情况： fun interface Printer { fun print() } fun test(printer: Printer) { //需要Printer接口实现对象 printer.print() } 我们在调用test时，也可以写的非常优雅： fun main() { test { //直接Lambda一步到位 println(\"Hello World\") } } 正是因为有了匿名类，所以有些时候我们通过函数得到的结果，可能并不是某个具体定义的类型，也有可能是直接采用匿名形式创建的匿名类对象： open class Human(val name: String) fun test() = object: Human(\"小明\") { //返回的一个匿名类对象 val age: Int = 10 override fun toString() = \"我叫$name\" } fun main() { println(test().name) println(test().age) //编译错误，因为返回的类型是Human，由于其匿名特性，只能当做Human使用 } object关键字除了用于声明匿名类型，也可以用于声明单例类。单例类是什么意思呢？就像它的名字一样，在整个程序中只能存在一个对象，也就是单个实例，不可以创建其他的对象，始终使用的只能是那一个对象。 object Singleton { //声明的一个单例类 private var name = \"你干嘛\" override fun toString() = \"我叫$name\" } fun main() { val singleton = Singleton //通过类名直接得到此单例类的对象 //不可以通过构造函数的形式创建对象 println(singleton) } object Singleton { fun test() = println(\"原神，启动！\") } fun main() { Singleton.test() //单例定义的函数直接使用类名即可调用 } 用起来与Java中的静态属性挺像的，只不过性质完全不一样。单例类的这种性质在很多情况下都很方便，比如我们要编写某些工具操作，可以直接使用单例类的形式编写。 现在我们希望一个类既支持单例类那样的直接调用，又支持像一个普通class那样使用，这时该怎么办呢？ 我们可以使用半生对象来完成，实际上就是将一个单例类写到某个类的内部： class Student(val name: String, val age: Int) { //使用companion关键字在内部编写一个伴生对象，它同样是单例的 companion object Tools { //伴生对象定义的函数可以直接通过外部类名调用 fun create(name: String, age: Int) = Student(name, age) } } fun main() { //现在Student不仅具有对象的函数，还可以通过类名直接调用其伴生对象通过的函数 val student = Student.create(\"小明\", 18) println(student.toString()) } 伴生对象在Student类加载的时候就自动创建好了，因此我们可以实现直接使用。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"委托模式 在有些时候，类的继承在属性的扩展上起到了很大的作用，通过继承我们可以直接获得某个类的全部属性，而不需要再次进行编写，不过，现在有了一个更好的继承替代方案，那就是委托模式（在设计模式中也有提及）名字虽然听着很高级，但是其实很简单，比如我们现在有一个接口： interface Base { fun print() } 正常情况下，我们需要编写一个它的实现类： class BaseImpl(val x: Int) : Base { override fun print() = println(x) } 现在我们换一个思路，我们再来创建一个实现类： class Derived(val base: Base): Base { //将一个Base的实现类作为属性保存到类中，同样实现Base接口 override fun print() = base.print() //真正去实现这个接口的，实际上并不是当前类，而是被拉进来的那个替身 } 这就是一个非常典型的委托模型，且大量实践已证明委托模式是实现继承的良好替代方案。 Kotlin对于这种模式同样给予了原生支持： interface Base { fun print() } class BaseImpl(val x: Int) : Base { override fun print() = println(x) } class Derived(val b: Base): Base by b //使用by关键字将所有接口待实现操作委托给指定成员 这样就可以轻松实现委托模式了。 除了类可以委托给其他对象之外，类的成员属性也可以委托给其他对象： import kotlin.reflect.KProperty class Example { var p: String by Delegate() //属性也可以使用by关键字委托给其他对象 } // 委托的类 class Delegate { //需要重载属性的获取和设置两个运算 operator fun getValue(thisRef: Any?, property: KProperty\u003c*\u003e): String { return \"$thisRef, 这里委托了 ${property.name} 属性\" } operator fun setValue(thisRef: Any?, property: KProperty\u003c*\u003e, value: String) { println(\"$thisRef 的 ${property.name} 属性赋值为 $value\") } } fun main() { println(Example().p) } 不过，自己去定义一个类来进行委托实在是太麻烦了，Kotlin在标准库中也为我们提供了大量的预设函数： class Example { val p: String by lazy { \"牛逼啊\" } //lazy为我们生成一个委托对象，这样在获取属性值的时候就会执行lazy里面的操作了，看起来效果就像是延迟执行一样，由于只能获取，所以说只支持val变量 } fun main() { println(Example().p) } 也可以设置观察者，实时观察变量的变化： class Example { var p: String by Delegates.observable(\"我是初始值\") { prop, old, new -\u003e println(\"检测到$prop 的值发生变化，旧值：$old -\u003e 新值：$new\") } } fun main() { Example().p = \"你干嘛\" } 属性也可以直接将自己委托给另一个属性： class Example(var a: String) { var p: String by ::a //使用双冒号来委托给其他属性 } fun main() { val example = Example(\"你干嘛\") println(example.p) } 相信各位应该能猜到，这样委托给其他属性，当前属性的值修改，会直接导致其他属性的值也会修改，相反同样它们已经被相互绑定了。 属性也可以被委托给一个Map来进行存储： class User(map: MutableMap\u003cString, Any\u003e) { var name: String by map //直接委托给外部传入的Map集合 var age: Int by map //变量的值从Map中进行存取 override fun toString(): String = \"名称: $name, 年龄: $age\" } fun main() { val map: MutableMap\u003cString, Any\u003e = mutableMapOf( \"name\" to \"John Doe\", \"age\" to 25 ) val user = User(map) println(user) //名称: John Doe, 年龄: 25 map[\"age\"] = 10 //映射的值修改会直接影响变量的值 println(user) //名称: John Doe, 年龄: 10 } 注意，在使用不可变的Map时，只能给val类型变量进行委托，因为不可修改。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"密封类型 有些时候，我们可能会编写一些类给其他人使用，但是我们不希望他们随意继承使用我们提供的类，我们只希望在我们提供的框架内部自己进行使用，这时我们就可以将类或接口设定为密封的。 密封类的所有直接子类在编译时都是已知的。不得在定义密封类的模块和包之外出现其他子类。例如，第三方项目无法在其代码中扩展您的密封类。因此，密封类的每个实例都有一个来自预设好的类型，且该类型在编译该类时是已知的。 package com.test sealed class A //声明密封类很简单，直接添加sealed关键字即可 sealed class B: A() //密封类同一个模块或包中可以随意继承，并且子类也可以是密封的 当我们在其他包中使用这个密封类，在其他包或模块中无法使用： class C: A() //编译错误，不在同一个模块 fun main() { val b = B() //编译错误，不可以实例化 } 密封类将类的使用严格控制在了模块内部，包括密封接口及其实现也是如此：一旦编译了具有密封接口的模块，就不会出现新的实现类。 从某种意义上说，密封类类似于枚举类：枚举类型的值数量也受到限制，由我们自己定义，但每个枚举变量仅作为单个实例存在，而密封类的子类可以有多个实例，每个实例都有自己的状态。密封类本身也是抽象的，它不能直接实例化，并且可以具有abstract成员： sealed class A sealed class B: A() { abstract fun test() } 密封类继承后也可以使其不继续密封，让外部可以正常使用： sealed class A class B: A() class C: A() class D: A() //不添加sealed关键字使其不再密封 但是由于类A是密封的，因此所有继承自A的类只能是我们自己写的，别人无法编写继承A的类，除非我们将某个继承A的类设定为open特性，允许继承。因此，这也进一步证明密封类在一开始就确定了有哪些子类。 由于密封类能够确定，所以在使用when进行类型判断时，也是有限的： fun main() { val a: A = C() when(a) { is B -\u003e println(\"是B\") is C -\u003e println(\"是C\") is D -\u003e println(\"是D\") } } 密封类的应用场景其实远不止这些，由于篇幅有限，这里就不展开讲解了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"异常机制 在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ 我们来看下面这段代码： fun main() { test(1, 0) //当b为0的时候，还能正常运行吗？ } private fun test(a: Int, b: Int): Int { return a / b //没有任何的判断而是直接做计算 } 1怎么可能去除以0呢，数学上有明确规定，0不能做除数，所以这里得到一个异常： 那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！它们在默认情况下会强行终止我们的程序。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:11:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"异常的使用 我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Throwable类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ 每个异常对象都包含一条消息、一个堆栈跟踪和一个可选原因。 我们自己也可以抛出异常，要抛出异常对象，请使用throw出表达式： fun main() { //Exception继承自Throwable类，作为普通的异常类型 throw Exception(\"牛逼\") } 可以看到，控制台出现了下面的报错： 所以，我们平时看到的那些丰富多彩的异常，其实大部分都是由程序主动抛出的。 我们也可以依葫芦画瓢，自定义我们自己的异常类： class TestException(message: String) : Exception(message) fun main() { throw TestException(\"自定义异常\") } 是不是感觉很简单，异常的出现就是为了方便我们快速判断程序的错误。我们可以在异常打印出来的栈追踪信息中得到当前程序出现问题的位置： 这里指示的很明确，是我们的Main.kt文件第四行代码出现了异常。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:11:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"异常的处理 当程序没有按照我们理想的样子运行而出现异常时（JVM平台下，默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： val array = arrayOf(1, 2, 3) println(array[3]) //数组长度根本没有4，很明显这里会出现异常 现在我们希望能够手动处理这种情况，即使发生异常也要继续下去，我们可以使用try-catch语句块来完成： fun main() { try { //使用try-catch语句进行异常捕获 val array = arrayOf(1, 2, 3) println(array[3]) } catch (e: ArrayIndexOutOfBoundsException) { //因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常 } println(\"程序继续正常运行！\") } 我们可以将代码编写到try语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用catch关键字对指定的异常进行捕获，这里我们捕获的是ArrayIndexOutOfBoundsException数组越界异常： 可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。 注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。 我们可以在catch语句块中对捕获到的异常进行处理： fun main() { try { //使用try-catch语句进行异常捕获 val array = arrayOf(1, 2, 3) println(array[3]) } catch (e: ArrayIndexOutOfBoundsException) { e.printStackTrace(); //打印栈追踪信息 println(\"异常错误信息：\"+e.message); //获取异常的错误信息 } println(\"程序继续正常运行！\") } 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： try { //.... } catch (e: Exception) { //父类型在前，会将子类的也捕获 } catch (e: NullPointerException) { //因为NullPointerException是Exception的子类型，永远都不会进入这里 } catch (e: IndexOutOfBoundsException) { //永远都不会进入这里 } 最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给finally语句块来处理： try { //.... } catch (e: Exception) { } finally { println(\"lbwnb\") //无论是否出现异常，都会在最后执行 } 注意：try语句块至少要配合catch或finally中的一个。 try也可以当做一个表达式使用，这意味着它可以有一个返回值： fun main() { val input = readln() val a: Int? = try { input.toInt() } catch (e: NumberFormatException) { null } println(a) } 针对于空类型，我们也可以在判断为空时直接抛出异常： val s = person.name ?: throw IllegalArgumentException(\"Name required\") ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:11:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["draft"],"content":"Btrfs文件系统介绍 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"1. Btrfs简介 Btrfs 是一种新型的写时复制（CoW）Linux 文件系统，已经并入内核主线。你可以读作 Better File System、B-tree File System、Butter File System 等等，都是正确的。Btrfs 在设计实现高级功能的同时，着重于容错、修复以及易于管理。它由 Oracle、Red Hat、Fujitsu、Intel、SUSE、STRATO 等企业和开发者共同开发。Btrfs 以 GNU GPL 协议授权，同时也欢迎任何人的贡献。 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"2. Btrfs的特性 扩展性相关 B-tree Btrfs 文件系统中所有的 metadata 都由 B-tree 管理。使用 B-tree 的主要好处在于查找、插入和删除操作都很高效。可以说 B-tree 是 Btrfs 的核心 基于 Extent 的文件存储 ✅ 针对 SSD 的优化支持 Btrfs 的 CoW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，Btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 I/O 性能 动态 Inode 分配 支持非常大的单个文件大小 数据一致性相关 ✅ 写时复制（CoW） 比就地修改的文件系统有更大的好处，详细的说明见下文 校验和（Checksum） 保证了数据的可靠性：由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变成了 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。如果最终从磁盘读取出来的数据和 checksum 不相同，Btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，Btrfs 将返回错误。写入磁盘数据之前，Btrfs 计算数据的 checksum。然后将 checksum 和数据同时写入磁盘。 多设备管理相关 ✅ 多设备管理 Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的相关命令将该设备添加到文件系统中 ✅ 子卷（Subvolume） 把文件系统的一部分配置为一个完整的子文件系统 ✅ 快照（Snapshot）和克隆（Clone） 支持快照 支持快照的快照（增量备份） 可以对单个文件进行备份 ✅ 内置支持 RAID，支持条带或 mirror 等常见的 RAID 功能 ✅ 支持热移除、热添加设备 其他特性 ✅ 透明压缩 减小了文件的大小，通过减少文件写入增幅来显著延长闪存介质的寿命。在某些特定的场景下（比如单线程、重负荷的文件 I/O）还提高了性能 延迟分配（Delay allocation） 在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配则是这样一种技术 —— 当用户需要磁盘空间时，先将数据保存在内存中。将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求 —— 一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 I/O 效率 Inline File 系统中往往存在大量的小文件（几百个字节或者更小）。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。Btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。得益于 Inline File 技术，Btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题 目录索引（Directory Index） 当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 B-tree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。然而，Btrfs 使用 B-tree 管理目录项的方式无法同时满足 readdir 的需求。readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件；并且特别的，这些文件要按照 inode number 排序。而 Btrfs 目录项插入 B-tree 时的 Key 并不是 inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，Btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 Key 以 sequence number 作为 B-tree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 Key 在 B-tree 中查找便可以方便的得到一个以 inode number 排序的文件列表 另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 I/O 效率 预分配 很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"Btrfs 与其它文件系统功能比较# Feature Ext 2 / 3 Ext 4 ReiserFS XFS OCFS2 Btrfs Journal (date / metadata) ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚫ ⚪ / ⚫ ⚪ / ⚫ N/A Journal (internal / external) ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚪ N/A Offline extend / shrink ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Online extend / shrink ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Inode allocation map table table B*-tree B+-tree table B-tree Sparse files ⚫ ⚫ ⚫ ⚫ ⚫ ⚫ Tail packing ⚪ ⚫ ⚫ ⚪ ⚪ ⚫ Defragmentation ⚪ ⚫ ⚪ ⚫ ⚪ ⚫ ExtArributes / ACLs ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ Quotas ⚫ ⚫ ⚫ ⚫ ⚫ 🔴 Dump / restore ⚫ ⚫ ⚪ ⚫ ⚪ ⚪ Default block size 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB max. file system size 16 TiB 1 EiB 16 TiB 8 EiB 4 PiB 16 EiB max. file size 2 TiB 1 EiB 1 EiB 8 EiB 4 PiB 16 EiB Support status SLES SLES SLES SLES SLE HA SLES ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:1","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"3. Barfs的简单使用 3.1 创建文件系统 mkfs.btrfs -f /dev/sda1 3.2 挂载文件系统 mount /dev/sda1 /mnt 3.3 创建子卷 btrfs subvolume create subvolume_name 3.4 删除子卷 btrfs subvolume delete subvolume_name # or rm -rf subvolume_name 3.5 创建快照 btrfs subvolume snapshot source destination 3.6 删除快照 btrfs subvolume delete snapshot_name 3.7 查看快照 btrfs subvolume list /mnt 3.8 查看文件系统信息 btrfs filesystem show /mnt 3.9 查看文件系统使用情况 btrfs filesystem df /mnt 3.10 查看文件系统的压缩情况 btrfs filesystem df -c /mnt 3.11 查看文件系统的压缩算法 btrfs filesystem df -c /mnt 3.12 查看子卷信息 btrfs subvolume show /mnt ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"VPN 原理浅谈 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:0:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的应用场景 保护隐私： VPN 通过加密通信，确保你的互联网连接是安全的。这对于在公共 Wi-Fi 网络上浏览互联网时尤其重要，因为公共网络通常更容易受到黑客攻击。 绕过地理限制： 有些网站或服务在特定地区可能不可用，或者内容受到地理限制。使用 VPN 可以改变你的 IP 地址，使你能够绕过这些地理限制，访问受限制的内容。 保护公司内部网络： 公司可以使用 VPN 来建立安全的远程访问通道，员工可以通过 VPN 连接到公司内部网络，以便在远程地点安全地访问公司资源。 匿名上网： VPN 可以隐藏你的真实 IP 地址，提高上网的匿名性。这对于那些希望在互联网上保持相对匿名的用户来说很有用。 绕过审查： 在一些国家，互联网审查可能会限制对特定网站或服务的访问。使用 VPN 可以绕过这些审查，让用户能够自由地访问互联网。 安全远程办公： 对于远程工作者或分布式团队来说，VPN 提供了一个安全的通信渠道，使他们能够远程连接到公司网络并访问必要的资源。 防止数据被窃取： 在使用不安全的网络时，VPN 可以加密你的数据流，防止敏感信息被窃取，确保通信的机密性。 游戏加速： 一些玩家可能使用 VPN 来连接到特定地区的游戏服务器，以获得更好的游戏性能或访问特定地区的游戏内容。 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:1:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的工作原理 涉及到的底层技术 tun/tap: 用于创建虚拟网卡，用于接收和发送数据包, 主要的操作就是在此实现的 iptables： 用于实现数据包的转发 iproute2： 用于实现路由表的管理 tun/tap 概述： tun 设备: TUN设备是一种虚拟网络设备，用于在用户空间和内核空间之间传递网络数据。TUN代表“网络隧道”（Network TUNnel），它允许用户空间的程序通过标准的网络套接字接口发送和接收IP数据包，同时内核会处理网络协议的部分。TUN设备通常用于创建虚拟私有网络（VPN）和其他网络隧道，以在用户空间中运行的程序与内核之间传递网络流量。这对于实现网络隔离、虚拟专用网络、安全隧道等应用场景非常有用。一般来说，使用TUN设备的流程如下： 用户空间程序通过TUN设备发送IP数据包。 内核将接收到的数据包从TUN设备中读取。 用户空间程序可以通过标准的套接字接口监听和处理这些数据包。 tap 设备：TAP设备（Tap虚拟网卡）是一种虚拟网络设备，与TUN设备类似，也用于在用户空间和内核空间之间传递网络数据。TAP代表“网络透明适配器”（Network TAP），与TUN设备不同的是，TAP设备在数据链路层（OSI模型的第二层）工作，而TUN设备在网络层（第三层）工作。主要区别在于： TAP设备：它以太网设备的形式存在，可以处理链路层的数据包。因此，TAP设备可以传输以太网帧，包括处理MAC地址等。TAP设备通常用于需要在二层进行操作的场景，比如虚拟局域网（VLAN）的实现、桥接网络、以太网隧道等。 TUN设备：与TAP不同，TUN设备是在网络层工作的，只能传输IP数据包。TUN设备通常用于实现虚拟私有网络（VPN）等应用，它只关心IP层的数据，而不涉及链路层的细节。 在使用TAP设备时，用户空间程序可以像处理真实的网络接口一样处理TAP设备，包括发送和接收以太网帧。 iptables 简单使用: # 设置从eth0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # 设置从tun0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE # 设置从eth0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 设置从tun0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i tun0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 允许所以数据包转发 iptables -A FORWARD -j ACCEPT iproute2 简单使用 # 设置tun0设备的ip为192.168.1.10/24 ip addr add 192.168.1.10/24 dev tun0 # 添加走到tun0设备的路由 ip route add 192.168 # 为table 100添加一条来自 192.168.1.10的规则 ip rule add from 192.168.1.10 table 100 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:2:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的简单实现","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:3:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"性能 Profiling – 使用 Perf 命令 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:0:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"1. Perf 常用命令 perf top 常用参数 -e：指定性能事件 -a：显示在所有 CPU 上的性能统计信息 -C：显示在指定 CPU 上的性能统计信息 -p：指定进程 PID -t：指定线程 TID -K：隐藏内核统计信息 -U：隐藏用户空间的统计信息 -s：指定待解析的符号信息 ‘‐G’ or‘‐‐call‐graph’ \u003coutput_type,min_percent,call_order\u003e graph: 使用调用树，将每条调用路径进一步折叠。这种显示方式更加直观。 每条调用路径的采样率为绝对值。也就是该条路径占整个采样域的比率。 perf list perf test perf record: 记录一段时间内系统/进程的性能时间 常用参数 -e：选择性能事件 -p：待分析进程的 id -t：待分析线程的 id -a：分析整个系统的性能 -C：只采集指定 CPU 数据 -c：事件的采样周期 -o：指定输出文件，默认为 perf.data -A：以 append 的方式写输出文件 -f：以 OverWrite 的方式写输出文件 -g：记录函数间的调用关系 perf report: 读取 perf record 生成的数据文件，并显示分析数据 常用参数 -i：输入的数据文件 -v：显示每个符号的地址 -d ：只显示指定 dos 的符号 -C：只显示指定 comm 的信息（Comm. 触发事件的进程名） -S：只考虑指定符号 -U：只显示已解析的符号 -g[type,min,order]：显示调用关系，具体等同于 perf top 命令中的-g -c：只显示指定 cpu 采样信息 -M：以指定汇编指令风格显示 –source：以汇编和 source 的形式进行显示 -p：用指定正则表达式过滤调用函数 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:1:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"2. 生成火焰图示例 # 采集数据 perf record -F 99 -p 1234 -g \u003ccommand\u003e -- sleep 30 # 解析数据 perf script -i perf.data \u0026\u003e perf.unfold # 生成火焰图 # 克隆仓库 git clone https://github.com/brendangregg/FlameGraph.git cd FlameGraph # 对perf.unfold文件进行符号折叠 ./stackcollapse-perf.pl perf.unfold \u003e perf.folded # 生成火焰图（svg图） ./flamegraph.pl perf.folded \u003e perf.svg ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:2:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"IP 路由相关命令总结 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:0:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"一，路由策略（使用ip rule命令操作路由策略数据库） 基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。 ip rule命令： Usage: ip rule { add | del } SELECTOR ACTION ip rule { flush | save | restore } ip rule [ list [ SELECTOR ]] SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK[/MASK] ] [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ] [ uidrange NUMBER-NUMBER ] [ ipproto PROTOCOL ] [ sport [ NUMBER | NUMBER-NUMBER ] [ dport [ NUMBER | NUMBER-NUMBER ] ] ACTION := [ table TABLE_ID ] [ protocol PROTO ] [ nat ADDRESS ] [ realms [SRCREALM/]DSTREALM ] [ goto NUMBER ] SUPPRESSOR SUPPRESSOR := [ suppress_prefixlength NUMBER ] [ suppress_ifgroup DEVGROUP ] TABLE_ID := [ local | main | default | NUMBER ] #例子1：通过路由表 table 1 路由来自源地址为192.203.80/24的数据包 ip rule add from 192.203.80/24 table 1 #例子2：把源地址为192.168.1.10的数据报的源地址转换为192.168.2.20，并通过表1进行路由 ip rule add from 193.168.1.10 nat 192.168.2.20 table 1 #实例3：让eht0流量使用table 1 ip rule add dev eth0 table1 在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则： 0：匹配任何条件，查询路由表local(ID 255)，该表local是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0非常特殊，不能被删除或者覆盖。 32766：匹配任何条件，查询路由表main(ID 254)，该表是一个通常的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。 32767：匹配任何条件，查询路由表default(ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。 **注：**不要混淆路由表和策略：规则指向路由表，多个规则可以引用一个路由表，而且某些路由表可以策略指向它。如果系统管理员删除了指向某个路由表的所有规则，这个表没有用了，但是仍然存在，直到里面的所有路由都被删除，它才会消失。 linux 系统中，可以自定义从 1－252个路由表，其中，linux系统维护了4个路由表： 0#表： 系统保留表 253#表： defulte table 没特别指定的默认路由都放在改表 254#表： main table 没指明路由表的所有路由放在该表 255#表： locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改 路由表的查看可有以下二种方法： ip route show table table_number ip route show table table_name 路由表序号和表名的对应关系在 /etc/iproute2/rt_tables文件中，可以手动编辑，路由表添加完毕及时生效，实例如下： #实例1：在一号表中添加默认路由为192.168.1.1 ip route add default via 192.168.1.1 table 1 #实例2：在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2 ip route add 192.168.0.0/24 via 192.168.1.2 table 1 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"二，路由表（使用ip route命令操作静态路由表） 所谓路由表，指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据–路由表，供路由选择时使用，表中包含的信息决定了数据转发的策略。 以一例子来说明：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。 首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关：ip route add default gw 20.0.0.1 之后通过 ip route 添加一个路由表：ip route add table 3 via 10.0.0.1 dev ethX (ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号) 之后添加 ip rule 规则：ip rule add fwmark 3 table 3 （fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表） 之后使用 iptables 给相应的数据打上标记：iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK –set-mark 3 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"Docker 基本命令 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:0:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"1. 使用镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 \u003c域名/IP\u003e[:端口号]。默认地址是 Docker Hub(docker.io)。 仓库名：如之前所说，这里的仓库名是两段式名称，即 \u003c用户名\u003e/\u003c软件名\u003e。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"2. 操作容器 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 -d: 让容器在后台运行 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash, 也可以使用dash或者fish。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"3. 数据管理 创建一个数据卷 docker volume create my-vol 删除数据卷 docker volume rm my-vol 无主的数据卷可能会占据很多空间，要清理请使用以下命令: docker volume prune 查看所有数据卷 docker volume ls 在主机里使用以下命令可以查看指定 数据卷 的信息 docker volume inspect my-vol 查看容器详细信息 docker inspect container_id 挂载主机目录 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\ nginx:alpine 注意: 本地目录的路径必须是绝对路径,使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ nginx:alpine ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["linux","docker"],"content":"Docker 基石-NetworkNamespace ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:0:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"1. veth-pair 是什么 veth-pair 是一对虚拟网卡，通过 veth-pair 可以将两个网络命名空间连接起来，从而实现两个网络命名空间之间的通信。和 tap/tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着 全程只使用 ip 命令进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:1:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2. 使用 veth-pair 和 netns 进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.1 创建两个网络命名空间 ip netns add ns1 ip netns add ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:1","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.2 创建 veth-pair ip link add veth1 type veth peer name veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:2","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.3 将 veth1 移动到 ns1 中 ip link set veth1 netns ns1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:3","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.4 将 veth2 移动到 ns2 中 ip link set veth2 netns ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:4","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.5 启动 veth1 ip netns exec ns1 ip link set dev veth1 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:5","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.6 启动 veth2 ip netns exec ns2 ip link set dev veth2 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:6","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.7 设置 veth1 的 IP 地址 ip netns exec ns1 ip addr add 192.168.1.2/24 dev veth1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:7","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.8 设置 veth2 的 IP 地址 ip netns exec ns2 ip addr add 192.168.1.3/24 dev veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:8","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.9 测试 ip netns exec ns1 ping 192.168.1.3 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:9","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["pytorch"],"content":"torch.fx模块的使用 ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"torch.fx主要有3个组件： 符号追踪器（symbolic tracer) 中间表示（intermediate representation) Python代码生成（Python code generation) import torch # Simple module for demonstration class MyModule(torch.nn.Module): def __init__(self): super().__init__() self.param = torch.nn.Parameter(torch.rand(3, 4)) self.linear = torch.nn.Linear(4, 5) def forward(self, x): return self.linear(x + self.param).clamp(min=0.0, max=1.0) module = MyModule() from torch.fx import symbolic_trace # 符号追踪这个模块 # Symbolic tracing frontend - captures the semantics of the module symbolic_traced : torch.fx.GraphModule = symbolic_trace(module) # 中间表示 # High-level intermediate representation (IR) - Graph representation print(symbolic_traced.graph) \"\"\" graph(): %x : [#users=1] = placeholder[target=x] %param : [#users=1] = get_attr[target=param] %add : [#users=1] = call_function[target=operator.add](args = (%x, %param), kwargs = {}) %linear : [#users=1] = call_module[target=linear](args = (%add,), kwargs = {}) %clamp : [#users=1] = call_method[target=clamp](args = (%linear,), kwargs = {min: 0.0, max: 1.0}) return clamp \"\"\" # 生成代码 # Code generation - valid Python code print(symbolic_traced.code) \"\"\" def forward(self, x): param = self.param add = x + param; x = param = None linear = self.linear(add); add = None clamp = linear.clamp(min = 0.0, max = 1.0); linear = None return clamp \"\"\" ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"使用场景 Replace one op Conv/Batch Norm fusion replace_pattern: Basic usage Quantization Invert Transformation 融合例子: # Works for length 2 patterns with 2 modules def matches_module_pattern(pattern: Iterable[Type], node: fx.Node, modules: Dict[str, Any]): if len(node.args) == 0: return False nodes: Tuple[Any, fx.Node] = (node.args[0], node) for expected_type, current_node in zip(pattern, nodes): if not isinstance(current_node, fx.Node): return False if current_node.op != 'call_module': return False if not isinstance(current_node.target, str): return False if current_node.target not in modules: return False if type(modules[current_node.target]) is not expected_type: return False return True def replace_node_module(node: fx.Node, modules: Dict[str, Any], new_module: torch.nn.Module): assert(isinstance(node.target, str)) parent_name, name = _parent_name(node.target) modules[node.target] = new_module setattr(modules[parent_name], name, new_module) def fuse(model: torch.nn.Module, inplace=False) -\u003e torch.nn.Module: \"\"\" Fuses convolution/BN layers for inference purposes. Will deepcopy your model by default, but can modify the model inplace as well. \"\"\" patterns = [(nn.Conv1d, nn.BatchNorm1d), (nn.Conv2d, nn.BatchNorm2d), (nn.Conv3d, nn.BatchNorm3d)] if not inplace: model = copy.deepcopy(model) fx_model = fx.symbolic_trace(model) modules = dict(fx_model.named_modules()) new_graph = copy.deepcopy(fx_model.graph) for pattern in patterns: for node in new_graph.nodes: # 找到目标Node：args是Conv，target是BN if matches_module_pattern(pattern, node, modules): if len(node.args[0].users) \u003e 1: # Output of conv is used by other nodes continue conv = modules[node.args[0].target] bn = modules[node.target] # 融合BN和Conv fused_conv = fuse_conv_bn_eval(conv, bn) # 替换Node的module，其实就是将融合后的module替换Conv Node的target，背后是模块替换 replace_node_module(node.args[0], modules, fused_conv) # 将所有用到BN Node的替换为Conv Node（已经融合后的Conv） node.replace_all_uses_with(node.args[0]) # 删除BN Node new_graph.erase_node(node) return fx.GraphModule(fx_model, new_graph) from torch.fx.experimental.optimization import fuse from torchvision.models import resnet18 model = resnet18() model.eval() # 必须在eval模型下fuse ''' (layer4): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' fused_model = fuse(model) ''' (layer4): Module( (0): Module( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (downsample): Module( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2)) ) ) (1): Module( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"参考链接: PyTorch新技能解锁：torch.fx - 知乎 (zhihu.com) ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"matplotlib的简单使用 matplotlib结构 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:0:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1. fig,ax,plt 三者的基本概念 fig Figure，就是图的外框，也叫画布，可以包括1-无穷个内框Axes ax Axes，就是图的内框(可以将画布分为多个绘图区域)，里面可以画各种图，最常见的就是二维的统计图或者折线图，也可以画三维图xyz和极坐标图theta-r Axis，就是坐标轴 plt Pyplot为底层面向对象的绘图库提供状态机接口。状态机隐式自动创建图形和轴，以实现所需的绘图。 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:1:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.常用函数说明 matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布 import matplotlib.pyplot as plt plt.plot([1,2,3]) #现在创建一个子图，它表示一个有2行1列的网格的顶部图。 #因为这个子图将与第一个重叠，所以之前创建的图将被删除 plt.subplot(211) plt.plot(range(12)) #创建带有黄色背景的第二个子图 plt.subplot(212, facecolor='y') plt.plot(range(12)) Matplotlib 提供了matplotlib.figure图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。如下所示： from matplotlib import pyplot as plt import numpy as np import math x = np.arange(0, math.pi*2, 0.05) y = np.sin(x) fig = plt.figure() # add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。 ax = fig.add_axes([0,0,1,1]) ax.plot(x,y) ax.set_title(\"sine wave\") ax.set_xlabel('angle') ax.set_ylabel('sine') plt.show() matplotlib.pyplot模块提供了一个 subplots() 函数，它的使用方法和 subplot() 函数类似。其不同之处在于，subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。 import matplotlib.pyplot as plt # 将画布分为2*2的绘图区域 fig,a = plt.subplots(2,2) import numpy as np x = np.arange(1,5) #绘制平方函数 a[0][0].plot(x,x*x) a[0][0].set_title('square') #绘制平方根图像 a[0][1].plot(x,np.sqrt(x)) a[0][1].set_title('square root') #绘制指数函数 a[1][0].plot(x,np.exp(x)) a[1][0].set_title('exp') #绘制对数函数 a[1][1].plot(x,np.log10(x)) a[1][1].set_title('log') plt.show() ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:2:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["c/cpp"],"content":"一、string.h中字符串处理函数 在头文件\u003cstring.h\u003e中定义了两组字符串函数。第一组函数的名字以str开头；第二组函数的名字以mem开头。 只有函数memmove对重叠对象间的拷贝进行了定义，而其他函数都未定义。比较类函数将其变量视为unsigned char类型的数组。 1 strcpy #include \u003cstring.h\u003e char *strcpy(char *str1, const char *str2); 把字符串str2(包括’\\0’)拷贝到字符串str1当中，并返回str1。 2 strncpy #include \u003cstring.h\u003e char *strncpy(char *str1, const char *str2, size_t count); 把字符串str2中最多count个字符拷贝到字符串str1中，并返回str1。如果str2中少于count个字符，那么就用’\\0’来填充，直到满足count个字符为止。 3 strcat #include \u003cstring.h\u003e char *strcat(char *str1, const char *str2); 把str2(包括’\\0’)拷贝到str1的尾部(连接)，并返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 4 strncat #include \u003cstring.h\u003e char *strncat(char *str1, const char *str2, size_t count); 把str2中最多count个字符连接到str1的尾部，并以’\\0’终止str1，返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 注意，最大拷贝字符数是count+1。 5 strcmp #include \u003cstring.h\u003e int strcmp(const char *str1, const char *str2); 按字典顺序比较两个字符串，返回整数值的意义如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 6 strncmp #include \u003cstring.h\u003e int strncmp(const char *str1, const char *str2, size_t count); 同strcmp，除了最多比较count个字符。根据比较结果返回的整数值如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 7 strchr #include \u003cstring.h\u003e char *strchr(const char *str, int ch); 返回指向字符串str中字符ch第一次出现的位置的指针，如果str中不包含ch，则返回NULL。 8 strrchr #include \u003cstring.h\u003e char *strrchr(const char *str, int ch); 返回指向字符串str中字符ch最后一次出现的位置的指针，如果str中不包含ch，则返回NULL。 9 strspn #include \u003cstring.h\u003e size_t strspn(const char *str1, const char *str2); 返回字符串str1中由字符串str2中字符构成的第一个子串的长度。 10 strcspn #include \u003cstring.h\u003e size_t strcspn(const char *str1, const char *str2); 返回字符串str1中由不在字符串str2中字符构成的第一个子串的长度。 11 strpbrk #include \u003cstring.h\u003e char *strpbrk(const char *str1, const char *str2); 返回指向字符串str2中的任意字符第一次出现在字符串str1中的位置的指针；如果str1中没有与str2相同的字符，那么返回NULL。 12 strstr #include \u003cstring.h\u003e char *strstr(const char *str1, const char *str2); 返回指向字符串str2第一次出现在字符串str1中的位置的指针；如果str1中不包含str2，则返回NULL。 13 strlen #include \u003cstring.h\u003e size_t strlen(const char *str); 返回字符串str的长度，’\\0’不算在内。 14 strerror #include \u003cstring.h\u003e char *strerror(int errnum); 返回指向与错误序号errnum对应的错误信息字符串的指针(错误信息的具体内容依赖于实现)。 15 strtok #include \u003cstring.h\u003e char *strtok(char *str1, const char *str2); 在str1中搜索由str2中的分界符界定的单词。 对strtok()的一系列调用将把字符串str1分成许多单词，这些单词以str2中的字符为分界符。第一次调用时str1非空，它搜索str1，找出由非str2中的字符组成的第一个单词，将str1中的下一个字符替换为’\\0’，并返回指向单词的指针。随后的每次strtok()调用(参数str1用NULL代替)，均从前一次结束的位置之后开始，返回下一个由非str2中的字符组成的单词。当str1中没有这样的单词时返回NULL。每次调用时字符串str2可以不同。 如： char *p; p = strtok(\"The summer soldier,the sunshine patriot\", \" \"); printf(\"%s\", p); do { p = strtok(\"\\0\", \", \"); /* 此处str2是逗号和空格 */ if (p) printf(\"|%s\", p); } while (p); 显示结果是：The | summer | soldier | the | sunshine | patriot 16 memcpy #include \u003cstring.h\u003e void *memcpy(void *to, const void *from, size_t count); 把from中的count个字符拷贝到to中。并返回to。 17 memmove #include \u003cstring.h\u003e void *memmove(void *to, const void *from, size_t count); 功能与memcpy类似，不同之处在于，当发生对象重叠时，函数仍能正确执行。 18 memcmp #include \u003cstring.h\u003e int memcmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2的前count个字符，返回值与strcmp的返回值相同。 19 memchr #include \u003cstring.h\u003e void *memchr(const void *buffer, int ch, size_t count); 返回指向ch在buffer中第一次出现的位置指针，如果在buffer的前count个字符当中找不到匹配，则返回NULL。 20 memset #include \u003cstring.h\u003e void *memset(void *buf, int ch, size_t count); 把buf中的前count个字符替换为ch，并返回buf ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"example #include \"malloc.h\" #include \"stdint.h\" #include \"stdio.h\" #include \"stdlib.h\" #include \"string.h\" #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { // malloc and memset and strlen usage char *s = (char *)malloc(sizeof(char) * 10); printf(\"origin strlen(s): %llu\\n\", strlen(s)); memset(s, 'i', 12); printf(\"after memset, strlen(s): %llu\\n\", strlen(s)); int *i = (int *)malloc(sizeof(int) * 10); printf(\"sizeof(i): %llu\\n\", sizeof(i)); // strcpy usage char *s1 = (char *)malloc(sizeof(char) * 10); char s2[] = {\"hello\"}; printf(\"strlen(s1): %llu\\n\", strlen(s1)); printf(\"sizeof(s1): %llu\\n\", sizeof(s1)); printf(\"strlen(s2): %llu\\n\", strlen(s2)); printf(\"sizeof(s2): %llu\\n\", sizeof(s2)); strcpy_s(s1, strlen(s2) + 1, s2); // strncpy_s(s1, strlen(s2)+1, s2, 3); printf(\"s1=%s\\n\", s1); printf(\"*****************************\\n\"); char s3[] = {\"world\"}; // strstr return pointer char *p = strstr(s3, \"ld\"); printf(\"p=%s\\n\", p); // calculate the offset printf(\"%lld\\n\", p-s3); p = strchr(s3, 'o'); printf(\"strchr p=%s\\n\", p); printf(\"strchr offset:%lld\\n\", p-s3); p = strrchr(s3, 'l'); printf(\"strrchr p=%s\\n\", p); printf(\"strrchr offset:%lld\\n\", p-s3); p = strtok(s3, \"or\"); while (p) { printf(\"strtok p=%s\\n\", p); p = strtok(NULL, \"or\"); } printf(\"after strtok, s3=%s\\n\", s3); int a = strcmp(s3, \"world\"); printf(\"strcmp a=%d\\n\", a); a = strncmp(s3, \"world\", 1); printf(\"strncmp a=%d\\n\", a); char s4[] = {\"hello\"}; memmove(s4+1, s4, 1); printf(\"memmove s4=%s\\n\", s4); memcpy(s4, \"hello\", 5); printf(\"memccpy s4=%s\\n\", s4); return 0; } // output: // origin strlen(s): 6 // after memset, strlen(s): 14 // sizeof(i): 8 // strlen(s1): 6 // sizeof(s1): 8 // strlen(s2): 5 // sizeof(s2): 6 // s1=hello // ***************************** // p=ld // 3 // strchr p=orld // strchr offset:1 // strrchr p=ld // strrchr offset:3 // strtok p=w // strtok p=ld // after strtok, s3=w // strcmp a=-1 // strncmp a=0 // memmove s4=hhllo // memccpy s4=hello 二、stdlib.h中字符串与数字相互转换处理函数 1. 数字转化为字符串: ● itoa()：将整型值转换为字符串。 ● ltoa()：将长整型值转换为字符串。 ● ultoa()：将无符号长整型值转换为字符串。 ● gcvt()：将浮点型数转换为字符串，取四舍五入。 ● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。 ● fcvt()：指定位数为转换精度，其余同ecvt()。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int = 435; double num_double = 435.10f; char str_int[30]; char str_double[30]; itoa(num_int, str_int, 10); //把整数num_int转成字符串str_int gcvt(num_double, 8, str_double); //把浮点数num_double转成字符串str_double printf(\"str_int: %s\\n\", str_int); printf(\"str_double: %s\\n\", str_double); return 0; } 程序输出结果： str_int: 435 str_double: 435.10001 代码第11行中的参数10表示按十进制类型进行转换，转换后的结果是“435”，如果按二进制类型进行转换，则结果为“1101110011”。 代码第12行中的参数8表示精确位数，这里得到的结果是“435.10001”。 2. 字符串转化为数字 atof()：将字符串转换为双精度浮点型值。 atoi()：将字符串转换为整型值。 atol()：将字符串转换为长整型值。 strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。 strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。 strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int; double num_double; char str_int[30] = \"435\"; //将要被转换为整型的字符串 char str_double[30] = \"436.55\"; //将要被转换为浮点型的字符串 num_int = atoi(str_int); //转换为整型值 num_double = atof(str_double); //转换为浮点型值 printf(\"num_int: %d\\n\", num_int); printf(\"num_double: %lf\\n\", num_double); return 0; } // 输出结果： // num_int: 435 // num_double: 436.550000 ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"进制互转 // int to binary char tmp[10] = {}; char *conv = itoa(5, tmp, 2); printf(\"itoa to 2: conv=%s\\n\", conv); // int to hex conv = itoa(17, tmp, 16); printf(\"itoa to 16: conv=0x%s\\n\", conv); // hex to 10 int hex = strtol(\"0x11\", NULL, 16); printf(\"strtol: hex=%d\\n\", hex); // binary to 10 int bin = strtol(\"101\", NULL, 2); printf(\"strtol: bin=%d\\n\", bin); // output // itoa to 2: conv=101 // itoa to 16: conv=0x11 // strtol: hex=17 // strtol: bin=5? ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["python"],"content":"介绍 异步IO：就是发起一个IO操作（如：网络请求，文件读写等），这些操作一般是比较耗时的，不用等待它结束，可以继续做其他事情，结束时会发来通知。 协程：又称为微线程，在一个线程中执行，执行函数时可以随时中断，由程序（用户）自身控制，执行效率极高，与多线程比较，没有切换线程的开销和多线程锁机制。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:0:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio中几个重要概念 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1.事件循环 事件循环是每个 asyncio 应用的核心，管理所有的事件，在整个程序运行过程中不断循环执行并追踪事件发生的顺序将它们放在队列中，空闲时调用相应的事件处理者来处理这些事件。 创建事件循环 loop = asyncio.get_event_loop() 获取当前事件循环。 如果当前 OS 线程没有设置当前事件循环并且 set_event_loop() 还没有被调用，asyncio 将创建一个新的事件循环并将其设置为当前循环。 另起一个线程创建事件循环 from threading import Thread import asyncio def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() new_loop = asyncio.new_event_loop() loop_thread = Thread(target=start_thread_loop, args=(new_loop,)) loop_thread.setDaemon(True) # 守护线程 loop_thread.start() ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.Future Future对象表示尚未完成的计算，还未完成的结果，它和task上没有本质上的区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"3.Task 是Future的子类，作用是在运行某个任务的同时可以并发的运行多个任务。 asyncio.Task用于实现协作式多任务的库，且Task对象不能用户手动实例化，通过下面2个函数创建： loop.create_task() 或 asyncio.ensure_future() loop.create_task() ,要在定义loop对象之后，调用将方法对象转化成了task的对象 asyncio.ensure_future() 直接调用asyncio 的ensure_future() 方法，返回的也是task 对象（我们还没有声明 loop 也可以提前定义好 task 对象） ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"4.async/await 关键字 asyncio实现了TCP、UDP、SSL等协议，async定义一个协程，await用于挂起阻塞的异步调用接口。 对于异步io你需要知道的重点，要注意的是，await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。而且await后面的对象需要是一个Awaitable，或者实现了相关的协议。 注意 1. 所有需要异步执行的函数，都需要asyncio中的轮询器去轮询执行，如果函数阻塞，轮询器就会去执行下一个函数。所以所有需要异步执行的函数都需要加入到这个轮询器中。若在协程中需要有延时操作，应该使用 await asyncio.sleep()，而不是使用time.sleep()，因为使用time.sleep()后会释放GIL，阻塞整个主线程，从而阻塞整个事件循环。 创建一个协程 使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行 耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:4","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"简单例子 import asyncio from asyncio import tasks from asyncore import loop async def main(): await asyncio.sleep(2) print('this is main running') async def add_log(): await asyncio.sleep(1) print('add log before running') async def run_background(): await asyncio.sleep(3) print('running task in background') async def parameter_verification(): await asyncio.sleep(1) print('parameter verification before running') if __name__ == '__main__': # running async function method: # first method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) # the sequence of the tasks is not the same as the sequence of the function calling, and the same as define sequence result = asyncio.run(tasks) print(result) print(f'{\"*\" * 20}{\"another method\"}{\"*\" * 20}') # second method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) loop = asyncio.get_event_loop() result = loop.run_until_complete(tasks) print(result) 首先我们引入了 asyncio 这个包，这样我们才可以使用 async 和 await，然后我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。 随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。 可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:2:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"进阶例子 多个任务，定义一个task列表，使用asyncio.gather(*tasks) 或 asyncio.wait(tasks) 接收 import asyncio import time now = lambda: time.time() \"\"\" asyncio.gather主要集中在收集结果上。它等待一堆task并按给定的顺序返回结果。 asyncio.wait等待task。而不是直接给你结果，它提供完成和待处理的任务。你必须手工收集结果。 asyncio.wait(tasks) ps:asyncio.wait([1,2,3]) 也可以使用 asyncio.gather(*tasks) ps: asyncio.gather(1,2,3),前者接受一个task列表，后者接收一堆task。 \"\"\" # 定义一个异步任务 async def do_some_work(x): print(\"waiting:\", x) # 模拟io阻塞 await asyncio.sleep(x) return \"Done after {}s\".format(x) async def main(loop): \"\"\" :param loop: loop.create_task（需要传进loop参数） :return: None \"\"\" coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(4) # asyncio.ensure_future tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] # loop.create_task（需要传进loop参数） # tasks = [ # loop.create_task(coroutine1), # loop.create_task(coroutine2), # loop.create_task(coroutine3) # ] # 返回 完成的 task object dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) # 返回 task 方法的 返回值 # results = await asyncio.gather(*tasks) # for result in results: # print(\"Task ret:\",result) start = now() loop = asyncio.get_event_loop() loop.run_until_complete(main(loop)) print(\"Time:\", now() - start) gather和wait 的区别 把多个协程注册进一个事件循环中的两种方法 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:3:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"使用方式区别 使用asyncio.wait() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 使用asyncio.gather() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) # *接收args参数 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:4:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"接收参数区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.wait 参数必须是list对象 ，list 对象存放多个 task object 用asyncio.ensure_future转为task对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 不转为task对象 loop = asyncio.get_event_loop() tasks=[ coroutine1, coroutine2, coroutine3 ] loop.run_until_complete(asyncio.wait(tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.gather 必须用 * 来接收 list 对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"返回结果区别 asyncio.wait asyncio.wait返回dones和pendings dones：表示已经完成的任务 pendings：表示未完成的任务 我们需要手动去获取结果 dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) asyncio.gather 它的返回值就是 return的结果 ，不用再task.result() 来获取 # 返回 task 方法的 返回值 results = await asyncio.gather(*tasks) for result in results: print(\"Task ret:\",result) 另 asyncio.wait 带有控制功能 【控制运行任务数】：运行第一个任务就返回 FIRST_COMPLETED ：第一个任务完全返回 FIRST_EXCEPTION：产生第一个异常返回 ALL_COMPLETED：所有任务完成返回 （默认选项） import asyncio import random async def coro(tag): print(\"\u003e\", tag) await asyncio.sleep(random.uniform(0.5, 5)) print(\"\u003c\", tag) return tag loop = asyncio.get_event_loop() tasks = [coro(i) for i in range(1, 11)] # 第一次wait 完成情况 print(\"Get first result:\") finished, unfinished = loop.run_until_complete( asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)) # 第一个任务完全返回 for task in finished: print(task.result()) print(\"unfinished:\", len(unfinished)) # 继续第一次未完成任务 print(\"Get more results in 2 seconds:\") finished2, unfinished2 = loop.run_until_complete( asyncio.wait(unfinished, timeout=2)) # 超时2s 返回 for task in finished2: print(task.result()) print(\"unfinished2:\", len(unfinished2)) # 继续第2次未完成任务 print(\"Get all other results:\") finished3, unfinished3 = loop.run_until_complete(asyncio.wait(unfinished2)) # ALL_COMPLETED：所有任务完成返回 （默认项） for task in finished3: print(task.result()) loop.close() 动态添加协程 很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block 相关函数介绍： loop.call_soon_threadsafe() ：与 call_soon()类似，等待此函数返回后马上调用回调函数，返回值是一个 asyncio.Handle 对象，此对象内只有一个方法为 cancel()方法，用来取消回调函数。 loop.call_soon() ： 与call_soon_threadsafe()类似，call_soon_threadsafe() 是线程安全的 loop.call_later()：延迟多少秒后执行回调函数 loop.call_at()：在指定时间执行回调函数，这里的时间统一使用 loop.time() 来替代 time.sleep() asyncio.run_coroutine_threadsafe()： 动态的加入协程，参数为一个回调函数和一个loop对象，返回值为future对象，通过future.result()获取回调函数返回值 动态添加协程同步方式 通过调用 call_soon_threadsafe()函数，传入一个回调函数callback和一个位置参数 注意：同步方式，回调函数 more_work()为普通函数 import asyncio from threading import Thread import time now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() def more_work(x): print('More work {}'.format(x)) time.sleep(x) print('Finished more work {}'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) new_loop.call_soon_threadsafe(more_work, 6) new_loop.call_soon_threadsafe(more_work, 3) print('here') 启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3 异步方式 import asyncio import time from threading import Thread now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() async def do_some_work(x): print('Waiting {}'.format(x)) await asyncio.sleep(x) print('Done after {}s'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop) asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop) 上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。 协程的停止 future对象有几个状态： Pending Running Done Cacelled 创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task import asyncio import time now = lambda: time.time() async def do_some_work(x): print(\"Waiting:\", x) await asyncio.sleep(x) return \"Done after {}s\".format(x) coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(2) tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3), ] start = now() loop = asyncio.get_event_loop() try: loop.run_until_complete(asyncio.wait(tasks)) except KeyboardInterrupt as e: print(asyncio.Task.all_tasks()) for ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["draft"],"content":"SelfAttention和MultiHeadAttention流程简述 ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:0:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["draft"],"content":"1. SelfAttention 1.1 对于每一个输入$I$,初始化3个权重矩阵$W_q,W_k,W_v$. 1.2 输入$I$分别与3个权重矩阵相乘得到$Q,K,V$ 1.3 将$Q$与$K$相乘(矩阵乘法)得到$A$(attention score) 1.4 $A$经过softmax激活得到$A'$ 1.5 将$A’$与$V$相乘得到B 代码示例: In [16]: i = torch.randn(3,4) In [17]: w_query = torch.randn(4, 2) In [18]: w_key = torch.randn(4, 2) In [19]: w_value = torch.randn(4, 2) In [20]: i Out[20]: tensor([[ 0.4313, 1.3749, -0.2489, 1.3275], [-0.6467, 1.6335, 2.8923, 0.9124], [ 0.2326, -0.2314, 0.3554, 0.0892]]) In [21]: w_query Out[21]: tensor([[ 0.3673, -0.8505], [-0.3559, -0.3708], [-1.2093, 0.6634], [ 0.4042, 0.8015]]) In [22]: w_key Out[22]: tensor([[-1.1617, 0.4023], [-0.1249, -0.1605], [-0.8427, 1.1002], [-1.1320, 0.4611]]) In [23]: w_value Out[23]: tensor([[-0.7675, -0.3179], [-1.1910, -0.6937], [-1.4809, -1.5502], [-0.7373, 1.0511]]) In [24]: querys = i @ w_query In [25]: keys = i @ w_key In [26]: values = i @ w_value In [27]: querys Out[27]: tensor([[ 0.5066, 0.0223], [-3.9478, 2.5946], [-0.2259, 0.1952]]) In [28]: keys Out[28]: tensor([[-1.9656, 0.2911], [-2.9229, 3.0806], [-0.6418, 0.5629]]) In [29]: values Out[29]: tensor([[-2.5787, 0.6903], [-6.4049, -4.4522], [-0.4950, -0.3706]]) In [30]: att_scores = querys @ keys.T In [31]: att_scores Out[31]: tensor([[-0.9893, -1.4121, -0.3126], [ 8.5152, 19.5319, 3.9940], [ 0.5009, 1.2617, 0.2549]]) In [32]: att_scores_softmax = torch.nn.functional.softmax(att_scores, dim=-1) In [33]: att_scores_softmax Out[33]: tensor([[2.7604e-01, 1.8087e-01, 5.4310e-01], [1.6426e-05, 9.9998e-01, 1.7865e-07], [2.5498e-01, 5.4565e-01, 1.9937e-01]]) In [34]: outputs = att_scores_softmax @ values In [35]: outputs Out[35]: tensor([[-2.1390, -0.8160], [-6.4048, -4.4521], [-4.2510, -2.3272]]) In [36]: outputs.shape Out[36]: torch.Size([3, 2]) ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:1:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["DeepLearning"],"content":"什么是交叉熵 交叉熵是一个在ML领域经常会被提到的名词。在这篇文章里将对这个概念进行详细的分析。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:0:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"1.什么是信息量？ 假设$x$是一个离散型随机变量，其取值集合为$X$，概率分布函数为$p(x)=Pr(X=x), x \\in X $，我们定义事件的信息量为：$X=x_0$，可以理解为，一个事件发生的概率越大，则它所携带的信息量就越小，而当$p(x_0)=1$时，熵将等于0，也就是说该事件的发生不会导致任何信息量的增加。举个例子，小明平时不爱学习，考试经常不及格，而小王是个勤奋学习的好学生，经常得满分，所以我们可以做如下假设： 事件A：小明考试及格，对应的概率$P(x_A)=0.1$，信息量为$I(x_A)=−log(0.1)=3.3219$ 事件B：小王考试及格，对应的概率$P(x_B)=0.999$，信息量为$I(x_B)=−log(0.999)=0.0014$ 可以看出，结果非常符合直观：小明及格的可能性很低(十次考试只有一次及格)，因此如果某次考试及格了（大家都会说：XXX竟然及格了！），必然会引入较大的信息量，对应的$I$值也较高。而对于小王而言，考试及格是大概率事件，在事件B发生前，大家普遍认为事件B的发生几乎是确定的，因此当某次考试小王及格这个事件发生时并不会引入太多的信息量，相应的$I$值也非常的低。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:1:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"2.什么是熵？ 那么什么又是熵呢？还是通过上边的例子来说明，假设小明的考试结果是一个0-1分布$X_A$只有两个取值{0：不及格，1：及格}，在某次考试结果公布前，小明的考试结果有多大的不确定度呢？你肯定会说：十有八九不及格！因为根据先验知识，小明及格的概率仅有0.1,90%的可能都是不及格的。怎么来度量这个不确定度？求期望！不错，我们对所有可能结果带来的额外信息量求取均值（期望），其结果不就能够衡量出小明考试成绩的不确定度了吗。 即： $H_A(x) = -[p(x_A)log(p(X_A))] + (1-p(x_A))log(1-p(x_A))]=0.4690$ 对应小王的熵： $H_B(x)=−[p(x_B)log(p(x_B))+(1−p(x_B))log(1−p(x_B))]=0.0114$ 虽然小明考试结果的不确定性较低，毕竟十次有9次都不及格，但是也比不上小王（1000次考试只有一次才可能不及格，结果相当的确定） 我们再假设一个成绩相对普通的学生小东，他及格的概率是$P(x_C)=0.5$,即及格与否的概率是一样的，对应的熵： $H_C(x)=−[p(x_C)log(p(x_C))+(1−p(x_C))log(1−p(x_C))]=1$ 其熵为1，他的不确定性比前边两位同学要高很多，在成绩公布之前，很难准确猜测出他的考试结果。 可以看出，熵其实是信息量的期望值，它是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。 对于一个随机变量X而言，它的所有可能取值的信息量的期望$（E[I(x)]$就称为熵。 $X$的熵定义为： $H(X)=Ep \\space log \\frac 1 {p(x)}=−\\sum \\limits_{x \\in X}p(x)logp(x)$ 如果$p(x)$是连续型随机变量的pdf，则熵定义为： $H(X)=−∫_{x∈X}p(x)logp(x)dx$ 为了保证有效性，这里约定当$p(x)→0$时,有$p(x)logp(x)→0$ 当X为0-1分布时，熵与概率p的关系如下图： 可以看出，当两种取值的可能性相等时，不确定度最大（此时没有任何先验知识），这个结论可以推广到多种取值的情况。在图中也可以看出，当p=0或1时，熵为0，即此时X完全确定。 熵的单位随着公式中$log$运算的底数而变化，当底数为2时，单位为“比特”(bit)，底数为e时，单位为“奈特”。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:2:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"3.什么是相对熵？ 相对熵(relative entropy)又称为KL散度（Kullback-Leibler divergence），KL距离，是两个随机分布间距离的度量。记为$D_{KL}(p||q)$。它度量当真实分布为p时，假设分布$q$的无效性。 $$\\begin{split} \\ D_{KL}(p||q) \u0026= Ep[log \\frac {p(x)} {q(x)}] \\ \u0026=\\sum _{x∈X} p(x) log \\frac {p(x)} {q(x)} \\ \u0026=\\sum {x∈X}[p(x)logp(x)−p(x)logq(x)] \\ \u0026=\\sum{x∈X}p(x)logp(x)−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−H(p)−\\sum _{x∈X} p(x)logq(x) \\ \u0026=−H(p)+Ep[−logq(x)] \\ \u0026=Hp(q)−H(p)\\end{split}$$ 并且为了保证连续性，做如下约定： $$0log \\frac 0 0=0，0log \\frac 0 q=0，plog \\frac p 0=∞$$ 显然，当$p=q$时,两者之间的相对熵$D_{KL}(p||q)=0$ 上式最后的$H_p(q)$)表示在p分布下，使用q进行编码需要的bit数，而$H(p)$表示对真实分布p所需要的最小编码bit数。基于此，相对熵的意义就很明确了：$D_{KL}(p||q)$)表示在实分布为$p$的前提下，使用q分布进行编码相对于使用真实分布p进行编码（即最优编码）所多出来的bit数。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:3:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"4. 什么是交叉熵？ 交叉熵容易跟相对熵搞混，二者联系紧密，但又有所区别。假设有两个分布$p，q$则它们在给定样本集上的交叉熵定义如下： $$ CEH(p,q)=Ep[−logq]=−∑\\limits_{x∈X}p(x)logq(x)=H(p)+D_{KL}(p||q) $$ 可以看出，交叉熵与上一节定义的相对熵仅相差了$H(p)$,当$p$已知时，可以把$H(p)$看做一个常数，此时交叉熵与KL距离在行为上是等价的，都反映了分布$p，q$的相似程度。最小化交叉熵等于最小化KL距离。它们都将在$p=q$时取得最小值$H(p)$（p=q时KL距离为0），因此有的工程文献中将最小化KL距离的方法称为Principle of Minimum Cross-Entropy (MCE)或Minxent方法。 特别的，在logistic regression中， p:真实样本分布，服从参数为p的0-1分布，即$X∼B(1,p)$ q:待估计的模型，服从参数为q的0-1分布，即$X∼B(1,q)$ 两者的交叉熵为： $$\\begin{split} CEH(p,q) \u0026=−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−[P_p(x=1)logP_q(x=1)+P_p(x=0)logP_q(x=0)] \\ \u0026=−[plogq+(1−p)log(1−q)] \\ \u0026=−[ylogh_θ(x)+(1−y)log(1−h_θ(x))] \\ \\end{split}$$ 对所有训练样本取均值得： $$−\\frac 1 m \\sum \\limits^{m} \\limits _{i=1m} [y(i)logh_θ(x^{(i)})+(1−y^{(i)})log(1−h_θ(x^{(i)}))]$$ 这个结果与通过最大似然估计方法求出来的结果一致。 转载出处: 交叉熵（Cross-Entropy）_rtygbwwwerr的博客-CSDN博客 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:4:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["Python"],"content":"强大的GAN网络 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:0:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"1. 概要 ​ GAN网络全称generative adversarial network,翻译为生成式对抗网络,是一种非监督式学习机器学习方法。由Ian J,Goodfello 等人于2014年在Generative Adversarial Nets 论文中提出。其中在GAN网络中,有两个模型——生成模型(generative model G),判别模型(discriminative model D). ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:1:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"2. 原理 ​ GAN网络主要运用了博弈论的思想,模型中的2为博弈方分别由生成模型和判别模型担当.生成模型用随机取样作为输入,它的输出结果要尽可能和训练样本尽可能相似,最好的情况就是分辨不出是真实样本还是生成出来的样本.而判别模型就是尽可能判别生成模型生成的结果和真实样本.这样2个网络相互对抗,不断调整参数,最终达到纳什均衡. 这个过程可以表示为: $$ min_G max_DV(D,G) = \\Epsilon_{x\\sim P_{data}(x)}[logD(x)] + \\Epsilon_{z\\sim p_{z}(z)}[log(1-D(G(z)))] $$ 公式解释: 1. 当训练D时,希望这个式子的值越大越好.真实数据希望被D分成1,生成数据希望被分成0\r2. 当训练G时,希望这个式子的值越小越好.希望D分不开真实数据还是生成数据\r零和博弈（zero-sum game），又称零和游戏，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。指参与博弈的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”，双方不存在合作的可能。就像下棋的游戏一样，你走的每一步和对方走的每一步都是向着对自己有利的方向走，然后你和对手轮流走步 每一步都向着自己最大可能能赢的地方走。这就是零和博弈。 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:2:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3. 简单代码实现 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.1 导包 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:1","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.2 加载数据集 # 初始化tensorboard数据保存路径 writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:2","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.3 定义生成模型 class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:3","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.4 定义判别模型 class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:4","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.5 构造模型,定义损失和优化器 z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:5","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.6 训练判别器和生成器 def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:6","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.7 训练网络 epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_step=step) writer.close() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:7","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.8 保存模型 torch.save(D, './model/discriminator.pt') torch.save(G, './model/generator.pt') ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:8","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.9 汇总代码 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torchinfo import summary from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) # 设置drop_last丢弃最后不满一个batch_size的数据 train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) # 添加网络图到tensorboard writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:9","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"参考资料: GAN入门理解及公式推导 - 知乎 (zhihu.com) lyeoni/pytorch-mnist-GAN (github.com) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:10","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Markdown"],"content":"Markdown使用mermaid ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:0:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"0. 符号表示 类元素的可见范围 可见范围 表示方法 private - public + protected # package ~ 类的修饰 符号 类型 \u003c\u003cInterface\u003e\u003e 接口 \u003c\u003cabstract\u003e\u003e 抽象类 \u003c\u003cService\u003e\u003e service类 \u003c\u003cenumeration\u003e\u003e 枚举 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:1:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"1. 泛化 定义: 表示继承关系(子类和父类). 表示:三角实线,指向父类. classDiagram class Animal{ -age: int +sleep(): void } class Dog Animal \u003c|-- Dog ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:2:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"2. 实现 定义: 表示类和接口之间的关系. 表示: 三角虚线,指向接口. classDiagram class Person { + say(): void } class Man Person \u003c|.. Man ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:3:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"3. 组合 定义: 整体与局部的关系,部分不能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 实心菱形实线,实心菱形指向整体. 代码体现: 成员变量 classDiagram class Person{ -brain } class Brain { - weight } Person *-- Brain ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:4:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"4. 聚合 定义: 整体与局部的关系,部分能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 空心菱形实线,空心菱形指向整体. 代码体现: 成员变量 classDiagram class Computer { -keyboard } class Keyboard { -type } Computer o-- Keyboard ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:5:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"5. 关联 定义: 一种拥有的关系, 使一个类知道另一个类的属性和方法,关联可以是单向的,也可以是双向的.双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头. 表示: 普通箭头的实心线,指向被拥有者. 代码体现: 成员变量 classDiagram class Teacher { -students: List\u003cStudent\u003e +teach(): void } class Student { -teacher: List\u003cTeacher\u003e +learn(): void } Teacher \u003c--\u003e Student ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:6:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"6. 依赖 定义: 一种使用关系. 表示: 普通箭头的虚线,箭头指向被使用者 代码体现: 局部变量, 方法的形参, 方法返回值静态方法的调用 classDiagram class Person { +draw(tool: DrawTool): void } class DrawTool { -color } Person \u003c.. DrawTool ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:7:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"7. 各种关系强弱顺序 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:8:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Git","Windows"],"content":"Git for Windows 安装 Pacman ","date":"2022-12-24","objectID":"/git_for_windows/:0:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"1. 下载必要压缩包 curl -o pacman-6.0.1-9-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-6.0.1-9-x86_64.pkg.tar.zst curl -o pacman-mirrors-20221016-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-mirrors-20221016-1-any.pkg.tar.zst curl -o msys2-keyring-1~20221024-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/msys2-keyring-1~20221024-1-any.pkg.tar.zst # 正常来说只需要上面三个包但是由于缺少 zstd 解压工具还需要 zstd 包 curl -o zstd-1.5.2-2-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/zstd-1.5.2-2-x86_64.pkg.tar.zst # 但是又因为 zstd 包也是 zstd 打包又需要另一个不是 zstd 打包的解压工具来解压 curl -o zstd-v1.5.2-win64.zip -L https://github.com/facebook/zstd/releases/download/v1.5.2/zstd-v1.5.2-win64.zip ","date":"2022-12-24","objectID":"/git_for_windows/:1:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"2 .解压并安装: unzip zstd-v1.5.2-win64.zip \"zstd-v1.5.2-win64/zstd.exe\" -d . ./zstd-v1.5.2-win64/zstd.exe -d -o zstd-1.5.2-2-x86_64.pkg.tar zstd-1.5.2-2-x86_64.pkg.tar.zst tar -xvf zstd-1.5.2-2-x86_64.pkg.tar -C / tar -xvf msys2-keyring-1~20221024-1-any.pkg.tar.zst -C / tar -xvf pacman-mirrors-20221016-1-any.pkg.tar.zst -C / tar -xvf pacman-6.0.1-9-x86_64.pkg.tar.zst -C / ","date":"2022-12-24","objectID":"/git_for_windows/:2:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"3. 添加密钥并更新数据库: pacman-key --init \u0026\u0026 pacman-key --populate msys2 pacman-db-upgrade -r /../ pacman -Sy ","date":"2022-12-24","objectID":"/git_for_windows/:3:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"4. 更新元数据: # pacman -S pacman-mirrors-20221016-1 msys2-keyring-1~20221024-1 zstd-1.5.2-2 # pacman -S $(cut -d ' ' -f 1 /etc/package-versions.txt) URL=https://github.com/git-for-windows/git-sdk-64/raw/main cat /etc/package-versions.txt | while read p v; do d=/var/lib/pacman/local/$p-$v mkdir -p $d for f in desc files install mtree; do echo \"$URL$d/$f\" ..... $d/$f curl -sSL \"$URL$d/$f\" -o $d/$f done done curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/desc -o /var/lib/pacman/local/pacman-6.0.1-9/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/files -o /var/lib/pacman/local/pacman-6.0.1-9/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/install -o /var/lib/pacman/local/pacman-6.0.1-9/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/mtree -o /var/lib/pacman/local/pacman-6.0.1-9/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/desc -o /var/lib/pacman/local/pacman-mirrors-20221016-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/files -o /var/lib/pacman/local/pacman-mirrors-20221016-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/install -o /var/lib/pacman/local/pacman-mirrors-20221016-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/mtree -o /var/lib/pacman/local/pacman-mirrors-20221016-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/desc -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/files -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/install -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/mtree -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/desc -o /var/lib/pacman/local/zstd-1.5.2-2/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/files -o /var/lib/pacman/local/zstd-1.5.2-2/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/install -o /var/lib/pacman/local/zstd-1.5.2-2/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/mtree -o /var/lib/pacman/local/zstd-1.5.2-2/mtree ","date":"2022-12-24","objectID":"/git_for_windows/:4:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 安装Fish Shell ","date":"2022-12-24","objectID":"/git_for_windows/:5:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.1 安装必要依赖 pacman -S gcc-libs ","date":"2022-12-24","objectID":"/git_for_windows/:5:1","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.2 安装Fish Shell并启动 pacman -S fish ","date":"2022-12-24","objectID":"/git_for_windows/:5:2","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.3 启动Fish Shell # 在~/.bashrc文件中添加以下内容，设置默认shell为fish if [ -t 1 ]; then exec fish fi ","date":"2022-12-24","objectID":"/git_for_windows/:5:3","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.4 更换Fish Shell 主题 fish_config ","date":"2022-12-24","objectID":"/git_for_windows/:5:4","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 5 Fish Shell 常用命令和基本设置 # 关闭问候语 set -g -x fish_greeting '' set -U fish_greeting # 设置环境变量 #在最后一行加入(注意目录间用空格隔开) set -x PATH /opt/demo/bin /home/guest/bin $PATH # 删除变量 set -e Foo # 配置别名 # Define alias in config file alias rmi=\"rm -i\" # 切换默认shell，git for windows下不可用 echo $SHELL cat /etc/shells chsh -s /usr/bin/fish # 命令替换 echo (date) # 在bash下面 # echo `date` 参考资料: pacman常用命令-昨夜星辰 (hustlei.github.io) Install inside MSYS2 proper · git-for-windows/git Wiki (github.com) Git:給 git for windows 裝個翅膀 (安裝 pacman 及其他工具) @ 傑克! 真是太神奇了! :: 痞客邦 :: (pixnet.net) 在 Windows 的 Git Bash 中使用包管理器 - iris (ginshio.org) Index of /msys/x86_64/ (msys2.org) Releases · facebook/zstd (github.com) Windows 的终端配置(给 git-windows 添加 msys2 包管理器) - zeromake 的个人博客 MSYS2 和 mintty 打造 Windows 下 Linux 工具体验 - Creaink - Build something for life Using fish shell with git bash on windows (github.com) Package management in Git for Windows (Git Bash)? - Stack Overflow Fish Shell | 安装配置指南 - URmyLucky - 博客园 (cnblogs.com) ","date":"2022-12-24","objectID":"/git_for_windows/:5:5","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Rust"],"content":"Rust偏僻知识点 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Cow(Clone on Write) 两个可选值： Borrowed，用于包裹对象的引用（通用引用）； Owned，用于包裹对象的所有者； Cow 提供 对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）； 如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，Cow 提供方法做克隆处理，并避免多次重复克隆。 Cow 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 Cow，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。 它有以下几个要点需要掌握： Cow\u003cT\u003e 能直接调用 T 的不可变方法，因为 Cow 这个枚举，实现了 Deref； 在需要写 T 的时候，可以使用 .to_mut() 方法得到一个具有所有权的值的可变借用；注意，调用 .to_mut() 不一定会产生克隆； 在已经具有所有权的情况下，调用 .to_mut() 有效，但是不会产生新的克隆； 多次调用 .to_mut() 只会产生一次克隆。 在需要写 T 的时候，可以使用 .into_owned() 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象； 如果之前 Cow 中的值是借用状态，调用此操作将执行克隆； 本方法，参数是self类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 Cow 上不能调用多次； 举例:写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。 use std::borrow::Cow; fn remove_spaces\u003c'a\u003e(input: \u0026'a str) -\u003e Cow\u003c'a, str\u003e { if input.contains(' ') { let mut buf = String::with_capacity(input.len()); for c in input.chars() { if c != ' ' { buf.push(c); } } return Cow::Owned(buf); } return Cow::Borrowed(input); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"HRTBS(Higher-Ranked Trait Bounds) HRTBS主要用于解决函数参数含有闭包,并且闭包参数含有引用 语法:for\u003c‘a\u003e T: Trait\u003c‘a\u003e 例如如下代码实际是不能编译通过的,因为编译器不能推断出返回哪个引用 fn call_on_ref_zero\u003cF\u003e(f: F) where F: Fn(\u0026i32, \u0026i32) -\u003e \u0026i32 { let zero = 0; f(\u0026zero, \u0026zero); } 尝试添加生命周期参数,还是不能通过编译,因为zero变量的生命周期是短于’a的. fn call_on_ref_zero\u003c'a, F\u003e(f: F) where F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 我们尝试使用HRTBS试试 fn call_on_ref_zero\u003cF\u003e(f: F) where for\u003c'a\u003e F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 另一个例子 fn foo\u003c'b, F\u003e(f: F) -\u003e \u0026'b str where for\u003c'a\u003e F: Fn(\u0026'a str) -\u003e \u0026'a str, { let s = \"hello\"; f(s) } fn bar(s: \u0026str) -\u003e \u0026str { \u0026s[..1] } fn main() { let s = foo(bar); println!(\"{s}\"); } 最后一个例子: fn foo\u003c'a\u003e(f: Box\u003cdyn Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 第一次调用 f(\u0026x) 时生命周期 'a 等于变量 x 的生命周期；而在第二次调用 f(\u0026y) 时，生命周期 'a 又等于了变量 y 的生命周期；而变量 x 和变量 y 的生命周期显然是不同的。因此无法用一个静态的生命周期来描述 'a ，我们希望的是，闭包 f 在具体调用时绑定具体的生命周期，比如调用 f(\u0026x) 时绑定的是 x 的生命周期，而调用 f(\u0026y) 时绑定的是 y 的生命周期。 使用HRTBS修改如下: fn foo(f: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 这样生命周期 'a 就不再是静态的了，他会随着闭包 f 的调用绑定到不同的生命周期：f(\u0026x) 调用时绑定到 x 的生命周期，f(\u0026y) 调用时绑定到 y 的生命周期。 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"PhantomData PhantomData主要用于无界生命周期(unbounded lifetime)或者需要drop struct非自身字段,例如: use std::marker: struct Vec\u003cT\u003e { data: *const T, // *const是可变的！ len: usize, cap: usize, _marker: marker::PhantomData\u003cT\u003e, } PhantomData模式表 Phantom 类型 'a 'T PhantomData\u003cT\u003e - 协变（可触发drop检查） PhantomData\u003c\u0026'a T\u003e 协变 协变 PhantomData\u003c\u0026'a mut T\u003e 协变 不变 PhantomData\u003c*const T\u003e - 协变 PhantomData\u003c*mut T\u003e - 不变 PhantomData\u003cfn(T)\u003e - 逆变(*) PhantomData\u003cfn() -\u003e T\u003e - 协变 PhantomData\u003cfn(T) -\u003e T\u003e - 不变 PhantomData\u003cCell\u003c\u0026'a ()\u003e\u003e 不变 - (*)如果发生变性的冲突，这个是不变的 我们可以使用泛型结构体来实现对同一种类对象不同子类对象的区分，例如，我们的系统中要设计这样一个功能，将用户分为免费用户和付费用户，而且免费用户在体验免费功能之后，如果想升级成付费用户也是可以的。按照我们常规的思维，可能是定义两个结构体 FreeCustomer 以及 PaidCustomer，但是我们可以通过泛型结构体来实现，例如： struct Customer\u003cT\u003e { id: u64, name: String, } 不过，我们这里的 T 又无处安放，所以又不得不使用 PhantomData，它就像一个占位符，但是又没有大小，可以为我们持有在声明时使用不到的数据： use std::{ marker::PhantomData, sync::atomic::{self, AtomicU64}, }; static NEXT_ID: AtomicU64 = AtomicU64::new(0); struct Customer\u003cT\u003e { id: u64, name: String, phantom: PhantomData\u003cT\u003e, } struct FreeFeature; struct PaidFeature; trait Free { fn feature1(\u0026self); fn feature2(\u0026self); } trait Paid: Free { fn paid_feature(\u0026self); } /// 为 Customer\u003cT\u003e 实现需要的方法 impl\u003cT\u003e Customer\u003cT\u003e { fn new(name: String) -\u003e Self { Self { id: NEXT_ID.fetch_add(1, atomic::Ordering::Relaxed), name, phantom: PhantomData, } } } /// 免费用户可以升级到付费用户 impl Customer\u003cFreeFeature\u003e { fn advance(self, payment: f64) -\u003e Customer\u003cPaidFeature\u003e { println!( \"{}（{}） 将花费 {:.2} 元升级到付费用户\", self.name, self.id, payment ); self.into() } } /// 所有客户都有权使用免费功能 impl\u003cT\u003e Free for Customer\u003cT\u003e { fn feature1(\u0026self) { println!(\"{} 正在使用免费功能一\", self.name) } fn feature2(\u0026self) { println!(\"{} 正在使用免费功能二\", self.name) } } /// 付费用户才能使用的功能 impl Paid for Customer\u003cPaidFeature\u003e { fn paid_feature(\u0026self) { println!(\"{} 正在使用付费功能\", self.name) } } /// 允许使用免费用户转换成付费用户 impl From\u003cCustomer\u003cFreeFeature\u003e\u003e for Customer\u003cPaidFeature\u003e { fn from(c: Customer\u003cFreeFeature\u003e) -\u003e Self { Self::new(c.name) } } #[cfg(test)] mod tests { use super::*; #[test] fn test_customer() { // 一开始是免费用户 let customer = Customer::\u003cFreeFeature\u003e::new(\"MichaelFu\".to_owned()); customer.feature1(); customer.feature2(); // 升级成付费用户，可能使用付费功能和普通功能 let customer = customer.advance(99.99); customer.feature1(); customer.feature2(); customer.paid_feature(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Thread_local thread_local是一种将数据存储到全局变量中的方法，程序中的每个线程都有自己的副本。线程不共享这个数据，所以访问不需要同步,thread_local中声明的变量，在线程结束后会被释放，比如如果有10个线程中使用了该thread_local变量,则这10个线程结束时将有10个该类型的变量被释放。这适用于thread_per_core架构的异步运行时(类似于nginx),而不是tokio这种work-stealing scheduler(任务窃取). 举个例子: use std::borrow::Cow; use std::cell::RefCell; use std::thread; fn main() { thread_local!(static FOO: RefCell\u003cu32\u003e = RefCell::new(1)); FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 2; }); // 每个线程开始时都会拿到线程局部变量的FOO的初始值 let t = thread::spawn(move || { FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 3; }); }); // 等待线程完成 t.join().unwrap(); // 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2 FOO.with(|f| { assert_eq!(*f.borrow(), 2); }); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Barrier(线程屏障) 使用 Barrier 让多个线程都执行到某个点后，才继续一起往后执行： use std::sync::{Arc, Barrier}; use std::thread; fn main() { let mut handles = Vec::with_capacity(5); let barrier = Arc::new(Barrier::new(5)); for _ in 0..5 { let b = barrier.clone(); handles.push(thread::spawn(move|| { println!(\"before wait\"); b.wait(); println!(\"after wait\"); })); } for handle in handles { handle.join().unwrap(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"once_cell和lazy_static once_cell 和 lazy_static 都是 Rust 中用于实现单例模式（Singleton）的库。 once_cell 适用于程序初始化加载配置文件这种场景 LazyCell和LazyLock适用于初始化某个变量,比如说正则的compile,数据库连接等场景. #![feature(once_cell)] use std::cell; use std::collections::HashMap; use std::sync; use std::sync::Once; static INIT: Once = sync::Once::new(); static mut SUM: u64 = 0; fn init_sum() -\u003e u64 { unsafe { INIT.call_once(|| { println!(\"this is first init\"); SUM = (1..100000).sum(); }); SUM } } fn main() { let split_line = \"*\".repeat(100); let first_result = init_sum(); println!(\"first result: {first_result}\"); let second_result = init_sum(); println!(\"second result: {second_result}\"); println!(\"{split_line}\"); let once = cell::OnceCell::\u003cHashMap\u003c\u0026str, \u0026str\u003e\u003e::new(); let dict = once.get_or_init(|| { println!(\"this is hash map init once\"); let mut map = HashMap::new(); map.insert(\"lang\", \"rust\"); map.insert(\"edition\", \"2021\"); map }); println!(\"once dict: {dict:?}\"); let dict_twice = once.get_or_init(|| { println!(\"this is hash map init twice\"); let mut map = HashMap::new(); map.insert(\"lang\", \"python\"); map.insert(\"version\", \"1.10\"); map }); println!(\"twice dict: {dict_twice:?}\"); println!(\"{split_line}\"); let lazy_init = cell::LazyCell::new(|| env!(\"PATH\")); println!(\"lazy_init: {}\", *lazy_init); // thread safe lazy cell let lazy_init_safe = sync::LazyLock::new(|| env!(\"PATH\")); print!(\"lazy_init_safe: {}\", *lazy_init_safe); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"impl A and T: A 在 impl 中被声明的类型参数，至少要满足下面三种形式： impl Foo， T 出现在实现的Self 类型Foo 中 。 impl SomeTrait for Foo ， T出现在要实现的 trait 中 。 impl\u003cT, U\u003e SomeTrait for T where T: AnotherTrait\u003cAssocType=U\u003e ， 出现在 T 的 trait 限定的关联类型中。 参考资料: 【Rust】幽灵数据（PhantomData） | MichaelFu (fudenglong.site) 3.10 PhantomData（幽灵数据） | 第三章、所有权 |《Rust 高级编程 2018》| Rust 技术论坛 (learnku.com) Rust高阶生命周期绑定 (xiaopengli89.github.io) ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["c/c++"],"content":"cmake简易教程 ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"1. 添加头文件目录INCLUDE_DIRECTORIES 它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。 语法： include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"2. 添加需要链接的库文件目录LINK_DIRECTORIES 语法： link_directories(directory1 directory2 ...) 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。 link_directories(\"/home/server/third/lib\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"3. 添加需要链接的库文件路径LINK_LIBRARIES 语法： link_libraries(library1 \u003cdebug | optimized\u003e library2 ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"4. 设置要链接的库文件的名称TARGET_LINK_LIBRARIES 语法： target_link_libraries(\u003ctarget\u003e [item1 [item2 [...]]] [[debug|optimized|general] \u003citem\u003e] ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"5. 查找库所在目录FIND_LIBRARY 语法： find_library (\u003cVAR\u003e name1 [path1 path2 ...]) find_library ( \u003cVAR\u003e name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \"cache documentation string\"] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 例子如下： FIND_LIBRARY(RUNTIME_LIB rt /usr/lib /usr/local/lib NO_DEFAULT_PATH) cmake会在目录中查找，如果所有目录中都没有，值RUNTIME_LIB就会被赋为NO_DEFAULT_PATH ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:5:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"6. 查找源文件和头文件 # 查找指定目录下的所有.cpp与.h文件 并存放到指定变量名SC_FILES中 FILE(GLOB SC_FILES \"*.cpp\" \"*.h\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:6:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"7. 添加源文件目录 使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。 语法： aux_source_directory(\u003cdir\u003e \u003cvariable\u003e) # 生成链接库 add_library (MathFunctions ${DIR_LIB_SRCS}) 参考链接： cmake 添加头文件目录，链接动态、静态库 - 王彬彬 - 博客园 (cnblogs.com) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:7:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"opencv实现抠图和裁剪 ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:0:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"1. 抠图 步骤: 加载图像 转换图像格式(BGR –\u003e HSV) 设置阈值 通过阈值提取部分区域 显示图片 关于HSV可参考：HSL和HSV色彩空间 - 维基百科，自由的百科全书 (wikipedia.org) window_name = 'hsv' img = cv2.imread(r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\") # 设置高低阈值 hsv_low = np.array([0, 0, 0]) hsv_high = np.array([134, 255, 138]) # 将BGR转为HSV dst = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 通过HSV的高低阈值，提取图像部分区域 mask_img = cv2.inRange(dst, hsv_low, hsv_high) # 进行与位运算 img_ = cv2.bitwise_and(img, img, mask=mask_img) cv2.imshow(window_name, img_) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:1:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"2. 裁剪图片 步骤 加载图像 设置鼠标事件 - 鼠标左键单击画点\r- 鼠标右键单击闭合所画的点\r- 鼠标右键双击填充 # 触发鼠标移动事件 # cv2.CV_EVENT_MOUSEMOVE # 触发左键抬起事件 # cv2.CV_EVENT_LBUTTONUP # 触发右键按下事件 # cv2.CV_EVENT_RBUTTONDOWN # 触发右键抬起事件 # cv2.CV_EVENT_RBUTTONUP # 触发左键双击事件 # cv2.CV_EVENT_LBUTTONDBLCLK # 触发右键双击事件 # cv2.CV_EVENT_RBUTTONDBLCLK coordinates = [] window_name = 'draw' def on_mouse_callback(event, x, y, flag, param): # 左键点击,画点 if event == cv2.EVENT_LBUTTONDOWN: xy = f'{x},{y}' coordinates.append((x, y)) cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1) cv2.putText(img, xy, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness=1) cv2.imshow(window_name, img) # 右键单击，画不规则图形 elif event == cv2.EVENT_RBUTTONDOWN: pts = np.array(coordinates, np.int32) # 顶点集 #顶点坐标转为rowsx1x2, row为顶点数 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (255, 255, 255), 2) cv2.imshow(window_name, img) # 右键双击，填充颜色 elif event == cv2.EVENT_RBUTTONDBLCLK: area = np.array(coordinates) # 可以绘制多个图形 cv2.fillPoly(img, [area], (255, 255, 255)) # 绘制凸多边形 # cv2.fillConvexPoly(img, area, (255, 255, 255)) cv2.imshow(window_name, img) coordinates.clear() cv2.namedWindow(window_name) cv2.setMouseCallback(window_name, on_mouse_callback) cv2.imshow(window_name, img) cv2.waitKey(0) cv2.destroyAllWindows() Rust版opencv实现抠图 Cargo.toml [dependencies] opencv = { version = \"0.71\" } src/main.rs use opencv::{ core::{bitwise_and, in_range, Vector, CV_8UC3}, highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, imgproc::{cvt_color, COLOR_BGR2HSV}, prelude::*, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img = imread( r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\", ImreadModes::IMREAD_COLOR as i32, )?; unsafe { let mut lowerb = Vector::from_slice(\u0026[0, 0, 0u8]); let mut upperb = Vector::from_slice(\u0026[134, 255, 138u8]); let mut dst = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut mask_img = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut result = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; cvt_color(\u0026img, \u0026mut dst, COLOR_BGR2HSV, 0)?; in_range(\u0026img, \u0026mut lowerb, \u0026mut upperb, \u0026mut mask_img)?; bitwise_and(\u0026img, \u0026img, \u0026mut result, \u0026mask_img)?; imshow(\"winname\", \u0026result)?; } wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:2:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Rust"],"content":"Rust中使用opencv 因为在macos和linux上安装比较简单，这里只介绍windows上的安装 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:0:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"安装环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 安装opencv 下载地址：Releases - OpenCV 选择windows平台，下载后默认安装即可 设置环境变量 OPENCV_INCLUDE_PATHS OPENCV_LINK_LIBS OPENCV_LINK_PATHS 注意：opencv_world460这个不是固定的，需要根据下载的具体版本设置，我的版本中位于D:\\development\\opencv\\build\\x64\\vc15\\bin目录 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 安装LLVM 下载地址：Releases · llvm/llvm-project (github.com) 根据需要安装32位或者64位，有些版本可能没有这2个选项，可以选择以前的版本，没必要选择最新的版本。下载后默认安装即可，注意需要在添加LLVM到环境变量中 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"简单使用 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 确保安装了Rust环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 新建项目 cargo new opencv-rust-test ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"3. 配置Cargo.toml文件 [dependencies] opencv = { version = \"0.71\" } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:3","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"4. 将opencv_world460.dll文件拷贝到项目根目录(重要！！！) 如果opencv_world460.dll路径添加到环境变量中，应该就不需要将文件拷贝(没有实际测试) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:4","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"5. 编写代码测试环境是否正常 src/main.rs use opencv::{ highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img_path = r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\"; let img = imread(img_path, ImreadModes::IMREAD_COLOR as i32)?; imshow(\"winname\", \u0026img)?; wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:5","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"6. 运行测试 # 使用cargo命令运行看看是否正常显示图片 cargo run ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:6","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"7. 报错解决 主要参考官方文档： twistedfall/opencv-rust: Rust bindings for OpenCV 3 \u0026 4 (github.com) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:7","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Linux"],"content":"管道 ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:0:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"匿名管道(Pipe) 特点 半双工 只能用于具有亲缘关系进程(父子，兄弟) 可以视作特殊文件，读写可以使用write，read函数 #include\"stdio.h\" #include\"unistd.h\" // https://learnku.com/articles/44477 // **特点** // 1. 半双工 // 2. 只能用于具有亲缘关系进程(父子，兄弟) // 3. 可以视作特殊文件，读写可以使用write，read函数 int main() { int fd[2]; pid_t pid; char buf[32]; //创建管道 if (pipe(fd) \u003c 0) { printf(\"Create Pipe Error \\n\"); } //创建子进程 if ((pid = fork()) \u003c 0) { printf(\"Fork Error \\n\"); } else if (pid \u003e 0) { close(fd[0]); // 关闭父进程读端 write(fd[1], \"hello world\", 8); //父进程写端写入 } else { close(fd[1]); // 关闭子进程写端 read(fd[0], buf, 8); // 子进程读取父进程消息 printf(\"Child Recv Msg: %s\", buf); } } ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:1:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"命名管道(FIFO) 特点 和匿名管道不同，FIFO可以在无关进程间通信 FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 fifo_read.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"errno.h\" #include\"fcntl.h\" #include\"sys/stat.h\" int main() { int fd; int len; char buf[1024]; if (mkfifo(\"/home\", 0666) \u003c 0 \u0026\u0026 errno != EEXIST) { perror(\"Create FIFO Failed\"); } if ((fd = open(\"/home\", O_RDONLY)) \u003c 0) { perror(\"Open FIFO Failed\"); exit(1); } while ((len = read(fd, buf, 1024)) \u003e 0) { printf(\"Read Message: %s\", buf); } close(fd); return 0; } fifo_write.c #include\"stdio.h\" #include\"unistd.h\" #include\"stdlib.h\" #include\"fcntl.h\" // O_WRONLY #include\"sys/stat.h\" #include\"time.h\" // ## 命名管道(FIFO) // ** 特点** // 1. 和匿名管道不同，FIFO可以在无关进程间通信 // 2. FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 int main() { int fd; int n, i; char buf[1024]; time_t tp; printf(\"Parent Process PID:\", getpid()); if ((fd = open(\"/home\", O_WRONLY)) \u003c 0) { // 写模式打开FIFO perror(\"Open FIFO Failed\"); exit(1); } for (i = 0; i \u003c 10; ++i) { time(\u0026tp);// 当前系统时间 n = sprintf(buf, \"Process %d's time is %s\", getpid(), ctime(\u0026tp)); printf(\"Send message: %s\", buf); // 写入数据到FIFO中 if (write(fd, buf, n + 1) \u003c 0) { perror(\"Write FIFO Failed\"); close(fd); exit(1); } sleep(1); } close(fd); return 0; } 消息队列 特点 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。 msg_client.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // key值不变，要么确保ftok()的文件不被删除，要么不用ftok()，指定一个固定的key值。 // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } printf(\"Message Queue - Client key is: %d.\\n\", key); // 打开消息队列 if ((msqid = msgget(key, IPC_CREAT | 0777)) == -1) { perror(\"msgget error\"); exit(1); } // 打印消息队列ID和进程ID printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); // 添加消息，类型为888 msg.mtype = 888; sprintf(msg.mtext, \"hello, I'm client %d\", getpid()); //msgid是由msgget函数返回的消息队列标识符。 // __msgp是一个指向准备发送消息的指针，消息的数据结构却有一定的要求， // 指针msg_ptr所指向的消息结构一定要是以一个**长整型**成员变量开始的结构体，接收函数将用这个成员来确定消息的类型 msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); // msgrcv函数type参数有以下几种可能： // type == 0，返回队列中的第一个消息； // type \u003e 0，返回队列中消息类型为 type 的第一个消息； // type \u003c 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。 // 读取类型为999的消息 msgrcv(msqid, \u0026msg, 256, 999, 0); printf(\"Client: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Client: receive msg.mtype is: %d.\\n\", msg.mtype); } msg_server.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } // 打印key值 printf(\"Message Queue - Server key is: %d.\\n\", key); // 创建消息队列 if ((msqid = msgget(key, IPC_CREAT | 0700)) == -1) { perror(\"msgget error\"); exit(1); } printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); for (;;) { // 返回类型为888的第一个消息 msgrcv(msqid, \u0026msg, 256, 888, 0); printf(\"Server: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Server: receive msg.mtype is: %d.\\n\", msg.mtype); msg.mtype = 999; sprintf(msg.mtext, \"hello, I'm server %d\", getpid()); msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); } return 0; } 信号量 特点 是一个计数器 用于实现进程间互斥和同步,不是存储进程间通信数据 示例 #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/sem.h\" union semun { int val; struct semid_ds* buf; unsigned short* array; }; int init_sem(int sem_id, int value) { union semun tmp; tmp.val = value; if (semctl(sem_id, 0, SETVAL, tmp) == -1) { perror(\"Init Semaphore Error\"); return -1; } return 0; } // p操作 // 若信号量值为1，获取资源并将信号值置为-1 // 若信号量值为0，进程挂起等待 int sem_p(int sem_id) { struct sembuf sbuf; sbuf.sem_num = 0; // 序号 sbuf.sem_op = -1; // 操作 sbuf.sem_flg = SEM_UNDO; if (semop(sem_id, \u0026sbuf, 1) == -1) { perror(\"P operation Error\"); return -","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:2:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Python"],"content":"索引 import pandas as pd import numpy as np df = pd.DataFrame(np.arange(50).reshape(-1, 5), columns=list('abcde')) # 根据列标签索引 df['a'] # 或者 df.loc[:,'a'] # 根据列索引 df.iloc[:, 0] # df['a'] == df.loc[:,'a'] == df.iloc[:, 0] 计算 # 所有元素乘法 df * 10 # 指定列相乘 # 注意：不会在原地修改，需要重新赋值 df['a'] = df['a'] * 10 # 指定位置操作 df.iloc[0,3] = 100 # 也可以指定多列操作，生成新列 df['e'] = df['a'] * df['b'] 合并 df_new = pd.DataFrame(np.arange(200, 230).reshape(-1, 2), columns=['z','x']) # 注意：这里因为2个DataFrame行索引没有冲突，索引这里没有问题。 # axis 为0时以行合并(可以是实现数据追加)，为1时以列合并 pd.concat([df, df_new], axis=1) # 当下面的df的行索引不连续时，df_new就会缺少一些行的数据 df = df[df.loc[:, 'a'] % 100 == 0] pd.concat([df, df_new], axis=1) # 如果当出现上面一种情况，而又不想丢掉df_new的数据时可以使用重新索引的方法 df = df.reset_index(drop=True) pd.concat([df, df_new], axis=1) 追加数据 # 不能这样追加，需要列标签相对应 df.append([1, 3, 5, 3,5]) # 新Dataframe需要和df标签对应 new_row = pd.DataFrame(np.full((1,4), 5), columns=list('abcd')) df.append(new_row) # 也可以这样 # pd.concat([df, new_row], axis=0) Apply 使用 # 当Dateframe中不再是存数字时，就不能根据直接对列进行操作生成新列，有些时候还含有复杂的条件判断，这时候既可以使用apply函数 # 注意当新加列时需要设置axis=1 df['f'] = df[['b','c']].apply(lambda x: x[0]*100 if x[0] % 2 == 0 else x[1] - 100, axis=1) 排序 # 根据索引排序,axis=0代表行，axis=1代表列 df.sort_index() # 根据值排序,可根据多个值排序 df.sort_values(by=['a']) # 如果Dataframe含有重复列，重复列的数据又不相同，但又想按值排序，可以参考下面 # 比如说2，4列名相同，想按照第2列的值排序 # sort_col_values = df.iloc[:, 2].to_numpy() # sort_indexs = sort_col_values.argsort() # df = df.iloc[:, sort_indexs] 去重 # 使用函数drop_duplicates，其中subset指定要去重的列名，不能写列索引，即指定的相同列才进行去重，默认按照所有列相同去重，keep参数可以指定保留first，last。inplace选择是否修改原Dataframe # df.drop_duplicates(subset=[], keep='first', inplace=False) # 当Dataframe有重复列名，重复列名数据不相同时，可以将Dataframe拆分，再进行去重，去重后再合并 # 例如：2，4列名重复，需要按照1，2列去重 # 拆分 front = df.iloc[:, :2] back = df.iloc[:, 2:] # 去重 front.drop_duplicates(subset=['a', 'b'], keep='first', inplace=True) back = back.iloc[front.index, :] # 合并,这里能保证行索引能一一对应，所以不用重建索引也行。当时也可以选择重建索引 pd.concat([front, back], axis=1) 字符串操作 在pandas中可以针对需要操作列方便的使用字符串的所有函数 # 举例： # 注意：这里的replace方法默认使用正则表达式，可以添加regex=False来关闭 df['a'].str.replace(regex=False) 分组和聚合 # 对指定列进行聚合计算，agg会返回分组结果，并且列数据为聚合操作后的结果 # 使用以下访问生成聚合结果 lang = df.groupby(by='姓名').agg({'语文': 'sum'}) math = df.groupby(by='姓名').agg({'数学': 'sum'}) english = df.groupby(by='姓名').agg({'英语': 'sum'}) # pd.concat([lang, math, english], axis=1) # 以上等于下面这行。 # df.groupby(by='姓名').sum() # 如果要对不同列进行不同聚合操作，可以使用以下方法： df = df.groupby(by='姓名').agg({'语文': 'sum', '姓名': 'count'}) # 注意：如果使用以上方法会出现重复列，那就需要重命名列名 df = df.rename({'姓名': 'count'}, axis=1) # 使用transform返回DataFrame # df['count'] = df.groupby(by='姓名')['数学'].transform('sum') 读取和保存 # 读取csv提供了许多使用的选项，比如可以指定分隔符，读取部分数据，跳过表头，指定列名读取 # 参考：https://www.gairuo.com/p/pandas-read-csv pd.read_csv( filepath_or_buffer: 'FilePathOrBuffer', sep=\u003cno_default\u003e, delimiter=None, header='infer', names=\u003cno_default\u003e, index_col=None, usecols=None, squeeze=False, prefix=\u003cno_default\u003e, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None, ) # 读取excel # 参考https://www.gairuo.com/p/pandas-read-excel pd.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=Fa","date":"2022-11-12","objectID":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["pandas"],"title":"Pandas使用小结","uri":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["Numpy","Python"],"content":"Numpy 排序函数 numpy.sort(a, axis=-1, kind=None, order=None) 参数: a : 要排序的数组； axis ： 按什么轴进行排序，默认按最后一个轴进行排序； kind ：排序方法，默认是快速排序(不稳定)，可选参数有:{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’} order : 当数组定义了字段属性时，可以按照某个属性进行排序； numpy.argsort(a, axis=-1, kind=None, order=None):numpy.argsort 函数用于将数组排序后，返回数组元素从小到大依次排序的所有元素索引 参数: a : 要排序的数组 axis ： 按什么轴进行排序，默认按最后一个轴进行排序 kind ：排序方法，默认是快速排序 order : 当数组定义了字段属性时，可以按照某个属性进行排序 排序后索引解释： 比如说第一行排序后的结果为：[1, 0, 2] 表示原数组索引为 1 的数现在变为 0，原索引为 0 变为 1，原索引为 2 保持不变,即[0, 1, 2] -\u003e [1, 0, 2] numpy.lexsort(keys, axis=-1): numpy.lexsort 函数用于按照多个条件（键）进行排序，返回排序后索引。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 参数: keys ：序列或元组，要排序的不同的列 axis ：指定次排序的轴(默认为-1，即最后一个轴) 注意：根据数组的 shape 维数指定次排序轴，也就是说如果是二维数组只能设置为 0，因为 1 是著排序轴。如果 shape 为(2,3,5),则 axis 可指定为 0 或者 1 根据行和列排序 ","date":"2022-11-05","objectID":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/:0:0","tags":["numpy","sort"],"title":"Numpy使用排序","uri":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/"},{"categories":["Rust","Openssl","Crypto"],"content":"AES 加密算法 AES(Advanced Encryption Standard)，全称：高级加密标准，是一种最常见的对称加密算法 ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"配置 Rust Toml 文件 [dependencies] openssl = { version = \"0.10\", features = [\"vendored\"] } ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"示例代码 use openssl::symm::{Cipher, Crypter, Mode}; fn main() { let key = \"061cecfd897548208c76c04b6e7fb\".as_bytes(); let crypto_word: \u0026mut Vec\u003cu8\u003e = \u0026mut \"keyword\".as_bytes().to_vec(); let block_size = Cipher::aes_128_cbc().block_size(); // 添加填充 pkcs7_padding(crypto_word, block_size); let mut output = vec![0; 1024]; // 取16位密钥 let mut encrypter = Crypter::new(Cipher::aes_128_ecb(), Mode::Encrypt, \u0026key[..16], None).unwrap(); match encrypter.update(\u0026f, \u0026mut output) { Ok(size) =\u003e { eprintln!(\"size is: {size}\"); println!(\"{:?}\", \u0026output[..size]); println!(\"{:02x?}\", \u0026output[..size]); // 转换为16进制 } Err(_) =\u003e {} }; } fn pkcs7_padding(data: \u0026mut Vec\u003cu8\u003e, block_size: usize) { let padding_num = block_size - data.len() % block_size; let padding = padding_num as u8; data.append(\u0026mut [padding].repeat(padding_num)); } 参考链接： AES 加解密-CBC ECB - 独孤剑—宇枫 - 博客园 (cnblogs.com) AES 加密(3)：AES 加密模式与填充 - 知乎 (zhihu.com) ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["教程"],"content":"安装镜像 下载地址： https://ubuntu.com/download/raspberry-pi 刷入镜像到SD卡 刷入后需要重新拔插SD卡 找到system-boot盘符盘符下network-config文件 根据实际情况修改wifi配置 version: 2 ethernets: eth0: dhcp4: true optional: true #wifis: # wlan0: # dhcp4: true # optional: true # access-points: # myhomewifi: # password: \"S3kr1t\" # myworkwifi: # password: \"correct battery horse staple\" # workssid: # auth: # key-management: eap # method: peap # identity: \"me@example.com\" # password: \"passw0rd\" # ca-certificate: /etc/my_ca.pem 开机查找wifi 查找树莓派ip地址可用方法： 登录路由器后台查看连接设备中树莓派IP 使用Advanced_IP_Scanner软件 连接ssh 初始用户名和密码都是：ubuntu ssh ubuntu@ip 注意：第一次登陆会强制要求修改密码，修改后再次登录即可，密码也不能太短 换源 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改文件内容为: deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-backports main restricted universe multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security multiverse 更新 sudo apt update sudo apt upgrade -y 参考链接： 树莓派折腾记（一）– 安装系统（Ubuntu Server 20.04.1） | 修行的技术阁 (mrxiuxing.com) ","date":"2022-10-24","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/:0:0","tags":["raspberry"],"title":"树莓派安装Ubutnu无显示器网络初次开机","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/"},{"categories":["教程"],"content":"Hugo博客从零到发布 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:0:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"1. 安装 安装hugo: 下载地址：https://github.com/gohugoio/hugo/releases/tag/v0.104.3 注意： 有些主题需要下载extended版本 安装git： 下载地址：https://git-scm.com/ ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:1:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"2. 配置远程仓库，并新建一个空项目(不需要README.md文件)，名字一般和站点名相同 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:2:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 本地部署 新建站点并配置git hugo new site your_site_name # 下载你需要的主题的压缩包放到theme目录下或者使用`git submodule`拉取，例： git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt # 根据主题文档配置config.toml文件，如果只有一个主题可直接在项目根目录下的config.toml文件配置 # 0. 当本地可以正常预览站点时运行，hugo命令打包，生成静态文件 # 1. 使用git初始化站点 # 2. 添加远程仓库 git remote add origin remtoe_url # 3. 拉取远程 # 4. 提交当前代码 # 4. 新建分支(例如：release)，命令如下： git switch -c release # 或者 git checkout -b release # 5. 合并主分支分支public目录到当前分支，命令如下： git checkout master public/** # 6. 移动public下所有内容到项目根目录下，例如： mv public/* . # 7. 再提交当前分支内容 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:3:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 推送到远程 # 使用git推送到远程仓库 git switch master git push -u origin master git switch release git push -u origin release # 将远程仓库默认分支设置为release ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:4:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"4. 使用cloudflare发布 注册一个cloudflare账号：https://dash.cloudflare.com/ 点击Pages，选择创建项目下连接到Git，然后根据需要配置相应信息 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:5:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"Kunpeng Compute安全编程指南 本文档基于C语言提供一些安全编程建议，用于指导开发实践。 数据类型 ","date":"0001-01-01","objectID":"/securecoding/:0:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保有符号整数运算不溢出 【描述】 有符号整数溢出是未定义的行为。出于安全考虑，对外部数据中的有符号整数值在如下场景中使用时，需要确保运算不会导致溢出： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 1)加法 【错误代码示例】(加法) 如下代码示例中，参与加法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = num_a + num_b; ... 【正确代码示例】(加法) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = 0; if (((num_a \u003e 0) \u0026\u0026 (num_b \u003e (INT_MAX - num_a))) || ((num_a \u003c 0) \u0026\u0026 (num_b \u003c (INT_MIN - num_a)))) { ... // 错误处理 } sum = num_a + num_b; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，参与减法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出，进而造成后续的内存复制操作出现缓冲区溢出。 unsigned char *content = ... // 指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 int total_len = ... // 报文总长度 int skip_len = ... // 从消息中解析出来的需要忽略的数据长度 // 用total_len - skip_len 计算剩余数据长度，可能出现整数溢出 (void)memmove(content, content + skip_len, total_len - skip_len); ... 【正确代码示例】(减法) 如下代码示例中，重构为使用size_t类型的变量表示数据长度，并校验外部数据长度是否在合法范围内。 unsigned char *content = ... //指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 size_t total_len = ... // 报文总长度 size_t skip_len = ... // 从消息中解析出来的需要忽略的数据长度 if (skip_len \u003e= total_len || total_len \u003e content_size) { ... // 错误处理 } (void)memmove(content, content + skip_len, total_len - skip_len); ... 3)乘法 【错误代码示例】(乘法) 如下代码示例中，内核代码对来自用户态的数值范围做了校验，但是由于opt是int类型，而校验条件中错误的使用了ULONG_MAX进行限制，导致整数溢出。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (ULONG_MAX / (60 * HZ)))) { // 错误的使用了ULONG_MAX做上限校验 return -EINVAL; } ... = opt * 60 * HZ; // 可能出现整数溢出 ... 【正确代码示例】(乘法) 一种改进方案是将opt的类型修改为unsigned long类型，这种方案适用于修改了变量类型更符合业务逻辑的场景。 unsigned long opt = ... // 将类型重构为 unsigned long 类型。 if (opt \u003e (ULONG_MAX / (60 * HZ))) { return -EINVAL; } ... = opt * 60 * HZ; ... 另一种改进方案是将数值上限修改为INT_MAX。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (INT_MAX / (60 * HZ)))) { // 修改使用INT_MAX作为上限值 return -EINVAL; } ... = opt * 60 * HZ; 4)除法 【错误代码示例】(除法) 如下代码示例中，做除法运算前只检查了是否出现被零除的问题，缺少对数值范围的校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a / num_b; // 可能出现整数溢出 ... 【正确代码示例】(除法) 如下代码示例中，按照最大允许值进行校验，防止整数溢出，在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 5)求余数 【错误代码示例】(求余数) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a % num_b; // 可能出现整数溢出 ... } 【正确代码示例】(求余数) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... } 6)一元减 当操作数等于有符号整数类型的最小值时，在二进制补码一元求反期间会发生溢出。 【错误代码示例】(一元减) 如下代码示例中，计算前未校验数值范围，可能出现整数溢出。 int num_a = ... // 来自外部数据 int result = -num_a; // 可能出现整数溢出 ... 【正确代码示例】(一元减) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int result = 0; if (num_a == LNT_MIN) { ... // 错误处理 } result = -num_a; ... ","date":"0001-01-01","objectID":"/securecoding/:1:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保无符号整数运算不回绕 【描述】 涉及无符号操作数的计算永远不会溢出，因为超出无符号整数类型表示范围的计算结果会按照（结果类型可表示的最大值 + 1）的数值取模。 这种行为更多时候被非正式地称为无符号整数回绕。 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 出于安全考虑，对外部数据中的无符号整数值在如下场景中使用时，需要确保运算不会导致回绕： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 1)加法 【错误代码示例】(加法) 如下代码示例中，校验下一个子报文的长度加上已处理报文的长度是否超过了整体报文的最大长度，在校验条件中的加法运算可能会出现整数回绕，造成绕过该校验的问题。 size_t total_len = ... // 报文的总长度 size_t read_len = 0 // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 从网络报文中解析出来的下一个子报文的长度 if (read_len + pkt_len \u003e total_len) { // 可能出现整数回绕 ... // 错误处理 } ... read_len += pkt_len; ... 【正确代码示例】(加法) 由于read_len变量记录的是已经处理报文的长度，必然会小于total_len，因此将代码中的加法运算修改为减法运算，导致条件绕过。 size_t total_len = ... // 报文的总长度 size_t read_len = 0; // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 来自网络报文 if (pkt_len \u003e total_len - read_len) { ... // 错误处理 } ... read_len += pkt_len; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，校验len合法范围的运算可能会出现整数回绕，导致条件绕过。 size_t len = ... // 来自用户态输入 if (SCTP_SIZE_MAX - len \u003c sizeof(SctpAuthBytes)) { // 减法操作可能出现整数回绕 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); // 可能出现整数回绕 ... 【正确代码示例】(减法) 如下代码示例中，调整减法运算的位置（需要确保编译期间减法表达式的值不翻转），避免整数回绕问题。 size_t len = ... // 来自用户态输入 if (len \u003e SCTP_SIZE_MAX - sizeof(SctpAuthBytes)) { // 确保编译期间减法表达式的值不翻转 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); ... 3)乘法 【错误代码示例】（乘法） 如下代码示例中，使用外部数据计算申请内存长度时未校验，可能出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 unsigned char *buf = (unsigned char *)malloc(width * hight); 无符号整数回绕可能导致分配的内存不足。 【正确代码示例】（乘法） 如下代码是一种解决方案，校验参与乘法运算的整数数值范围，确保不会出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 if (width == 0 || hight == 0) { ... // 错误处理 } if (width \u003e SIZE_MAX / hight) { ... // 错误处理 } unsigned char *buf = (unsigned char *)malloc(width * hight); 【例外】 为正确执行程序，必要时无符号整数可能表现出模态（回绕）。建议将变量声明明确注释为支持模数行为，并且对该整数的每个操作也应明确注释为支持模数行为。 【相关软件CWE编号】 CWE-190 ","date":"0001-01-01","objectID":"/securecoding/:2:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保除法和余数运算不会导致除零错误(被零除) 【描述】 整数的除法和取余运算的第二个操作数值为0会导致程序产生未定义的行为，因此使用时要确保整数的除法和余数运算不会导致除零错误(被零除，下同)。 1)除法 【错误代码示例】(除法) 有符号整数类型的除法运算如果限制不当，会导致溢出。 如下示例对有符号整数进行的除法运算做了防止溢出限制，确保不会导致溢出，但不能防止有符号操作数num_a和num_b之间的除法过程中出现除零错误： int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a / num_b; // 可能出现除零错误 ... 【正确代码示例】(除法) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 2)取余 【错误代码示例】(求余数) 如下代码，同除法的错误代码示例一样，可能出现除零错误，因为许多平台以相同的指令实现求余数和除法运算。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a % num_b; // 可能出现除零错误 ... 【正确代码示例】(求余数) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... 变量 ","date":"0001-01-01","objectID":"/securecoding/:3:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用未经初始化的变量 【描述】 这里的变量，指的是局部动态变量，并且还包括内存堆上申请的内存块。 因为他们的初始值都是不可预料的，所以禁止未经有效初始化就直接读取其值。 void foo( ...) { int data; bar(data); // 错误：未初始化就使用 ... } 如果有不同分支，要确保所有分支都得到初始化后才能使用： #define CUSTOMIZED_SIZE 100 void foo( ...) { int data; if (condition \u003e 0) { data = CUSTOMIZED_SIZE; } bar(data); // 错误：部分分支该值未初始化 ... } ","date":"0001-01-01","objectID":"/securecoding/:4:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"指向资源句柄或描述符的变量，在资源释放后立即赋予新值 【描述】 指向资源句柄或描述符的变量包括指针、文件描述符、socket描述符以及其它指向资源的变量。 以指针为例，当指针成功申请了一段内存之后，在这段内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，那这个指针就是一个悬空指针。 如果再对悬空指针操作，可能会发生重复释放或访问已释放内存的问题，造成安全漏洞。 消减该漏洞的有效方法是将释放后的指针立即设置为一个确定的新值，例如设置为NULL。对于全局性的资源句柄或描述符，在资源释放后，应该马上设置新值，以避免使用其已释放的无效值；对于只在单个函数内使用的资源句柄或描述符，应确保资源释放后其无效值不被再次使用。 【错误代码示例】 如下代码示例中，根据消息类型处理消息，处理完后释放掉body或head指向的内存，但是释放后未将指针设置为NULL。如果还有其他函数再次处理该消息结构体时，可能出现重复释放内存或访问已释放内存的问题。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); } ... EXIT: ... free(msg-\u003ebody); return ret; } 【正确代码示例】 如下代码示例中，立即对释放后的指针设置为NULL，避免重复放指针。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); msg-\u003ebody = NULL; } ... EXIT: ... free(msg-\u003ebody); return ret; } 当free()函数的入参为NULL时，函数不执行任何操作。 【错误代码示例】 如下代码示例中文件描述符关闭后未赋新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); ... close(fd); ... 【正确代码示例】 如下代码示例中，在资源释放后，对应的变量应该立即赋予新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); s = INVALID_SOCKET; ... close(fd); fd = -1; ... 指针和数组 ","date":"0001-01-01","objectID":"/securecoding/:5:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部数据作为数组索引时必须确保在数组大小范围内 【描述】 外部数据作为数组索引对内存进行访问时，必须对数据的大小进行严格的校验，确保数组索引在有效范围内，否则会导致严重的错误。 当一个指针指向数组元素时，可以指向数组最后一个元素的下一个元素的位置，但是不能读写该位置的内存。 【错误代码示例】 如下代码示例中, set_dev_id()函数存在差一错误，当 index 等于 DEV_NUM 时，恰好越界写一个元素； 同样get_dev()函数也存在差一错误，虽然函数执行过程中没有问题，但是当解引用这个函数返回的指针时，行为是未定义的。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_id(size_t index, int id) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } return devs + index; } 【正确代码示例】 如下代码示例中，修改校验索引的条件，避免差一错误。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_Id (size_t index, int id) { if (index \u003e= DEV_NUM) { ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e= DEV_NUM) { ... // 错误处理 } return devs + index; } 【相关软件CWE编号】 CWE-119，CWE-123，CWE-125 ","date":"0001-01-01","objectID":"/securecoding/:6:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止通过对指针变量进行sizeof操作来获取数组大小 【描述】 将指针当做数组进行sizeof操作时，会导致实际的执行结果与预期不符。例如：变量定义 char *p = array，其中array的定义为char array[LEN]，表达式sizeof(p) 得到的结果与 sizeof(char *)相同，并非array的长度。 【错误代码示例】 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了sizeof(buffer)，与预期不符。 char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小 (void)memset(buffer, 0, sizeof(buffer)); 【正确代码示例】 如下代码示例中，将sizeof(buffer)修改为申请的缓冲区大小： char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); (void)memset(buffer, 0, SIZE); // 使用申请的缓冲区大小 字符串 ","date":"0001-01-01","objectID":"/securecoding/:7:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保字符串存储有足够的空间容纳字符数据和null结束符 【描述】 将数据复制到不足以容纳数据的缓冲区，会导致缓冲区溢出。缓冲区溢出经常发生在字符串操作中。为了避免这种错误，截断拷贝的数据以限制字符串的字节长度是一种防御方法，但是最好的措施是确保目标缓冲区的大小足以容纳复制数据和null结束符。当字符串存储在堆空间时， 确保分配内存时已分配了足够的空间。 部分字符串处理函数由于设计时安全考虑不足，或者存在一些隐含的目的缓冲区长度要求，容易被误用，导致缓冲区写溢出。此类典型函数包括不在C标准库函数中的itoa()，realpath()函数。 【错误代码示例】(itoa) 有些函数如itoa(), realpath()需要在对传入的缓冲区指针位置进行写入操作，但函数并没有提供缓冲区长度。因此，在调用这些函数前，必须提供足够的缓冲区。 如下代码示例中，试图将数字转为字符串，但是目标存储空间的预留长度不足： int num = ... char str[8]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【正确代码示例】 如下代码示例中，在对外部数据进行解析并将内容保存到name中，考虑了name的大小： int num = ... char str[13]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【错误代码示例】(realpath) 如下代码示例中，试图将路径标准化，但是目标存储空间的长度不足： #define MAX_PATH_LEN 100 char resolved_path[MAX_PATH_LEN]; / * - realpath函数的存储缓冲区长度是由PATH_MAX常量定义， - 或是由_PC_PATH_MAX系统值配置的，通常都大于100字节 */ char *res = realpath(path, resolved_path); ... 【正确代码示例】 可以将realpath的第二个参数传入NULL, 以让系统自动分配合适的内存。 char *resolved_path = NULL; resolved_path = realpath(path, NULL); if (resolved_path == NULL) { ... // 处理错误 } ... if (resolved_path != NULL) { free(resolved_path); resolved_path = NULL; } ... ","date":"0001-01-01","objectID":"/securecoding/:8:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"对字符串进行存储操作，确保字符串有null结束符 【描述】 部分字符串处理函数操作字符串时，将截断超出指定长度的字符串，如strncpy()函数最多复制n个字符到目的缓冲区，如果源字符串长度大于n，则不会写入null结束符到目的缓冲区，目的缓冲区的内容为n个被复制的字符。使用这类函数时，可能会无意截断导致数据丢失，并在某些情况下会导致软件漏洞。 因此，对字符串进行存储操作，必须确保字符串有null结束符，否则在后续的调用strlen等操作中，可能会导致内存越界访问漏洞。 【错误代码示例】 在如下代码示例中，使用strncpy函数复制字符串时可能会发生截断（发生条件为：strlen(name) \u003e sizeof(file_name) - 1）。当发生截断时，file_name的内容是不完整的，并且缺少 ’ 0 ‘结束符，后续对file_name的操作可能会导致软件漏洞： #define FILE_NAME_LEN 128 char file_name [FILE_NAME_LEN ]; (void)strncpy(file_name, name, sizeof(file_name) - 1); ... 【正确代码示例】 #define FILE_NAME_LEN 128 char file_name[FILE_NAME_LEN ]; if (strlen(name) \u003e FILE_NAME_LEN - 1) { ... // 处理错误 } (void)strcpy(file_name, name); ... 【例外】 程序员的目的是故意截断字符串。 【相关软件CWE编号】 CWE-170，CWE-464 断言 ","date":"0001-01-01","objectID":"/securecoding/:9:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理 【描述】 断言主要用于调试期间，在编译Release版本时将其关闭。因此，断言应该用于防止不正确的程序员假设，而不能用在Release版本上检查程序运行过程中发生的错误。 断言永远不应用于验证是否存在运行时（与逻辑相对）错误，例如 无效的用户输入（包括命令行参数和环境变量） 文件错误（例如，打开，读取或写入文件时出错） 网络错误（包括网络协议错误） 内存不足的情况（例如，malloc()类似的故障） 系统资源耗尽（例如，文件描述符，进程，线程） 系统调用错误（例如，执行文件，锁定或解锁互斥锁时出错） 无效的权限（例如，文件，内存，用户） 例如，防止缓冲区溢出的代码不能使用断言实现，因为该代码必须编译到Release版本的可执行文件中。 如果服务器程序在网运行时由恶意用户触发断言失败，会导致拒绝服务攻击。在这种情况下，更适合使用软故障模式，例如写入日志文件和拒绝请求。 【错误代码示例】 以下代码的所有ASSERT的用法是错误的。例如，错误的使用ASSERT宏来验证内存分配是否成功，因为内存的可用性取决于系统的整体状态，并且在程序运行的任何时候都可能耗尽，所以必须以具有韧性的方式来妥善处理并将程序从内存耗尽中恢复。因此，使用ASSERT宏来验证内存分配是否成功将是不合适的，因为这样做可能导致进程突然终止，从而开启了拒绝服务攻击的可能性。 FILE *fp = fopen(path, \"r\"); ASSERT(fp != NULL); // 错误用法：文件有可能打开失败 char *str = (char *)malloc(MAX_LINE); ASSERT(str != NULL); // 错误用法：内存有可能分配失败 ReadLine(fp, str); char *p = strstr(str, \"age=\"); ASSERT(p != NULL); // 错误用法：文件中不一定存在该字符串 char *end = NULL; long age = strtol(p + 4, \u0026end, 10); ASSERT(age \u003e 0); // 错误用法：文件内容不一定符合预期 【正确代码示例】 下面代码演示了如何重构上面的错误代码: FILE *fp = fopen(path, \"r\"); if (fp == NULL) { ... // 错误处理 } char *str = (char *)malloc(MAX_LINE); if (str == NULL) { ... // 错误处理 } read_line(fp, str); char *p = strstr(str, \"age=\"); if (p == NULL) { ... // 错误处理 } char *end = NULL; long age = strtol(p + 4, \u0026end, 10); if (age \u003c= 0) { ... // 错误处理 } ","date":"0001-01-01","objectID":"/securecoding/:10:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在断言内改变运行环境 【描述】 在程序正式发布阶段，断言不会被编译进去，为了确保调试版和正式版的功能一致性，严禁在断言中使用任何赋值、修改变量、资源操作、内存申请等操作。 例如，以下的断言方式是错误的： ASSERT(p1 = p2); // p1被修改 ASSERT(i++ \u003e 1000); // i被修改 ASSERT(close(fd) == 0); // fd被关闭 函数设计 ","date":"0001-01-01","objectID":"/securecoding/:11:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"数组作为函数参数时，必须同时将其长度作为函数的参数 【描述】 通过函数参数传递数组函数参数必须同时传递数组可容纳元素的个数，而不是以字节为单位的数组最大大小；同样，通过函数参数传递一块内存进行读写操作时，必须同时传递内存块大小，否则函数在访问内存偏移时，无法判断偏移的合法范围，产生越界访问的漏洞。在本规则中所说的\"数组\"不仅局限为数组类型变量，还包括字符串或指向连续内存块的指针。 【错误代码示例】 如下代码示例中，函数pars_msg不知道msg的范围，容易产生内存越界访问漏洞。 int parse_msg(unsigned char *msg) { ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg); ... } 【正确代码示例】 正确的做法是将msg的大小作为参数传递到parse_msg中，如下代码： int parse_msg(unsigned char *msg, size_t msg_len) { ASSERT(msg != NULL); ASSERT(msg_len != 0); ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg, len); ... } ","date":"0001-01-01","objectID":"/securecoding/:12:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"函数的指针参数如果不是用于修改所指向的对象就应该声明为指向const的指针 【描述】 const 指针参数，将限制函数通过该指针修改所指向对象，使代码更牢固、更安全。 示例：如strncmp 的例子，指向的对象不变化的指针参数声明为const。 // 正确：不变参数声明为const int strncmp(const char *s1, const char *s2, size_t n); 注意： 指针参数要不要加const取决于函数设计，而不是看函数实体内有没有发生\"修改对象\"的动作。 ","date":"0001-01-01","objectID":"/securecoding/:13:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，禁止format参数受外部数据控制 【描述】 调用格式化函数时，如果format参数由外部数据提供，或由外部数据拼接而来，会造成字符串格式化漏洞。 攻击者如果能够完全或者部分控制格式字符串内容，可以使被攻击的进程崩溃、查看栈内容、查看内存内容或者在任意内存位置写入数据。结果是，攻击者能够以被攻击进程的权限执行任意代码。 格式化输出函数特别危险，这是因为许多程序员没有意识到它们是具有攻击能力的。比如：格式化输出函数可以使用%n转换符，向指定地址写入一个整数值。 这些格式化函数有： 格式化输出函数: xxxprintf; 格式化输入函数: xxxscanf; 格式化错误消息函数: err(), verr(), errx(), verrx(), warn(), vwarn(), warnx(), vwarnx(), error(), error_at_line(); 格式化日志函数: syslog(), vsyslog(). 【错误代码示例】 如下代码示例中的incorrect_password()函数的功能是在身份验证无效时（指定用户没有找到或者密码不正确），显示一条错误信息。 该函数接受一个源自用户的字符串数据user，而user是未验证的，是外部可控的。 该函数将user构造一条错误信息，然后用C语言标准函数fprintf打印到stderr。 // 调用者需保证入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fprintf(stderr, msg); // msg中有来自未验证的外部数据，存在格式化漏洞 } free(msg); } 示例代码中首先计算了消息的长度，然后分配内存，接着利用snprintf()函数拼接了消息内容。因此消息内容中包含了msg_format的内容和用户的内容。 当入参user中含有用户输入的格式符（如%s,%p,%n等后，fprintf()在执行时，会将msg作为一个格式化字符串来进行解析，而不是直接输出消息内容， 也就是说此时msg中的内容不会被直接打印到stderr中，反而会将一些未知的数据打印到stderr，引发程序未定义的行为。这是一个非常严重的格式化漏洞。 【正确代码示例】 下面是第一种推荐做法，代码中使用fputs()来代替fprintf()函数，fputs()会直接将msg的内容输出到stderr中，而不会去解析它。 // 入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; // 这里加法运算不会整数溢出，因为user有限制 size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fputs(stderr, msg); // 使用fputs函数代替fprintf函数 } free(msg); } 【正确代码示例】 下面是第二种推荐做法，代码中将不受信任的用户输入user作为fprintf()的可选参数之一，用\"%s\"将user以字符串的形式固定下来，然后输出到stderr中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void incorrect_password(const char *user) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; fprintf(stderr, msg_format, user); } 【错误代码示例】 如下代码示例中，使用了POSIX函数syslog()，但是syslog()函数也可能出现格式字符串漏洞。 void foo(void) { char *msg = get_msg(); ... syslog(LOG_INFO, msg); // 存在格式化漏洞 } 【正确代码示例】 下面是推荐做法，代码中将不受信任的用户输入msg作为syslog()的可选参数之一，用\"%s\"将msg以字符串的形式固定下来，然后输出到系统日志中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void foo(void) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; char *msg = get_msg(); ... syslog(LOG_INFO, msg_format, msg); // 这里没有格式化漏洞 } 函数使用 ","date":"0001-01-01","objectID":"/securecoding/:14:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，使用有效的格式字符串 【描述】 格式化输入/输出函数（如fscanf()/fprintf()及相关函数）在format字符串控制下进行转换、格式化、打印其实参。 在创建格式化字符串时的常见错误包括： format中参数个数与实参个数不一致； 使用无效的转换指示符； 使用与转换指示符不兼容的标志字符； 使用与转换指示符不兼容的长度修饰符； format中转换指示符与实参类型不匹配； 使用int以外类型的实参指定宽度或者精度； 不要为格式化输入/输出函数提供未知的或者无效的转换规格，以及标志字符、精度、长度修饰符、转换指示符的无效组合。同样，不要提供与格式化字符串中的转换指示符类型不匹配的实参。这可能会使程序产生未定义行为。 【错误代码示例】 如下代码示例中，printf()的实参infoLevel类型与对应的转换指示符 ’s ‘不匹配，正确的转换指示符要使用 ’d ‘。同样，实参infoMsg类型与对应的转换指示符 ’d ‘不匹配，正确的转换指示符要使用 ’s ‘。 这些用法会使程序产生未定义行为，比如：printf()将把infoLevel实参解释为指针，试图从infoLevel包含的地址中读取一个字符串，从而发生非法访问。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %s, infoMsg: %d\\n\", info_level, info_msg); ... } 【正确代码示例】 正确的做法是确保printf()函数的实参匹配format的转换指示符。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %d, infoMsg: %s\\n\", info_level, info_msg); ... } 【影响】 错误的格式串可能造成内存破坏或者程序异常终止。 ","date":"0001-01-01","objectID":"/securecoding/:15:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用alloca()函数申请栈上内存 【描述】 POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。 请使用malloc从堆中动态分配内存。 【影响】 程序栈的大小非常有限，如果分配导致栈溢出，则程序产生未定义行 ","date":"0001-01-01","objectID":"/securecoding/:16:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用realloc()函数 【描述】 realloc()是一个非常特殊的函数，原型如下： void *realloc(void *ptr, size_t size); 随着参数的不同，其行为也是不同： 当ptr不为NULL，且size不为0时，该函数会重新调整内存大小，并将新的内存指针返回，并保证最小的size的内容不变； 参数ptr为NULL，但size不为0，那么其行为等同于malloc(size)； 参数size为0，则realloc的行为等同于free(ptr)。 由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编程中提供了一些便利性，如果认识不足，使用不当，是却极易引发各种bug。 【错误代码示例】 如下代码示例中，使用realloc不当导致内存泄漏。 代码中希望对ptr的空间进行扩充，当realloc()分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的，如果直接将realloc()的返回值赋给ptr，那么ptr原来指向的内存就会丢失，造成内存泄漏。 // 当realloc()分配内存失败时会返回NULL，导致内存泄漏 char *ptr = (char *)realloc(ptr, NEW_SIZE); if (ptr == NULL) { ...// 错误处理 } 【正确代码示例】 使用malloc()函数代替realloc()函数。 // 使用malloc()函数代替realloc()函数 char *new_ptr = (char *)malloc(NEW_SIZE); if (new_ptr == NULL) { ... // 错误处理 } (void)memcpy(new_ptr, old_ptr, old_size); ... // 返回前，释放old_Ptr 【影响】 使用不当容易造成内存泄漏和双重释放问题。不正确的内存对齐可能导致对象访问异常。 ","date":"0001-01-01","objectID":"/securecoding/:17:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止外部可控数据作为进程启动函数的参数 【描述】 本条款中进程启动函数包括system、popen、execl、execlp、execle、execv、execvp等。 system()、popen()等函数会创建一个新的进程，如果外部可控数据作为这些函数的参数，会导致注入漏洞。 使用execl()、execlp()等函数执行新进程时，如果使用shell启动的新进程，则同样存在命令注入风险。 因此，总是优先考虑使用C标准函数实现需要的功能。如果确实需要使用这些函数，请使用白名单机制确保这些函数的参数不受任何外来数据的影响。 【错误代码示例】 如下代码示例中，使用 system() 函数执行 cmd 命令串来自外部，攻击者可以执行任意命令： char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } system(cmd); 如下代码示例中，使用 system() 函数执行 cmd 命令串的一部分来自外部，攻击者可能输入 ‘some dir;useradd xxx ‘字符串，创建一个xxx的用户： char cmd[MAX_LEN ]; int ret; char *name = get_dir_name_from_remote(); if (name == NULL) { ... // 处理错误 } ret = sprintf(cmd, \"ls %s\", name); ... system(cmd); 使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析器(如/bin/sh)。 int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); 例如，禁止如下使用方式： char *cmd = get_dir_name_from_remote(); execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL); 【正确代码示例】 (使用库函数) 在Linux下实现对当前目录下文件名的打印，可以使用opendir(), readdir(), stat()等函数直接实现ls-l命令的功能，不必使用system()函数。下面是一个简化的ls -l示例版本，列出一个由程序内部指定的文件的信息，该函数仅考虑了不需要重入的情况。 static int OutputFileInfo(const char *file_name) { const char priv[] = {'x', 'w', 'r'}; ASSERT(file_name != NULL); struct stat st; int ret = stat(file_name, \u0026st); if (ret == -1) { return -1; } const struct passwd *pw = getpwuid(st.st_uid); if (pw == NULL) { return -1; } const struct group *gp = getgrgid(st.st_gid); if (gp == NULL) { return -1; } if (S_ISREG(st.st_mode)) { printf(\"-\"); } else if (S_ISDIR(st.st_mode)) { printf(\"d\"); } for (int i = 8; i \u003e= 0; i --) { if ((st.st_mode \u0026 (1 \u003c \u003c i)) != 0) { printf(\"%c\", priv[i % 3]); } else { printf(\"-\"); } } printf(\"%s %s %ld %s\\n\", pw-\u003epw_name, gp-\u003egr_name, st.st_size, file_name); return 0; } 【正确代码示例】 (使用exec系列函数) 可以通过库函数简单实现的功能（如上例），需要避免调用命令处理器来执行外部命令。如果确实需要调用单个命令，应使用exec *函数来实现参数化调用，并对调用的命令实施白名单管理。 pid_t pid; char * const envp[] = { NULL }; ... char *file_name = get_dir_name_from_remote(); if (file_name == NULL) { ... // 处理错误 } ... if ((pid = fork()) \u003c 0) { ... } else if (pid == 0) { // 使用some_tool对指定文件进行加工 execle( \"/bin/some_tool\", \"some_tool\", file_name, NULL, envp); _Exit(-1); } ... int status; waitpid(pid, \u0026status, 0); FILE *fp = fopen(file_name, \"r\"); ... 此时，外部输入的file_name仅作为some_tool命令的参数，没有命令注入的风险。 【正确代码示例】 (使用白名单) 对输入的文件名基于合理的白名单检查，避免命令注入。 char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } // 使用白名单检查命令是否合法，仅允许 \"some_tool_a\", \"some_tool_b\"命令，外部无法随意控制 if (!is_valid_cmd(cmd)) { ... // 处理错误 } system(cmd); ... 【相关软件CWE编号】 CWE-676，CWE-88 ","date":"0001-01-01","objectID":"/securecoding/:18:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在信号处理例程中调用非异步安全函数 【描述】 在信号处理程序中只调用异步安全函数。 除了C语言标准函数以外，其他系统函数也提供了一些的异步安全函数，在信号处理程序中使用这些函数之前，应确保调用的函数在所有可能的执行环境下均是异步安全的。 【错误代码示例】 如下代码示例中，信号处理函数中调用了非异步安全函数printf()： void handler(int num) { printf(\"receive signal = %d \\n\", SIGINT); } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { ... // 程序主循环代码 } return 0; } 【正确代码示例】 如下代码示例中，尽量不在信号处理函数中调用其他函数，仅在信号处理程序中修改volatile sig_atomic_t类型的变量： static volatile sig_atomic_t g_flag = 0; void handler(int num) { g_flag = 1; } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { if (g_flag != 0) { printf(\"receive signal = %d\\n\", SIGINT); } ... // 程序主循环代码 } ... return 0; } 【相关软件CWE编号】 CWE-479 内存 ","date":"0001-01-01","objectID":"/securecoding/:19:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存分配后必须判断是否成功 【描述】 内存分配一旦失败，那么后续的操作会存在未定义的行为风险。比如malloc申请失败返回了空指针，对空指针的解引用是一种未定义行为。 【错误代码示例】 如下代码示例中，调用malloc分配内存之后，没有判断是否成功，直接引用了p。如果malloc失败，它将返回一个空指针并传递给p。当如下代码在内存拷贝中解引用了该空指针p时，程序会出现未定义行为。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm*)malloc(sizeof(*tmb)); tmb-\u003eyear = year; ... return tmb; } 【正确代码示例】 如下代码示例中，在malloc分配内存之后，立即判断其是否成功，消除了上述的风险。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm *)malloc(sizeof(*tmb)); if (tmb == NULL) { ... // 错误处理 } tmb-\u003eyear = year; ... return tmb; } ","date":"0001-01-01","objectID":"/securecoding/:20:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部输入作为内存操作相关函数的复制长度时，需要校验其合法性 【描述】 将数据复制到容量不足以容纳该数据的内存中会导致缓冲区溢出。为了防止此类错误，必须根据目标容量的大小限制被复制的数据大小，或者必须确保目标容量足够大以容纳要复制的数据。 【错误代码示例】 外部输入的数据不一定会直接作为内存复制长度使用，还可能会间接参与内存复制操作。 如下代码示例中，inputTable-\u003ecount来自外部报文，虽然没有直接作为内存复制长度使用，而是作为for循环体的上限使用，间接参与了内存复制操作。由于没有校验其大小，可造成缓冲区溢出： typedef struct { size_t count; int val[MAX_num_bERS]; } ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } 【正确代码示例】 如下代码示例中，对input_table-\u003ecount做了校验。 typedef struct { size_t count; int val[MAX_num_bERS]; }ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... / * - 根据应用场景，对来自外部报文的循环长度input_table-\u003ecount - 与output_table-\u003eval数组大小做校验，避免造成缓冲区溢出 */ if (input_table-\u003ecount \u003e sizeof(output_table-\u003eval) / sizeof(output_table-\u003eval[0]){ return NULL; } for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } ","date":"0001-01-01","objectID":"/securecoding/:21:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存中的敏感信息使用完毕后立即清0 【描述】 内存中的口令、密钥等敏感信息使用完毕后立即清0，避免被攻击者获取或者无意间泄漏给低权限用户。这里所说的内存包括但不限于： 动态分配的内存 静态分配的内存 自动分配（堆栈）内存 内存缓存 磁盘缓存 【错误代码示例】 通常内存在释放前不需要清除内存数据，因为这样在运行时会增加额外开销，所以在这段内存被释放之后，之前的数据还是会保留在其中。如果这段内存中的数据包含敏感信息，则可能会意外泄漏敏感信息。为了防止敏感信息泄漏，必须先清除内存中的敏感信息，然后再释放。 在如下代码示例中，存储在所引用的动态内存中的敏感信息secret被复制到新动态分配的缓冲区newSecret，最终通过free()释放。因为释放前未清除这块内存数据，这块内存可能被重新分配到程序的另一部分，之前存储在newSecret中的敏感信息可能会无意中被泄露。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... free(new_secret); new_secret = NULL; } ... 【正确代码示例】 如下代码示例中，为了防止信息泄漏，应先清除包含敏感信息的动态内存（用 ’ 0 ‘字符填充空间），然后再释放它。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... (void)memset(new_secret, 0, size + 1); free(new_secret); new_secret = NULL; } ... 【正确代码示例】 下面是另外一个涉及敏感信息清理的场景，在代码获取到密码后，将密码保存到password中，进行密码验证，使用完毕后，通过memset对password清0。 int foo(void) { char password [MAX_PWD_LEN ] = {0}; if (!get_password(password, sizeof(password))) { ... // 处理错误 } if (!verify_password(password)) { ... // 处理错误 } ... (void)memset(password, 0, sizeof(password)); ... } 文件 ","date":"0001-01-01","objectID":"/securecoding/:22:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"创建文件时必须显式指定合适的文件访问权限 【描述】 创建文件时，如果不显式指定合适访问权限，可能会让未经授权的用户访问该文件，造成信息泄露，文件数据被篡改，文件中被注入恶意代码等风险。 虽然文件的访问权限也依赖于文件系统，但是当前许多文件创建函数（例如POSIX open函数）都具有设置（或影响）文件访问权限的功能，所以当使用这些函数创建文件时，必须显式指定合适的文件访问权限，以防止意外访问。 【错误代码示例】 使用POSIX open()函数创建文件但未显示指定该文件的访问权限，可能会导致文件创建时具有过高的访问权限，这可能会导致漏洞。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name fd = open(file_name, O_CREAT | O_WRONLY); // 没有显式指定访问权限 if (fd == -1) { ... // 错误处理 } ... } 【正确代码示例】 应该在open的第三个参数中显式指定新创建文件的访问权限。可以根据文件实际的应用情况设置何种访问权限。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name 和指定其访问权限 // 此处根据文件实际需要，显式指定其访问权限 int fd = open(file_name, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR); if (fd == -1) { ... // 错误处理 } ... } ","date":"0001-01-01","objectID":"/securecoding/:23:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对文件路径进行规范化后再使用 【描述】 当文件路径来自外部数据时，必须对其做合法性校验，如果不校验，可能造成系统文件的被任意访问。但是禁止直接对其进行校验，正确做法是在校验之前必须对其进行路径规范化处理，因为： 同一个文件可以通过多种形式的路径来描述和引用，例如既可以是绝对路径，也可以是相对路径；而且路径名、目录名和文件名可能包含使校验变得困难和不准确的字符（如：\".\"、\"..\"）。此外，文件还可以是符号链接，这进一步模糊了文件的实际位置或标识，增加了校验的难度和校验准确性。所以必须先将文件路径规范化，从而更容易校验其路径、目录或文件名，增加校验准确性，如使用realpath函数。 一个简单的案例说明如下： 当文件路径来自外部数据时，需要先将文件路径规范化，如果没有作规范化处理，攻击者就有机会通过恶意构造文件路径进行文件的越权访问。 例如，攻击者可以构造\"../../../etc/passwd\"的方式进行任意文件访问。 【错误代码示例】 在此错误的示例中，argv[1]包含一个源于受污染源的文件名，并且该文件名已打开以进行写入。在使用此文件名操作之前，应该对其进行验证，以确保它引用的是预期的有效文件。 不幸的是，argv[1]引用的文件名可能包含特殊字符，例如目录字符，这使验证变得困难，甚至不可能。而且，argv[1]中可能包含可以指向任意文件路径的符号链接，即使该文件名通过了验证，也会导致该文件名是无效的。 这种场景下，对文件名的直接验证即使被执行也是得不到预期的结果，对fopen()的调用可能会导致访问一个意外的文件。 ... if (!verify_file(input_file_name) { // 没有对input_file_name做规范化，直接做校验 ... // 错误处理 } if (fopen(input_file_name, \"w\") == NULL) { ... // 错误处理 } ... 【正确代码示例】 规范化文件名是具有一定难度的，因为这需要了解底层文件系统。 POSIX realpath()函数可以帮助将路径名转换为规范形式。 对上面的错误代码示例，我们采用如下解决方案： char *real_path_res = NULL; ... // 在校验之前，先对input_file_name做规范化处理 real_path_res = realpath(input_file_name, NULL); if (real_path_res == NULL) { ... // 规范化的错误处理 } // 规范化以后对路径进行校验 if (!verify_file(real_path_res) { ... // 校验的错误处理 } // 使用 if (fopen(real_path_res, \"w\") == NULL) { ... // 实际操作的错误处理 } ... free(real_path_res); real_path_res = NULL; ... 【正确代码示例】 根据我们的实际场景，我们还可以采用的第二套解决方案，说明如下： 如果PATH_MAX被定义为中的一个常量，那么使用非空的resolved_path调用realpath()也是安全的。 在本例中realpath()函数期望resolved_path引用一个字符数组，该字符数组足够大，可以容纳规范化的路径。 如果定义了PATH_MAX，则分配一个大小为PATH_MAX的缓冲区来保存realpath()的结果。正确代码示例如下： char *real_path_res = NULL; char *canonical_file_name = NULL; size_t path_size = 0; ... path_size = (size_t)PATH_MAX; if (verify_path_size(path_size) == TRUE) { canonical_file_name = (char *)malloc(path_size); if (canonical_file_name == NULL) { ... // 错误处理 } real_path_res = realpath(inputFilename, canonical_file_name); } if (real_path_res == NULL) { ... // 错误处理 } if (verify_file(real_path_res) == FALSE) { ... // 错误处理 } if (fopen(real_path_res, \"w\") == NULL ) { ... // 错误处理 } ... free(canonical_file_name); canonical_file_name = NULL; ... 【错误代码示例】 下面的代码场景是从外部获取到文件名称，拼接成文件路径后，直接对文件内容进行读取，导致攻击者可以读取到任意文件的内容： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char *text = read_file_content(untrust_path); 【正确代码示例】 正确的做法是，对路径进行规范化后，再判断路径是否是本程序所认为的合法的路径： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char path[PATH_MAX] = {0}; if (realpath(untrust_path, path) == NULL) { ... // 处理错误 } if (!is_valid_path(path)) { // 检查文件的位置是否正确 ... // 处理错误 } char *text = read_file_content(path); 【例外】 运行于控制台的命令行程序，通过控制台手工输入文件路径，可以作为本条款例外。 int main(int argc, char **argv) { int fd = -1; if (argc == 2) { fd = open(argv[1], O_RDONLY); ... } ... } ","date":"0001-01-01","objectID":"/securecoding/:24:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在共享目录中创建临时文件 【描述】 程序的临时文件应当是程序自身独享的，任何将自身临时文件置于共享目录的做法，将导致其他共享用户获得该程序的额外信息，产生信息泄露。因此，不要在任何共享目录创建仅由程序自身使用的临时文件。 程序员通常会在共享目录中(例如在/tmp和/var/tmp创建临时文件，并且还有可能会定期清除这些临时文件(例如，每晚或重新启动期间)，但也可能不注意清理。 临时文件通常用于辅助保存不能驻留在内存中的数据或存储临时的数据，也可用作进程间通信的一种手段（通过文件系统传输数据）。例如，一个进程在共享目录中创建一个临时文件，该文件名可能使用了众所周知的名称或者一个临时的名称，然后就可以通过该文件在进程间共享信息。这种通过在共享目录中创建临时文件的方法实现进程间共享的做法很危险，因为共享目录中的这些文件很容易被攻击者劫持或操纵。这里有几种缓解策略： 1.使用其他低级IPC（进程间通信）机制，例如套接字或共享内存。 2.使用更高级别的IPC机制，例如远程过程调用。 3.使用仅能由程序本身访问的安全目录(多线程/进程下注意防止条件竞争)。 同时，下面列出了几项临时文件创建使用的方法，产品根据具体场景执行以下一项或者几项，同时产品也可以自定义合适的方法。 1.文件必须具有合适的权限，只有符合权限的用户才能访问 2.创建的文件名是唯一的、或不可预测的 3.仅当文件不存在时才创建打开(原子创建打开) 4.使用独占访问打开，避免竞争条件 5.在程序退出之前移除 同时也需要注意到，当某个目录被开放读/写权限给多个用户或者一组用户时，该共享目录潜在的安全风险远远大于访问该目录中临时文件这个功能的本身。 如果想安全地在共享目录中创建临时文件，而不受威胁是不容易的。例如，用于本地挂载的文件系统的代码在与远程挂载的文件系统一起共享使用时可能会受到攻击。而且上面的函数安全版本还受限于所使用的C运行时库、操作系统和文件系统的版本。唯一安全的解决方案是不要在共享目录中创建临时文件。 【错误代码示例】 如下代码示例，程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。 由于文件名是硬编码的，因此是可预测的，攻击者只需用符号链接替换文件，然后链接所引用的目标文件就会被打开并写入新内容。 void proc_data(const char *file_name) { FILE *fp = fopen(file_name, \"wb+\"); if (fp == NULL) { ... // 错误处理 } ... // 写文件 fclose(fp); } int main(void) { // 不合规：1.在系统共享目录中创建临时文件；2.临时文件名硬编码 char *real_file = \"/tmp/data\"; ... proc_data(real_file); ... return 0; } 【正确案例】 Linux下的/tmp目录是一个所有用户都可以访问的共享目录，不应在该目录下创建仅由程序自身使用的临时文件。 【业界典型漏洞】CVE-2004-2502 其它 ","date":"0001-01-01","objectID":"/securecoding/:25:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在信号处理函数中访问共享对象 【描述】 在信号处理程序中访问和修改共享对象可能会造成竞争条件，使数据处于不确定的状态。 这条规则有两个不适用的场景（C11标准第5.1.2.3章节第5段）是： 1） 读写不需要加锁的原子对象; 2）读写volatile sig_atomic_t类型的对象，因为具有volatile sig_atomic_t类型的对象即使在出现异步中断的时候也可以作为一个原子实体访问，是异步安全的。 此外，在信号处理程序中，如果要调用函数，请仅调用异步信号安全函数。 【错误代码示例】 在这个信号处理过程中，程序打算将p_msg作为共享对象，当产生SIGINT信号时更新共享对象的内容，但是该p_msg变量类型不是volatile sig_atomic_t，所以不是异步安全的。 #define MAX_MSG_SIZE 32 static char g_msg_buf[MAX_MSG_SIZE] = {0}; static char *g_msg = g_msg_buf; void signal_handler(int signum) { // 下面代码操作g_msg不合规，因为不是异步安全的 (void)memset(g_msg, 0, MAX_MSG_SIZE); strcpy(g_msg, \"signal SIGINT received.\"); ... // } int main(void) { strcpy(g_msg, \"No msg yet.\"); // 初始化消息内容 signal(SIGINT, signal_handler); // 设置SIGINT信号对应的处理函数 ... // 程序主循环代码 return 0; } 【正确代码示例】 如下代码示例中，在信号处理函数中仅将volatile sig_atomic_t类型作为共享对象使用。 #define MAX_MSG_SIZE 32 volatile sig_atomic_t g_sig_flag = 0; void signal_handler(int signum) { g_sig_flag = 1; // 合规 } int main(void) { signal(SIGINT, signal_handler); char msg_buf[MAX_MSG_SIZE]; strcpy(msg_buf, \"No msg yet.\"); // 初始化消息内容 ... // 程序主循环代码 if (g_sig_flag == 1) { // 在退出主循环之后，根据sigFlag状态再刷新消息内容 strcpy(msgBuf, \"signal SIGINT received.\"); } return 0; } 【相关软件CWE编号】 CWE-662，CWE-828 ","date":"0001-01-01","objectID":"/securecoding/:26:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁用rand函数产生用于安全用途的伪随机数 【描述】 C语言标准库rand()函数生成的是伪随机数，所以不能保证其产生的随机数序列质量。所以禁止使用rand()函数产生的随机数用于安全用途，必须使用安全的随机数产生方式，如： /dev/random文件。 典型的安全用途场景包括(但不限于)以下几种： 会话标识SessionID的生成； 挑战算法中的随机数生成； 验证码的随机数生成； 用于密码算法用途（例如用于生成IV、盐值、密钥等）的随机数生成。 【错误代码示例】 程序员期望生成一个唯一的不可被猜测的HTTP会话ID，但该ID是通过调用rand()函数产生的数字随机数，它的ID是可猜测的，并且随机性有限。 【正确代码示例】(POSIX) 可以使用/dev/random文件得到随机数。 【影响】 使用rand()函数可能造成可预测的随机数。 内核操作 ","date":"0001-01-01","objectID":"/securecoding/:27:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核mmap接口实现中，确保对映射起始地址和大小进行合法性校验 【描述】 **说明：**Linux内核 mmap接口中，经常使用remap_pfn_range()函数将设备物理内存映射到用户进程空间。如果映射起始地址等参数由用户态控制并缺少合法性校验，将导致用户态可通过映射读写任意内核地址。如果攻击者精心构造传入参数，甚至可在内核中执行任意代码。 【错误代码示例】 如下代码在使用remap_pfn_range()进行内存映射时，未对用户可控的映射起始地址和空间大小进行合法性校验，可导致内核崩溃或任意代码执行。 static int incorrect_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); //错误：未对映射起始地址、空间大小做合法性校验 if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log(\"%s, remap_pfn_range fail\", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } 【正确代码示例】 增加对映射起始地址等参数的合法性校验。 static int correct_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; //修改：添加校验函数，验证映射起始地址、空间大小是否合法 if (!valid_mmap_phys_addr_range(vma-\u003evm_pgoff, size)) { return EINVAL; } vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log( \"%s, remap_pfn_range fail \", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } ","date":"0001-01-01","objectID":"/securecoding/:28:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核程序中必须使用内核专用函数读写用户态缓冲区 【描述】 用户态与内核态之间进行数据交换时，如果在内核中不加任何校验（如校验地址范围、空指针）而直接引用用户态传入指针，当用户态传入非法指针时，可导致内核崩溃、任意地址读写等问题。因此，应当禁止使用memcpy()、sprintf()等危险函数，而是使用内核提供的专用函数：copy_from_user()、copy_to_user()、put_user()和get_user()来读写用户态缓冲区，这些函数内部添加了入参校验功能。 所有禁用函数列表为：memcpy()、bcopy()、memmove()、strcpy()、strncpy()、strcat()、strncat()、sprintf()、vsprintf()、snprintf()、vsnprintf()、sscanf()、vsscanf()。 【错误代码示例】 内核态直接使用用户态传入的buf指针作为snprintf()的参数，当buf为NULL时，可导致内核崩溃。 ssize_t incorrect_show(struct file *file, char__user *buf, size_t size, loff_t *data) { // 错误：直接引用用户态传入指针，如果buf为NULL，则空指针异常导致内核崩溃 return snprintf(buf, size, \"%ld\\n\", debug_level); } 【正确代码示例】 使用copy_to_user()函数代替snprintf()。 ssize_t correct_show(struct file *file, char __user *buf, size_t size, loff_t *data) { int ret = 0; char level_str[MAX_STR_LEN] = {0}; snprintf(level_str, MAX_STR_LEN, \"%ld \\n\", debug_level); if(strlen(level_str) \u003e= size) { return EFAULT; } // 修改：使用专用函数copy_to_user()将数据写入到用户态buf，并注意防止缓冲区溢出 ret = copy_to_user(buf, level_str, strlen(level_str)+1); return ret; } 【错误代码示例】 内核态直接使用用户态传入的指针user_buf作为数据源进行memcpy()操作，当user_buf为NULL时，可导致内核崩溃。 size_t incorrect_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf [128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 错误：直接引用用户态传入指针，如果user_buf为NULL，则可导致内核崩溃 (void)memcpy(buf, user_buf, buf_size); ... } 【正确代码示例】 使用copy_from_user()函数代替memcpy()。 ssize_t correct_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf[128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 修改：使用专用函数copy_from_user()将数据写入到内核态buf，并注意防止缓冲区溢出 if (copy_from_user(buf, user_buf, buf_size)) { return EFAULT; } ... } ","date":"0001-01-01","objectID":"/securecoding/:29:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_from_user()拷贝长度进行校验，防止缓冲区溢出 **说明：**内核态从用户态拷贝数据时通常使用copy_from_user()函数，如果未对拷贝长度做校验或者校验不当，会造成内核缓冲区溢出，导致内核panic或提权。 【错误代码示例】 未校验拷贝长度。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))) {...} // 错误：拷贝长度参数smd_write_arg.size由用户输入，未校验 copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } 【正确代码示例】 添加长度校验。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))){...} // 修改：添加校验 if (smd_write_arg.size \u003e= GSERIAL_BUF_LEN) {......} copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } ","date":"0001-01-01","objectID":"/securecoding/:30:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_to_user()拷贝的数据进行初始化，防止信息泄漏 【描述】 **说明：**内核态使用copy_to_user()向用户态拷贝数据时，当数据未完全初始化（如结构体成员未赋值、字节对齐引起的内存空洞等），会导致栈上指针等敏感信息泄漏。攻击者可利用绕过kaslr等安全机制。 【错误代码示例】 未完全初始化数据结构成员。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; // 错误: info结构体有4个成员，未全部赋值 ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } 【正确代码示例】 全部进行初始化。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; // 修改：使用memset初始化缓冲区，保证不存在因字节对齐或未赋值导致的内存空洞 (void)memset(\u0026info, '0', sizeof(ep_info)); switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } ","date":"0001-01-01","objectID":"/securecoding/:31:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在异常处理中使用BUG_ON宏，避免造成内核panic 【描述】 BUG_ON宏会调用内核的panic()函数，打印错误信息并主动崩溃系统，在正常逻辑处理中（如ioctl接口的cmd参数不识别）不应当使系统崩溃，禁止在此类异常处理场景中使用BUG_ON宏，推荐使用WARN_ON宏。 【错误代码示例】 正常流程中使用了BUG_ON宏 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 错误：系统BUG_ON宏打印调用栈后调用panic()，导致内核拒绝服务，不应在正常流程中使用 BUG_ON(1); return 1; } ... } 【正确代码示例】 去掉BUG_ON宏。 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 修改：去掉BUG_ON调用，或使用WARN_ON return 1; } ... } ","date":"0001-01-01","objectID":"/securecoding/:32:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"在中断处理程序或持有自旋锁的进程上下文代码中，禁止使用会引起进程休眠的函数 【描述】 Linux以进程为调度单位，在Linux中断上下文中，只有更高优先级的中断才能将其打断，系统在中断处理的时候不能进行进程调度。如果中断处理程序处于休眠状态，就会导致内核无法唤醒，从而使得内核处于瘫痪。 自旋锁在使用时，抢占是失效的。若自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其它进程都将因为不能获得CPU（单核CPU）而停止运行，对外表现为系统将不作任何响应，出现挂死。 因此，在中断处理程序或持有自旋锁的进程上下文代码中，应该禁止使用可能会引起休眠（如vmalloc()、msleep()等）、阻塞（如copy_from_user(),copy_to_user()等）或者耗费大量时间（如printk()等）的函数。 ","date":"0001-01-01","objectID":"/securecoding/:33:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"合理使用内核栈，防止内核栈溢出 【描述】 Linux的内核栈大小是固定的（一般32位系统为8K，64位系统为16K，因此资源非常宝贵。不合理的使用内核栈，可能会导致栈溢出，造成系统挂死。因此需要做到以下几点： 在栈上申请内存空间不要超过内核栈大小； 注意函数的嵌套使用次数； 不要定义过多的变量。 【错误代码示例】 以下代码中定义的变量过大，导致栈溢出。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result temp[512]; // 错误: temp数组含有512个元素，总大小为10K，远超内核栈大小 (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something return 0; } ... 代码中数组temp有512个元素，总共10K大小，远超内核的8K，明显的栈溢出。 【正确代码示例】 使用kmalloc()代替之。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result *temp = NULL; temp = (result *)kmalloc(sizeof(result) * 512, GFP_KERNEL); //修改：使用kmalloc()申请内存 ... // check temp is not NULL (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something ... // free temp return 0; } ... ","date":"0001-01-01","objectID":"/securecoding/:34:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"临时关闭地址校验机制后，在操作完成后必须及时恢复 【描述】 SMEP安全机制是指禁止内核执行用户空间的代码（PXN是ARM版本的SMEP）。系统调用（如open()，write()等）本来是提供给用户空间程序访问的。默认情况下，这些函数会对传入的参数地址进行校验，如果入参是非用户空间地址则报错。因此，要在内核程序中使用这些系统调用，就必须使参数地址校验功能失效。set_fs()/get_fs()就用来解决该问题。详细说明见如下代码： ... mmegment_t old_fs; printk(\"Hello, I'm the module that intends to write message to file.\\n\"); if (file == NULL) { file = filp_open(MY_FILE, O_RDWR | O_APPEND | O_CREAT, 0664); } if (IS_ERR(file)) { printk(\"Error occured while opening file %s, exiting ...\\n\", MY_FILE); return 0; } sprintf(buf, \"%s\", \"The Message.\"); old_fs = get_fs(); // get_fs()的作用是获取用户空间地址上限值 // #define get_fs() (current-\u003eaddr_limit set_fs(KERNEL_DS); // set_fs的作用是将地址空间上限扩大到KERNEL_DS，这样内核代码可以调用系统函数 file-\u003ef_op-\u003ewrite(file, (char *)buf, sizeof(buf), \u0026file-\u003ef_pos); // 内核代码可以调用write()函数 set_fs(old_fs); // 使用完后及时恢复原来用户空间地址限制值 ... 通过上述代码，可以了解到最为关键的就是操作完成后，要及时恢复地址校验功能。否则SMEP/PXN安全机制就会失效，使得许多漏洞的利用变得很容易。 【错误代码示例】 在程序错误处理分支，未通过set_fs()恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d]\\n\", path, fd); return; // 错误：在错误处理程序分支未恢复地址校验机制 } sys_close(fd); set_fs(oldfs); ... 【正确代码示例】 在错误处理程序中恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d] \\n\", path, fd); set_fs(oldfs); // 修改：在错误处理程序分支中恢复地址校验机制 return; } sys_close(fd); set_fs(oldfs); ... ","date":"0001-01-01","objectID":"/securecoding/:35:0","tags":null,"title":"","uri":"/securecoding/"}]