[{"categories":["Rust"],"content":"Rust 项目配置 Github Action ","date":"2024-06-20","objectID":"/rust%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEgithub-action/:0:0","tags":["Github Action"],"title":"Rust项目配置Github Action","uri":"/rust%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEgithub-action/"},{"categories":["Rust"],"content":"多平台编译的几种方式 ","date":"2024-06-20","objectID":"/rust%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEgithub-action/:1:0","tags":["Github Action"],"title":"Rust项目配置Github Action","uri":"/rust%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEgithub-action/"},{"categories":["Rust"],"content":"1. 在多个平台上分别编译 name: cross-release on: workflow_dispatch: push: tags: - '**' env: # The project name specified in your Cargo.toml PROJECT_NAME: action-demo jobs: release: runs-on: ${{ matrix.runner }} strategy: matrix: # You can add more, for any target you'd like! include: - name: linux-amd64-gnu runner: ubuntu-latest target: x86_64-unknown-linux-gnu - name: linux-amd64-musl runner: ubuntu-latest target: x86_64-unknown-linux-musl - name: macos-amd64 runner: macos-latest target: x86_64-apple-darwin - name: macos-arm64 runner: macos-latest target: aarch64-apple-darwin - name: windows-amd64 runner: windows-latest target: x86_64-pc-windows-msvc - name: windows-gnu runner: windows-latest target: x86_64-pc-windows-gnu steps: - name: Checkout uses: actions/checkout@v3 - name: Install Rust uses: dtolnay/rust-toolchain@stable with: targets: \"${{ matrix.target }}\" - name: Build Binary run: cargo build --verbose --locked --release --target ${{ matrix.target }} - name: Release Binary shell: bash run: | BIN_SUFFIX=\"\" if [[ \"${{ matrix.runner }}\" == \"windows-latest\" ]]; then BIN_SUFFIX=\".exe\" fi ls target/* # The built binary output location BIN_OUTPUT=\"target/${{ matrix.target }}/release/${PROJECT_NAME}${BIN_SUFFIX}\" # Define a better name for the final binary BIN_RELEASE=\"${PROJECT_NAME}-${{ matrix.name }}${BIN_SUFFIX}\" BIN_RELEASE_VERSIONED=\"${PROJECT_NAME}-${{ github.ref_name }}-${{ matrix.name }}${BIN_SUFFIX}\" tar -zcf \"${PROJECT_NAME}.tar.gz\" \"${BIN_OUTPUT}\" # Move the built binary where you want it # mv \"${BIN_OUTPUT}\" \"./\u003cyour-destination\u003e/${BIN_RELEASE}\" - name : upload binary uses: actions/upload-artifact@master if: always() with: name: ${{ matrix.name }} path: ./*.tar.gz ","date":"2024-06-20","objectID":"/rust%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEgithub-action/:1:1","tags":["Github Action"],"title":"Rust项目配置Github Action","uri":"/rust%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEgithub-action/"},{"categories":["golang"],"content":"Goang标准库例子 第一章 输入输出 (Input/Output) 一般的，计算机程序是：输入 (Input) 经过算法处理产生输出 (Output)。各种语言一般都会提供IO库供开发者使用。Go语言也不例外。 Go 语言中，为了方便开发者使用，将 IO 操作封装在了如下几个包中： io 为 IO 原语（I/O primitives）提供基本的接口 io/ioutil 封装一些实用的 I/O 函数 fmt 实现格式化 I/O，类似 C 语言中的 printf 和 scanf bufio 实现带缓冲I/O 本章会详细介绍这些 IO 包提供的函数、类型和方法，同时通过实例讲解这些包的使用方法。 1.1 io — 基本的 IO 接口 io 包为 I/O 原语提供了基本的接口。它主要包装了这些原语的已有实现。 由于这些被接口包装的I/O原语是由不同的低级操作实现，因此，在另有声明之前不该假定它们的并发执行是安全的。 在 io 包中最重要的是两个接口：Reader 和 Writer 接口。本章所提到的各种 IO 包，都跟这两个接口有关，也就是说，只要满足这两个接口，它就可以使用 IO 包的功能。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:0:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Reader 接口 Reader 接口的定义如下： type Reader interface { Read(p []byte) (n int, err error) } 官方文档中关于该接口方法的说明： Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 \u003c= n \u003c= len(p)） 以及任何遇到的错误。即使 Read 返回的 n \u003c len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。若可读取的数据不到 len(p) 个字节，Read 会返回可用数据，而不是等待更多数据。 当 Read 在成功读取 n \u003e 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会同时在本次的调用中返回一个non-nil错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, Reader会返回一个非0字节数n, 若 n = len(p) 个字节从输入源的结尾处由 Read 返回，Read可能返回 err == EOF 或者 err == nil。并且之后的 Read() 都应该返回 (n:0, err:EOF)。 调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许EOF的出现。 根据 Go 语言中关于接口和满足了接口的类型的定义（Interface_types），我们知道 Reader 接口的方法集（Method_sets）只包含一个 Read 方法，因此，所有实现了 Read 方法的类型都满足 io.Reader 接口，也就是说，在所有需要 io.Reader 的地方，可以传递实现了 Read() 方法的类型的实例。 下面，我们通过具体例子来谈谈该接口的用法。 func ReadFrom(reader io.Reader, num int) ([]byte, error) { p := make([]byte, num) n, err := reader.Read(p) if n \u003e 0 { return p[:n], nil } return p, err } ReadFrom 函数将 io.Reader 作为参数，也就是说，ReadFrom 可以从任意的地方读取数据，只要来源实现了 io.Reader 接口。比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下： // 从标准输入读取 data, err = ReadFrom(os.Stdin, 11) // 从普通文件读取，其中 file 是 os.File 的实例 data, err = ReadFrom(file, 9) // 从字符串读取 data, err = ReadFrom(strings.NewReader(\"from string\"), 12) 完整的演示例子源码见 code/src/chapter01/io/reader.go 小贴士 io.EOF 变量的定义：var EOF = errors.New(\"EOF\")，是 error 类型。根据 reader 接口的说明，在 n \u003e 0 且数据被读完了的情况下，返回的 error 有可能是 EOF 也有可能是 nil。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:1:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Writer 接口 Writer 接口的定义如下： type Writer interface { Write(p []byte) (n int, err error) } 官方文档中关于该接口方法的说明： Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 \u003c= n \u003c= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n \u003c len(p)，它就必须返回一个 非nil 的错误。 同样的，所有实现了Write方法的类型都实现了 io.Writer 接口。 在上个例子中，我们是自己实现一个函数接收一个 io.Reader 类型的参数。这里，我们通过标准库的例子来学习。 在fmt标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个 io.Wrtier 类型参数（第一个参数），也就是说它们将数据格式化输出到 io.Writer 中。那么，调用这组函数时，该如何传递这个参数呢？ 我们以 fmt.Fprintln 为例，同时看一下 fmt.Println 函数的源码。 func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } 很显然，fmt.Println会将内容输出到标准输出中。下一节我们将详细介绍fmt包。 关于 io.Writer 的更多说明，可以查看笔者之前写的博文《以io.Writer为例看go中的interface{}》。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:2:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实现了 io.Reader 接口或 io.Writer 接口的类型 初学者看到函数参数是一个接口类型，很多时候有些束手无策，不知道该怎么传递参数。还有人问：标准库中有哪些类型实现了 io.Reader 或 io.Writer 接口？ 通过本节上面的例子，我们可以知道，os.File 同时实现了这两个接口。我们还看到 os.Stdin/Stdout 这样的代码，它们似乎分别实现了 io.Reader/io.Writer 接口。没错，实际上在 os 包中有这样的代码： var ( Stdin = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\") Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\") Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\") ) 也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件类型的标识（即都是 os.File 的实例），自然也实现了 io.Reader 和 io.Writer。 目前，Go 文档中还没有直接列出实现了某个接口的所有类型。不过，我们可以通过查看标准库文档，列出实现了 io.Reader 或 io.Writer 接口的类型（导出的类型）：（注：godoc 命令支持额外参数 -analysis ，能列出都有哪些类型实现了某个接口，相关参考 godoc -h 或 Static analysis features of godoc。另外，我做了一个官网镜像，能查看接口所有的实现类型，地址：http://docs.studygolang.com。 os.File 同时实现了 io.Reader 和 io.Writer strings.Reader 实现了 io.Reader bufio.Reader/Writer 分别实现了 io.Reader 和 io.Writer bytes.Buffer 同时实现了 io.Reader 和 io.Writer bytes.Reader 实现了 io.Reader compress/gzip.Reader/Writer 分别实现了 io.Reader 和 io.Writer crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和 io.Writer crypto/tls.Conn 同时实现了 io.Reader 和 io.Writer encoding/csv.Reader/Writer 分别实现了 io.Reader 和 io.Writer mime/multipart.Part 实现了 io.Reader net/conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read/Write) 除此之外，io 包本身也有这两个接口的实现类型。如： 实现了 Reader 的类型：LimitedReader、PipeReader、SectionReader\r实现了 Writer 的类型：PipeWriter\r以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader 小贴士 从接口名称很容易猜到，一般地， Go 中接口的命名约定：接口名以 er 结尾。注意，这里并非强行要求，你完全可以不以 er 结尾。标准库中有些接口也不是以 er 结尾的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:3:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReaderAt 和 WriterAt 接口 ReaderAt 接口的定义如下： type ReaderAt interface { ReadAt(p []byte, off int64) (n int, err error) } 官方文档中关于该接口方法的说明： ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 \u003c= n \u003c= len(p)）以及任何遇到的错误。 当 ReadAt 返回的 n \u003c len(p) 时，它就会返回一个 非nil 的错误来解释 为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。 即使 ReadAt 返回的 n \u003c len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若可读取的数据不到 len(p) 字节，ReadAt 就会阻塞,直到所有数据都可用或一个错误发生。 在这一点上 ReadAt 不同于 Read。 若 n = len(p) 个字节从输入源的结尾处由 ReadAt 返回，Read可能返回 err == EOF 或者 err == nil 若 ReadAt 携带一个偏移量从输入源读取，ReadAt 应当既不影响偏移量也不被它所影响。 可对相同的输入源并行执行 ReadAt 调用。 可见，ReaderAt 接口使得可以从指定偏移量处开始读取数据。 简单示例代码如下： reader := strings.NewReader(\"Go语言中文网\") p := make([]byte, 6) n, err := reader.ReadAt(p, 2) if err != nil { panic(err) } fmt.Printf(\"%s, %d\\n\", p, n) 输出： 语言, 6\rWriterAt 接口的定义如下： type WriterAt interface { WriteAt(p []byte, off int64) (n int, err error) } 官方文档中关于该接口方法的说明： WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。它返回从 p 中被写入的字节数 n（0 \u003c= n \u003c= len(p)）以及任何遇到的引起写入提前停止的错误。若 WriteAt 返回的 n \u003c len(p)，它就必须返回一个 非nil 的错误。 若 WriteAt 携带一个偏移量写入到目标中，WriteAt 应当既不影响偏移量也不被它所影响。 若被写区域没有重叠，可对相同的目标并行执行 WriteAt 调用。 我们可以通过该接口将数据写入到数据流的特定偏移量之后。 通过简单示例来演示 WriteAt 方法的使用（os.File 实现了 WriterAt 接口）： file, err := os.Create(\"writeAt.txt\") if err != nil { panic(err) } defer file.Close() file.WriteString(\"Golang中文社区——这里是多余\") n, err := file.WriteAt([]byte(\"Go语言中文网\"), 24) if err != nil { panic(err) } fmt.Println(n) 打开文件 WriteAt.txt，内容是：Golang中文社区——Go语言中文网。 分析： file.WriteString(\"Golang中文社区——这里是多余\") 往文件中写入 Golang中文社区——这里是多余，之后 file.WriteAt([]byte(\"Go语言中文网\"), 24) 在文件流的 offset=24 处写入 Go语言中文网（会覆盖该位置的内容）。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:4:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReaderFrom 和 WriterTo 接口 ReaderFrom 的定义如下： type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) } 官方文档中关于该接口方法的说明： ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。 如果 ReaderFrom 可用，Copy 函数就会使用它。 注意：ReadFrom 方法不会返回 err == EOF。 下面的例子简单的实现将文件中的数据全部读取（显示在标准输出）： file, err := os.Open(\"writeAt.txt\") if err != nil { panic(err) } defer file.Close() writer := bufio.NewWriter(os.Stdout) writer.ReadFrom(file) writer.Flush() 当然，我们可以通过 ioutil 包的 ReadFile 函数获取文件全部内容。其实，跟踪一下 ioutil.ReadFile 的源码，会发现其实也是通过 ReadFrom 方法实现（用的是 bytes.Buffer，它实现了 ReaderFrom 接口）。 如果不通过 ReadFrom 接口来做这件事，而是使用 io.Reader 接口，我们有两种思路： 先获取文件的大小（File 的 Stat 方法），之后定义一个该大小的 []byte，通过 Read 一次性读取 定义一个小的 []byte，不断的调用 Read 方法直到遇到 EOF，将所有读取到的 []byte 连接到一起 这里不给出实现代码了，有兴趣的可以实现一下。 提示 通过查看 bufio.Writer 或 strings.Buffer 类型的 ReadFrom 方法实现，会发现，其实它们的实现和上面说的第 2 种思路类似。 WriterTo的定义如下： type WriterTo interface { WriteTo(w Writer) (n int64, err error) } 官方文档中关于该接口方法的说明： WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。 如果 WriterTo 可用，Copy 函数就会使用它。 读者是否发现，其实 ReaderFrom 和 WriterTo 接口的方法接收的参数是 io.Reader 和 io.Writer 类型。根据 io.Reader 和 io.Writer 接口的讲解，对该接口的使用应该可以很好的掌握。 这里只提供简单的一个示例代码：将一段文本输出到标准输出 reader := bytes.NewReader([]byte(\"Go语言中文网\")) reader.WriteTo(os.Stdout) 通过 io.ReaderFrom 和 io.WriterTo 的学习，我们知道，如果这样的需求，可以考虑使用这两个接口：“一次性从某个地方读或写到某个地方去。” ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:5:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Seeker 接口 接口定义如下： type Seeker interface { Seek(offset int64, whence int) (ret int64, err error) } 官方文档中关于该接口方法的说明： Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。 也就是说，Seek 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 ReaderAt/WriteAt 接口有些类似，不过 Seeker 接口更灵活，可以更好的控制读写数据流的位置。 简单的示例代码：获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例） reader := strings.NewReader(\"Go语言中文网\") reader.Seek(-6, io.SeekEnd) r, _, _ := reader.ReadRune() fmt.Printf(\"%c\\n\", r) 小贴士 whence 的值，在 io 包中定义了相应的常量，应该使用这些常量 const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end ) 而原先 os 包中的常量已经被标注为Deprecated // Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. const ( SEEK_SET int = 0 // seek relative to the origin of the file SEEK_CUR int = 1 // seek relative to the current offset SEEK_END int = 2 // seek relative to the end ) ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:6:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Closer接口 接口定义如下： type Closer interface { Close() error } 该接口比较简单，只有一个 Close() 方法，用于关闭数据流。 文件 (os.File)、归档（压缩包）、数据库连接、Socket 等需要手动关闭的资源都实现了 Closer 接口。 实际编程中，经常将 Close 方法的调用放在 defer 语句中。 小提示 初学者容易写出这样的代码： file, err := os.Open(\"studygolang.txt\") defer file.Close() if err != nil { ... } 当文件 studygolang.txt 不存在或找不到时，file.Close() 会 panic，因为 file 是 nil。因此，应该将 defer file.Close() 放在错误检查之后。 经过 issue40 提醒，查看源码： func (f *File) Close() error { if f == nil { return ErrInvalid } return f.file.close() } 可见并不会 panic，但在 Close 之前校验错误是个好习惯！ ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:7:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"其他接口 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:8:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ByteReader 和 ByteWriter 通过名称大概也能猜出这组接口的用途：读或写一个字节。接口定义如下： type ByteReader interface { ReadByte() (c byte, err error) } type ByteWriter interface { WriteByte(c byte) error } 在标准库中，有如下类型实现了 io.ByteReader 或 io.ByteWriter: bufio.Reader/Writer 分别实现了io.ByteReader 和 io.ByteWriter bytes.Buffer 同时实现了 io.ByteReader 和 io.ByteWriter bytes.Reader 实现了 io.ByteReader strings.Reader 实现了 io.ByteReader 接下来的示例中，我们通过 bytes.Buffer 来一次读取或写入一个字节（主要代码）： var ch byte fmt.Scanf(\"%c\\n\", \u0026ch) buffer := new(bytes.Buffer) err := buffer.WriteByte(ch) if err == nil { fmt.Println(\"写入一个字节成功！准备读取该字节……\") newCh, _ := buffer.ReadByte() fmt.Printf(\"读取的字节：%c\\n\", newCh) } else { fmt.Println(\"写入错误\") } 程序从标准输入接收一个字节（ASCII 字符），调用 buffer 的 WriteByte 将该字节写入 buffer 中，之后通过 ReadByte 读取该字节。完整的代码见：code/src/chapter01/io/byterwer.go 一般地，我们不会使用 bytes.Buffer 来一次读取或写入一个字节。那么，这两个接口有哪些用处呢？ 在标准库 encoding/binary 中，实现Google-ProtoBuf中的 Varints 读取，ReadVarint 就需要一个 io.ByteReader 类型的参数，也就是说，它需要一个字节一个字节的读取。关于 encoding/binary 包在后面会详细介绍。 在标准库 image/jpeg 中，Encode函数的内部实现使用了 ByteWriter 写入一个字节。 小贴士 可以通过在 Go 语言源码 src/pkg 中搜索 “io.ByteReader” 或 “io.ByteWiter”，获得哪些地方用到了这两个接口。你会发现，这两个接口在二进制数据或归档压缩时用的比较多。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:8:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ByteScanner、RuneReader 和 RuneScanner 将这三个接口放在一起，是考虑到与 ByteReader 相关或相应。 ByteScanner 接口的定义如下： type ByteScanner interface { ByteReader UnreadByte() error } 可见，它内嵌了 ByteReader 接口（可以理解为继承了 ByteReader 接口），UnreadByte 方法的意思是：将上一次 ReadByte 的字节还原，使得再次调用 ReadByte 返回的结果和上一次调用相同，也就是说，UnreadByte 是重置上一次的 ReadByte。注意，UnreadByte 调用之前必须调用了 ReadByte，且不能连续调用 UnreadByte。即： buffer := bytes.NewBuffer([]byte{'a', 'b'}) err := buffer.UnreadByte() 和 buffer := bytes.NewBuffer([]byte{'a', 'b'}) buffer.ReadByte() err := buffer.UnreadByte() err = buffer.UnreadByte() err 都 非nil，错误为：bytes.Buffer: UnreadByte: previous operation was not a read RuneReader 接口和 ByteReader 类似，只是 ReadRune 方法读取单个 UTF-8 字符，返回其 rune 和该字符占用的字节数。该接口在 regexp 包有用到。 之前有人在QQ群中问道： strings.Index(“行业交流群”, “交流”) 返回的是单字节字符的位置：6。但是想要的是 unicode 字符的位置：2。 这里借助utf8的RuneCountInString函数,实现代码如下： // strings.Index 的 UTF-8 版本 // 即 Utf8Index(\"Go语言中文网\", \"中文\") 返回 4，而不是 strings.Index 的 8 func Utf8Index(str, substr string) int { index := strings.Index(str, substr) if index \u003c 0{ return -1 } return utf8.RuneCountInString(str[:index]) } RuneScanner 接口和 ByteScanner 类似，就不赘述了。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:8:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker 接口 这些接口是上面介绍的接口的两个或三个组合而成的新接口。例如 ReadWriter 接口： type ReadWriter interface { Reader Writer } 这是 Reader 接口和 Writer 接口的简单组合（内嵌）。 这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。可见，io 包中有大量的“小接口”，这样方便组合为“大接口”。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:8:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"SectionReader 类型 SectionReader 是一个 struct（没有任何导出的字段），实现了 Read, Seek 和 ReadAt，同时，内嵌了 ReaderAt 接口。结构定义如下： type SectionReader struct { r ReaderAt // 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现 base int64 // NewSectionReader 会将 base 设置为 off off int64 // 从 r 中的 off 偏移处开始读取数据 limit int64 // limit - off = SectionReader 流的长度 } 从名称我们可以猜到，该类型读取数据流中部分数据。看一下 func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader 的文档说明就知道了： NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。 也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。 这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。 由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。 关于该类型在标准库中的使用，我们在 8.5 archive/zip — zip归档访问 会讲到。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:9:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"LimitedReader 类型 LimitedReader 结构定义如下： type LimitedReader struct { R Reader // underlying reader，最终的读取操作通过 R.Read 完成 N int64 // max bytes remaining } 文档说明如下： 从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。 也就是说，最多只能返回 N 字节数据。 LimitedReader 只实现了 Read 方法（Reader 接口）。 使用示例如下： content := \"This Is LimitReader Example\" reader := strings.NewReader(content) limitReader := \u0026io.LimitedReader{R: reader, N: 8} for limitReader.N \u003e 0 { tmp := make([]byte, 2) limitReader.Read(tmp) fmt.Printf(\"%s\", tmp) } 输出： This Is\r可见，通过该类型可以达到 只允许读取一定长度数据 的目的。 在 io 包中，LimitReader 函数的实现其实就是调用 LimitedReader： func LimitReader(r Reader, n int64) Reader { return \u0026LimitedReader{r, n} } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:10:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"PipeReader 和 PipeWriter 类型 PipeReader（一个没有任何导出字段的 struct）是管道的读取端。它实现了 io.Reader 和 io.Closer 接口。结构定义如下： type PipeReader struct { p *pipe } 关于 PipeReader.Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 error（即调用 CloseWithError 关闭），该Read返回的 err 就是写入端传递的error；否则 err 为 EOF。 PipeWriter（一个没有任何导出字段的 struct）是管道的写入端。它实现了 io.Writer 和 io.Closer 接口。结构定义如下： type PipeWriter struct { p *pipe } 关于 PipeWriter.Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时带有 error（即调用 CloseWithError 关闭），该Write返回的 err 就是读取端传递的error；否则 err 为 ErrClosedPipe。 使用示例如下： func main() { pipeReader, pipeWriter := io.Pipe() go PipeWrite(pipeWriter) go PipeRead(pipeReader) time.Sleep(30 * time.Second) } func PipeWrite(writer *io.PipeWriter){ data := []byte(\"Go语言中文网\") for i := 0; i \u003c 3; i++{ n, err := writer.Write(data) if err != nil{ fmt.Println(err) return } fmt.Printf(\"写入字节 %d\\n\",n) } writer.CloseWithError(errors.New(\"写入段已关闭\")) } func PipeRead(reader *io.PipeReader){ buf := make([]byte, 128) for{ fmt.Println(\"接口端开始阻塞5秒钟...\") time.Sleep(5 * time.Second) fmt.Println(\"接收端开始接受\") n, err := reader.Read(buf) if err != nil{ fmt.Println(err) return } fmt.Printf(\"收到字节: %d\\n buf内容: %s\\n\",n,buf) } } io.Pipe() 用于创建一个同步的内存管道 (synchronous in-memory pipe)，函数签名： func Pipe() (*PipeReader, *PipeWriter) 它将 io.Reader 连接到 io.Writer。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 Read 和 Write 以及其它函数或 Close 来说都是安全的。一旦等待的 I/O 结束，Close 就会完成。并行调用 Read 或并行调用 Write 也同样安全：同种类的调用将按顺序进行控制。 正因为是同步的，因此不能在一个 goroutine 中进行读和写。 另外，对于管道的 close 方法（非 CloseWithError 时），err 会被置为 EOF。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:11:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Copy 和 CopyN 函数 Copy 函数的签名： func Copy(dst Writer, src Reader) (written int64, err error) 函数文档： Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一个错误。 成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。 若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。 代码： io.Copy(os.Stdout, strings.NewReader(\"Go语言中文网\")) 直接将内容输出（写入 Stdout 中）。 我们甚至可以这么做： package main import ( \"fmt\" \"io\" \"os\" ) func main() { io.Copy(os.Stdout, os.Stdin) fmt.Println(\"Got EOF -- bye\") } 执行：echo \"Hello, World\" | go run main.go CopyN 函数的签名： func CopyN(dst Writer, src Reader, n int64) (written int64, err error) 函数文档： CopyN 将 n 个字节(或到一个error)从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。当且仅当err == nil时,written == n 。 若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。 代码： io.CopyN(os.Stdout, strings.NewReader(\"Go语言中文网\"), 8) 会输出： Go语言\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:12:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReadAtLeast 和 ReadFull 函数 ReadAtLeast 函数的签名： func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) 函数文档： ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了少于 min 个字节之后，ReadAtLeast 就会返回 ErrUnexpectedEOF。若 min 大于 buf 的长度，ReadAtLeast 就会返回 ErrShortBuffer。对于返回值，当且仅当 err == nil 时，才有 n \u003e= min。 一般可能不太会用到这个函数。使用时需要注意返回的 error 判断。 ReadFull 函数的签名： func ReadFull(r Reader, buf []byte) (n int, err error) 函数文档： ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF。对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。 注意该函数和 ReadAtLeast 的区别：ReadFull 将 buf 读满；而 ReadAtLeast 是最少读取 min 个字节。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:13:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"WriteString 函数 这是为了方便写入 string 类型提供的函数，函数签名： func WriteString(w Writer, s string) (n int, err error) 函数文档： WriteString 将s的内容写入w中，当 w 实现了 WriteString 方法时，会直接调用该方法，否则执行 w.Write([]byte(s))。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:14:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"MultiReader 和 MultiWriter 函数 这两个函数的定义分别是： func MultiReader(readers ...Reader) Reader func MultiWriter(writers ...Writer) Writer 它们接收多个 Reader 或 Writer，返回一个 Reader 或 Writer。我们可以猜想到这两个函数就是操作多个 Reader 或 Writer 就像操作一个。 事实上，在 io 包中定义了两个非导出类型：mutilReader 和 multiWriter，它们分别实现了 io.Reader 和 io.Writer 接口。类型定义为： type multiReader struct { readers []Reader } type multiWriter struct { writers []Writer } 对于这两种类型对应的实现方法（Read 和 Write 方法）的使用，我们通过例子来演示。 MultiReader 的使用： readers := []io.Reader{ strings.NewReader(\"from strings reader\"), bytes.NewBufferString(\"from bytes buffer\"), } reader := io.MultiReader(readers...) data := make([]byte, 0, 128) buf := make([]byte, 10) for n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf){ if err != nil{ panic(err) } data = append(data,buf[:n]...) } fmt.Printf(\"%s\\n\", data) 输出： from strings readerfrom bytes buffer\r代码中首先构造了一个 io.Reader 的 slice，由 strings.Reader 和 bytes.Buffer 两个实例组成，然后通过 MultiReader 得到新的 Reader，循环读取新 Reader 中的内容。从输出结果可以看到，第一次调用 Reader 的 Read 方法获取到的是 slice 中第一个元素的内容……也就是说，MultiReader 只是逻辑上将多个 Reader 组合起来，并不能通过调用一次 Read 方法获取所有 Reader 的内容。在所有的 Reader 内容都被读完后，Reader 会返回 EOF。 MultiWriter 的使用： file, err := os.Create(\"tmp.txt\") if err != nil { panic(err) } defer file.Close() writers := []io.Writer{ file, os.Stdout, } writer := io.MultiWriter(writers...) writer.Write([]byte(\"Go语言中文网\")) 这段程序执行后在生成 tmp.txt 文件，同时在文件和屏幕中都输出：Go语言中文网。这和 Unix 中的 tee 命令类似。 动手试试 Go 实现 Unix 中 tee 命令的功能很简单吧。MultiWriter 的 Write 方法是如何实现的？有兴趣可以自己实现一个，然后对着源码比较一下。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:15:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"TeeReader函数 函数签名如下： func TeeReader(r Reader, w Writer) Reader TeeReader 返回一个 Reader，它将从 r 中读到的数据写入 w 中。所有经由它处理的从 r 的读取都匹配于对应的对 w 的写入。它没有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。 也就是说，我们通过 Reader 读取内容后，会自动写入到 Writer 中去。例子代码如下： reader := io.TeeReader(strings.NewReader(\"Go语言中文网\"), os.Stdout) reader.Read(make([]byte, 20)) 输出结果： Go语言中文网\r这种功能的实现其实挺简单，无非是在 Read 完后执行 Write。 至此，io 所有接口、类型和函数都讲解完成。 1.2 ioutil — 方便的IO操作函数集 虽然 io 包提供了不少类型、方法和函数，但有时候使用起来不是那么方便。比如读取一个文件中的所有内容。为此，标准库中提供了一些常用、方便的IO操作函数。 说明：这些函数使用都相对简单，一般就不举例子了。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:16:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"NopCloser 函数 有时候我们需要传递一个 io.ReadCloser 的实例，而我们现在有一个 io.Reader 的实例，比如：strings.Reader ，这个时候 NopCloser 就派上用场了。它包装一个io.Reader，返回一个 io.ReadCloser ，而相应的 Close 方法啥也不做，只是返回 nil。 比如，在标准库 net/http 包中的 NewRequest，接收一个 io.Reader 的 body，而实际上，Request 的 Body 的类型是 io.ReadCloser，因此，代码内部进行了判断，如果传递的 io.Reader 也实现了 io.ReadCloser 接口，则转换，否则通过ioutil.NopCloser 包装转换一下。相关代码如下： rc, ok := body.(io.ReadCloser) if !ok \u0026\u0026 body != nil { rc = ioutil.NopCloser(body) } 如果没有这个函数，我们得自己实现一个。当然，实现起来很简单，读者可以看看 NopCloser 的实现。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:17:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReadAll 函数 很多时候，我们需要一次性读取 io.Reader 中的数据，通过上一节的讲解，我们知道有很多种实现方式。考虑到读取所有数据的需求比较多，Go 提供了 ReadAll 这个函数，用来从io.Reader 中一次读取所有数据。 func ReadAll(r io.Reader) ([]byte, error) 阅读该函数的源码发现，它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的。该函数成功调用后会返回 err == nil 而不是 err == EOF。(成功读取完毕应该为 err == io.EOF，这里返回 nil 由于该函数成功期望 err == io.EOF，符合无错误不处理的理念) ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:18:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReadDir 函数 笔试题：编写程序输出某目录下的所有文件（包括子目录） 是否见过这样的笔试题？ 在 Go 中如何输出目录下的所有文件呢？首先，我们会想到查 os 包，看 File 类型是否提供了相关方法（关于 os 包，后面会讲解）。 其实在 ioutil 中提供了一个方便的函数：ReadDir，它读取目录并返回排好序的文件和子目录名（ []os.FileInfo ）。通过这个方法，我们可以很容易的实现“面试题”。 func main() { dir := os.Args[1] listAll(dir,0) } func listAll(path string, curHier int){ fileInfos, err := ioutil.ReadDir(path) if err != nil{fmt.Println(err); return} for _, info := range fileInfos{ if info.IsDir(){ for tmpHier := curHier; tmpHier \u003e 0; tmpHier--{ fmt.Printf(\"|\\t\") } fmt.Println(info.Name(),\"\\\\\") listAll(path + \"/\" + info.Name(),curHier + 1) }else{ for tmpHier := curHier; tmpHier \u003e 0; tmpHier--{ fmt.Printf(\"|\\t\") } fmt.Println(info.Name()) } } } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:19:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"ReadFile 和 WriteFile 函数 ReadFile 读取整个文件的内容，在上一节我们自己实现了一个函数读取文件整个内容，由于这种需求很常见，因此 Go 提供了 ReadFile 函数，方便使用。ReadFile 的实现和ReadAll 类似，不过，ReadFile 会先判断文件的大小，给 bytes.Buffer 一个预定义容量，避免额外分配内存。 ReadFile 函数的签名如下: func ReadFile(filename string) ([]byte, error) 函数文档： ReadFile 从 filename 指定的文件中读取数据并返回文件的内容。成功的调用返回的err 为 nil 而非 EOF。因为本函数定义为读取整个文件，它不会将读取返回的 EOF 视为应报告的错误。(同 ReadAll ) WriteFile 函数的签名如下： func WriteFile(filename string, data []byte, perm os.FileMode) error 函数文档: WriteFile 将data写入filename文件中，当文件不存在时会根据perm指定的权限进行创建一个,文件存在时会先清空文件内容。对于 perm 参数，我们一般可以指定为：0666，具体含义 os 包中讲解。 小提示 ReadFile 源码中先获取了文件的大小，当大小 \u003c 1e9 时，才会用到文件的大小。按源码中注释的说法是 FileInfo 不会很精确地得到文件大小。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:20:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"TempDir 和 TempFile 函数 操作系统中一般都会提供临时目录，比如 linux 下的 /tmp 目录（通过 os.TempDir() 可以获取到)。有时候，我们自己需要创建临时目录，比如 Go 工具链源码中（src/cmd/go/build.go），通过 TempDir 创建一个临时目录，用于存放编译过程的临时文件： b.work, err = ioutil.TempDir(\"\", \"go-build\") 第一个参数如果为空，表明在系统默认的临时目录（ os.TempDir ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。 相应的，TempFile 用于创建临时文件。如 gofmt 命令的源码中创建临时文件： f1, err := ioutil.TempFile(\"\", \"gofmt\") 参数和 ioutil.TempDir 参数含义类似。 这里需要注意：创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。如删除临时文件： defer func() { f.Close() os.Remove(f.Name()) }() ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:21:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Discard 变量 Discard 对应的类型（type devNull int）实现了 io.Writer 接口，同时，为了优化 io.Copy 到 Discard，避免不必要的工作，实现了 io.ReaderFrom 接口。 devNull 在实现 io.Writer 接口时，只是简单的返回（标准库文件：src/pkg/io/ioutil.go)。 func (devNull) Write(p []byte) (int, error) { return len(p), nil } 而 ReadFrom 的实现是读取内容到一个 buf 中，最大也就 8192 字节，其他的会丢弃（当然，这个也不会读取）。 1.3 fmt — 格式化IO fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf. 格式“占位符”衍生自C，但比C更简单。 fmt 包的官方文档对 Printing 和 Scanning 有很详细的说明。这里就直接引用文档进行说明，同时附上额外的说明或例子，之后再介绍具体的函数使用。 以下例子中用到的类型或变量定义： type Website struct { Name string } // 定义结构体变量 var site = Website{Name:\"studygolang\"} ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:22:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Printing ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:23:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Sample type user struct { name string } func main() { u := user{\"tang\"} //Printf 格式化输出 fmt.Printf(\"% + v\\n\", u) //格式化输出结构 fmt.Printf(\"%#v\\n\", u) //输出值的 Go 语言表示方法 fmt.Printf(\"%T\\n\", u) //输出值的类型的 Go 语言表示 fmt.Printf(\"%t\\n\", true) //输出值的 true 或 false fmt.Printf(\"%b\\n\", 1024) //二进制表示 fmt.Printf(\"%c\\n\", 11111111) //数值对应的 Unicode 编码字符 fmt.Printf(\"%d\\n\", 10) //十进制表示 fmt.Printf(\"%o\\n\", 8) //八进制表示 fmt.Printf(\"%q\\n\", 22) //转化为十六进制并附上单引号 fmt.Printf(\"%x\\n\", 1223) //十六进制表示，用a-f表示 fmt.Printf(\"%X\\n\", 1223) //十六进制表示，用A-F表示 fmt.Printf(\"%U\\n\", 1233) //Unicode表示 fmt.Printf(\"%b\\n\", 12.34) //无小数部分，两位指数的科学计数法6946802425218990p-49 fmt.Printf(\"%e\\n\", 12.345) //科学计数法，e表示 fmt.Printf(\"%E\\n\", 12.34455) //科学计数法，E表示 fmt.Printf(\"%f\\n\", 12.3456) //有小数部分，无指数部分 fmt.Printf(\"%g\\n\", 12.3456) //根据实际情况采用%e或%f输出 fmt.Printf(\"%G\\n\", 12.3456) //根据实际情况采用%E或%f输出 fmt.Printf(\"%s\\n\", \"wqdew\") //直接输出字符串或者[]byte fmt.Printf(\"%q\\n\", \"dedede\") //双引号括起来的字符串 fmt.Printf(\"%x\\n\", \"abczxc\") //每个字节用两字节十六进制表示，a-f表示 fmt.Printf(\"%X\\n\", \"asdzxc\") //每个字节用两字节十六进制表示，A-F表示 fmt.Printf(\"%p\\n\", 0x123) //0x开头的十六进制数表示 } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:23:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"占位符 普通占位符 占位符 说明 举例 输出\r%v 相应值的默认格式。 Printf(\"%v\", site)，Printf(\"%+v\", site) {studygolang}，{Name:studygolang}\r在打印结构体时，“加号”标记（%+v）会添加字段名\r%#v 相应值的Go语法表示 Printf(\"#v\", site) main.Website{Name:\"studygolang\"}\r%T 相应值的类型的Go语法表示 Printf(\"%T\", site) main.Website\r%% 字面上的百分号，并非值的占位符 Printf(\"%%\") %\r布尔占位符 占位符 说明 举例 输出\r%t 单词 true 或 false。 Printf(\"%t\", true) true\r整数占位符 占位符 说明 举例 输出\r%b 二进制表示 Printf(\"%b\", 5) 101\r%c 相应Unicode码点所表示的字符 Printf(\"%c\", 0x4E2D) 中\r%d 十进制表示 Printf(\"%d\", 0x12) 18\r%o 八进制表示 Printf(\"%o\", 10) 12\r%q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(\"%q\", 0x4E2D) '中'\r%x 十六进制表示，字母形式为小写 a-f Printf(\"%x\", 13) d\r%X 十六进制表示，字母形式为大写 A-F Printf(\"%x\", 13) D\r%U Unicode格式：U+1234，等同于 \"U+%04X\" Printf(\"%U\", 0x4E2D) U+4E2D\r浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出\r%b 无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat\r的 'b' 转换格式一致。例如 -123456p-78\r%e 科学计数法，例如 -1234.456e+78 Printf(\"%e\", 10.2) 1.020000e+01\r%E 科学计数法，例如 -1234.456E+78 Printf(\"%e\", 10.2) 1.020000E+01\r%f 有小数点而无指数，例如 123.456 Printf(\"%f\", 10.2) 10.200000\r%g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%g\", 10.20) 10.2\r%G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%G\", 10.20+2i) (10.2+2i)\r字符串与字节切片 占位符 说明 举例 输出\r%s 输出字符串表示（string类型或[]byte) Printf(\"%s\", []byte(\"Go语言中文网\")) Go语言中文网\r%q 双引号围绕的字符串，由Go语法安全地转义 Printf(\"%q\", \"Go语言中文网\") \"Go语言中文网\"\r%x 十六进制，小写字母，每字节两个字符 Printf(\"%x\", \"golang\") 676f6c616e67\r%X 十六进制，大写字母，每字节两个字符 Printf(\"%X\", \"golang\") 676F6C616E67\r指针 占位符 说明 举例 输出\r%p 十六进制表示，前缀 0x Printf(\"%p\", \u0026site) 0x4f57f0\r这里没有 ‘u’ 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地，这里也不需要指定操作数的大小（int8，int64）。 宽度与精度的控制格式以 Unicode 码点为单位。（这点与C的 printf 不同，它以字节数为单位）二者或其中之一均可用字符 ‘*’ 表示，此时它们的值会从下一个操作数中获取，该操作数的类型必须为 int。 对数值而言，宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 但对于 %g/%G 而言，精度为所有数字的总数。例如，对于123.45，格式 %6.2f 会打印123.45，而 %.4g 会打印123.5。%e 和 %f 的默认精度为6；但对于 %g 而言，它的默认精度为确定该值所必须的最小位数。 对大多数的值而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。对字符串而言，精度为输出的最大字符数，如果必要的话会直接截断。 其它标记 占位符 说明 举例 输出\r+ 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(\"%+q\", \"中文\") \"\\u4e2d\\u6587\"\r- 在右侧而非左侧填充空格（左对齐该区域）\r# 备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或 Printf(\"%#U\", '中') U+4E2D '中'\r0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始\r（即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的\rUnicode 编码形式（如字符 x 会被打印成 U+0078 'x'）。\r' ' （空格）为数值中省略的正负号留出空白（% d）；\r以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开\r0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后\r标记有时会被占位符忽略，所以不要指望它们。例如十进制没有备用格式，因此 %#d 与 %d 的行为相同。 对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化，它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白，并在末尾追加一个换行符。 不考虑占位符的话，如果操作数是接口值，就会使用其内部的具体值，而非接口本身。 因此： var i interface{} = 23 fmt.Printf(\"%v\\n\", i) 会打印 23。 若一个操作数实现了 Formatter 接口，该接口就能更好地用于控制格式化。 若其格式（它对于 Println 等函数是隐式的 %v）对于字符串是有效的 （%s %q %v %x %X），以下两条规则也适用： 1. 若一个操作数实现了 error 接口，Error 方法就能将该对象转换为字符串，随后会根据占位符的需要进行格式化。 2. 若一个操作数实现了 String() string 方法，该方法能将该对象转换为字符串，随后会根据占位符的需要进行格式化。 为避免以下这类递归的情况： type X string func (x X) String() string { return Sprintf(\"\u003c%s\u003e\", x) } 需要在递归前转换该值： func (x X) String() string { return Sprintf(\"\u003c%s\u003e\", string(x)) } 格式化错误 如果给占位符提供了无效的实参（例如将一个字符串提供给 %d），所生成的字符串会包含该问题的描述，如下例所示： 类型错误或占位符未知：%!verb(type=value) Printf(\"%d\", hi): %!d(string=hi) 实参太多：%!(EXTRA type=value) Printf(\"hi\", \"guys\"): hi%!(EXTRA string=guys) 实参太少： %!verb(MISSING) Printf(\"hi%d\"): hi %!d(MISSING) 宽度或精度不是int类型: %!(BADWIDTH) 或 %!(BADPREC) Printf(\"%*s\", 4.5, \"hi\"): %!(BADWIDTH)hi Printf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi 所有错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:23:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Scanning 一组类似的函数通过扫描已格式化的文本来产生值。 Scan、Scanf 和 Scanln 从 os.Stdin 中读取； Fscan、Fscanf 和 Fscanln 从指定的 io.Reader 中读取； Sscan、Sscanf 和 Sscanln 从实参字符串中读取。 Scanln、Fscanln 和 Sscanln 在换行符处停止扫描，且需要条目紧随换行符之后； Scanf、Fscanf 和 Sscanf 需要输入换行符来匹配格式中的换行符；其它函数则将换行符视为空格。 Scanf、Fscanf 和 Sscanf 根据格式字符串解析实参，类似于 Printf。例如，%x 会将一个整数扫描为十六进制数，而 %v 则会扫描该值的默认表现格式。 格式化行为类似于 Printf，但也有如下例外： %p 没有实现\r%T 没有实现\r%e %E %f %F %g %G 都完全等价，且可扫描任何浮点数或复数数值\r%s 和 %v 在扫描字符串时会将其中的空格作为分隔符\r标记 # 和 + 没有实现\r在使用 %v 占位符扫描整数时，可接受友好的进制前缀0（八进制）和0x（十六进制）。 宽度被解释为输入的文本（%5s 意为最多从输入中读取5个 rune 来扫描成字符串），而扫描函数则没有精度的语法（没有 %5.2f，只有 %5f）。 当以某种格式进行扫描时，无论在格式中还是在输入中，所有非空的连续空白字符 （除换行符外）都等价于单个空格。由于这种限制，格式字符串文本必须匹配输入的文本，如果不匹配，扫描过程就会停止，并返回已扫描的实参数。 在所有的扫描参数中，若一个操作数实现了 Scan 方法（即它实现了 Scanner 接口）， 该操作数将使用该方法扫描其文本。此外，若已扫描的实参数少于所提供的实参数，就会返回一个错误。 所有需要被扫描的实参都必须是基本类型或 Scanner 接口的实现。 注意：Fscan 等函数会从输入中多读取一个字符（rune），因此，如果循环调用扫描函数，可能会跳过输入中的某些数据。一般只有在输入的数据中没有空白符时该问题才会出现。若提供给 Fscan 的读取器实现了 ReadRune，就会用该方法读取字符。若此读取器还实现了 UnreadRune 方法，就会用该方法保存字符，而连续的调用将不会丢失数据。若要为没有 ReadRune 和 UnreadRune 方法的读取器加上这些功能，需使用 bufio.NewReader。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:24:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Print 序列函数 这里说的 Print 序列函数包括：Fprint/Fprintf/Fprintln/Sprint/Sprintf/Sprintln/Print/Printf/Println。之所以将放在一起介绍，是因为它们的使用方式类似、参数意思也类似。 一般的，我们将 Fprint/Fprintf/Fprintln 归为一类；Sprint/Sprintf/Sprintln 归为一类；Print/Printf/Println 归为另一类。其中，Print/Printf/Println 会调用相应的F开头一类函数。如： func Print(a ...interface{}) (n int, err error) { return Fprint(os.Stdout, a...) } Fprint/Fprintf/Fprintln 函数的第一个参数接收一个io.Writer类型，会将内容输出到 io.Writer 中去。而 Print/Printf/Println 函数是将内容输出到标准输出中，因此，直接调用 F类函数 做这件事，并将 os.Stdout 作为第一个参数传入。 Sprint/Sprintf/Sprintln 是格式化内容为 string 类型，而并不输出到某处，需要格式化字符串并返回时，可以用这组函数。 在这三组函数中，S/F/Printf函数通过指定的格式输出或格式化内容；S/F/Print函数只是使用默认的格式输出或格式化内容；S/F/Println函数使用默认的格式输出或格式化内容，同时会在最后加上\"换行符\"。 Print 序列函数的最后一个参数都是 a ...interface{} 这种不定参数。对于S/F/Printf序列，这个不定参数的实参个数应该和formt参数的占位符个数一致，否则会出现格式化错误；而对于其他函数，当不定参数的实参个数为多个时，它们之间会直接（对于S/F/Print）或通过\" “（空格）（对于S/F/Println）连接起来（注：对于S/F/Print，当两个参数都不是字符串时，会自动添加一个空格，否则不会加。感谢guoshanhe1983 反馈。官方 effective_go 也有说明）。利用这一点，我们可以做如下事情： result1 := fmt.Sprintln(\"studygolang.com\", 2013)\rresult2 := fmt.Sprint(\"studygolang.com\", 2013)\rresult1的值是：studygolang.com 2013，result2的值是：studygolang.com2013。这起到了连接字符串的作用，而不需要通过strconv.Itoa()转换。 Print 序列函数用的较多，而且也易于使用（可能需要掌握一些常用的占位符用法），接下来我们结合 fmt 包中几个相关的接口来掌握更多关于 Print 的内容。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:25:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Stringer 接口 Stringer接口的定义如下： type Stringer interface { String() string } 根据 Go 语言中实现接口的定义，一个类型只要有 String() string 方法，我们就说它实现了 Stringer 接口。而在本节开始已经说到，如果格式化输出某种类型的值，只要它实现了 String() 方法，那么会调用 String() 方法进行处理。 我们定义如下struct： type Person struct { Name string Age int Sex int } 我们给Person实现String方法，这个时候，我们输出Person的实例： p := \u0026Person{\"polaris\", 28, 0} fmt.Println(p) 输出： \u0026{polaris 28 0} 接下来，为Person增加String方法。 func (this *Person) String() string { buffer := bytes.NewBufferString(\"This is \") buffer.WriteString(this.Name + \", \") if this.Sex == 0 { buffer.WriteString(\"He \") } else { buffer.WriteString(\"She \") } buffer.WriteString(\"is \") buffer.WriteString(strconv.Itoa(this.Age)) buffer.WriteString(\" years old.\") return buffer.String() } 这个时候运行： p := \u0026Person{\"polaris\", 28, 0} fmt.Println(p) 输出变为： This is polaris, He is 28 years old 可见，Stringer接口和Java中的ToString方法类似。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:26:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Formatter 接口 Formatter 接口的定义如下： type Formatter interface { Format(f State, c rune) } 官方文档中关于该接口方法的说明： Formatter 接口由带有定制的格式化器的值所实现。 Format 的实现可调用 Sprintf 或 Fprintf(f) 等函数来生成其输出。 也就是说，通过实现 Formatter 接口可以做到自定义输出格式（自定义占位符）。 接着上面的例子，我们为 Person 增加一个方法： func (this *Person) Format(f fmt.State, c rune) { if c == 'L' { f.Write([]byte(this.String())) f.Write([]byte(\" Person has three fields.\")) } else { // 没有此句，会导致 fmt.Printf(\"%s\", p) 啥也不输出 f.Write([]byte(fmt.Sprintln(this.String()))) } } 这样，Person便实现了Formatter接口。这时再运行： p := \u0026Person{\"polaris\", 28, 0} fmt.Printf(\"%L\", p) 输出为： This is polaris, He is 28 years old. Person has three fields. 这里需要解释以下几点： 1）fmt.State 是一个接口。由于 Format 方法是被 fmt 包调用的，它内部会实例化好一个 fmt.State 接口的实例，我们不需要关心该接口； 2）可以实现自定义占位符，同时 fmt 包中和类型相对应的预定义占位符会无效。因此例子中 Format 的实现加上了 else 子句； 3）实现了 Formatter 接口，相应的 Stringer 接口不起作用。但实现了 Formatter 接口的类型应该实现 Stringer 接口，这样方便在 Format 方法中调用 String() 方法。就像本例的做法； 4）Format 方法的第二个参数是占位符中%后的字母（有精度和宽度会被忽略，只保留字母）； 一般地，我们不需要实现 Formatter 接口。如果对 Formatter 接口的实现感兴趣，可以看看标准库 math/big 包中 Int 类型的 Formatter 接口实现。 小贴士 State接口相关说明： type State interface { // Write is the function to call to emit formatted output to be printed. // Write 函数用于打印出已格式化的输出。 Write(b []byte) (ret int, err error) // Width returns the value of the width option and whether it has been set. // Width 返回宽度选项的值以及它是否已被设置。 Width() (wid int, ok bool) // Precision returns the value of the precision option and whether it has been set. // Precision 返回精度选项的值以及它是否已被设置。 Precision() (prec int, ok bool) // Flag returns whether the flag c, a character, has been set. // Flag 返回标记 c（一个字符）是否已被设置。 Flag(c int) bool } fmt 包中的 print.go 文件中的type pp struct实现了 State 接口。由于 State 接口有 Write 方法，因此，实现了 State 接口的类型必然实现了 io.Writer 接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:27:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"GoStringer 接口 GoStringer 接口定义如下； type GoStringer interface { GoString() string } 该接口定义了类型的Go语法格式。用于打印(Printf)格式化占位符为 %#v 的值。 用前面的例子演示。执行： p := \u0026Person{\"polaris\", 28, 0} fmt.Printf(\"%#v\", p) 输出： \u0026main.Person{Name:\"polaris\", Age:28, Sex:0} 接着为Person增加方法： func (this *Person) GoString() string { return \"\u0026Person{Name is \"+this.Name+\", Age is \"+strconv.Itoa(this.Age)+\", Sex is \"+strconv.Itoa(this.Sex)+\"}\" } 这个时候再执行 p := \u0026Person{\"polaris\", 28, 0} fmt.Printf(\"%#v\", p) 输出： \u0026Person{Name is polaris, Age is 28, Sex is 0} 一般的，我们不需要实现该接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:28:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Scan 序列函数 该序列函数和 Print 序列函数相对应，包括：Fscan/Fscanf/Fscanln/Sscan/Sscanf/Sscanln/Scan/Scanf/Scanln。 一般的，我们将Fscan/Fscanf/Fscanln归为一类；Sscan/Sscanf/Sscanln归为一类；Scan/Scanf/Scanln归为另一类。其中，Scan/Scanf/Scanln会调用相应的F开头一类函数。如： func Scan(a ...interface{}) (n int, err error) { return Fscan(os.Stdin, a...) } Fscan/Fscanf/Fscanln 函数的第一个参数接收一个 io.Reader 类型，从其读取内容并赋值给相应的实参。而 Scan/Scanf/Scanln 正是从标准输入获取内容，因此，直接调用 F类函数 做这件事，并将 os.Stdin 作为第一个参数传入。 Sscan/Sscanf/Sscanln 则直接从字符串中获取内容。 对于Scan/Scanf/Scanln三个函数的区别，我们通过例子来说明，为了方便讲解，我们使用Sscan/Sscanf/Sscanln这组函数。 Scan/FScan/Sscan var ( name string age int ) n, _ := fmt.Sscan(\"polaris 28\", \u0026name, \u0026age) // 可以将\"polaris 28\"中的空格换成\"\\n\"试试 // n, _ := fmt.Sscan(\"polaris\\n28\", \u0026name, \u0026age) fmt.Println(n, name, age) 输出为： 2 polaris 28 不管\"polaris 28\"是用空格分隔还是”\\n\"分隔，输出一样。也就是说，Scan/FScan/Sscan 这组函数将连续由空格分隔的值存储为连续的实参（换行符也记为空格）。 Scanf/FScanf/Sscanf var ( name string age int ) n, _ := fmt.Sscanf(\"polaris 28\", \"%s%d\", \u0026name, \u0026age) // 可以将\"polaris 28\"中的空格换成\"\\n\"试试 // n, _ := fmt.Sscanf(\"polaris\\n28\", \"%s%d\", \u0026name, \u0026age) fmt.Println(n, name, age) 输出： 2 polaris 28 如果将\"空格\"分隔改为\"\\n\"分隔，则输出为：1 polaris 0。可见，Scanf/FScanf/Sscanf 这组函数将连续由空格分隔的值存储为连续的实参， 其格式由 format 决定，换行符处停止扫描(Scan)。 Scanln/FScanln/Sscanln var ( name string age int ) n, _ := fmt.Sscanln(\"polaris 28\", \u0026name, \u0026age) // 可以将\"polaris 28\"中的空格换成\"\\n\"试试 // n, _ := fmt.Sscanln(\"polaris\\n28\", \u0026name, \u0026age) fmt.Println(n, name, age) 输出： 2 polaris 28 Scanln/FScanln/Sscanln表现和上一组一样，遇到\"\\n\"停止（对于Scanln，表示从标准输入获取内容，最后需要回车）。 一般地，我们使用 Scan/Scanf/Scanln 这组函数。 提示 如果你是Windows系统，在使用 Scanf 时，有一个地方需要注意。看下面的代码： for i := 0; i \u003c 2; i++ { var name string fmt.Print(\"Input Name:\") n, err := fmt.Scanf(\"%s\", \u0026name) fmt.Println(n, err, name) } 编译、运行（或直接 go run )，输入：polaris 回车。控制台内如下： Input Name:polaris 1 \u003cnil\u003e polaris Input Name:0 unexpected newline 为什么不是让输入两次？第二次好像有默认值一样。 同样的代码在Linux下正常。个人认为这是go在Windows下的一个bug，已经向官方提出：issue5391。 目前的解决方法是：换用Scanln或者改为Scanf(\"%s\\n\", \u0026name)。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:29:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Scanner 和 ScanState 接口 基本上，我们不会去自己实现这两个接口，只需要使用上文中相应的 Scan 函数就可以了。这里只是简单的介绍一下这两个接口的作用。 任何实现了 Scan 方法的对象都实现了 Scanner 接口，Scan 方法会从输入读取数据并将处理结果存入接收端，接收端必须是有效的指针。Scan 方法会被任何 Scan、Scanf、Scanln 等函数调用，只要对应的参数实现了该方法。Scan 方法接收的第一个参数为ScanState接口类型。 ScanState 是一个交给用户定制的 Scanner 接口的参数的接口。Scanner 接口可能会进行一次一个字符的扫描或者要求 ScanState 去探测下一个空白分隔的 token。该接口的方法基本上在 io 包中都有讲解，这里不赘述。 在fmt包中，scan.go 文件中的 ss 结构实现了 ScanState 接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:30:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fmt/print.go 阅读 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:31:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Fprint func Fprint(w io.Writer, a ...interface{}) (n int, err error) { p := newPrinter() // 实际工作结构 p.doPrint(a) n, err = w.Write(p.buf) p.free() return } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:31:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"newPrinter // printer 状态结构 type pp struct { buf buffer arg interface{} value reflect.Value fmt fmt reordered bool goodArgNum bool panicking bool erroring bool } // 通过 sync.Pool 复用，避免回收造成 GC var ppFree = sync.Pool{ New: func() interface{} { return new(pp) }, } // 分配或重用 pp 结构 func newPrinter() *pp { p := ppFree.Get().(*pp) p.panicking = false p.erroring = false p.fmt.init(\u0026p.buf) return p } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:31:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"doPrint func (p *pp) doPrint(a []interface{}) { prevString := false // 获取可变参数索引及参数 for argNum, arg := range a { // reflect.TypeOf.Kind isString := arg != nil \u0026\u0026 reflect.TypeOf(arg).Kind() == reflect.String // 判断是否需要一个空格 if argNum \u003e 0 \u0026\u0026 !isString \u0026\u0026 !prevString { p.buf.WriteByte(' ') } p.printArg(arg, 'v') prevString = isString } } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:31:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"printArg func (p *pp) printArg(arg interface{}, verb rune) { p.arg = arg p.value = reflect.Value{} if arg == nil { switch verb { case 'T', 'v': p.fmt.padString(nilAngleString) default: p.badVerb(verb) } return } switch verb { case 'T': p.fmt.fmt_s(reflect.TypeOf(arg).String()) return case 'p': p.fmtPointer(reflect.ValueOf(arg), 'p') return } // 类型判断 switch f := arg.(type) { case bool: p.fmtBool(f, verb) case float32: p.fmtFloat(float64(f), 32, verb) case float64: p.fmtFloat(f, 64, verb) case complex64: p.fmtComplex(complex128(f), 64, verb) case complex128: p.fmtComplex(f, 128, verb) case int: p.fmtInteger(uint64(f), signed, verb) case int8: p.fmtInteger(uint64(f), signed, verb) case int16: p.fmtInteger(uint64(f), signed, verb) case int32: p.fmtInteger(uint64(f), signed, verb) case int64: p.fmtInteger(uint64(f), signed, verb) case uint: p.fmtInteger(uint64(f), unsigned, verb) case uint8: p.fmtInteger(uint64(f), unsigned, verb) case uint16: p.fmtInteger(uint64(f), unsigned, verb) case uint32: p.fmtInteger(uint64(f), unsigned, verb) case uint64: p.fmtInteger(f, unsigned, verb) case uintptr: p.fmtInteger(uint64(f), unsigned, verb) case string: p.fmtString(f, verb) case []byte: p.fmtBytes(f, verb, \"[]byte\") case reflect.Value: // Handle extractable values with special methods // since printValue does not handle them at depth 0. if f.IsValid() \u0026\u0026 f.CanInterface() { p.arg = f.Interface() if p.handleMethods(verb) { return } } p.printValue(f, verb, 0) default: // If the type is not simple, it might have methods. if !p.handleMethods(verb) { // Need to use reflection, since the type had no // interface methods that could be used for formatting. p.printValue(reflect.ValueOf(f), verb, 0) } } } 1.4 bufio — 缓存IO bufio 包实现了缓存IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:31:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.1 Reader 类型和方法 bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。 Reader 结构没有任何导出的字段，结构定义如下： type Reader struct { buf []byte // 缓存 rd io.Reader // 底层的io.Reader // r:从buf中读走的字节（偏移）；w:buf中填充内容的偏移； // w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值 r, w int err error // 读过程中遇到的错误 lastByte int // 最后一次读到的字节（ReadByte/UnreadByte) lastRuneSize int // 最后一次读到的Rune的大小 (ReadRune/UnreadRune) } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:32:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.1.1 实例化 bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的： func NewReader(rd io.Reader) *Reader { // 默认缓存大小：defaultBufSize=4096 return NewReaderSize(rd, defaultBufSize) } 我们看一下NewReaderSize的源码： func NewReaderSize(rd io.Reader, size int) *Reader { // 已经是bufio.Reader类型，且缓存大小不小于 size，则直接返回 b, ok := rd.(*Reader) if ok \u0026\u0026 len(b.buf) \u003e= size { return b } // 缓存大小不会小于 minReadBufferSize （16字节） if size \u003c minReadBufferSize { size = minReadBufferSize } // 构造一个bufio.Reader实例 return \u0026Reader{ buf: make([]byte, size), rd: rd, lastByte: -1, lastRuneSize: -1, } } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:32:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.1.2 ReadSlice、ReadBytes、ReadString 和 ReadLine 方法 之所以将这几个方法放在一起，是因为他们有着类似的行为。事实上，后三个方法最终都是调用ReadSlice来实现的。所以，我们先来看看ReadSlice方法。(感觉这一段直接看源码较好) ReadSlice方法签名如下： func (b *Reader) ReadSlice(delim byte) (line []byte, err error) ReadSlice 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 slice，在下次调用读操作（read）时，这些字节会无效。举例说明： reader := bufio.NewReader(strings.NewReader(\"http://studygolang.com. \\nIt is the home of gophers\")) line, _ := reader.ReadSlice('\\n') fmt.Printf(\"the line:%s\\n\", line) // 这里可以换上任意的 bufio 的 Read/Write 操作 n, _ := reader.ReadSlice('\\n') fmt.Printf(\"the line:%s\\n\", line) fmt.Println(string(n)) 输出： the line:http://studygolang.com. the line:It is the home of gophers It is the home of gophers 从结果可以看出，第一次ReadSlice的结果（line），在第二次调用读操作后，内容发生了变化。也就是说，ReadSlice 返回的 []byte 是指向 Reader 中的 buffer ，而不是 copy 一份返回。正因为ReadSlice 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择使用 ReadBytes 或者 ReadString 来代替。读者可以将上面代码中的 ReadSlice 改为 ReadBytes 或 ReadString ，看看结果有什么不同。 注意，这里的界定符可以是任意的字符，可以将上面代码中的’\\n’改为’m’试试。同时，返回的结果是包含界定符本身的，上例中，输出结果有一空行就是’\\n’本身(line携带一个’\\n’,printf又追加了一个’\\n’)。 如果 ReadSlice 在找到界定符之前遇到了 error ，它就会返回缓存中所有的数据和错误本身（经常是 io.EOF）。如果在找到界定符之前缓存已经满了，ReadSlice 会返回 bufio.ErrBufferFull 错误。当且仅当返回的结果（line）没有以界定符结束的时候，ReadSlice 返回err != nil，也就是说，如果ReadSlice 返回的结果 line 不是以界定符 delim 结尾，那么返回的 er r也一定不等于 nil（可能是bufio.ErrBufferFull或io.EOF）。 例子代码： reader := bufio.NewReaderSize(strings.NewReader(\"http://studygolang.com\"),16) line, err := reader.ReadSlice('\\n') fmt.Printf(\"line:%s\\terror:%s\\n\", line, err) line, err = reader.ReadSlice('\\n') fmt.Printf(\"line:%s\\terror:%s\\n\", line, err) 输出： line:http://studygola error:bufio: buffer full line:ng.com error:EOF ReadBytes方法签名如下： func (b *Reader) ReadBytes(delim byte) (line []byte, err error) 该方法的参数和返回值类型与 ReadSlice 都一样。 ReadBytes 从输入中读取直到遇到界定符（delim）为止，返回的 slice 包含了从当前到界定符的内容 （包括界定符）。如果 ReadBytes 在遇到界定符之前就捕获到一个错误，它会返回遇到错误之前已经读取的数据，和这个捕获到的错误（经常是 io.EOF）。跟 ReadSlice 一样，如果 ReadBytes 返回的结果 line 不是以界定符 delim 结尾，那么返回的 err 也一定不等于 nil（可能是bufio.ErrBufferFull 或 io.EOF）。 从这个说明可以看出，ReadBytes和ReadSlice功能和用法都很像，那他们有什么不同呢？ 在讲解ReadSlice时说到，它返回的 []byte 是指向 Reader 中的 buffer，而不是 copy 一份返回，也正因为如此，通常我们会使用 ReadBytes 或 ReadString。很显然，ReadBytes 返回的 []byte 不会是指向 Reader 中的 buffer，通过查看源码可以证实这一点。 还是上面的例子，我们将 ReadSlice 改为 ReadBytes： reader := bufio.NewReader(strings.NewReader(\"http://studygolang.com. \\nIt is the home of gophers\")) line, _ := reader.ReadBytes('\\n') fmt.Printf(\"the line:%s\\n\", line) // 这里可以换上任意的 bufio 的 Read/Write 操作 n, _ := reader.ReadBytes('\\n') fmt.Printf(\"the line:%s\\n\", line) fmt.Println(string(n)) 输出： the line:http://studygolang.com. the line:http://studygolang.com. It is the home of gophers ReadString方法 看一下该方法的源码： func (b *Reader) ReadString(delim byte) (line string, err error) { bytes, err := b.ReadBytes(delim) return string(bytes), err } 它调用了 ReadBytes 方法，并将结果的 []byte 转为 string 类型。 ReadLine方法签名如下 func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) ReadLine 是一个底层的原始行读取命令。许多调用者或许会使用 ReadBytes(’\\n’) 或者 ReadString(’\\n’) 来代替这个方法。 ReadLine 尝试返回单独的行，不包括行尾的换行符。如果一行大于缓存，isPrefix 会被设置为 true，同时返回该行的开始部分（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，isPrefix 将会是 false 。跟 ReadSlice 一样，返回的 line 只是 buffer 的引用，在下次执行IO操作时，line 会无效。可以将 ReadSlice 中的例子该为 ReadLine 试试。 注意，返回值中，要么 line 不是 nil，要么 err 非 nil，两者不会同时非 nil。 ReadLine 返回的文本不会包含行结尾（\"\\r\\n\"或者\"\\n\"）。如果输入中没有行尾标识符，不会返回任何指示或者错误。 从上面的讲解中，我们知道，读取一行，通常会选择 ReadBytes 或 ReadString。不过，正常人的思维，应该用 ReadLine，只是不明白为啥 ReadLine 的实现不是通过 ReadBytes，然后清除掉行尾的\\n（或\\r\\n），它现在的实现，用不好会出现意想不到的问题，比如丢数据。个人建议可以这么实现读取一行： line, err := reader.ReadBytes('\\n') line = bytes.TrimRight(line, \"\\r\\n\") 这样既读取了一行，也去掉了行尾结束符（当然，如果你希望留下行尾结束符，只用ReadBytes即可）。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:32:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.1.3 Peek 方法 从方法的名称可以猜到，该方法只是“窥探”一下 Reader 中没有读取的 n 个字节。好比栈数据结构中的取栈顶元素，但不出栈。 方法的签名如下： func (b *Reader) Peek(n int) ([]byte, error) 同上面介绍的 ReadSlice一样，返回的 []byte 只是 buffer 中的引用，在下次IO操作后会无效，可见该方法（以及ReadSlice这样的，返回buffer引用的方法）对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。 我们通过例子来证明一下： package main import ( \"bufio\" \"fmt\" \"strings\" \"time\" ) func main() { reader := bufio.NewReaderSize(strings.NewReader(\"http://studygolang.com.\\t It is the home of gophers\"), 14) go Peek(reader) go reader.ReadBytes('\\t') time.Sleep(1e8) } func Peek(reader *bufio.Reader) { line, _ := reader.Peek(14) fmt.Printf(\"%s\\n\", line) // time.Sleep(1) fmt.Printf(\"%s\\n\", line) } 输出： http://studygo http://studygo 输出结果和预期的一致。然而，这是由于目前的 goroutine 调度方式导致的结果。如果我们将例子中注释掉的 time.Sleep(1) 取消注释（这样调度其他 goroutine 执行），再次运行，得到的结果为： http://studygo ng.com. It is 另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 err != nil ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:32:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.1.4 其他方法 Reader 的其他方法都是实现了 io 包中的接口，它们的使用方法在io包中都有介绍，在此不赘述。 这些方法包括： func (b *Reader) Read(p []byte) (n int, err error) func (b *Reader) ReadByte() (c byte, err error) func (b *Reader) ReadRune() (r rune, size int, err error) func (b *Reader) UnreadByte() error func (b *Reader) UnreadRune() error func (b *Reader) WriteTo(w io.Writer) (n int64, err error) 你应该知道它们都是哪个接口的方法吧。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:32:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.2 Scanner 类型和方法 对于简单的读取一行，在 Reader 类型中，感觉没有让人特别满意的方法。于是，Go1.1增加了一个类型：Scanner。官方关于Go1.1增加该类型的说明如下： 在 bufio 包中有多种方式获取文本输入，ReadBytes、ReadString 和独特的 ReadLine，对于简单的目的这些都有些过于复杂了。在 Go 1.1 中，添加了一个新类型，Scanner，以便更容易的处理如按行读取输入序列或空格分隔单词等，这类简单的任务。它终结了如输入一个很长的有问题的行这样的输入错误，并且提供了简单的默认行为：基于行的输入，每行都剔除分隔标识。这里的代码展示一次输入一行： scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) // Println will add back the final '\\n' } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading standard input:\", err) } 输入的行为可以通过一个函数控制，来控制输入的每个部分（参阅 SplitFunc 的文档），但是对于复杂的问题或持续传递错误的，可能还是需要原有接口。 Scanner 类型和 Reader 类型一样，没有任何导出的字段，同时它也包装了一个 io.Reader 对象，但它没有实现 io.Reader 接口。 Scanner 的结构定义如下： type Scanner struct {\rr io.Reader // The reader provided by the client.\rsplit SplitFunc // The function to split the tokens.\rmaxTokenSize int // Maximum size of a token; modified by tests.\rtoken []byte // Last token returned by split.\rbuf []byte // Buffer used as argument to split.\rstart int // First non-processed byte in buf.\rend int // End of data in buf.\rerr error // Sticky error.\r}\r这里 split、maxTokenSize 和 token 需要讲解一下。 然而，在讲解之前，需要先讲解 split 字段的类型 SplitFunc。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:33:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.2.1 SplitFunc 类型和实例 SplitFunc 类型定义如下： type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error) SplitFunc 定义了 用于对输入进行分词的 split 函数的签名。参数 data 是还未处理的数据，atEOF 标识 Reader 是否还有更多数据（是否到了EOF）。返回值 advance 表示从输入中读取的字节数，token 表示下一个结果数据，err 则代表可能的错误。 举例说明一下这里的 token 代表的意思： 有数据 \"studygolang\\tpolaris\\tgolangchina\"，通过\"\\t\"进行分词，那么会得到三个token，它们的内容分别是：studygolang、polaris 和 golangchina。而 SplitFunc 的功能是：进行分词，并返回未处理的数据中第一个 token。对于这个数据，就是返回 studygolang。\r如果 data 中没有一个完整的 token，例如，在扫描行（scanning lines）时没有换行符，SplitFunc 会返回(0,nil,nil)通知 Scanner 读取更多数据到 slice 中，然后在这个更大的 slice 中同样的读取点处，从输入中重试读取。如下面要讲解的 split 函数的源码中有这样的代码： // Request more data. return 0, nil, nil 如果 err != nil，扫描停止，同时该错误会返回。 如果参数 data 为空的 slice，除非 atEOF 为 true，否则该函数永远不会被调用。如果 atEOF 为 true，这时 data 可以非空，这时的数据是没有处理的。 bufio 包定义的 split 函数，即 SplitFunc 的实例 在 bufio 包中预定义了一些 split 函数，也就是说，在 Scanner 结构中的 split 字段，可以通过这些预定义的 split 赋值，同时 Scanner 类型的 Split 方法也可以接收这些预定义函数作为参数。所以，我们可以说，这些预定义 split 函数都是 SplitFunc 类型的实例。这些函数包括：ScanBytes、ScanRunes、ScanWords 和 ScanLines。（由于都是 SplitFunc 的实例，自然这些函数的签名都和 SplitFunc 一样） ScanBytes 返回单个字节作为一个 token。 ScanRunes 返回单个 UTF-8 编码的 rune 作为一个 token。返回的 rune 序列（token）和 range string类型 返回的序列是等价的，也就是说，对于无效的 UTF-8 编码会解释为 U+FFFD = “\\xef\\xbf\\xbd”。 ScanWords 返回通过“空格”分词的单词。如：study golang，调用会返回study。注意，这里的“空格”是 unicode.IsSpace()，即包括：’\\t’, ‘\\n’, ‘\\v’, ‘\\f’, ‘\\r’, ’ ‘, U+0085 (NEL), U+00A0 (NBSP)。 ScanLines 返回一行文本，不包括行尾的换行符。这里的换行包括了Windows下的\"\\r\\n\"和Unix下的\"\\n\"。 一般地，我们不会单独使用这些函数，而是提供给 Scanner 实例使用。现在我们回到 Scanner 的 split、maxTokenSize 和 token 字段上来。 split 字段（SplitFunc 类型实例），很显然，代表了当前 Scanner 使用的分词策略，可以使用上面介绍的预定义 SplitFunc 实例赋值，也可以自定义 SplitFunc 实例。（当然，要给 split 字段赋值，必须调用 Scanner 的 Split 方法） maxTokenSize 字段 表示通过 split 分词后的一个 token 允许的最大长度。在该包中定义了一个常量 MaxScanTokenSize = 64 * 1024，这是允许的最大 token 长度（64k）。 token 字段 上文已经解释了这个是什么意思。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:33:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.2.2 Scanner 的实例化 Scanner 没有导出任何字段，而它需要有外部的 io.Reader 对象，因此，我们不能直接实例化 Scanner 对象，必须通过 bufio 包提供的实例化函数来实例化。实例化函数签名以及内部实现： func NewScanner(r io.Reader) *Scanner { return \u0026Scanner{ r: r, split: ScanLines, maxTokenSize: MaxScanTokenSize, buf: make([]byte, 4096), // Plausible starting size; needn't be large. } } 可见，返回的 Scanner 实例默认的 split 函数是 ScanLines。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:33:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.2.2 Scanner 的方法 Split 方法 前面我们提到过可以通过 Split 方法为 Scanner 实例设置分词行为。由于 Scanner 实例的默认 split 总是 ScanLines，如果我们想要用其他的 split，可以通过 Split 方法做到。 比如，我们想要统计一段英文有多少个单词（不排除重复），我们可以这么做： const input = \"This is The Golang Standard Library.\\nWelcome you!\" scanner := bufio.NewScanner(strings.NewReader(input)) scanner.Split(bufio.ScanWords) count := 0 for scanner.Scan() { count++ } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading input:\", err) } fmt.Println(count) 输出： 8 我们实例化 Scanner 后，通过调用 scanner.Split(bufio.ScanWords) 来更改 split 函数。注意，我们应该在调用 Scan 方法之前调用 Split 方法。 Scan 方法 该方法好比 iterator 中的 Next 方法，它用于将 Scanner 获取下一个 token，以便 Bytes 和 Text 方法可用。当扫描停止时，它返回false，这时候，要么是到了输入的末尾要么是遇到了一个错误。注意，当 Scan 返回 false 时，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。 Bytes 和 Text 方法 这两个方法的行为一致，都是返回最近的 token，无非 Bytes 返回的是 []byte，Text 返回的是 string。该方法应该在 Scan 调用后调用，而且，下次调用 Scan 会覆盖这次的 token。比如： scanner := bufio.NewScanner(strings.NewReader(\"http://studygolang.com. \\nIt is the home of gophers\")) if scanner.Scan() { scanner.Scan() fmt.Printf(\"%s\", scanner.Text()) } 返回的是：It is the home of gophers 而不是 http://studygolang.com. Err 方法 前面已经提到，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。 下面，我们通过一个完整的示例来演示 Scanner 类型的使用。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:33:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.2.3 Scanner 使用示例 我们经常会有这样的需求：读取文件中的数据，一次读取一行。在学习了 Reader 类型，我们可以使用它的 ReadBytes 或 ReadString来实现，甚至使用 ReadLine 来实现。然而，在 Go1.1 中，我们可以使用 Scanner 来做这件事，而且更简单好用。 file, err := os.Create(\"scanner.txt\") if err != nil { panic(err) } defer file.Close() file.WriteString(\"http://studygolang.com.\\nIt is the home of gophers.\\nIf you are studying golang, welcome you!\") // 将文件 offset 设置到文件开头 file.Seek(0, os.SEEK_SET) scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } 输出结果： http://studygolang.com. It is the home of gophers. If you are studying golang, welcome you! ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:33:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.3 Writer 类型和方法 bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。 Writer 结构没有任何导出的字段，结构定义如下： type Writer struct { err error // 写过程中遇到的错误 buf []byte // 缓存 n int // 当前缓存中的字节数 wr io.Writer // 底层的 io.Writer 对象 } 相比 bufio.Reader, bufio.Writer 结构定义简单很多。 注意：如果在写数据到 Writer 的时候出现了一个错误，不会再允许有数据被写进来了，并且所有随后的写操作都会返回该错误。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:34:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.3.1 实例化 和 Reader 类型一样，bufio 包提供了两个实例化 bufio.Writer 对象的函数：NewWriter 和 NewWriterSize。其中，NewWriter 函数是调用 NewWriterSize 函数实现的： func NewWriter(wr io.Writer) *Writer { // 默认缓存大小：defaultBufSize=4096 return NewWriterSize(wr, defaultBufSize) } 我们看一下 NewWriterSize 的源码： func NewWriterSize(wr io.Writer, size int) *Writer { // 已经是 bufio.Writer 类型，且缓存大小不小于 size，则直接返回 b, ok := wr.(*Writer) if ok \u0026\u0026 len(b.buf) \u003e= size { return b } if size \u003c= 0 { size = defaultBufSize } return \u0026Writer{ buf: make([]byte, size), wr: w, } } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:34:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.3.2 Available 和 Buffered 方法 Available 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）；Buffered 方法获取写入当前缓存中的字节数（字段 n 的值） ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:34:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.3.3 Flush 方法 该方法将缓存中的所有数据写入底层的 io.Writer 对象中。使用 bufio.Writer 时，在所有的 Write 操作完成之后，应该调用 Flush 方法使得缓存都写入 io.Writer 对象中。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:34:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.3.4 其他方法 Writer 类型其他方法是一些实际的写方法： // 实现了 io.ReaderFrom 接口 func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) // 实现了 io.Writer 接口 func (b *Writer) Write(p []byte) (nn int, err error) // 实现了 io.ByteWriter 接口 func (b *Writer) WriteByte(c byte) error // io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString func (b *Writer) WriteRune(r rune) (size int, err error) // 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因 func (b *Writer) WriteString(s string) (int, error) 这些写方法在缓存满了时会调用 Flush 方法。另外，这些写方法源码开始处，有这样的代码： if b.err != nil { return b.err } 也就是说，只要写的过程中遇到了错误，再次调用写操作会直接返回该错误。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:34:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"1.4.4 ReadWriter 类型和实例化 ReadWriter 结构存储了 bufio.Reader 和 bufio.Writer 类型的指针（内嵌），它实现了 io.ReadWriter 结构。 type ReadWriter struct { *Reader *Writer } ReadWriter 的实例化可以跟普通结构类型一样，也可以通过调用 bufio.NewReadWriter 函数来实现：只是简单的实例化 ReadWriter func NewReadWriter(r *Reader, w *Writer) *ReadWriter { return \u0026ReadWriter{r, w} } 第二章 文本 几乎任何程序都离不开文本（字符串）。Go 中 string 是内置类型，同时它与普通的 slice 类型有着相似的性质，例如，可以进行切片（slice）操作，这使得 Go 中少了一些处理 string 类型的函数，比如没有 substring 这样的函数，然而却能够很方便的进行这样的操作。除此之外，Go 标准库中有几个包专门用于处理文本。 strings 包提供了很多操作字符串的简单函数，通常一般的字符串操作需求都可以在这个包中找到。 strconv 包提供了基本数据类型和字符串之间的转换。在 Go 中，没有隐式类型转换，一般的类型转换可以这么做：int32(i)，将 i （比如为 int 类型）转换为 int32，然而，字符串类型和 int、float、bool 等类型之间的转换却没有这么简单。 进行复杂的文本处理必然离不开正则表达式。regexp 包提供了正则表达式功能，它的语法基于 RE2 ，regexp/syntax 子包进行正则表达式解析。 Go 代码使用 UTF-8 编码（且不能带 BOM），同时标识符支持 Unicode 字符。在标准库 unicode 包及其子包 utf8、utf16 中，提供了对 Unicode 相关编码、解码的支持，同时提供了测试 Unicode 码点（Unicode code points）属性的功能。 在开发过程中，可能涉及到字符集的转换，作为补充，本章最后会讲解一个第三方库：mahonia — 纯 Go 语言实现的字符集转换库，以方便需要进行字符集转换的读者。 2.1 strings — 字符串操作 字符串常见操作有： 字符串长度； 求子串； 是否存在某个字符或子串； 子串出现的次数（字符串匹配）； 字符串分割（切分）为[]string； 字符串是否有某个前缀或后缀； 字符或子串在字符串中首次出现的位置或最后一次出现的位置； 通过某个字符串将[]string 连接起来； 字符串重复几次； 字符串中子串替换； 大小写转换； Trim 操作； … 前面已经说过，由于 string 类型可以看成是一种特殊的 slice 类型，因此获取长度可以用内置的函数 len；同时支持 切片 操作，因此，子串获取很容易。 其他的字符串常见操作就是我们这小节要介绍的，由于这些操作函数的使用比较简单，只会对某些函数举例说明；但会深入这些函数的内部实现，更好的掌握它们。 说明：这里说的字符，指得是 rune 类型，即一个 UTF-8 字符（Unicode 代码点）。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:35:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.1 字符串比较 // Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != \u003e \u003c \u003e= \u003c= 等一系列运算符更加直观。 func Compare(a, b string) int // EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。 func EqualFold(s, t string) bool 示例： a := \"gopher\" b := \"hello world\" fmt.Println(strings.Compare(a, b)) fmt.Println(strings.Compare(a, a)) fmt.Println(strings.Compare(b, a)) fmt.Println(strings.EqualFold(\"GO\", \"go\")) fmt.Println(strings.EqualFold(\"壹\", \"一\")) 输出结果： -1 0 1 true false ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:36:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.2 是否存在某个字符或子串 有三个函数做这件事： // 子串 substr 在 s 中，返回 true func Contains(s, substr string) bool // chars 中任何一个 Unicode 代码点在 s 中，返回 true func ContainsAny(s, chars string) bool // Unicode 代码点 r 在 s 中，返回 true func ContainsRune(s string, r rune) bool 这里对 ContainsAny 函数进行一下说明，看如下例子： fmt.Println(strings.ContainsAny(\"team\", \"i\")) fmt.Println(strings.ContainsAny(\"failure\", \"u \u0026 i\")) fmt.Println(strings.ContainsAny(\"in failure\", \"s g\")) fmt.Println(strings.ContainsAny(\"foo\", \"\")) fmt.Println(strings.ContainsAny(\"\", \"\")) 输出： false true true false false 也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回 true。 查看这三个函数的源码，发现它们只是调用了相应的 Index 函数（子串出现的位置），然后和 0 作比较返回 true 或 fale。如，Contains： func Contains(s, substr string) bool { return Index(s, substr) \u003e= 0 } 关于 Index 相关函数的实现，我们后面介绍。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:37:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.3 子串出现次数 ( 字符串匹配 ) 在数据结构与算法中，可能会讲解以下字符串匹配算法： 朴素匹配算法 KMP 算法 Rabin-Karp 算法 Boyer-Moore 算法 还有其他的算法，这里不一一列举，感兴趣的可以网上搜一下。 在 Go 中，查找子串出现次数即字符串模式匹配，实现的是 Rabin-Karp 算法。Count 函数的签名如下： func Count(s, sep string) int 在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1 fmt.Println(strings.Count(\"cheese\", \"e\")) fmt.Println(len(\"谷歌中国\")) fmt.Println(strings.Count(\"谷歌中国\", \"\")) 输出： 3 12 5 关于 Rabin-Karp 算法的实现，有兴趣的可以看看 Count 的源码。 另外，Count 是计算子串在字符串中出现的无重叠的次数，比如： fmt.Println(strings.Count(\"fivevev\", \"vev\")) 输出： 1 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:38:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.4 字符串分割为[]string 这个需求很常见，倒不一定是为了得到[]string。 该包提供了六个三组分割函数：Fields 和 FieldsFunc、Split 和 SplitAfter、SplitN 和 SplitAfterN。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:39:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.3.1 Fields 和 FieldsFunc 这两个函数的签名如下： func Fields(s string) []string func FieldsFunc(s string, f func(rune) bool) []string Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。如果字符串 s 只包含空格，则返回空列表 ([]string 的长度为 0）。其中，空格的定义是 unicode.IsSpace，之前已经介绍过。 常见间隔符包括：’\\t’, ‘\\n’, ‘\\v’, ‘\\f’, ‘\\r’, ’ ‘, U+0085 (NEL), U+00A0 (NBSP) 由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如： fmt.Printf(\"Fields are: %q\", strings.Fields(\" foo bar baz \")) 输出结果： Fields are: [\"foo\" \"bar\" \"baz\"] FieldsFunc 用这样的 Unicode 代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点 (unicode code points) 都满足 f(c) 或者 s 是空，则 FieldsFunc 返回空 slice。 也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现： fmt.Println(strings.FieldsFunc(\" foo bar baz \", unicode.IsSpace)) 实际上，Fields 函数就是调用 FieldsFunc 实现的： func Fields(s string) []string { return FieldsFunc(s, unicode.IsSpace) } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:39:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.3.2 Split 和 SplitAfter、 SplitN 和 SplitAfterN 之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现： func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) } func SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) } func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) } func SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) } 它们都调用了 genSplit 函数。 这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(\"abc\",\"\")，得到的是[a b c]。 Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。 那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了： fmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\")) fmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\")) 输出： [\"foo\" \"bar\" \"baz\"] [\"foo,\" \"bar,\" \"baz\"] 也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。 带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n \u003c 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n \u003e 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如： fmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2)) 输出： [\"foo\" \"bar,baz\"] 另外看一下官方文档提供的例子，注意一下输出结果： fmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\")) fmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \")) fmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\")) fmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\")) 输出： [\"a\" \"b\" \"c\"] [\"\" \"man \" \"plan \" \"canal panama\"] [\" \" \"x\" \"y\" \"z\" \" \"] [\"\"] ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:39:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.4 字符串是否有某个前缀或后缀 这两个函数比较简单，源码如下： // s 中是否以 prefix 开始 func HasPrefix(s, prefix string) bool { return len(s) \u003e= len(prefix) \u0026\u0026 s[0:len(prefix)] == prefix } // s 中是否以 suffix 结尾 func HasSuffix(s, suffix string) bool { return len(s) \u003e= len(suffix) \u0026\u0026 s[len(s)-len(suffix):] == suffix } 如果 prefix 或 suffix 为 \"\" , 返回值总是 true。 示例： fmt.Println(strings.HasPrefix(\"Gopher\", \"Go\")) fmt.Println(strings.HasPrefix(\"Gopher\", \"C\")) fmt.Println(strings.HasPrefix(\"Gopher\", \"\")) fmt.Println(strings.HasSuffix(\"Amigo\", \"go\")) fmt.Println(strings.HasSuffix(\"Amigo\", \"Ami\")) fmt.Println(strings.HasSuffix(\"Amigo\", \"\")) 输出结果： true false true true false true ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:40:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.5 字符或子串在字符串中出现的位置 有一序列函数与该功能有关： // 在 s 中查找 sep 的第一次出现，返回第一次出现的索引 func Index(s, sep string) int // 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引 func IndexByte(s string, c byte) int // chars 中任何一个 Unicode 代码点在 s 中首次出现的位置 func IndexAny(s, chars string) int // 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true func IndexFunc(s string, f func(rune) bool) int // Unicode 代码点 r 在 s 中第一次出现的位置 func IndexRune(s string, r rune) int // 有三个对应的查找最后一次出现的位置 func LastIndex(s, sep string) int func LastIndexByte(s string, c byte) int func LastIndexAny(s, chars string) int func LastIndexFunc(s string, f func(rune) bool) int 在 2.1.1 小节提到过，Contain 相关的函数内部调用的是响应的 Index 函数。 这一序列函数，只举 IndexFunc 的例子： han := func(c rune) bool { return unicode.Is(unicode.Han, c) // 汉字 } fmt.Println(strings.IndexFunc(\"Hello, world\", han)) fmt.Println(strings.IndexFunc(\"Hello, 世界\", han)) 输出： -1 7 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:41:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.6 字符串 JOIN 操作 将字符串数组（或 slice）连接起来可以通过 Join 实现，函数签名如下： func Join(a []string, sep string) string 假如没有这个库函数，我们自己实现一个，我们会这么实现： func Join(str []string, sep string) string { // 特殊情况应该做处理 if len(str) == 0 { return \"\" } if len(str) == 1 { return str[0] } buffer := bytes.NewBufferString(str[0]) for _, s := range str[1:] { buffer.WriteString(sep) buffer.WriteString(s) } return buffer.String() } 这里，我们使用了 bytes 包的 Buffer 类型，避免大量的字符串连接操作（因为 Go 中字符串是不可变的）。我们再看一下标准库的实现： func Join(a []string, sep string) string { if len(a) == 0 { return \"\" } if len(a) == 1 { return a[0] } n := len(sep) * (len(a) - 1) for i := 0; i \u003c len(a); i++ { n += len(a[i]) } b := make([]byte, n) bp := copy(b, a[0]) for _, s := range a[1:] { bp += copy(b[bp:], sep) bp += copy(b[bp:], s) } return string(b) } 标准库的实现没有用 bytes 包，当然也不会简单的通过 + 号连接字符串。Go 中是不允许循环依赖的，标准库中很多时候会出现代码拷贝，而不是引入某个包。这里 Join 的实现方式挺好，我个人猜测，不直接使用 bytes 包，也是不想依赖 bytes 包（其实 bytes 中的实现也是 copy 方式）。 简单使用示例： fmt.Println(Join([]string{\"name=xxx\", \"age=xx\"}, \"\u0026\")) 输出结果: name=xxx\u0026age=xx ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:42:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.7 字符串重复几次 函数签名如下： func Repeat(s string, count int) string 将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单： fmt.Println(\"ba\" + strings.Repeat(\"na\", 2)) 输出结果： banana ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:43:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.8 字符替换 func Map(mapping func(rune) rune, s string) string Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 \u003c0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。 示例： mapping := func(r rune) rune { switch { case r \u003e= 'A' \u0026\u0026 r \u003c= 'Z': // 大写字母转小写 return r + 32 case r \u003e= 'a' \u0026\u0026 r \u003c= 'z': // 小写字母不处理 return r case unicode.Is(unicode.Han, r): // 汉字换行 return '\\n' } return -1 // 过滤所有非字母、汉字的字符 } fmt.Println(strings.Map(mapping, \"Hello你#￥%……\\n（'World\\n,好Hello^(\u0026(*界gopher...\")) 输出结果： hello world hello gopher ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:44:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.9 字符串子串替换 进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。 字符串替换的函数签名如下： // 用 new 替换 s 中的 old，一共替换 n 个。 // 如果 n \u003c 0，则不限制替换次数，即全部替换 func Replace(s, old, new string, n int) string // 该函数内部直接调用了函数 Replace(s, old, new , -1) func ReplaceAll(s, old, new string) string 使用示例： fmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2)) fmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1)) fmt.Println(strings.ReplaceAll(\"oink oink oink\", \"oink\", \"moo\")) 输出： oinky oinky oink moo moo moo moo moo moo 如果我们希望一次替换多个，比如我们希望替换 This is \u003cb\u003eHTML\u003c/b\u003e 中的 \u003c 和 \u003e 为 \u0026lt; 和 \u0026gt;，可以调用上面的函数两次。但标准库提供了另外的方法进行这种替换。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:45:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.10 大小写转换 func ToLower(s string) string func ToLowerSpecial(c unicode.SpecialCase, s string) string func ToUpper(s string) string func ToUpperSpecial(c unicode.SpecialCase, s string) string 大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子： fmt.Println(strings.ToLower(\"HELLO WORLD\")) fmt.Println(strings.ToLower(\"Ā Á Ǎ À\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"壹\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"HELLO WORLD\")) fmt.Println(strings.ToLower(\"Önnek İş\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"Önnek İş\")) fmt.Println(strings.ToUpper(\"hello world\")) fmt.Println(strings.ToUpper(\"ā á ǎ à\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"一\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"hello world\")) fmt.Println(strings.ToUpper(\"örnek iş\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"örnek iş\")) 输出结果: hello world ā á ǎ à 壹 hello world önnek iş önnek iş HELLO WORLD Ā Á Ǎ À // 汉字拼音有效 一 // 汉字无效 HELLO WORLD ÖRNEK IŞ ÖRNEK İŞ // 有细微差别 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:46:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.10 标题处理 func Title(s string) string func ToTitle(s string) string func ToTitleSpecial(c unicode.SpecialCase, s string) string 标题处理包含 3 个相关函数，其中 Title 会将 s 每个单词的首字母大写，不处理该单词的后续字符。ToTitle 将 s 的每个字母大写。ToTitleSpecial 将 s 的每个字母大写，并且会将一些特殊字母转换为其对应的特殊大写字母。 举个例子： fmt.Println(strings.Title(\"hElLo wOrLd\")) fmt.Println(strings.ToTitle(\"hElLo wOrLd\")) fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, \"hElLo wOrLd\")) fmt.Println(strings.Title(\"āáǎà ōóǒò êēéěè\")) fmt.Println(strings.ToTitle(\"āáǎà ōóǒò êēéěè\")) fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, \"āáǎà ōóǒò êēéěè\")) fmt.Println(strings.Title(\"dünyanın ilk borsa yapısı Aizonai kabul edilir\")) fmt.Println(strings.ToTitle(\"dünyanın ilk borsa yapısı Aizonai kabul edilir\")) fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, \"dünyanın ilk borsa yapısı Aizonai kabul edilir\")) 输出结果： HElLo WOrLd HELLO WORLD HELLO WORLD Āáǎà Ōóǒò Êēéěè ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ Dünyanın Ilk Borsa Yapısı Aizonai Kabul Edilir DÜNYANIN ILK BORSA YAPISI AIZONAI KABUL EDILIR DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:47:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.11 修剪 // 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉 func Trim(s string, cutset string) string // 将 s 左侧的匹配 cutset 中的任一字符的字符去掉 func TrimLeft(s string, cutset string) string // 将 s 右侧的匹配 cutset 中的任一字符的字符去掉 func TrimRight(s string, cutset string) string // 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。 func TrimPrefix(s, prefix string) string // 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。 func TrimSuffix(s, suffix string) string // 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL) func TrimSpace(s string) string // 将 s 左侧和右侧的匹配 f 的字符去掉 func TrimFunc(s string, f func(rune) bool) string // 将 s 左侧的匹配 f 的字符去掉 func TrimLeftFunc(s string, f func(rune) bool) string // 将 s 右侧的匹配 f 的字符去掉 func TrimRightFunc(s string, f func(rune) bool) string 包含了 9 个相关函数用于修剪字符串。 举个例子： x := \"!!!@@@你好,!@#$ Gophers###$$$\" fmt.Println(strings.Trim(x, \"@#$!%^\u0026*()_+=-\")) fmt.Println(strings.TrimLeft(x, \"@#$!%^\u0026*()_+=-\")) fmt.Println(strings.TrimRight(x, \"@#$!%^\u0026*()_+=-\")) fmt.Println(strings.TrimSpace(\" \\t\\n Hello, Gophers \\n\\t\\r\\n\")) fmt.Println(strings.TrimPrefix(x, \"!\")) fmt.Println(strings.TrimSuffix(x, \"$\")) f := func(r rune) bool { return !unicode.Is(unicode.Han, r) // 非汉字返回 true } fmt.Println(strings.TrimFunc(x, f)) fmt.Println(strings.TrimLeftFunc(x, f)) fmt.Println(strings.TrimRightFunc(x, f)) 输出结果： 你好,!@#$ Gophers 你好,!@#$ Gophers###$$$ !!!@@@你好,!@#$ Gophers Hello, Gophers !!@@@你好,!@#$ Gophers###$$$ !!!@@@你好,!@#$ Gophers###$$ 你好 你好,!@#$ Gophers###$$$ !!!@@@你好 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:48:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.12 Replacer 类型 这是一个结构，没有导出任何字段，实例化通过 func NewReplacer(oldnew ...string) *Replacer 函数进行，其中不定参数 oldnew 是 old-new 对，即进行多个替换。如果 oldnew 长度与奇数，会导致 panic. 示例： r := strings.NewReplacer(\"\u003c\", \"\u0026lt;\", \"\u003e\", \"\u0026gt;\") fmt.Println(r.Replace(\"This is \u003cb\u003eHTML\u003c/b\u003e!\")) 输出结果： This is \u0026lt;b\u0026gt;HTML\u0026lt;/b\u0026gt;! 另外，Replacer 还提供了另外一个方法，它在替换之后将结果写入 io.Writer 中。 func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:49:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.13 Reader 类型 看到名字就能猜到，这是实现了 io 包中的接口。它实现了 io.Reader（Read 方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。 Reader 结构如下： type Reader struct { s string // Reader 读取的数据来源 i int // current reading index（当前读的索引位置） prevRune int // index of previous rune; or \u003c 0（前一个读取的 rune 索引位置） } 可见 Reader 结构没有导出任何字段，而是提供一个实例化方法： func NewReader(s string) *Reader 该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。在后面学习了 bytes 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。 其他方法不介绍了，都是之前接口的实现，有兴趣的可以看看源码实现，大部分都是根据 i、prevRune 两个属性来控制。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:50:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.1.14 Builder 类型 type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } 该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。 // 该方法向 b 写入一个字节 func (b *Builder) WriteByte(c byte) error // WriteRune 方法向 b 写入一个字符 func (b *Builder) WriteRune(r rune) (int, error) // WriteRune 方法向 b 写入字节数组 p func (b *Builder) Write(p []byte) (int, error) // WriteRune 方法向 b 写入字符串 s func (b *Builder) WriteString(s string) (int, error) // Len 方法返回 b 的数据长度。 func (b *Builder) Len() int // Cap 方法返回 b 的 cap。 func (b *Builder) Cap() int // Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。 func (b *Builder) Grow(n int) // Reset 方法将 b 清空 b 的所有内容。 func (b *Builder) Reset() // String 方法将 b 的数据以 string 类型返回。 func (b *Builder) String() string Builder 有 4 个与写入相关的方法，这 4 个方法的 error 都总是为 nil. Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。 String 方法可以方便的获取 Builder 的内容。 举个例子： b := strings.Builder{} _ = b.WriteByte('7') n, _ := b.WriteRune('夕') fmt.Println(n) n, _ = b.Write([]byte(\"Hello, World\")) fmt.Println(n) n, _ = b.WriteString(\"你好，世界\") fmt.Println(n) fmt.Println(b.Len()) fmt.Println(b.Cap()) b.Grow(100) fmt.Println(b.Len()) fmt.Println(b.Cap()) fmt.Println(b.String()) b.Reset() fmt.Println(b.String()) 输出结果： 3 12 15 31 32 31 164 7夕Hello, World你好，世界 2.2 bytes — byte slice 便利操作 该包定义了一些操作 byte slice 的便利操作。因为字符串可以表示为 []byte，因此，bytes 包定义的函数、方法等和 strings 包很类似，所以讲解时会和 strings 包类似甚至可以直接参考。 说明：为了方便，会称呼 []byte 为 字节数组 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:51:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Buffer 类型 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:52:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"逻辑 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:52:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.2.1 是否存在某个子 slice // 子 slice subslice 在 b 中，返回 true func Contains(b, subslice []byte) bool 该函数的内部调用了 bytes.Index 函数（在后面会讲解）: func Contains(b, subslice []byte) bool { return Index(b, subslice) != -1 } 题外：对比 strings.Contains 你会发现，一个判断 \u003e=0，一个判断 != -1，可见库不是一个人写的，没有做到一致性。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:53:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.2.2 []byte 出现次数 // slice sep 在 s 中出现的次数（无重叠） func Count(s, sep []byte) int 和 strings 实现不同，此包中的 Count 核心代码如下： count := 0 c := sep[0] i := 0 t := s[:len(s)-n+1] for i \u003c len(t) { // 判断 sep 第一个字节是否在 t[i:] 中 // 如果在，则比较之后相应的字节 if t[i] != c { o := IndexByte(t[i:], c) if o \u003c 0 { break } i += o } // 执行到这里表示 sep[0] == t[i] if n == 1 || Equal(s[i:i+n], sep) { count++ i += n continue } i++ } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:54:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.2.3 Runes 类型转换 // 将 []byte 转换为 []rune func Runes(s []byte) []rune 该函数将 []byte 转换为 []rune ，适用于汉字等多字节字符，示例： b:=[]byte(\"你好，世界\") for k,v:=range b{ fmt.Printf(\"%d:%s |\",k,string(v)) } r:=bytes.Runes(b) for k,v:=range r{ fmt.Printf(\"%d:%s|\",k,string(v)) } 运行结果： 0:ä |1:½ |2: |3:å |4:¥ |5:½ |6:ï |7:¼ |8: |9:ä |10:¸ |11: |12:ç |13: |14: | 0:你|1:好|2:，|3:世|4:界| ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:55:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.2.4 Reader 类型 type Reader struct { s []byte i int64 // 当前读取下标 prevRune int // 前一个字符的下标，也可能 \u003c 0 } bytes 包下的 Reader 类型实现了 io 包下的 Reader, ReaderAt, RuneReader, RuneScanner, ByteReader, ByteScanner, ReadSeeker, Seeker, WriterTo 等多个接口。主要用于 Read 数据。 我们需要在通过 bytes.NewReader 方法来初始化 bytes.Reader 类型的对象。初始化时传入 []byte 类型的数据。NewReader 函数签名如下： func NewReader(b []byte) *Reader 如果直接声明该对象了，可以通过 Reset 方法重新写入数据，示例： x:=[]byte(\"你好，世界\") r1:=bytes.NewReader(x) d1:=make([]byte,len(x)) n,_:=r1.Read(d1) fmt.Println(n,string(d1)) r2:=bytes.Reader{} r2.Reset(x) d2:=make([]byte,len(x)) n,_=r2.Read(d2) fmt.Println(n,string(d2)) 输出结果： 15 你好，世界 15 你好，世界 Reader 包含了 8 个读取相关的方法，实现了前面提到的 io 包下的 9 个接口（ReadSeeker 接口内嵌 Reader 和 Seeker 两个接口）： // 读取数据至 b func (r *Reader) Read(b []byte) (n int, err error) // 读取一个字节 func (r *Reader) ReadByte() (byte, error) // 读取一个字符 func (r *Reader) ReadRune() (ch rune, size int, err error) // 读取数据至 w func (r *Reader) WriteTo(w io.Writer) (n int64, err error) // 进度下标指向前一个字节，如果 r.i \u003c= 0 返回错误。 func (r *Reader) UnreadByte() // 进度下标指向前一个字符，如果 r.i \u003c= 0 返回错误，且只能在每次 ReadRune 方法后使用一次，否则返回错误。 func (r *Reader) UnreadRune() // 读取 r.s[off:] 的数据至b，该方法忽略进度下标 i，不使用也不修改。 func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) // 根据 whence 的值，修改并返回进度下标 i ，当 whence == 0 ，进度下标修改为 off，当 whence == 1 ，进度下标修改为 i+off，当 whence == 2 ，进度下标修改为 len[s]+off. // off 可以为负数，whence 的只能为 0，1，2，当 whence 为其他值或计算后的进度下标越界，则返回错误。 func (r *Reader) Seek(offset int64, whence int) (int64, error) 示例： x := []byte(\"你好，世界\") r1 := bytes.NewReader(x) ch, size, _ := r1.ReadRune() fmt.Println(size, string(ch)) _ = r1.UnreadRune() ch, size, _ = r1.ReadRune() fmt.Println(size, string(ch)) _ = r1.UnreadRune() by, _ := r1.ReadByte() fmt.Println(by) _ = r1.UnreadByte() by, _ = r1.ReadByte() fmt.Println(by) _ = r1.UnreadByte() d1 := make([]byte, 6) n, _ := r1.Read(d1) fmt.Println(n, string(d1)) d2 := make([]byte, 6) n, _ = r1.ReadAt(d2, 0) fmt.Println(n, string(d2)) w1 := \u0026bytes.Buffer{} _, _ = r1.Seek(0, 0) _, _ = r1.WriteTo(w1) fmt.Println(w1.String()) 运行结果： 3 你 3 你 228 228 6 你好 6 你好 你好，世界 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:56:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.2.5 Buffer 类型 type Buffer struct { buf []byte off int lastRead readOp } 在上一个示例的最后，我们使用了 bytes.Buffer 类型，该类型实现了 io 包下的 ByteScanner, ByteWriter, ReadWriter, Reader, ReaderFrom, RuneReader, RuneScanner, StringWriter, Writer, WriterTo 等接口，可以方便的进行读写操作。 对象可读取数据为 buf[off : len(buf)], off 表示进度下标，lastRead 表示最后读取的一个字符所占字节数，方便 Unread* 相关操作。 Buffer 可以通过 3 中方法初始化对象： a := bytes.NewBufferString(\"Hello World\") b := bytes.NewBuffer([]byte(\"Hello World\")) c := bytes.Buffer{} fmt.Println(a) fmt.Println(b) fmt.Println(c) } 输出结果： Hello World Hello World {[] 0 0} Buffer 包含了 21 个读写相关的方法，大部分同名方法的用法与前面讲的类似，这里只讲演示其中的 3 个方法： // 读取到字节 delim 后，以字节数组的形式返回该字节及前面读取到的字节。如果遍历 b.buf 也找不到匹配的字节，则返回错误(一般是 EOF) func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) // 读取到字节 delim 后，以字符串的形式返回该字节及前面读取到的字节。如果遍历 b.buf 也找不到匹配的字节，则返回错误(一般是 EOF) func (b *Buffer) ReadString(delim byte) (line string, err error) // 截断 b.buf , 舍弃 b.off+n 之后的数据。n == 0 时，调用 Reset 方法重置该对象，当 n 越界时（n \u003c 0 || n \u003e b.Len() ）方法会触发 panic. func (b *Buffer) Truncate(n int) 示例： a := bytes.NewBufferString(\"Good Night\") x, err := a.ReadBytes('t') if err != nil { fmt.Println(\"delim:t err:\", err) } else { fmt.Println(string(x)) } a.Truncate(0) a.WriteString(\"Good Night\") fmt.Println(a.Len()) a.Truncate(5) fmt.Println(a.Len()) y, err := a.ReadString('N') if err != nil { fmt.Println(\"delim:N err:\", err) } else { fmt.Println(y) } 输出结果： Good Night 10 5 delim:N err: EOF ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:57:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.2.6 其它函数 其它大部分函数、方法与 strings 包下的函数、方法类似，只是数据源从 string 变为了 []byte ，请参考 strings 包的用法。 2.3 strconv — 字符串和基本数据类型之间转换 这里的基本数据类型包括：布尔、整型（包括有 / 无符号、二进制、八进制、十进制和十六进制）和浮点型等。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:58:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.1 strconv 包转换错误处理 介绍具体的转换之前，先看看 strconv 中的错误处理。 由于将字符串转为其他数据类型可能会出错，strconv 包定义了两个 error 类型的变量：ErrRange 和 ErrSyntax。其中，ErrRange 表示值超过了类型能表示的最大范围，比如将 “128” 转为 int8 就会返回这个错误；ErrSyntax 表示语法错误，比如将 \"\" 转为 int 类型会返回这个错误。 然而，在返回错误的时候，不是直接将上面的变量值返回，而是通过构造一个 NumError 类型的 error 对象返回。NumError 结构的定义如下： // A NumError records a failed conversion.\rtype NumError struct {\rFunc string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)\rNum string // the input\rErr error // the reason the conversion failed (ErrRange, ErrSyntax)\r}\r可见，该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 error 类型的成员，记录具体的错误信息，而且它自己也实现了 error 接口： func (e *NumError) Error() string {\rreturn \"strconv.\" + e.Func + \": \" + \"parsing \" + Quote(e.Num) + \": \" + e.Err.Error()\r}\r包的实现中，定义了两个便捷函数，用于构造 NumError 对象： func syntaxError(fn, str string) *NumError {\rreturn \u0026NumError{fn, str, ErrSyntax}\r}\rfunc rangeError(fn, str string) *NumError {\rreturn \u0026NumError{fn, str, ErrRange}\r}\r在遇到 ErrSyntax 或 ErrRange 错误时，通过上面的函数构造 NumError 对象。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:59:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.2 字符串和整型之间的转换 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:60:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.2.1 字符串转为整型 包括三个函数：ParseInt、ParseUint 和 Atoi，函数原型如下： func ParseInt(s string, base int, bitSize int) (i int64, err error)\rfunc ParseUint(s string, base int, bitSize int) (n uint64, err error)\rfunc Atoi(s string) (i int, err error)\r其中，Atoi 是 ParseInt 的便捷版，内部通过调用 ParseInt(s, 10, 0) 来实现的；ParseInt 转为有符号整型；ParseUint 转为无符号整型，着重介绍 ParseInt。 参数 base 代表字符串按照给定的进制进行解释。一般的，base 的取值为 2~36，如果 base 的值为 0，则会根据字符串的前缀来确定 base 的值：“0x” 表示 16 进制； “0” 表示 8 进制；否则就是 10 进制。 参数 bitSize 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。 这里有必要说一下，当 bitSize==0 时的情况。 Go 中，int/uint 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。当 bitSize==0 时，应该表示 32 位还是 64 位呢？这里没有利用 runtime.GOARCH 之类的方式，而是巧妙的通过如下表达式确定 intSize： const intSize = 32 \u003c\u003c uint(^uint(0)\u003e\u003e63)\rconst IntSize = intSize // number of bits in int, uint (32 or 64)\r主要是 ^uint(0)»63 这个表达式。操作符 ^ 在这里是一元操作符 按位取反，而不是 按位异或。更多解释可以参考：Go 位运算：取反和异或。 问题：下面的代码 n 和 err 的值分别是什么？ n, err := strconv.ParseInt(\"128\", 10, 8)\r在 ParseInt/ParseUint 的实现中，如果字符串表示的整数超过了 bitSize 参数能够表示的范围，则会返回 ErrRange，同时会返回 bitSize 能够表示的最大或最小值。因此，这里的 n 是 127。 另外，ParseInt 返回的是 int64，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 bitSize，然后将结果转为实际需要的类型。 转换的基本原理（以 “128” 转 为 10 进制 int 为例）： s := \"128\"\rn := 0\rfor i := 0; i \u003c len(s); i++ {\rn *= 10 + s[i] // base\r}\r在循环处理的过程中，会检查数据的有效性和是否越界等。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:60:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.2.2 整型转为字符串 实际应用中，我们经常会遇到需要将字符串和整型连接起来，在 Java 中，可以通过操作符 “+” 做到。不过，在 Go 语言中，你需要将整型转为字符串类型，然后才能进行连接。这个时候，strconv 包中的整型转字符串的相关函数就派上用场了。这些函数签名如下： func FormatUint(i uint64, base int) string // 无符号整型转字符串\rfunc FormatInt(i int64, base int) string // 有符号整型转字符串\rfunc Itoa(i int) string\r其中，Itoa 内部直接调用 FormatInt(i, 10) 实现的。base 参数可以取 2~36（0-9，a-z）。 转换的基本原理（以 10 进制的 127 转 string 为例） ： const digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\ru := uint64(127)\rvar a [65]byte\ri := len(a)\rb := uint64(base)\rfor u \u003e= b {\ri--\ra[i] = digits[uintptr(u%b)]\ru /= b\r}\ri--\ra[i] = digits[uintptr(u)]\rreturn string(a[1:])\r即将整数每一位数字对应到相应的字符，存入字符数组中，最后字符数组转为字符串即为结果。 具体实现时，当 base 是 2 的幂次方时，有优化处理（移位和掩码）；十进制也做了优化。 标准库还提供了另外两个函数：AppendInt 和 AppendUint，这两个函数不是将整数转为字符串，而是将整数转为字符数组 append 到目标字符数组中。（最终，我们也可以通过返回的 []byte 得到字符串） 除了使用上述方法将整数转为字符串外，经常见到有人使用 fmt 包来做这件事。如： fmt.Sprintf(\"%d\", 127)\r那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。 startTime := time.Now()\rfor i := 0; i \u003c 10000; i++ {\rfmt.Sprintf(\"%d\", i)\r}\rfmt.Println(time.Now().Sub(startTime))\rstartTime := time.Now()\rfor i := 0; i \u003c 10000; i++ {\rstrconv.Itoa(i)\r}\rfmt.Println(time.Now().Sub(startTime))\r我们分别循环转换了 10000 次。Sprintf 的时间是 3.549761ms，而 Itoa 的时间是 848.208us，相差 4 倍多。 Sprintf 性能差些可以预见，因为它接收的是 interface，需要进行反射等操作。个人建议使用 strconv 包中的方法进行转换。 注意：别想着通过 string(65) 这种方式将整数转为字符串，这样实际上得到的会是 ASCCII 值为 65 的字符，即 ‘A’。 思考： 给定一个 40 以内的正整数，如何快速判断其是否是 2 的幂次方？\r提示：在 strconv 包源码 itoa.go 文件中找答案 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:60:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.3 字符串和布尔值之间的转换 Go 中字符串和布尔值之间的转换比较简单，主要有三个函数： // 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；\r// 其他形式的字符串会返回错误\rfunc ParseBool(str string) (value bool, err error)\r// 直接返回 \"true\" 或 \"false\"\rfunc FormatBool(b bool) string\r// 将 \"true\" 或 \"false\" append 到 dst 中\r// 这里用了一个 append 函数对于字符串的特殊形式：append(dst, \"true\"...)\rfunc AppendBool(dst []byte, b bool)\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:61:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.4 字符串和浮点数之间的转换 类似的，包含三个函数： func ParseFloat(s string, bitSize int) (f float64, err error)\rfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\rfunc AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int)\r函数的命名和作用跟上面讲解的其他类型一致。 关于 FormatFloat 的 fmt 参数， 在第一章第三节格式化 IO 中有详细介绍。而 prec 表示有效数字（对 fmt=‘b’ 无效），对于 ’e’, ‘E’ 和 ‘f’，有效数字用于小数点之后的位数；对于 ‘g’ 和 ‘G’，则是所有的有效数字。例如： strconv.FormatFloat(1223.13252, 'e', 3, 32) // 结果：1.223e+03\rstrconv.FormatFloat(1223.13252, 'g', 3, 32) // 结果：1.22e+03\r由于浮点数有精度的问题，精度不一样，ParseFloat 和 FormatFloat 可能达不到互逆的效果。如： s := strconv.FormatFloat(1234.5678, 'g', 6, 64)\rstrconv.ParseFloat(s, 64)\r另外，fmt=‘b’ 时，得到的字符串是无法通过 ParseFloat 还原的。 特别地（不区分大小写），+inf/inf，+infinity/infinity，-inf/-infinity 和 nan 通过 ParseFloat 转换分别返回对应的值（在 math 包中定义）。 同样的，基于性能的考虑，应该使用 FormatFloat 而不是 fmt.Sprintf。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:62:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.3.5 其他导出的函数 如果要输出这样一句话：This is “studygolang.com” website. 该如何做？ So easy: fmt.Println(`This is \"studygolang.com\" website`)\r如果没有 `` 符号，该怎么做？转义： fmt.Println(\"This is \\\"studygolang.com\\\" website\")\r除了这两种方法，strconv 包还提供了函数这做件事（Quote 函数）。我们称 “studygolang.com” 这种用双引号引起来的字符串为 Go 语言字面值字符串（Go string literal）。 上面的一句话可以这么做： fmt.Println(\"This is\", strconv.Quote(\"studygolang.com\"), \"website\")\r2.4 regexp — 正则表达式 正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。正则表达式为文本处理提供了强大的功能。Go 作为一门通用语言，自然提供了对正则表达式的支持。 regexp 包实现了正则表达式搜索。 正则表达式采用 RE2 语法（除了 \\c、\\C），和 Perl、Python 等语言的正则基本一致。确切地说是兼容 RE2 语法。相关资料：http://code.google.com/p/re2/wiki/Syntax，包：regexp/syntax 注意：regexp 包的正则表达式实现保证运行时间随着输入大小线性增长的（即复杂度为 O(n)，其中 n 为输入的长度），这一点，很多正则表达式的开源实现无法保证，参见：RSC 的 《Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, …)》 另外，所有的字符都被视为 utf-8 编码的码值 (Code Point)。 Regexp 类型提供了多达 16 个方法，用于匹配正则表达式并获取匹配的结果。它们的名字满足如下正则表达式： Find(All)?(String)?(Submatch)?(Index)? 2.5 unicode — Unicode 码点、UTF-8/16 编码 世界中的字符有许许多多，有英文，中文，韩文等。随着全球化进程不断深入，我们强烈需要一个能够容纳世界上所有字符的字符集，方便编码为计算机能处理的二进制数。每个字符都给予一个独一无二的编号，就不会出现写文字的人和阅读文字的人使用不同的编码而出现乱码现象。 于是 Unicode 就出现了，它将所有的字符用一个唯一的数字表示。最开始的时候，unicode 认为使用两个字节，也就是 16 位就能包含所有的字符了。但是非常可惜，两个字节最多只能覆盖 65536 个字符，这显然是不够的，于是出现了 unicode4.0，附加的字符用 4 个字节表示。现在为止，大概 Unicode 可以覆盖 100 多万个字符了。 Unicode 就只是代表字符集，也就是只定义了字符到码点（Code Point）的映射（可以理解为 Unicode 定义了一个表，表中每一行记录是一个字符到一个唯一 ID 的映射，而这个 ID 就是码点），并没有定义码点具体如何编码。对应的字符编码有多种，比如 UTF-8、UTF-16 等。所以需要理解字符集和字符编码是不一样的。更详细的说明可以参考该文：https://polarisxu.studygolang.com/posts/basic/char-set-encoding/。 UTF-8 表示最少用一个字节就能表示一个字符的编码实现。它采取的方式是对不同的语言使用不同的方法，将 unicode 编码按照这个方法进行转换。 我们只要记住最后的结果是英文占一个字节，中文占三个字节。这种编码实现方式也是现在应用最为广泛的方式了。 UTF-16 表示最少用两个字节能表示一个字符的编码实现。同样是对 unicode 编码进行转换，它的结果是英文占用两个字节，中文占用两个或者四个字节。 实际上，UTF-16 就是最严格实现了 unicode4.0 的编码方式。但由于英文是最通用的语言，所以推广程度没有 UTF-8 那么普及。 回到 Go 对 unicode 包的支持，由于 UTF-8 的作者 Ken Thompson 同时也是 Go 语言的创始人，所以说，在字符支持方面，几乎没有语言的理解会高于 Go 了。 Go 对 unicode 的支持包含三个包 : unicode unicode/utf8 unicode/utf16 unicode 包包含基本的字符判断函数。utf8 包主要负责 rune 和 byte 之间的转换。utf16 包负责 rune 和 uint16 数组之间的转换。 由于字符的概念有的时候比较模糊，比如字符（小写 a）普通显示为 a，在重音字符中（grave-accented）中显示为 à。 这时候字符（character）的概念就有点不准确了，因为 a 和 à 显然是两个不同的 unicode 编码，但是却代表同一个字符，所以引入了 rune。 一个 rune 就代表一个 unicode 码点，所以上面的 a 和 à 是两个不同的 rune。 这里有个要注意的事情，Go 语言的所有代码都是 UTF-8 的，所以我们在程序中的字符串都是 UTF-8 编码的，但是我们的单个字符（单引号扩起来的）却是 unicode 的（码点）。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:63:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.5.1 unicode 包 unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。 注意，在 Go1.16 之前，unicode 包实现的 unicode 版本是 12.0，Go1.16 实现了 13.0 这个包把所有 unicode 涉及到的码点进行了分类，使用结构 RengeTable 来表示不同类别的字符集合。这些类别都列在 table.go 这个源文件里。 // RangeTable 通过列出一组 Unicode 码点的范围来定义它。为了节省空间，在两个切片中列出了范围：切片的 16 位范围（R16）和切片的 32 位（R32）范围。这两个切片必须按排序顺序且不重叠。同样，R32 应该仅包含 \u003e = 0x10000（1 \u003c\u003c 16）的值（即附加半部分字符）。 type RangeTable struct { R16 []Range16 R32 []Range32 LatinOffset int // Hi \u003c= MaxLatin1 的 R16 中的条目数；在 Go 1.1 中添加 } type Range16 struct { Lo uint16 Hi uint16 Stride uint16 } 比如控制字符集合： var _Pc = \u0026RangeTable{ R16: []Range16{ {0x005f, 0x203f, 8160}, {0x2040, 0x2054, 20}, {0xfe33, 0xfe34, 1}, {0xfe4d, 0xfe4f, 1}, {0xff3f, 0xff3f, 1}, }, } 比如对国内开发者很实用的汉字字符集： var _Han = \u0026RangeTable{ R16: []Range16{ {0x2e80, 0x2e99, 1}, {0x2e9b, 0x2ef3, 1}, {0x2f00, 0x2fd5, 1}, {0x3005, 0x3005, 1}, {0x3007, 0x3007, 1}, {0x3021, 0x3029, 1}, {0x3038, 0x303b, 1}, {0x3400, 0x4db5, 1}, {0x4e00, 0x9fea, 1}, {0xf900, 0xfa6d, 1}, {0xfa70, 0xfad9, 1}, }, R32: []Range32{ {0x20000, 0x2a6d6, 1}, {0x2a700, 0x2b734, 1}, {0x2b740, 0x2b81d, 1}, {0x2b820, 0x2cea1, 1}, {0x2ceb0, 0x2ebe0, 1}, {0x2f800, 0x2fa1d, 1}, }, } 回到包的函数，我们看到有下面这些判断函数： func IsControl(r rune) bool // 是否控制字符 func IsDigit(r rune) bool // 是否阿拉伯数字字符，即 0-9 func IsGraphic(r rune) bool // 是否图形字符 func IsLetter(r rune) bool // 是否字母 func IsLower(r rune) bool // 是否小写字符 func IsMark(r rune) bool // 是否符号字符 func IsNumber(r rune) bool // 是否数字字符，比如罗马数字 Ⅷ 也是数字字符 func IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个 func IsPrint(r rune) bool // 是否可打印字符 func IsPunct(r rune) bool // 是否标点符号 func IsSpace(r rune) bool // 是否空格 func IsSymbol(r rune) bool // 是否符号字符 func IsTitle(r rune) bool // 是否 title case func IsUpper(r rune) bool // 是否大写字符 func Is(rangeTab *RangeTable, r rune) bool // r 是否为 rangeTab 类型的字符 func In(r rune, ranges ...*RangeTable) bool // r 是否为 ranges 中任意一个类型的字符 看下面这个例子： func main() { single := '\\u0015' fmt.Println(unicode.IsControl(single)) single = '\\ufe35' fmt.Println(unicode.IsControl(single)) digit := '1' fmt.Println(unicode.IsDigit(digit)) fmt.Println(unicode.IsNumber(digit)) letter := 'Ⅷ' fmt.Println(unicode.IsDigit(letter)) fmt.Println(unicode.IsNumber(letter)) han:='你' fmt.Println(unicode.IsDigit(han)) fmt.Println(unicode.Is(unicode.Han,han)) fmt.Println(unicode.In(han,unicode.Gujarati,unicode.White_Space)) } 输出结果： true false true true false true false true false ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:64:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.5.2 utf8 包 utf8 包用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。 1）判断是否是有效 utf8 编码的函数： func Valid(p []byte) bool func ValidRune(r rune) bool func ValidString(s string) bool 2）得到 rune 所占字节数： func RuneLen(r rune) int 3）判断字节数组或者字符串的 rune 数： func RuneCount(p []byte) int func RuneCountInString(s string) (n int) 4）编码、解码 rune： func EncodeRune(p []byte, r rune) int func DecodeRune(p []byte) (r rune, size int) func DecodeRuneInString(s string) (r rune, size int) func DecodeLastRune(p []byte) (r rune, size int) func DecodeLastRuneInString(s string) (r rune, size int) 5）是否为完整 rune： func FullRune(p []byte) bool func FullRuneInString(s string) bool 6）判断一个字节是否为 rune 的第一个字节： func RuneStart(b byte) bool 示例： word:=[]byte(\"界\") fmt.Println(utf8.Valid(word[:2])) fmt.Println(utf8.ValidRune('界')) fmt.Println(utf8.ValidString(\"世界\")) fmt.Println(utf8.RuneLen('界')) fmt.Println(utf8.RuneCount(word)) fmt.Println(utf8.RuneCountInString(\"世界\")) p:=make([]byte,3) utf8.EncodeRune(p,'好') fmt.Println(p) fmt.Println(utf8.DecodeRune(p)) fmt.Println(utf8.DecodeRuneInString(\"你好\")) fmt.Println(utf8.DecodeLastRune([]byte(\"你好\"))) fmt.Println(utf8.DecodeLastRuneInString(\"你好\")) fmt.Println(utf8.FullRune(word[:2])) fmt.Println(utf8.FullRuneInString(\"你好\")) fmt.Println(utf8.RuneStart(word[1])) fmt.Println(utf8.RuneStart(word[0])) 运行结果： false true true 3 1 2 [229 165 189] 22909 3 20320 3 22909 3 22909 3 false true false true ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:65:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"2.5.3 utf16 包 utf16 包的函数就比较少了，主要是 UTF-16 序列的编码和解码。 将 uint16 和 rune 进行转换： func Encode(s []rune) []uint16 func EncodeRune(r rune) (r1, r2 rune) func Decode(s []uint16) []rune func DecodeRune(r1, r2 rune) rune func IsSurrogate(r rune) bool // 是否为有效代理对 unicode 有个基本字符平面和增补平面的概念，基本字符平面只有 65535 个字符，增补平面（有 16 个）加上去就能表示 1114112 个字符。 utf16 严格地实现了 unicode 的这种编码规范。 而基本字符和增补平面字符就是一个代理对（Surrogate Pair）。一个代理对可以和一个 rune 进行转换。 示例： words := []rune{'𝓐','𝓑'} u16 := utf16.Encode(words) fmt.Println(u16) fmt.Println(utf16.Decode(u16)) r1, r2 := utf16.EncodeRune('𝓐') fmt.Println(r1,r2) fmt.Println(utf16.DecodeRune(r1, r2)) fmt.Println(utf16.IsSurrogate(r1)) fmt.Println(utf16.IsSurrogate(r2)) fmt.Println(utf16.IsSurrogate(1234)) 输出结果： [55349 56528 55349 56529] [120016 120017] 55349 56528 120016 true true false 第三章 数据结构与算法 程序设计离不开数据结构和算法。数据结构是数据组织和存储的逻辑形式，以达到方便访问和修改数据的目的。而算法是根据实际输入输出的需求设计的一系列计算过程，被认为是程序的灵魂。设计良好的算法的重要意义正如Thomas在《算法导论》中提到“计算机可以做得很快，但不是无限快；存储器可以做到很便宜，但不是免费的。因此，计算时间是一种有限的资源，存储空间也是一种有限的资源。这些有限的资源必须有效地使用，那些时间上和空间上有效的算法可以帮助做到这一点。“ 本章内容涵盖了 Go 标准库中的 3 个包： sort 包包含基本的排序方法，支持切片数据排序以及用户自定义数据集合排序 index/suffixary 包实现了后缀数组相关算法以支持许多常见的字符串操作 container 包提供了对 heap、list 和 ring 这 3 种数据结构的底层支持。任何实现了相应接口的数据结构都可以调用该结构的方法。 3.1 sort —— 排序算法 该包实现了四种基本排序算法：插入排序、归并排序、堆排序和快速排序。 但是这四种排序方法是不公开的，它们只被用于 sort 包内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法：获取数据集合长度的 Len() 方法、比较两个元素大小的 Less() 方法和交换两个元素位置的 Swap() 方法，就可以顺利对数据集合进行排序。sort 包会根据实际数据自动选择高效的排序算法。 除此之外，为了方便对常用数据类型的操作，sort 包提供了对[]int 切片、[]float64 切片和[]string 切片完整支持，主要包括： 对基本数据类型切片的排序支持 基本数据元素查找 判断基本数据类型切片是否已经排好序 对排好序的数据集合逆序 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:66:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"3.1.1 数据集合排序 前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，我们看以下该接口的定义： type Interface interface { // 获取数据集合元素个数 Len() int // 如果 i 索引的数据小于 j 索引的数据，返回 true，且不会调用下面的 Swap()，即数据升序排序。 Less(i, j int) bool // 交换 i 和 j 索引的两个元素的位置 Swap(i, j int) } 数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下： func Sort(data Interface) Sort() 方法惟一的参数就是待排序的数据集合。 该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 Len() 和 Less() 方法： func IsSorted(data Interface) bool { n := data.Len() for i := n - 1; i \u003e 0; i-- { if data.Less(i, i-1) { return false } } return true } 下面是一个使用 sort 包对学生成绩排序的示例： package main import ( \"fmt\" \"sort\" ) // 学生成绩结构体 type StuScore struct { name string // 姓名 score int // 成绩 } type StuScores []StuScore //Len() func (s StuScores) Len() int { return len(s) } //Less(): 成绩将有低到高排序 func (s StuScores) Less(i, j int) bool { return s[i].score \u003c s[j].score } //Swap() func (s StuScores) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func main() { stus := StuScores{ {\"alan\", 95}, {\"hikerell\", 91}, {\"acmfly\", 96}, {\"leao\", 90}, } // 打印未排序的 stus 数据 fmt.Println(\"Default:\\n\\t\",stus) //StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序 sort.Sort(stus) // 判断是否已经排好顺序，将会打印 true fmt.Println(\"IS Sorted?\\n\\t\", sort.IsSorted(stus)) // 打印排序后的 stus 数据 fmt.Println(\"Sorted:\\n\\t\",stus) } 该示例程序的自定义类型 StuScores 实现了 sort.Interface 接口，所以可以将其对象作为 sort.Sort() 和 sort.IsSorted() 的参数传入。运行结果： Default: [{alan 95} {hikerell 91} {acmfly 96} {leao 90}] IS Sorted? true Sorted: [{leao 90} {hikerell 91} {alan 95} {acmfly 96}] 该示例实现的是升序排序，如果要得到降序排序结果，其实只要修改 Less() 函数： //Less(): 成绩降序排序 , 只将小于号修改为大于号 func (s StuScores) Less(i, j int) bool { return s[i].score \u003e s[j].score } 此外，sort包提供了 Reverse() 方法，可以允许将数据按 Less() 定义的排序方式逆序排序，而不必修改 Less() 代码。方法定义如下： func Reverse(data Interface) Interface 我们可以看到 Reverse() 返回的一个 sort.Interface 接口类型，整个 Reverse() 的内部实现比较有趣： // 定义了一个 reverse 结构类型，嵌入 Interface 接口 type reverse struct { Interface } //reverse 结构类型的 Less() 方法拥有嵌入的 Less() 方法相反的行为 //Len() 和 Swap() 方法则会保持嵌入类型的方法行为 func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } // 返回新的实现 Interface 接口的数据类型 func Reverse(data Interface) Interface { return \u0026reverse{data} } 了解内部原理后，可以在学生成绩排序示例中使用 Reverse() 来实现成绩升序排序： sort.Sort(sort.Reverse(stus)) fmt.Println(stus) 最后一个方法：Search() func Search(n int, f func(int) bool) int 该方法会使用“二分查找”算法来找出能使 f(x)(0\u003c=x\u003cn) 返回 ture 的最小值 i。 前提条件 : f(x)(0\u003c=x\u003ci) 均返回 false, f(x)(i\u003c=x\u003cn) 均返回 ture。 如果不存在 i 可以使 f(i) 返回 ture, 则返回 n。 Search() 函数一个常用的使用方式是搜索元素 x 是否在已经升序排好的切片 s 中： x := 11 s := []int{3, 6, 8, 11, 45} // 注意已经升序排序 pos := sort.Search(len(s), func(i int) bool { return s[i] \u003e= x }) if pos \u003c len(s) \u0026\u0026 s[pos] == x { fmt.Println(x, \" 在 s 中的位置为：\", pos) } else { fmt.Println(\"s 不包含元素 \", x) } 官方文档还给出了一个猜数字的小程序： func GuessingGame() { var s string fmt.Printf(\"Pick an integer from 0 to 100.\\n\") answer := sort.Search(100, func(i int) bool { fmt.Printf(\"Is your number \u003c= %d? \", i) fmt.Scanf(\"%s\", \u0026s) return s != \"\" \u0026\u0026 s[0] == 'y' }) fmt.Printf(\"Your number is %d.\\n\", answer) } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:67:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"3.1.2 sort包已经支持的内部数据类型排序 前面已经提到，sort包原生支持[]int、[]float64 和[]string 三种内建数据类型切片的排序操作，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。 1. IntSlice 类型及[]int 排序 由于[]int 切片排序内部实现及使用方法与[]float64 和[]string 类似，所以只详细描述该部分。 sort包定义了一个 IntSlice 类型，并且实现了 sort.Interface 接口： type IntSlice []int func (p IntSlice) Len() int { return len(p) } func (p IntSlice) Less(i, j int) bool { return p[i] \u003c p[j] } func (p IntSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } //IntSlice 类型定义了 Sort() 方法，包装了 sort.Sort() 函数 func (p IntSlice) Sort() { Sort(p) } //IntSlice 类型定义了 SearchInts() 方法，包装了 SearchInts() 函数 func (p IntSlice) Search(x int) int { return SearchInts(p, x) } 并且提供的 sort.Ints() 方法使用了该 IntSlice 类型： func Ints(a []int) { Sort(IntSlice(a)) } 所以，对[]int 切片排序更常使用 sort.Ints()，而不是直接使用 IntSlice 类型： s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据 sort.Ints(s) fmt.Println(s) // 将会输出[1 2 3 4 5 6] 如果要使用降序排序，显然要用前面提到的 Reverse() 方法： s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据 sort.Sort(sort.Reverse(sort.IntSlice(s))) fmt.Println(s) // 将会输出[6 5 4 3 2 1] 如果要查找整数 x 在切片 a 中的位置，相对于前面提到的 Search() 方法，sort包提供了 SearchInts(): func SearchInts(a []int, x int) int 注意，SearchInts() 的使用条件为：切片 a 已经升序排序 以下是一个错误使用的例子： s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据 fmt.Println(sort.SearchInts(s, 2)) // 将会输出 0 而不是 1 2. Float64Slice 类型及[]float64 排序 实现与 Ints 类似，只看一下其内部实现： type Float64Slice []float64 func (p Float64Slice) Len() int { return len(p) } func (p Float64Slice) Less(i, j int) bool { return p[i] \u003c p[j] || isNaN(p[i]) \u0026\u0026 !isNaN(p[j]) } func (p Float64Slice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p Float64Slice) Sort() { Sort(p) } func (p Float64Slice) Search(x float64) int { return SearchFloat64s(p, x) } 与 Sort()、IsSorted()、Search() 相对应的三个方法： func Float64s(a []float64) func Float64sAreSorted(a []float64) bool func SearchFloat64s(a []float64, x float64) int 要说明一下的是，在上面 Float64Slice 类型定义的 Less 方法中，有一个内部函数 isNaN()。 isNaN() 与math包中 IsNaN() 实现完全相同，sort包之所以不使用 math.IsNaN()，完全是基于包依赖性的考虑，应当看到，sort包的实现不依赖与其他任何包。 3. StringSlice 类型及[]string 排序 两个 string 对象之间的大小比较是基于“字典序”的。 实现与 Ints 类似，只看一下其内部实现： type StringSlice []string func (p StringSlice) Len() int { return len(p) } func (p StringSlice) Less(i, j int) bool { return p[i] \u003c p[j] } func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p StringSlice) Sort() { Sort(p) } func (p StringSlice) Search(x string) int { return SearchStrings(p, x) } 与 Sort()、IsSorted()、Search() 相对应的三个方法： func Strings(a []string) func StringsAreSorted(a []string) bool func SearchStrings(a []string, x string) int ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:68:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"3.1.3 []interface 排序与查找 通过前面的内容我们可以知道，只要实现了 sort.Interface 接口，即可通过 sort 包内的函数完成排序，查找等操作。并且 sort 包已经帮我们把[]int,[]float64,[]string 三种类型都实现了该接口，我们可以方便的调用。但是这种用法对于其它数据类型的 slice 不友好，可能我们需要为大量的 struct 定义一个单独的 []struct 类型，再为其实现 sort.Interface 接口，类似这样： type Person struct { Name string Age int } type Persons []Person func (p Persons) Len() int { panic(\"implement me\") } func (p Persons) Less(i, j int) bool { panic(\"implement me\") } func (p Persons) Swap(i, j int) { panic(\"implement me\") } 思考一个问题：为什么 sort 包可以完成 []int 的排序，而不能完成 []struct 的排序？ 因为排序涉及到比较两个变量的值，而 struct 可能包含多个属性，程序并不知道你想以哪一个属性或哪几个属性作为衡量大小的标准。如果你能帮助程序完成比较，并将结果返回， sort 包内的方法就可以完成排序，判断，查找等。sort 包提供了以下函数： func Slice(slice interface{}, less func(i, j int) bool) func SliceStable(slice interface{}, less func(i, j int) bool) func SliceIsSorted(slice interface{}, less func(i, j int) bool) bool func Search(n int, f func(int) bool) int 通过函数签名可以看到，排序相关的三个函数都接收 []interface，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为函数签名和作用域的原因，这个函数只能是 匿名函数。 1. sort.Slice 该函数完成 []interface 的排序，举个栗子： people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.Slice(people, func(i, j int) bool { return people[i].Age \u003c people[j].Age }) // 按年龄升序排序 fmt.Println(\"Sort by age:\", people) 输出结果： By age: [{Gopher 7} {Vera 24} {Alice 55} {Bob 75}] 2. sort.SliceStable 该函数完成 []interface 的稳定排序，举个栗子： people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.SliceStable(people, func(i, j int) bool { return people[i].Age \u003e people[j].Age }) // 按年龄降序排序 fmt.Println(\"Sort by age:\", people) 输出结果： By age: [{Bob 75} {Alice 55} {Vera 24} {Gopher 7}] 3. sort.SliceIsSorted 该函数判断 []interface 是否为有序，举个栗子： people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.Slice(people, func(i, j int) bool { return people[i].Age \u003e people[j].Age }) // 按年龄降序排序 fmt.Println(\"Sort by age:\", people) fmt.Println(\"Sorted:\",sort.SliceIsSorted(people,func(i, j int) bool { return people[i].Age \u003c people[j].Age })) 输出结果： Sort by age: [{Bob 75} {Alice 55} {Vera 24} {Gopher 7}] Sorted: false sort 包没有为 []interface 提供反序函数，但是从 1 和 2 可以看出，我们传入的比较函数已经决定了排序结果是升序还是降序。 判断 slice 是否为有序，同样取决于我们传入的比较函数，从 3 可以看出，虽然 slice 已经按年龄降序排序，但我们在判断 slice 是否为有序时给的比较函数是判断其是否为升序有序，所以最终得到的结果为 false。 4. sort.Search 该函数判断 []interface 是否存在指定元素，举个栗子： 升序 slice sort 包为 []int,[]float64,[]string 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要求 slice 为升序排序状态。并且判断条件必须为 \u003e=，这也是官方库提供的三个查找相关函数的的写法。 举个栗子： a := []int{2, 3, 4, 200, 100, 21, 234, 56} x := 21 sort.Slice(a, func(i, j int) bool { return a[i] \u003c a[j] }) // 升序排序 index := sort.Search(len(a), func(i int) bool { return a[i] \u003e= x }) // 查找元素 if index \u003c len(a) \u0026\u0026 a[index] == x { fmt.Printf(\"found %d at index %d in %v\\n\", x, index, a) } else { fmt.Printf(\"%d not found in %v,index:%d\\n\", x, a, index) } 输出结果： found 21 at index 3 in [2 3 4 21 56 100 200 234] 降序 slice 如果 slice 是降序状态，而我们又不想将其变为升序，只需将判断条件由 \u003e= 变更为 \u003c= 即可。此处就不给代码了，有兴趣的同学可以自己去尝试一下。推荐采用升序排列及相应的判断条件，与官方函数保持风格一致。 3.3 container — 容器数据类型：heap、list 和 ring 该包实现了三个复杂的数据结构：堆，链表，环。 这个包就意味着你使用这三个数据结构的时候不需要再费心从头开始写算法了。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:69:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"3.3.1 堆 这里的堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。 go 的堆包只是实现了一个接口，我们看下它的定义： type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. } 可以看出，这个堆结构继承自 sort.Interface, 回顾下 sort.Interface，它需要实现三个方法 Len() int Less(i, j int) bool Swap(i, j int) 加上堆接口定义的两个方法 Push(x interface{}) Pop() interface{} 就是说你定义了一个堆，就要实现五个方法，直接拿 package doc 中的 example 做例子： type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u003c h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } 那么 IntHeap 就实现了这个堆结构，我们就可以使用堆的方法来对它进行操作： h := \u0026IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) heap.Pop(h) 具体说下内部实现，是使用最小堆，索引排序从根节点开始，然后左子树，右子树的顺序方式。索引布局如下： 0\r1 2\r3 4 5 6\r7 8 9 10 11\r假设 (heap[1]== 小明 ) 它的左子树 (heap[3]== 小黑 ) 和右子树 (heap[4]== 大黄 ) 且 小明 \u003e 小黑 \u003e 大黄 ;\r堆内部实现了 down 和 up 函数 : down 函数用于将索引 i 处存储的值 ( 设 i=1, 即小明 ) 与它的左子树 ( 小黑 ) 和右子树 ( 大黄 ) 相比 , 将三者最小的值大黄与小明的位置交换，交换后小明继续与交换后的子树 (heap[9]和 heap[10]) 相比，重复以上步骤，直到小明位置不变。 up 函数用于将索引 i 处的值 ( 设 i=3, 即小黑 ) 与他的父节点 ( 小明 ) 比较，将两者较小的值放到父节点上，本例中即交换小黑和小明的位置，之后小黑继续与其父节点比较，重复以上步骤，直到小黑位置不变。\r假设 heap[11]== 阿花 当从堆中 Pop 一个元素的时候，先把元素和最后一个节点的值 ( 阿花 ) 交换，然后弹出，然后对阿花调用 down，向下保证最小堆。 当往堆中 Push 一个元素的时候，这个元素插入到最后一个节点，本例中为 heap[12]，即作为 heap[5]的右子树，然后调用 up 函数向上比较。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:70:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"3.3.2 链表 链表就是一个有 prev 和 next 指针的数组了。它维护两个 type，( 注意，这里不是 interface) type Element struct { next, prev *Element // 上一个元素和下一个元素 list *List // 元素所在链表 Value interface{} // 元素 } type List struct { root Element // 链表的根元素 len int // 链表的长度 } 基本使用是先创建 list，然后往 list 中插入值，list 就内部创建一个 Element，并内部设置好 Element 的 next,prev 等。具体可以看下例子： // This example demonstrates an integer heap built using the heap interface. package main import ( \"container/list\" \"fmt\" ) func main() { list := list.New() list.PushBack(1) list.PushBack(2) fmt.Printf(\"len: %v\\n\", list.Len()) fmt.Printf(\"first: %#v\\n\", list.Front()) fmt.Printf(\"second: %#v\\n\", list.Front().Next()) } output: len: 2 first: \u0026list.Element{next:(*list.Element)(0x2081be1b0), prev:(*list.Element)(0x2081be150), list:(*list.List)(0x2081be150), Value:1} second: \u0026list.Element{next:(*list.Element)(0x2081be150), prev:(*list.Element)(0x2081be180), list:(*list.List)(0x2081be150), Value:2} list 对应的方法有： type Element func (e *Element) Next() *Element func (e *Element) Prev() *Element type List func New() *List func (l *List) Back() *Element // 最后一个元素 func (l *List) Front() *Element // 第一个元素 func (l *List) Init() *List // 链表初始化 func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 在某个元素后插入 func (l *List) InsertBefore(v interface{}, mark *Element) *Element // 在某个元素前插入 func (l *List) Len() int // 在链表长度 func (l *List) MoveAfter(e, mark *Element) // 把 e 元素移动到 mark 之后 func (l *List) MoveBefore(e, mark *Element) // 把 e 元素移动到 mark 之前 func (l *List) MoveToBack(e *Element) // 把 e 元素移动到队列最后 func (l *List) MoveToFront(e *Element) // 把 e 元素移动到队列最头部 func (l *List) PushBack(v interface{}) *Element // 在队列最后插入元素 func (l *List) PushBackList(other *List) // 在队列最后插入接上新队列 func (l *List) PushFront(v interface{}) *Element // 在队列头部插入元素 func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列 func (l *List) Remove(e *Element) interface{} // 删除某个元素 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:71:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"3.3.3 环 环的结构有点特殊，环的尾部就是头部，所以每个元素实际上就可以代表自身的这个环。 它不需要像 list 一样保持 list 和 element 两个结构，只需要保持一个结构就行。 type Ring struct { next, prev *Ring Value interface{} } 我们初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 Do 方法，能遍历一遍环，对每个元素执行一个 function。 看下面的例子： // This example demonstrates an integer heap built using the heap interface. package main import ( \"container/ring\" \"fmt\" ) func main() { ring := ring.New(3) for i := 1; i \u003c= 3; i++ { ring.Value = i ring = ring.Next() } // 计算 1+2+3 s := 0 ring.Do(func(p interface{}){ s += p.(int) }) fmt.Println(\"sum is\", s) } output: sum is 6 ring 提供的方法有 type Ring func New(n int) *Ring // 初始化环 func (r *Ring) Do(f func(interface{})) // 循环环进行操作 func (r *Ring) Len() int // 环长度 func (r *Ring) Link(s *Ring) *Ring // 连接两个环 func (r *Ring) Move(n int) *Ring // 指针从当前元素开始向后移动或者向前（n 可以为负数） func (r *Ring) Next() *Ring // 当前元素的下个元素 func (r *Ring) Prev() *Ring // 当前元素的上个元素 func (r *Ring) Unlink(n int) *Ring // 从当前元素开始，删除 n 个元素 第四章 日期与时间 实际开发中，经常会遇到日期和时间相关的操作，比如：格式化日期和时间，解析一个日期时间字符串等。Go 语言通过标准库 time 包处理日期和时间相关的问题。 本章只有 time 这一个包，为了便于阅读，将拆为如下小结进行讲解： 主要类型概述 时区 Time 类型详解 定时器 4.1 主要类型概述 time 包提供了时间的显示和计量用的功能。日历的计算采用的是公历。提供的主要类型如下： ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:72:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Location 代表一个地区，并表示该地区所在的时区（可能多个）。Location 通常代表地理位置的偏移，比如 CEST 和 CET 表示中欧。下一节将详细讲解 Location。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:73:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Time 代表一个纳秒精度的时间点，是公历时间。后面会详细介绍。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:74:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Duration 代表两个时间点之间经过的时间，以纳秒为单位。可表示的最长时间段大约 290 年，也就是说如果两个时间点相差超过 290 年，会返回 290 年，也就是 minDuration(-1 « 63) 或 maxDuration(1 « 63 - 1)。 类型定义：type Duration int64。 将 Duration 类型直接输出时，因为实现了 fmt.Stringer 接口，会输出人类友好的可读形式，如：72h3m0.5s。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:75:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Timer 和 Ticker 这是定时器相关类型。本章最后会讨论定时器。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:76:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Weekday 和 Month 这两个类型的原始类型都是 int，定义它们，语义更明确，同时，实现 fmt.Stringer 接口，方便输出。 4.2 时区 不同国家（有时甚至是同一个国家内的不同地区）使用不同的时区。对于要输入和输出时间的程序来说，必须对系统所处的时区加以考虑。Go 语言使用 Location 来表示地区相关的时区，一个 Location 可能表示多个时区。 time 包提供了 Location 的两个实例：Local 和 UTC。Local 代表当前系统本地时区；UTC 代表通用协调时间，也就是零时区。time 包默认（为显示提供时区）使用 UTC 时区。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:77:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Local 是如何做到表示本地时区的？ 时区信息既浩繁又多变，Unix 系统以标准格式存于文件中，这些文件位于 /usr/share/zoneinfo，而本地时区可以通过 /etc/localtime 获取，这是一个符号链接，指向 /usr/share/zoneinfo 中某一个时区。比如我本地电脑指向的是：/usr/share/zoneinfo/Asia/Shanghai。 因此，在初始化 Local 时，通过读取 /etc/localtime 可以获取到系统本地时区。 当然，如果设置了环境变量 TZ，则会优先使用它。 相关代码： tz, ok := syscall.Getenv(\"TZ\") switch { case !ok: z, err := loadZoneFile(\"\", \"/etc/localtime\") if err == nil { localLoc = *z localLoc.name = \"Local\" return } case tz != \"\" \u0026\u0026 tz != \"UTC\": if z, err := loadLocation(tz); err == nil { localLoc = *z return } } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:78:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"获得特定时区的实例 函数 LoadLocation 可以根据名称获取特定时区的实例。函数声明如下： func LoadLocation(name string) (*Location, error) 如果 name 是 \"\" 或 “UTC”，返回 UTC；如果 name 是 “Local”，返回 Local；否则 name 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 “America/New_York”。 LoadLocation 函数需要的时区数据库可能不是所有系统都提供，特别是非 Unix 系统。此时 LoadLocation 会查找环境变量 ZONEINFO 指定目录或解压该变量指定的 zip 文件（如果有该环境变量）；然后查找 Unix 系统的惯例时区数据安装位置，最后查找 $GOROOT/lib/time/zoneinfo.zip。 可以在 Unix 系统下的 /usr/share/zoneinfo 中找到所有的名称。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:79:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"总结 通常，我们使用 time.Local 即可，偶尔可能会需要使用 UTC。在解析时间时，心中一定记得有时区这么回事。当你发现时间出现莫名的情况时，很可能是因为时区的问题，特别是当时间相差 8 小时时。 4.3 Time 类型详解 Time 代表一个纳秒精度的时间点。 程序中应使用 Time 类型值来保存和传递时间，而不是指针。就是说，表示时间的变量和字段，应为 time.Time 类型，而不是 *time.Time. 类型。一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。 Time 零值代表时间点 January 1, year 1, 00:00:00.000000000 UTC。因为本时间点一般不会出现在使用中，IsZero 方法提供了检验时间是否是显式初始化的一个简单途径。 每一个 Time 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表示的时间点，因此也不会影响其计算。 通过 == 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:80:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Time 的内部结构 type Time struct { // sec gives the number of seconds elapsed since // January 1, year 1 00:00:00 UTC. sec int64 // nsec specifies a non-negative nanosecond // offset within the second named by Seconds. // It must be in the range [0, 999999999]. nsec int32 // loc specifies the Location that should be used to // determine the minute, hour, month, day, and year // that correspond to this Time. // Only the zero Time has a nil Location. // In that case it is interpreted to mean UTC. loc *Location } 要讲解 time.Time 的内部结构，得先看 time.Now() 函数。 // Now returns the current local time. func Now() Time { sec, nsec := now() return Time{sec + unixToInternal, nsec, Local} } now() 的具体实现在 runtime 包中，以 linux/amd64 为例，在 sys_linux_amd64.s 中的 time · now，这是汇编实现的： 调用系统调用 clock_gettime 获取时钟值（这是 POSIX 时钟）。其中 clockid_t 时钟类型是 CLOCK_REALTIME，也就是可设定的系统级实时时钟。得到的是 struct timespec 类型。（可以到纳秒） 如果 clock_gettime 不存在，则使用精度差些的系统调用 gettimeofday。得到的是 struct timeval 类型。（最多到微秒） 注意： 这里使用了 Linux 的 vdso 特性，不了解的，可以查阅相关知识。 虽然 timespec 和 timeval 不一样，但结构类似。因为 now() 函数返回两个值：sec( 秒 ) 和 nsec( 纳秒 )，所以，time · now 的实现将这两个结构转为需要的返回值。需要注意的是，Linux 系统调用返回的 sec( 秒 ) 是 Unix 时间戳，也就是从 1970-1-1 算起的。 回到 time.Now() 的实现，现在我们得到了 sec 和 nsec，从 Time{sec + unixToInternal, nsec, Local} 这句可以看出，Time 结构的 sec 并非 Unix 时间戳，实际上，加上的 unixToInternal 是 1-1-1 到 1970-1-1 经历的秒数。也就是 Time 中的 sec 是从 1-1-1 算起的秒数，而不是 Unix 时间戳。 Time 的最后一个字段表示地点时区信息。本章后面会专门介绍。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:81:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"常用函数或方法 Time 相关的函数和方法较多，有些很容易理解，不赘述，查文档即可。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:82:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"零值的判断 因为 Time 的零值是 sec 和 nsec 都是 0，表示 1 年 1 月 1 日。 Time.IsZero() 函数用于判断 Time 表示的时间是否是 0 值。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:82:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"与 Unix 时间戳的转换 相关函数或方法： time.Unix(sec, nsec int64) 通过 Unix 时间戳生成 time.Time 实例； time.Time.Unix() 得到 Unix 时间戳； time.Time.UnixNano() 得到 Unix 时间戳的纳秒表示； ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:82:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"格式化和解析 这是实际开发中常用到的。 time.Parse 和 time.ParseInLocation time.Time.Format 解析 对于解析，要特别注意时区问题，否则很容易出 bug。比如： t, _ := time.Parse(\"2006-01-02 15:04:05\", \"2016-06-13 09:14:00\") fmt.Println(time.Now().Sub(t).Hours()) 2016-06-13 09:14:00 这个时间可能是参数传递过来的。这段代码的结果跟预期的不一样。 原因是 time.Now() 的时区是 time.Local，而 time.Parse 解析出来的时区却是 time.UTC（可以通过 Time.Location() 函数知道是哪个时区）。在中国，它们相差 8 小时。 所以，一般的，我们应该总是使用 time.ParseInLocation 来解析时间，并给第三个参数传递 time.Local。 为什么是 2006-01-02 15:04:05 可能你已经注意到：2006-01-02 15:04:05 这个字符串了。没错，这是固定写法，类似于其他语言中 Y-m-d H:i:s 等。为什么采用这种形式？又为什么是这个时间点而不是其他时间点？ 官方说，使用具体的时间，比使用 Y-m-d H:i:s 更容易理解和记忆；这么一说还真是 ~ 而选择这个时间点，也是出于好记的考虑，官方的例子：Mon Jan 2 15:04:05 MST 2006，另一种形式 01/02 03:04:05PM '06 -0700，对应是 1、2、3、4、5、6、7；常见的格式：2006-01-02 15:04:05，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒 ~ 如果你是 PHPer，喜欢 PHP 的格式，可以试试 times 这个包。 格式化 时间格式化输出，使用 Format 方法，layout 参数和 Parse 的一样。Time.String() 方法使用了 2006-01-02 15:04:05.999999999 -0700 MST 这种 layout。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:82:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实现 序列化 / 反序列化 相关接口 Time 实现了 encoding 包中的 BinaryMarshaler、BinaryUnmarshaler、TextMarshaler 和 TextUnmarshaler 接口；encoding/json 包中的 Marshaler 和 Unmarshaler 接口。 它还实现了 gob 包中的 GobEncoder 和 GobDecoder 接口。 对于文本序列化 / 反序列化，通过 Parse 和 Format 实现；对于二进制序列化，需要单独实现。 对于 json，使用的是 time.RFC3339Nano 这种格式。通常程序中不使用这种格式。解决办法是定义自己的类型。如： type OftenTime time.Time func (self OftenTime) MarshalJSON() ([]byte, error) { t := time.Time(self) if y := t.Year(); y \u003c 0 || y \u003e= 10000 { return nil, errors.New(\"Time.MarshalJSON: year outside of range [0,9999]\") } // 注意 `\"2006-01-02 15:04:05\"`。因为是 JSON，双引号不能少 return []byte(t.Format(`\"2006-01-02 15:04:05\"`)), nil } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:82:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Round 和 Truncate 方法 比如，有这么个需求：获取当前时间整点的 Time 实例。例如，当前时间是 15:54:23，需要的是 15:00:00。我们可以这么做： t, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", time.Now().Format(\"2006-01-02 15:00:00\"), time.Local) fmt.Println(t) 实际上，time 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 Round 和 Trunate，它们区别，一个是取最接近的，一个是向下取整。 使用示例： t, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", \"2016-06-13 15:34:39\", time.Local) // 整点（向下取整） fmt.Println(t.Truncate(1 * time.Hour)) // 整点（最接近） fmt.Println(t.Round(1 * time.Hour)) // 整分（向下取整） fmt.Println(t.Truncate(1 * time.Minute)) // 整分（最接近） fmt.Println(t.Round(1 * time.Minute)) t2, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t.Format(\"2006-01-02 15:00:00\"), time.Local) fmt.Println(t2) 4.4 定时器 定时器是进程规划自己在未来某一时刻接获通知的一种机制。本节介绍两种定时器：Timer（到达指定时间触发且只触发一次）和 Ticker（间隔特定时间触发）。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:82:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Timer ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:83:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"内部实现源码分析 Timer 类型代表单次时间事件。当 Timer 到期时，当时的时间会被发送给 C (channel)，除非 Timer 是被 AfterFunc 函数创建的。 注意：Timer 的实例必须通过 NewTimer 或 AfterFunc 获得。 类型定义如下： type Timer struct { C \u003c-chan Time // The channel on which the time is delivered. r runtimeTimer } C 已经解释了，我们看看 runtimeTimer。它定义在 sleep.go 文件中，必须和 runtime 包中 time.go 文件中的 timer 必须保持一致： type timer struct { i int // heap index // Timer wakes up at when, and then at when+period, ... (period \u003e 0 only) // each time calling f(now, arg) in the timer goroutine, so f must be // a well-behaved function and not block. when int64 period int64 f func(interface{}, uintptr) arg interface{} seq uintptr } 我们通过 NewTimer() 来看这些字段都怎么赋值，是什么用途。 // NewTimer creates a new Timer that will send // the current time on its channel after at least duration d. func NewTimer(d Duration) *Timer { c := make(chan Time, 1) t := \u0026Timer{ C: c, r: runtimeTimer{ when: when(d), f: sendTime, arg: c, }, } startTimer(\u0026t.r) return t } 在 when 表示的时间到时，会往 Timer.C 中发送当前时间。when 表示的时间是纳秒时间，正常通过 runtimeNano() + int64(d) 赋值。跟上一节中讲到的 now() 类似，runtimeNano() 也在 runtime 中实现（runtime · nanotime）： 调用系统调用 clock_gettime 获取时钟值（这是 POSIX 时钟）。其中 clockid_t 时钟类型是 CLOCK_MONOTONIC，也就是不可设定的恒定态时钟。具体的是什么时间，SUSv3 规定始于未予规范的过去某一点，Linux 上，始于系统启动。 如果 clock_gettime 不存在，则使用精度差些的系统调用 gettimeofday。 f 参数的值是 sendTime，定时器时间到时，会调用 f，并将 arg 和 seq 传给 f。 因为 Timer 是一次性的，所以 period 保留默认值 0。 定时器的具体实现逻辑，都在 runtime 中的 time.go 中，它的实现，没有采用经典 Unix 间隔定时器 setitimer 系统调用，也没有 采用 POSIX 间隔式定时器（相关系统调用：timer_create、timer_settime 和 timer_delete），而是通过四叉树堆 (heep) 实现的（runtimeTimer 结构中的 i 字段，表示在堆中的索引）。通过构建一个最小堆，保证最快拿到到期了的定时器执行。定时器的执行，在专门的 goroutine 中进行的：go timerproc()。有兴趣的同学，可以阅读 runtime/time.go 的源码。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:83:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Timer 相关函数或方法的使用 通过 time.After 模拟超时： c := make(chan int) go func() { // time.Sleep(1 * time.Second) time.Sleep(3 * time.Second) \u003c-c }() select { case c \u003c- 1: fmt.Println(\"channel...\") case \u003c-time.After(2 * time.Second): close(c) fmt.Println(\"timeout...\") } time.Stop 停止定时器 或 time.Reset 重置定时器 start := time.Now() timer := time.AfterFunc(2*time.Second, func() { fmt.Println(\"after func callback, elaspe:\", time.Now().Sub(start)) }) time.Sleep(1 * time.Second) // time.Sleep(3*time.Second) // Reset 在 Timer 还未触发时返回 true；触发了或 Stop 了，返回 false if timer.Reset(3 * time.Second) { fmt.Println(\"timer has not trigger!\") } else { fmt.Println(\"timer had expired or stop!\") } time.Sleep(10 * time.Second) // output: // timer has not trigger! // after func callback, elaspe: 4.00026461s 如果定时器还未触发，Stop 会将其移除，并返回 true；否则返回 false；后续再对该 Timer 调用 Stop，直接返回 false。 Reset 会先调用 stopTimer 再调用 startTimer，类似于废弃之前的定时器，重新启动一个定时器。返回值和 Stop 一样。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:83:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Sleep 的内部实现 查看 runtime/time.go 文件中的 timeSleep 可知，Sleep 的是通过 Timer 实现的，把当前 goroutine 作为 arg 参数（getg())。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:83:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Ticker 相关函数或方法的使用 Ticker 和 Timer 类似，区别是：Ticker 中的 runtimeTimer 字段的 period 字段会赋值为 NewTicker(d Duration) 中的 d，表示每间隔 d 纳秒，定时器就会触发一次。 除非程序终止前定时器一直需要触发，否则，不需要时应该调用 Ticker.Stop 来释放相关资源。 如果程序终止前需要定时器一直触发，可以使用更简单方便的 time.Tick 函数，因为 Ticker 实例隐藏起来了，因此，该函数启动的定时器无法停止。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:84:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"定时器的实际应用 在实际开发中，定时器用的较多的会是 Timer，如模拟超时，而需要类似 Tiker 的功能时，可以使用实现了 cron spec 的库 cron，感兴趣的可以参考文章：《Go 语言版 crontab》。 5.1 math — 基本数学函数 math 包实现的就是数学函数计算。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:85:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"5.1.1 三角函数 正弦函数，反正弦函数，双曲正弦，反双曲正弦 - func Sin(x float64) float64\r- func Asin(x float64) float64\r- func Sinh(x float64) float64\r- func Asinh(x float64) float64\r一次性返回 sin,cos func Sincos(x float64) (sin, cos float64) 余弦函数，反余弦函数，双曲余弦，反双曲余弦 - func Cos(x float64) float64\r- func Acos(x float64) float64\r- func Cosh(x float64) float64\r- func Acosh(x float64) float64\r正切函数，反正切函数，双曲正切，反双曲正切 - func Tan(x float64) float64\r- func Atan(x float64) float64 和 func Atan2(y, x float64) float64\r- func Tanh(x float64) float64\r- func Atanh(x float64) float64\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:86:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"5.1.2 幂次函数 - func Cbrt(x float64) float64 // 立方根函数\r- func Pow(x, y float64) float64 // x 的幂函数\r- func Pow10(e int) float64 // 10 根的幂函数\r- func Sqrt(x float64) float64 // 平方根\r- func Log(x float64) float64 // 对数函数\r- func Log10(x float64) float64 // 10 为底的对数函数\r- func Log2(x float64) float64 // 2 为底的对数函数\r- func Log1p(x float64) float64 // log(1 + x)\r- func Logb(x float64) float64 // 相当于 log2(x) 的绝对值\r- func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分\r- func Exp(x float64) float64 // 指数函数\r- func Exp2(x float64) float64 // 2 为底的指数函数\r- func Expm1(x float64) float64 // Exp(x) - 1\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:87:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"5.1.3 特殊函数 - func Inf(sign int) float64 // 正无穷\r- func IsInf(f float64, sign int) bool // 是否正无穷\r- func NaN() float64 // 无穷值\r- func IsNaN(f float64) (is bool) // 是否是无穷值\r- func Hypot(p, q float64) float64 // 计算直角三角形的斜边长\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:88:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"5.1.4 类型转化函数 - func Float32bits(f float32) uint32 // float32 和 unit32 的转换\r- func Float32frombits(b uint32) float32 // uint32 和 float32 的转换\r- func Float64bits(f float64) uint64 // float64 和 uint64 的转换\r- func Float64frombits(b uint64) float64 // uint64 和 float64 的转换\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:89:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"5.1.5 其他函数 - func Abs(x float64) float64 // 绝对值函数\r- func Ceil(x float64) float64 // 向上取整\r- func Floor(x float64) float64 // 向下取整\r- func Mod(x, y float64) float64 // 取模\r- func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分\r- func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数\r- func Max(x, y float64) float64 // 取大值\r- func Min(x, y float64) float64 // 取小值\r- func Dim(x, y float64) float64 // 复数的维数\r- func J0(x float64) float64 // 0 阶贝塞尔函数\r- func J1(x float64) float64 // 1 阶贝塞尔函数\r- func Jn(n int, x float64) float64 // n 阶贝塞尔函数\r- func Y0(x float64) float64 // 第二类贝塞尔函数 0 阶\r- func Y1(x float64) float64 // 第二类贝塞尔函数 1 阶\r- func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶\r- func Erf(x float64) float64 // 误差函数\r- func Erfc(x float64) float64 // 余补误差函数\r- func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值\r- func Signbit(x float64) bool // 获取 x 的符号\r- func Gamma(x float64) float64 // 伽玛函数\r- func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数\r- func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂\r- func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x\r- func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x\r- func Remainder(x, y float64) float64 // 取余运算\r- func Trunc(x float64) float64 // 截取函数\r第六章 文件系统 Go 的标准库提供了很多工具，可以处理文件系统中的文件、构造和解析文件名等。 处理文件的第一步是确定要处理的文件的名字。Go 将文件名表示为简单的字符串，提供了 path、filepath 等库来操作文件名或路径。用 os 中 File 结构的 Readdir 可以列出一个目录中的内容。 可以用 os.Stat 或 os.Lstat 来检查文件的一些特性，如权限、大小等。 有时需要创建草稿文件来保存临时数据，或将数据移动到一个永久位置之前需要临时文件存储，os.TempDir 可以返回默认的临时目录，用于存放临时文件。关于临时文件，在 ioutil 中已经讲解了。 os 包还包含了很多其他文件系统相关的操作，比如创建目录、重命名、移动文件等等。 由于本章探讨文件系统相关知识，os 包中关于进程相关的知识会在后续章节讲解。 6.1 os — 平台无关的操作系统功能实现 os 包提供了平台无关的操作系统功能接口。尽管错误处理是 go 风格的，但设计是 Unix 风格的；所以，失败的调用会返回 error 而非错误码。通常 error 里会包含更多信息。例如，如果使用一个文件名的调用（如 Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为 *PathError，其内部可以解包获得更多信息。 os 包规定为所有操作系统实现的接口都是一致的。有一些某个系统特定的功能，需要使用 syscall 获取。实际上，os 依赖于 syscall。在实际编程中，我们应该总是优先使用 os 中提供的功能，而不是 syscall。 下面是一个简单的例子，打开一个文件并从中读取一些数据： file, err := os.Open(\"file.go\") // For read access. if err != nil { log.Fatal(err) } 如果打开失败，错误字符串是自解释的，例如： open file.go: no such file or directory 而不像 C 语言，需要额外的函数（或宏）来解释错误码。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:90:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"文件 I/O 在第一章，我们较全面的介绍了 Go 中的 I/O。本节，我们着重介绍文件相关的 I/O。因为 I/O 操作涉及到系统调用，在讲解时会涉及到 Unix 在这方面的系统调用。 在 Unix 系统调用中，所有 I/O 操作以文件描述符 ( 一个非负整数 , 通常是小整数 ) 来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。这里，我们主要介绍普通文件的 I/O。 在 Go 中，文件描述符封装在 os.File 结构中，通过 File.Fd() 可以获得底层的文件描述符：fd。 按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。os 包提供了 3 个 File 对象，分别代表这 3 种标准描述符：Stdin、Stdout 和 Stderr，它们对应的文件名分别是：/dev/stdin、/dev/stdout 和 /dev/stderr。注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:91:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"打开一个文件：OpenFile OpenFile 既能打开一个已经存在的文件，也能创建并打开一个新文件。 func OpenFile(name string, flag int, perm FileMode) (*File, error) OpenFile 是一个更一般性的文件打开函数，大多数调用者都应用 Open 或 Create 代替本函数。它会使用指定的选项（如 O_RDONLY 等）、指定的模式（如 0666 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 *PathError。 要打开的文件由参数 name 指定，它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。 位掩码参数 flag 用于指定文件的访问模式，可用的值在 os 中定义为常量（以下值并非所有操作系统都可用）： const ( O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件 O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件 O_RDWR int = syscall.O_RDWR // 读写模式打开文件 O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部 O_CREATE int = syscall.O_CREAT // 如果不存在将创建一个新文件 O_EXCL int = syscall.O_EXCL // 和 O_CREATE 配合使用，文件必须不存在 O_SYNC int = syscall.O_SYNC // 打开文件用于同步 I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件 ) 其中，O_RDONLY、O_WRONLY、O_RDWR 应该只指定一个，剩下的通过 | 操作符来指定。该函数内部会给 flags 加上 syscall.O_CLOEXEC，在 fork 子进程时会关闭通过 OpenFile 打开的文件，即子进程不会重用该文件描述符。 注意：由于历史原因，O_RDONLY | O_WRONLY 并非等于 O_RDWR，它们的值一般是 0、1、2。 位掩码参数 perm 指定了文件的模式和权限位，类型是 os.FileMode，文件模式位常量定义在 os 中： const ( // 单字符是被 String 方法用于格式化的属性缩写。 ModeDir FileMode = 1 \u003c\u003c (32 - 1 - iota) // d: 目录 ModeAppend // a: 只能写入，且只能写入到末尾 ModeExclusive // l: 用于执行 ModeTemporary // T: 临时文件（非备份文件） ModeSymlink // L: 符号链接（不是快捷方式文件） ModeDevice // D: 设备 ModeNamedPipe // p: 命名管道（FIFO） ModeSocket // S: Unix 域 socket ModeSetuid // u: 表示文件具有其创建者用户 id 权限 ModeSetgid // g: 表示文件具有其创建者组 id 的权限 ModeCharDevice // c: 字符设备，需已设置 ModeDevice ModeSticky // t: 只有 root/ 创建者能删除 / 移动文件 // 覆盖所有类型位（用于通过 \u0026 获取类型位），对普通文件，所有这些位都不应被设置 ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice ModePerm FileMode = 0777 // 覆盖所有 Unix 权限位（用于通过 \u0026 获取类型位） ) 以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，唯一共有的是用于表示目录的 ModeDir 位。 以上这些被定义的位是 FileMode 最重要的位。另外 9 个位（权限位）为标准 Unix rwxrwxrwx 权限（所有人都可读、写、运行）。 FileMode 还定义了几个方法，用于判断文件类型的 IsDir() 和 IsRegular()，用于获取权限的 Perm()。 返回的 error，具体实现是 *os.PathError，它会记录具体操作、文件路径和错误原因。 另外，在 OpenFile 内部会调用 NewFile，来得到 File 对象。 使用方法 打开一个文件，一般通过 Open 或 Create，我们看这两个函数的实现。 func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } func Create(name string) (*File, error) { return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:91:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"读取文件内容：Read func (f *File) Read(b []byte) (n int, err error) Read 方法从 f 中读取最多 len(b) 字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回值 err 为 io.EOF。 从方法声明可以知道，File 实现了 io.Reader 接口。 Read 对应的系统调用是 read。 对比下 ReadAt 方法： func (f *File) ReadAt(b []byte, off int64) (n int, err error) ReadAt 从指定的位置（相对于文件开始位置）读取长度为 len(b) 个字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。当 n\u003clen(b) 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 err 会是 io.EOF。它对应的系统调用是 pread。 Read 和 ReadAt 的区别：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 off 指定的位置开始读，且不会改变文件当前偏移量。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:91:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"数据写入文件：Write func (f *File) Write(b []byte) (n int, err error) Write 向文件中写入 len(b) 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 n!=len(b)，本方法会返回一个非 nil 的错误。 从方法声明可以知道，File 实现了 io.Writer 接口。 Write 对应的系统调用是 write。 Write 与 WriteAt 的区别同 Read 与 ReadAt 的区别一样。为了方便，还提供了 WriteString 方法，它实际是对 Write 的封装。 注意：Write 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会影响性能），有两种办法： 1. 打开文件时指定 `os.O_SYNC`；\r2. 调用 `File.Sync()` 方法。\r说明：File.Sync() 底层调用的是 fsync 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件数据），需要自己封装，调用 fdatasync 系统调用。（syscall.Fdatasync） ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:91:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"关闭文件：Close close() 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。 func (f *File) Close() error os.File.Close() 是对 close() 的封装。我们应该养成关闭不需要的文件的良好编程习惯。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，长期运行的服务可能会把文件描述符耗尽。 所以，通常的写法如下： file, err := os.Open(\"/tmp/studygolang.txt\") if err != nil { // 错误处理，一般会阻止程序往下执行 return } defer file.Close() 关于返回值 error 以下两种情况会导致 Close 返回错误： 1. 关闭一个未打开的文件；\r2. 两次关闭同一个文件；\r通常，我们不会去检查 Close 的错误。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:91:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"改变文件偏移量：Seek 对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 Read 或 Write 操作的文件其实位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。 文件打开时，会将文件偏移量设置为指向文件开始，以后每次 Read 或 Write 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。因此，连续的 Read 和 Write 调用将按顺序递进，对文件进行操作。 而 Seek 可以调整文件偏移量。方法定义如下： func (f *File) Seek(offset int64, whence int) (ret int64, err error) Seek 设置下一次读 / 写的位置。offset 为相对偏移量，而 whence 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。使用中，whence 应该使用 os 包中的常量：SEEK_SET、SEEK_CUR 和 SEEK_END。 注意：Seek 只是调整内核中与文件描述符相关的文件偏移量记录，并没有引起对任何物理设备的访问。 一些 Seek 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置： file.Seek(0, os.SEEK_SET) // 文件开始处 file.Seek(0, SEEK_END) // 文件结尾处的下一个字节 file.Seek(-1, SEEK_END) // 文件最后一个字节 file.Seek(-10, SEEK_CUR) // 当前位置前 10 个字节 file.Seek(1000, SEEK_END) // 文件结尾处的下 1001 个字节 最后一个例子在文件中会产生“空洞”。 Seek 对应系统调用 lseek。该系统调用并不适用于所有类型，不允许将 lseek 应用于管道、FIFO、socket 或 终端。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:91:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"截断文件 trucate 和 ftruncate 系统调用将文件大小设置为 size 参数指定的值；Go 语言中相应的包装函数是 os.Truncate 和 os.File.Truncate。 func Truncate(name string, size int64) error func (f *File) Truncate(size int64) error 如果文件当前长度大于参数 size，调用将丢弃超出部分，若小于参数 size，调用将在文件尾部添加一系列空字节或是一个文件空洞。 它们之间的区别在于如何指定操作文件： 1. `Truncate` 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。若文件名为符号链接，那么调用将对其进行解引用。\r2. 很明显，调用 `File.Truncate` 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:92:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"文件属性 文件属性，也即文件元数据。在 Go 中，文件属性具体信息通过 os.FileInfo 接口获取。函数 Stat、Lstat 和 File.Stat 可以得到该接口的实例。这三个函数对应三个系统调用：stat、lstat 和 fstat。 这三个函数的区别： stat 会返回所命名文件的相关信息。 lstat 与 stat 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。 fstat 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。 Stat 和 Lstat 无需对其所操作的文件本身拥有任何权限，但针对指定 name 的父目录要有执行（搜索）权限。而只要 File 对象 ok，File.Stat 总是成功。 FileInfo 接口如下： type FileInfo interface { Name() string // 文件的名字（不含扩展名） Size() int64 // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同 Mode() FileMode // 文件的模式位 ModTime() time.Time // 文件的修改时间 IsDir() bool // 等价于 Mode().IsDir() Sys() interface{} // 底层数据来源（可以返回 nil） } Sys() 底层数据的 C 语言 结构 statbuf 格式如下： struct stat { dev_t st_dev; // 设备 ID ino_t st_ino; // 文件 i 节点号 mode_t st_mode; // 位掩码，文件类型和文件权限 nlink_t st_nlink; // 硬链接数 uid_t st_uid; // 文件属主，用户 ID gid_t st_gid; // 文件属组，组 ID dev_t st_rdev; // 如果针对设备 i 节点，则此字段包含主、辅 ID off_t st_size; // 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小 blksize_t st_blsize; // 分配给文件的总块数，块大小为 512 字节 blkcnt_t st_blocks; // 实际分配给文件的磁盘块数量 time_t st_atime; // 对文件上次访问时间 time_t st_mtime; // 对文件上次修改时间 time_t st_ctime; // 文件状态发生改变的上次时间 } Go 中 syscal.Stat_t 与该结构对应。 如果我们要获取 FileInfo 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下： fileInfo, err := os.Stat(\"test.log\") if err != nil { log.Fatal(err) } sys := fileInfo.Sys() stat := sys.(*syscall.Stat_t) fmt.Println(time.Unix(stat.Atimespec.Unix())) ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:93:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"改变文件时间戳 可以显式改变文件的访问时间和修改时间。 func Chtimes(name string, atime time.Time, mtime time.Time) error Chtimes 修改 name 指定的文件对象的访问时间和修改时间，类似 Unix 的 utime() 或 utimes() 函数。底层的文件系统可能会截断 / 舍入时间单位到更低的精确度。如果出错，会返回 *PathError 类型的错误。在 Unix 中，底层实现会调用 utimenstat()，它提供纳秒级别的精度。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:93:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"文件属主 每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。系统调用 chown、lchown 和 fchown 可用来改变文件的属主和属组，Go 中对应的函数或方法： func Chown(name string, uid, gid int) error func Lchown(name string, uid, gid int) error func (f *File) Chown(uid, gid int) error 它们的区别和上文提到的 Stat 相关函数类似。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:93:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"文件权限 这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以及 Unix 域套接字等。 普通文件的权限 如前所述，os.FileMode 或 C 结构 stat 中的 st_mod 的低 12 位定义了文件权限。其中前 3 位为专用位，分别是 set-user-ID 位、set-group-ID 位和 sticky 位。其余 9 位则构成了定义权限的掩码，分别授予访问文件的各类用户。文件权限掩码分为 3 类： Owner（亦称为 user）：授予文件属主的权限。 Group：授予文件属组成员用户的权限。 Other：授予其他用户的权限。 可为每一类用户授予的权限如下： Read：可阅读文件的内容。 Write：可更改文件的内容。 Execute：可以执行文件（如程序或脚本）。 Unix 中表示：rwxrwxrwx。 目录权限 目录与文件拥有相同的权限方案，只是对 3 种权限的含义另有所指。 读权限：可列出（比如，通过 ls 命令）目录之下的内容（即目录下的文件名）。 写权限：可在目录内创建、删除文件。注意，要删除文件，对文件本身无需有任何权限。 可执行权限：可访问目录中的文件。因此，有时也将对目录的执行权限称为 search（搜索）权限。 访问文件时，需要拥有对路径名所列所有目录的执行权限。例如，想读取文件 /home/studygolang/abc，则需拥有对目录 /、/home 以及 /home/studygolang 的执行权限（还要有对文件 abc 自身的读权限）。 相关函数或方法 在文件相关操作报错时，可以通过 os.IsPermission 检查是否是权限的问题。 func IsPermission(err error) bool 返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。ErrPermission 和一些系统调用错误会使它返回真。 另外，syscall.Access 可以获取文件的权限。这对应系统调用 access。 Sticky 位 除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是 set-user-ID(bit 04000)、set-group-ID(bit 02000) 和 sticky(bit 01000) 位。set-user-ID 和 set-group-ID 权限位将在进程章节介绍。这里介绍 sticky 位。 Sticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操作。根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。/tmp 目录就设置了 sticky 位，正是出于这个原因。 chmod 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 ls -l 显示文件时，会在其他用户执行权限字段上看到字母 t（有执行权限时） 或 T（无执行权限时）。 os.Chmod 和 os.File.Chmod 可以修改文件权限（包括 sticky 位），分别对应系统调用 chmod 和 fchmod。 func main() { file, err := os.Create(\"studygolang.txt\") if err != nil { log.Fatal(\"error:\", err) } defer file.Close() fileMode := getFileMode(file) log.Println(\"file mode:\", fileMode) file.Chmod(fileMode | os.ModeSticky) log.Println(\"change after, file mode:\", getFileMode(file)) } func getFileMode(file *os.File) os.FileMode { fileInfo, err := file.Stat() if err != nil { log.Fatal(\"file stat error:\", err) } return fileInfo.Mode() } // Output: // 2016/06/18 15:59:06 file mode: -rw-rw-r-- // 2016/06/18 15:59:06 change after, file mode: trw-rw-r-- // ls -l 看到的 studygolang.tx 是：-rw-rw-r-T // 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:93:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"目录与链接 在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二： 在其 i-node 条目中，会将目录标记为一种不同的文件类型。 目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 i-node 标号。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:94:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"创建和移除（硬）链接 硬链接是针对文件而言的，目录不允许创建硬链接。 link 和 unlink 系统调用用于创建和移除（硬）链接。Go 中 os.Link 对应 link 系统调用；但 os.Remove 的实现会先执行 unlink 系统调用，如果要移除的是目录，则 unlink 会失败，这时 Remove 会再调用 rmdir 系统调用。 func Link(oldname, newname string) error Link 创建一个名为 newname 指向 oldname 的硬链接。如果出错，会返回 *LinkError 类型的错误。 func Remove(name string) error Remove 删除 name 指定的文件或目录。如果出错，会返回 *PathError 类型的错误。如果目录不为空，Remove 会返回失败。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:94:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"更改文件名 系统调用 rename 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。该系统调用既可以用于文件，也可以用于目录。相关细节，请查阅相关资料。 Go 中的 os.Rename 是对应的封装函数。 func Rename(oldpath, newpath string) error Rename 修改一个文件的名字或移动一个文件。如果 newpath 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:94:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"使用符号链接 symlink 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 unlink）。Go 中的 os.Symlink 是对应的封装函数。 func Symlink(oldname, newname string) error Symlink 创建一个名为 newname 指向 oldname 的符号链接。如果出错，会返回 *LinkError 类型的错误。 由 oldname 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，newname 成为“悬空链接”，其他系统调用试图对其进行解引用操作都将错误（通常错误号是 ENOENT）。 有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 readlink 能做到，Go 的封装函数是 os.Readlink： func Readlink(name string) (string, error) Readlink 获取 name 指定的符号链接指向的文件的路径。如果出错，会返回 *PathError 类型的错误。我们看看 Readlink 的实现。 func Readlink(name string) (string, error) { for len := 128; ; len *= 2 { b := make([]byte, len) n, e := fixCount(syscall.Readlink(name, b)) if e != nil { return \"\", \u0026PathError{\"readlink\", name, e} } if n \u003c len { return string(b[0:n]), nil } } } 这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 b 长度不够，文件名会被截断，而 readlink 系统调用无非分辨所返回的字符串到底是经过截断处理，还是恰巧将 b 填满。这里采用的验证方法是分配一个更大的（两倍）b 并再次调用 readlink。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:94:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"创建和移除目录 mkdir 系统调用创建一个新目录，Go 中的 os.Mkdir 是对应的封装函数。 func Mkdir(name string, perm FileMode) error Mkdir 使用指定的权限和名称创建一个目录。如果出错，会返回 *PathError 类型的错误。 name 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 os.ErrExist 错误。 perm 参数指定了新目录的权限。对该位掩码值的指定方式和 os.OpenFile 相同，也可以直接赋予八进制数值。注意，perm 值还将于进程掩码相与（\u0026）。如果 perm 中设置了 sticky 位，那么将对新目录设置该权限。 因为 Mkdir 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。os.MkdirAll 用于递归创建所有不存在的目录。 建议读者阅读下 os.MkdirAll 的源码，了解其实现方式、技巧。 rmdir 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。在讲解 unlink 时，已经介绍了 Go 中的 os.Remove。注意，这里要求目录必须为空。为了方便使用，Go 中封装了一个 os.RemoveAll 函数： func RemoveAll(path string) error RemoveAll 删除 path 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 path 指定的对象不存在，RemoveAll 会返回 nil 而不返回错误。 RemoveAll 的内部实现逻辑如下： 调用 Remove 尝试进行删除，如果成功或返回 path 不存在，则直接返回 nil； 调用 Lstat 获取 path 信息，以便判断是否是目录。注意，这里使用 Lstat，表示不对符号链接解引用； 调用 Open 打开目录，递归读取目录中内容，执行删除操作。 阅读 RemoveAll 源码，可以掌握马上要介绍的读目录内容或遍历目录。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:94:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"读目录 POSIX 与 SUS 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现了读目录功能。 func (f *File) Readdirnames(n int) (names []string, err error) Readdirnames 读取目录 f 的内容，返回一个最多有 n 个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用未读取的内容的信息。 如果 n\u003e0，Readdirnames 函数会返回一个最多 n 个成员的切片。这时，如果 Readdirnames 返回一个空切片，它会返回一个非 nil 的错误说明原因。如果到达了目录 f 的结尾，返回值 err 会是 io.EOF。 如果 n\u003c=0，Readdirnames 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 Readdirnames 调用成功（读取所有内容直到结尾），它会返回该切片和 nil 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。 func (f *File) Readdir(n int) (fi []FileInfo, err error) Readdir 内部会调用 Readdirnames，将得到的 names 构造路径，通过 Lstat 构造出 []FileInfo。 列出某个目录的文件列表示例程序见 dirtree。 6.2 path/filepath — 兼容操作系统的文件路径操作 path/filepath 包涉及到路径操作时，路径分隔符使用 os.PathSeparator。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。本包能够处理所有的文件路径，不管是什么系统。 注意，路径操作函数并不会校验路径是否真实存在。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:94:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"解析路径名字符串 Dir() 和 Base() 函数将一个路径名字符串分解成目录和文件名两部分。（注意一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果路径以 / 结尾，Dir 的行为和 dirname 不太一致。） func Dir(path string) string func Base(path string) string Dir 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 Split 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。如果路径是空字符串，会返回 “.\"；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 “/\"；其他任何情况下都不会返回以斜杠结尾的路径。 Base 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 “\"，会返回 “.\"；如果路径是只有一个斜杆构成的，会返回 “/\"。 比如，给定路径名 /home/polaris/studygolang.go，Dir 返回 /home/polaris，而 Base 返回 studygolang.go。 如果给定路径名 /home/polaris/studygolang/，Dir 返回 /home/polaris/studygolang（这与 Unix 中的 dirname 不一致，dirname 会返回 /home/polaris），而 Base 返回 studygolang。 有人提出此问题，见issue13199，不过官方认为这不是问题，如果需要和 dirname 一样的功能，应该自己处理，比如在调用 Dir 之前，先将末尾的 / 去掉。 此外，Ext 可以获得路径中文件名的扩展名。 func Ext(path string) string Ext 函数返回 path 文件扩展名。扩展名是路径中最后一个从 . 开始的部分，包括 .。如果该元素没有 . 会返回空字符串。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:95:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"相对路径和绝对路径 某个进程都会有当前工作目录（进程相关章节会详细介绍），一般的相对路径，就是针对进程当前工作目录而言的。当然，可以针对某个目录指定相对路径。 绝对路径，在 Unix 中，以 / 开始；在 Windows 下以某个盘符开始，比如 C:\\Program Files。 func IsAbs(path string) bool IsAbs 返回路径是否是一个绝对路径。而 func Abs(path string) (string, error) Abs 函数返回 path 代表的绝对路径，如果 path 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返回的绝对路径是唯一指向该地址的绝对路径。在 os.Getwd 出错时，Abs 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。 func Rel(basepath, targpath string) (string, error) Rel 函数返回一个相对路径，将 basepath 和该路径用路径分隔符连起来的新路径在词法上等价于 targpath。也就是说，Join(basepath, Rel(basepath, targpath)) 等价于 targpath。如果成功执行，返回值总是相对于 basepath 的，即使 basepath 和 targpath 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 targpath 无法表示为相对于 basepath 的路径，将返回错误。 fmt.Println(filepath.Rel(\"/home/polaris/studygolang\", \"/home/polaris/studygolang/src/logic/topic.go\")) fmt.Println(filepath.Rel(\"/home/polaris/studygolang\", \"/data/studygolang\")) // Output: // src/logic/topic.go \u003cnil\u003e // ../../../data/studygolang \u003cnil\u003e ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:96:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"路径的切分和拼接 对于一个常规文件路径，我们可以通过 Split 函数得到它的目录路径和文件名： func Split(path string) (dir, file string) Split 函数根据最后一个路径分隔符将路径 path 分隔为目录和文件名两部分（dir 和 file）。如果路径中没有路径分隔符，函数返回值 dir 为空字符串，file 等于 path；反之，如果路径中最后一个字符是 /，则 dir 等于 path，file 为空字符串。返回值满足 path == dir+file。dir 非空时，最后一个字符总是 /。 // dir == /home/polaris/，file == studygolang filepath.Split(\"/home/polaris/studygolang\") // dir == /home/polaris/studygolang/，file == \"\" filepath.Split(\"/home/polaris/studygolang/\") // dir == \"\"，file == studygolang filepath.Split(\"studygolang\") 相对路径到绝对路径的转变，需要经过路径的拼接。Join 用于将多个路径拼接起来，会根据情况添加路径分隔符。 func Join(elem ...string) string Join 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 Clean 的，所有的空字符串元素会被忽略。对于拼接路径的需求，我们应该总是使用 Join 函数来处理。 有时，我们需要分割 PATH 或 GOPATH 之类的环境变量（这些路径被特定于 OS 的列表分隔符连接起来），filepath.SplitList 就是这个用途： func SplitList(path string) []string 注意，与 strings.Split 函数的不同之处是：对 “\"，SplitList 返回[]string{}，而 strings.Split 返回 []string{”\"}。SplitList 内部调用的是 strings.Split。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:97:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"规整化路径 func Clean(path string) string Clean 函数通过单纯的词法操作返回和 path 代表同一地址的最短路径。 它会不断的依次应用如下的规则，直到不能再进行任何处理： 将连续的多个路径分隔符替换为单个路径分隔符 剔除每一个 . 路径名元素（代表当前目录） 剔除每一个路径内的 .. 路径名元素（代表父目录）和它前面的非 .. 路径名元素 剔除开始于根路径的 .. 路径名元素，即将路径开始处的 /.. 替换为 /（假设路径分隔符是 /） 返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 / 或 Windows 的 C:\\。 如果处理的结果是空字符串，Clean 会返回 .，代表当前路径。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:98:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"符号链接指向的路径名 在上一节 os 包中介绍了 Readlink，可以读取符号链接指向的路径名。不过，如果原路径中又包含符号链接，Readlink 却不会解析出来。filepath.EvalSymlinks 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。 func EvalSymlinks(path string) (string, error) 如果 path 或返回值是相对路径，则是相对于进程当前工作目录。 os.Readlink 和 filepath.EvalSymlinks 区别示例程序： // 在当前目录下创建一个 studygolang.txt 文件和一个 symlink 目录，在 symlink 目录下对 studygolang.txt 建一个符号链接 studygolang.txt.2 fmt.Println(filepath.EvalSymlinks(\"symlink/studygolang.txt.2\")) fmt.Println(os.Readlink(\"symlink/studygolang.txt.2\")) // Ouput: // studygolang.txt \u003cnil\u003e // ../studygolang.txt \u003cnil\u003e ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:99:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"文件路径匹配 func Match(pattern, name string) (matched bool, err error) Match 指示 name 是否和 shell 的文件模式匹配。模式语法如下： pattern: { term } term: '*' 匹配 0 或多个非路径分隔符的字符 '?' 匹配 1 个非路径分隔符的字符 '[' [ '^' ] { character-range } ']' 字符组（必须非空） c 匹配字符 c（c != '*', '?', '\\\\', '['） '\\\\' c 匹配字符 c character-range: c 匹配字符 c（c != '\\\\', '-', ']'） '\\\\' c 匹配字符 c lo '-' hi 匹配区间[lo, hi]内的字符 匹配要求 pattern 必须和 name 全匹配上，不只是子串。在 Windows 下转义字符被禁用。 Match 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 Glob 函数在模板标准库中被用到了。 func Glob(pattern string) (matches []string, err error) Glob 函数返回所有匹配了 模式字符串 pattern 的文件列表或者 nil（如果没有匹配的文件）。pattern 的语法和 Match 函数相同。pattern 可以描述多层的名字，如 /usr/*/bin/ed（假设路径分隔符是 /）。 注意，Glob 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 Match 一样，在 pattern 不合法时，返回 filepath.ErrBadPattern。返回的结果是根据文件名字典顺序进行了排序的。 Glob 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 testdata 目录下所有测试数据： filepath.Glob(\"testdata/*.input\") ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:100:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"遍历目录 在介绍 os 时，讲解了读取目录的方法，并给出了一个遍历目录的示例。在 filepath 中，提供了 Walk 函数，用于遍历目录树。 func Walk(root string, walkFn WalkFunc) error Walk 函数会遍历 root 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 walkFn，包括 root 自身。所有访问文件 / 目录时遇到的错误都会传递给 walkFn 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。Walk 函数不会遍历文件树中的符号链接（快捷方式）文件包含的路径。 walkFn 的类型 WalkFunc 的定义如下： type WalkFunc func(path string, info os.FileInfo, err error) error Walk 函数对每一个文件 / 目录都会调用 WalkFunc 函数类型值。调用时 path 参数会包含 Walk 的 root 参数作为前缀；就是说，如果 Walk 函数的 root 为 “dir”，该目录下有文件 “a”，将会使用 “dir/a” 作为调用 walkFn 的参数。walkFn 参数被调用时的 info 参数是 path 指定的地址（文件 / 目录）的文件信息，类型为 os.FileInfo。 如果遍历 path 指定的文件或目录时出现了问题，传入的参数 err 会描述该问题，WalkFunc 类型函数可以决定如何去处理该错误（Walk 函数将不会深入该目录）；如果该函数返回一个错误，Walk 函数的执行会中止；只有一个例外，如果 Walk 的 walkFn 返回值是 SkipDir，将会跳过该目录的内容而 Walk 函数照常执行处理下一个文件。 和 os 遍历目录树的示例对应，使用 Walk 遍历目录树的示例程序在 walk，程序简单很多。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:101:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Windows 起作用的函数 filepath 中有三个函数：VolumeName、FromSlash 和 ToSlash，针对非 Unix 平台的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:102:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"关于 path 包 path 包提供了对 / 分隔的路径的实用操作函数。 在 Unix 中，路径的分隔符是 /，但 Windows 是 \\。在使用 path 包时，应该总是使用 /，不论什么系统。 path 包中提供的函数，filepath 都有提供，功能类似，但实现不同。 一般应该总是使用 filepath 包，而不是 path 包。 6.3 io/fs — 抽象文件系统 Go 语言从 1.16 开始增加了 io/fs 包，该包定义了一个文件系统需要的相关基础接口，因此我们称之为抽象文件系统。该文件系统是层级文件系统或叫树形文件系统，Unix 文件系统就是这种类型。 本节除了讲解标准库的相关内容，还会实现一个文件系统作为例子。 注意，因为抽象了一个文件系统，之前 os 包中和文件系统相关的功能都移到 io/fs 包了，os 中的原类型只是 io/fs 对应类型的别名。如果你的系统要求 Go1.16，应该优先使用 io/fs 包。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:103:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"三个核心接口 一个文件系统有些必要的元素，io/fs 包提供两个最小的接口来表示，即 fs.FS 和 fs.File。但因为 fs.File 依赖 fs.FileInfo 接口，因此实际上是三个接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:104:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.FS 该接口提供了对层级文件系统的访问。一个文件系统的最低要求是必须实现 fs.FS 接口，但一般还会实现额外的接口，比如 ReadFileFS，该接口在后文讲解。 type FS interface { // Open opens the named file. // // When Open returns an error, it should be of type *PathError // with the Op field set to \"open\", the Path field set to name, // and the Err field describing the problem. // // Open should reject attempts to open names that do not satisfy // ValidPath(name), returning a *PathError with Err set to // ErrInvalid or ErrNotExist. Open(name string) (File, error) } 该接口只有一个方法，即打开一个命名文件，该方法的实现要求如下： 如果 Open 方法出错，应该返回 *PathError 类型的错误，该类型定义如下： type PathError struct { Op string Path string Err error } 返回该类型错误时，Op 字段设置为 “open”，Path 字段设置为文件名，而 Err 字段描述错误原因。 注：在 os 那小节提到过该类型，Go 1.16 后，os.PathError 只是 fs.PathError 的别名。 type PathError = fs.PathError 对于指定的文件名，需要满足 ValidPath(name) 函数，如果不满足，则返回 *PathError 的 Err 为 fs.ErrInvalid 或 fs.ErrNotExist 的错误。 func ValidPath(name string) bool 传递给该函数的 name 应该是一个非根，且是 / 分隔的，例如 x/y/z。除了只包含 .，其他情况不能有 . 和 ..。 因为 Open 方法返回一个 fs.File 接口类型，因此一个文件系统只实现 fs.FS 还不够，需要同时实现 fs.File 接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:104:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.File 该接口提供对单个文件的访问。File 接口是文件的最低实现要求。一个文件可以实现其他接口，例如fs.ReadDirFile，fs.ReaderAt 或 fs.Seeker，以提供额外或优化的功能。 type File interface { Stat() (FileInfo, error) Read([]byte) (int, error) Close() error } 通过 fs.FS 接口的 Open 打开文件后，通过 fs.File 接口的 Read 方法进行读操作，这个方法和 io.Reader 接口的 Read 方法签名一样。 对操作系统有所了解的读者应该知晓（特别是 Unix 系统），目录也是文件，只是特殊的文件。因此，在遍历文件目录树时，我们通常需要判断文件是什么类型，也可能需要获取文件的一些元数据信息，比如文件名、大小、修改时间等，而这就是 Stat 方法的功能。该方法会返回一个 FileInfo 类型，它也是一个接口。这就是文件系统需要实现的第三接口，稍后讲解。 在 Go 中，你应该始终记住，打开文件，进行操作后，记得关闭文件，否则会泄露文件描述符。所以，fs.File 的第是三个方法就是 Close 方法，它的签名和 io.Closer 是一致的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:104:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.FileInfo 该接口描述一个文件的元数据信息，它由 Stat 返回。为了方便，在 io/fs 包有一个 Stat 函数： func Stat(fsys FS, name string) (FileInfo, error) 该函数接受任意的 FS 文件系统和该系统下的任意一个文件。如果 fsys 实现了 StatFS，则直接通过 StatFS 的 Stat 方法获取 FileInfo，否则需要 Open 文件，然后调用 File 的 Stat 方法来获取 FileInfo。关于 fs.StatFS 接口后文讲解。 本节开头提到了，Go1.16 开始，os 包中和文件系统相关的类型移到 io/fs 包中了，fs.FileInfo 就是其中之一。因为在 os 中已经讲过该接口了，此处不再赘述。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:104:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实现一个文件系统 介绍完这三个核心接口，我们尝试实现一个文件系统。这是一个基于内存的文件系统，这个实现相对比较简陋。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:105:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实现 fs.File 和 fs.FileInfo 实现文件系统先实现这两个接口。我们通过一个类型来实现： type file struct { name string content *bytes.Buffer modTime time.Time closed bool } func (f *file) Read(p []byte) (int, error) { if f.closed { return 0, errors.New(\"file closed\") } return f.content.Read(p) } func (f *file) Stat() (fs.FileInfo, error) { if f.closed { return nil, errors.New(\"file closed\") } return f, nil } // Close 关闭文件，可以调用多次。 func (f *file) Close() error { f.closed = true return nil } // 实现 fs.FileInfo func (f *file) Name() string { return f.name } func (f *file) Size() int64 { return int64(f.content.Len()) } func (f *file) Mode() fs.FileMode { // 固定为 0444 return 0444 } func (f *file) ModTime() time.Time { return f.modTime } // IsDir 目前未实现目录功能 func (f *file) IsDir() bool { return false } func (f *file) Sys() interface{} { return nil } file 同时实现 fs.File 和 fs.FileInfo； 文件内容放在 file 的 bytes.Buffer 类型中，它实现了 io.Reader，因此 file 的 Read 可以直接通过它实现； 目前是一个简化实现，因此 IsDir 未实现目录功能，只返回 false； ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:105:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实现 fs.FS 实现了 fs.File，通过它可以实现 fs.FS： type FS struct { files map[string]*file } func NewFS() *FS { return \u0026FS{ files: make(map[string]*file), } } func (fsys *FS) Open(name string) (fs.File, error) { if !fs.ValidPath(name) { return nil, \u0026fs.PathError{ Op: \"open\", Path: name, Err: fs.ErrInvalid, } } if f, ok := fsys.files[name]; !ok { return nil, \u0026fs.PathError{ Op: \"open\", Path: name, Err: fs.ErrNotExist, } } else { return f, nil } } FS 类型中的 files 存放所有的文件； 按照前面 Open 方法的实现要求，先通过 ValidPath 函数进行校验，接着通过 name 查找 file； 细心的读者应该会发现，io/fs 并没有提供 Write 相关的功能，那我们读什么呢？为此，我们实现一个 Write 的功能。 func (fsys *FS) WriteFile(name, content string) error { if !fs.ValidPath(name) { return \u0026fs.PathError{ Op: \"write\", Path: name, Err: fs.ErrInvalid, } } f := \u0026file{ name: name, content: bytes.NewBufferString(content), modTime: time.Now(), } fsys.files[name] = f return nil } WriteFile 方法就是生成一个 file 然后存入 files 中。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:105:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"验证 一个基于内存的文件系统已经实现完成，接下来需要验证下。 func TestMemFS(t *testing.T) { name := \"x/y/name.txt\" content := \"This is polarisxu, welcome.\" memFS := memfs.NewFS() err := memFS.WriteFile(name, content) if err != nil { t.Fatal(err) } f, err := memFS.Open(name) if err != nil { t.Fatal(err) } defer f.Close() fi, err := f.Stat() if err != nil { t.Fatal(err) } t.Log(fi.Name(), fi.Size(), fi.ModTime()) var result = make([]byte, int(fi.Size())) n, err := f.Read(result) if err != nil { t.Fatal(err) } if string(result[:n]) != content { t.Errorf(\"expect: %s, actual: %s\", content, result[:n]) } } 如果测试通过，说明基于内存的简单文件系统已经完成。至于缺失的功能，本节后面再完善。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:105:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"增强型接口 上面实现的内存文件系统中，目录功能是有问题的，比如我们没法遍历整个文件系统。要实现一个更完整的文件系统，需要实现 io/fs 包中的其他接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:106:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.DirEntry 和相关接口 在文件系统中，一个目录下可能会有子目录或文件，这称为 entry，在 io/fs 包中用 DirEntry 接口表示： type DirEntry interface { // Name returns the name of the file (or subdirectory) described by the entry. // This name is only the final element of the path (the base name), not the entire path. // For example, Name would return \"hello.go\" not \"/home/gopher/hello.go\". Name() string // IsDir reports whether the entry describes a directory. IsDir() bool // Type returns the type bits for the entry. // The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method. Type() FileMode // Info returns the FileInfo for the file or subdirectory described by the entry. // The returned FileInfo may be from the time of the original directory read // or from the time of the call to Info. If the file has been removed or renamed // since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist). // If the entry denotes a symbolic link, Info reports the information about the link itself, // not the link's target. Info() (FileInfo, error) } Name() 方法和 FileInfo 接口的 Name() 方法类似，代表的是 base name，而我们上面实现的文件系统没有处理这一点； Type() 方法返回一个 fs.FileMode，表示 entry 的位类型，关于 FileMode 的详细信息在 os 包中有讲解； Info() 方法和 Stat 有点类似，获取元数据信息；如果 entry 是软链接，Info() 返回的 FileInfo 是链接本身的信息，而不是目标文件； 为了方便遍历文件系统（目录），io/fs 包提供了 ReadDir 函数，用来获取某个目录下的所有目录项： func ReadDir(fsys FS, name string) ([]DirEntry, error) 对于这个函数的实现，如果第一个参数实现了 fs.ReadDirFS 接口，直接调用该接口的 ReadDir 方法： type ReadDirFS interface { FS // ReadDir reads the named directory // and returns a list of directory entries sorted by filename. ReadDir(name string) ([]DirEntry, error) } 否则看是否实现了 fs.ReadDirFile 接口，没实现则报错；否则调用该接口的 ReadDir 方法： type ReadDirFile interface { File // ReadDir reads the contents of the directory and returns // a slice of up to n DirEntry values in directory order. // Subsequent calls on the same file will yield further DirEntry values. // // If n \u003e 0, ReadDir returns at most n DirEntry structures. // In this case, if ReadDir returns an empty slice, it will return // a non-nil error explaining why. // At the end of a directory, the error is io.EOF. // // If n \u003c= 0, ReadDir returns all the DirEntry values from the directory // in a single slice. In this case, if ReadDir succeeds (reads all the way // to the end of the directory), it returns the slice and a nil error. // If it encounters an error before the end of the directory, // ReadDir returns the DirEntry list read until that point and a non-nil error. ReadDir(n int) ([]DirEntry, error) } 这个接口的 ReadDir 比 ReadDirFS 复杂多了，但 ReadDirFS 的 ReadDir 必须自己对 entry 进行排序。此外，如果目录下内容特别多，ReadDirFile 接口会更适合，它可以分段读取。而且目录应该实现 ReadDirFile 接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:106:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"其他 fs.FS 相关的接口 在讲解 fs.FS 接口时提到还有其他接口，用于增强 fs.FS，即嵌入了 fs.FS 接口，除了已经介绍的 ReadDirFS 接口，还有如下接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:107:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.ReadFileFS 该接口的定义如下： type ReadFileFS interface { FS // ReadFile reads the named file and returns its contents. // A successful call returns a nil error, not io.EOF. // (Because ReadFile reads the whole file, the expected EOF // from the final Read is not treated as an error to be reported.) ReadFile(name string) ([]byte, error) } 也就是说这是一个支持 ReadFile 的文件系统，如果一个文件系统实现了该接口，则 fs.ReadFile 函数会先直接使用该接口的 ReadFile 方法来实现： func ReadFile(fsys FS, name string) ([]byte, error) 如果没实现该接口，则通过 fs.FS 的 Open 方法获取 fs.File 类型，然后调用 fs.File 的 Read 方法来实现。有兴趣可以查看 fs.ReadFile 函数的实现。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:107:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.StatFS 该接口的定义如下： type StatFS interface { FS // Stat returns a FileInfo describing the file. // If there is an error, it should be of type *PathError. Stat(name string) (FileInfo, error) } 如果一个文件系统支持 Stat 功能，则 fs.Stat 函数会优先使用该文件系统的 Stat 方法，否则通过 fs.FS 的 Open 方法获取 fs.File 类型，然后调用 fs.File 的 Stat 方法来实现。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:107:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.GlobFS 该接口的定义如下： type GlobFS interface { FS // Glob returns the names of all files matching pattern, // providing an implementation of the top-level // Glob function. Glob(pattern string) ([]string, error) } 类似的，实现了该接口，表示文件系统支持 Glob 方法。对应的，io/fs 提供了 Glob 函数： func Glob(fsys FS, pattern string) (matches []string, err error) 这是用于文件模式匹配的； 语法和 path.Match 相同； 模式（pattern）可以描述层级，比如：/usr/*/bin/ed； 该函数会忽略文件系统错误，比如 IO 错误；唯一的错误是模式语法错误； 和其他 fs.FS 相关接口对应的函数一样，Glob 函数内部实现优先调用 fs.GlobFS 接口，如果没实现该接口，则使用 ReadDir 遍历目录树来查找匹配的目标。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:107:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"fs.SubFS 该接口的定义如下： type SubFS interface { FS // Sub returns an FS corresponding to the subtree rooted at dir. Sub(dir string) (FS, error) } 这个接口的作用主要是让一个文件系统支持定义子文件系统。io/fs 包也提供了一个相应的函数 Sub： func Sub(fsys FS, dir string) (FS, error) 通过该函数可以获得一个子文件系统，该子文件系统的根由第二个参数 dir 指定。 类似的，该函数的实现会优先判断 fsys 是否实现了 fs.SubFS 接口，以便调用其 Sub 方法。如果未实现，同时 dir 是 .，则原样返回 fsys，否则返回一个新实现的 fs.FS。 不过有一点需要注意，对于 os 实现的 fs.FS 文件系统（磁盘文件系统），Sub 并不能提到 chroot 的进制，它不会限制子文件系统根之外的操作，典型的，子文件系统内部的文件软连到根之外，Sub 得到的子文件系统不会阻止这种行为。 查看 fs.Sub 函数的源码可以发现，如果 fsys 没有实现 fs.SubFS，Sub 函数返回的 FS 实现了不少 FS 相关接口。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:107:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"设计思想 上面啰啰嗦嗦讲了好几个 fs.FS 相关接口，其中目的之一是希望理解其设计思想。 io/fs 包中和 fs.FS 相关的接口如下： fs.ReadDirFS fs.ReadFileFS fs.StatFS fs.SubFS fs.GlobFS Go 以简单著称，大道至简。Go 强调定义小接口。fs.FS 接口只有一个方法：Open，其他 fs.FS 相关接口都内嵌了 fs.FS 接口，以此来扩展文件系统的功能。同时 io/fs 包辅以相关便捷函数（比如 Stat、Sub、Glob 等），达到操作 fs.FS 的目的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:107:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"完善内存文件系统 是时候完善我们上面实现的内存文件系统了。 前面只是实现了文件的写入、读取，并没有实现文件系统该有的目录树。现在补充完善这部分内容，实现一个较完整的内存文件系统。具体看代码前，看看如何设计。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:108:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"如何设计 先通过一个类图表示 io/fs 包相关接口的关系。 要基于这些接口实现一个文件系统，我们需要先了解一些文件系统相关的知识（前面有提到，这里总结下）。 文件系统是一个树形结构，有一个根目录； 一个目录下的目录项，可以是文件或子目录； 一切皆文件，所以目录也是文件；（虽然如此，但两者还是有不小区别，因此实现时不一定适合使用嵌入） 所以，我们在实现 fs.FS 接口时，定义的类型 FS 有一个根目录字段： type FS struct { rootDir *dir } 文件的实现 从上面类图可以看出，一个文件需要实现 fs.File 接口，同时因为该接口依赖 fs.FileInfo 接口，我们可以选择用一个单独的类型实现 fs.FileInfo 接口，也可以直接用这个文件类型（file）实现该接口，内存文件系统直接使用文件类型实现了 fs.FileInfo 接口。此外，一个文件还是其所在目录的目录项，因此还需要实现 fs.DirEntry 接口。因此内存文件系统的 file 类型实现了以下接口： fs.File fs.FileInfo fs.DirEntry 具体如何实现这些接口，需要先思考一个问题：文件内容用什么表示？因为是内存文件系统，因此一切都在内存中。文件内容本质上是字节数组，但因为要实现 fs.File 接口，这其中关键的是 Read 方法，它的签名和 io.Reader 接口的 Read 方法是一样的，因此在 file 类型中，我们用一个 bytes.Buffer 字段来存放文件内容。 至于其他接口的实现相对较简单，这里不赘述。值得一提的是，因为 file 类型实现了 fs.FileInfo 接口，所以在实现 Stat 方法时，直接返回 file 的实例即可。 目录的实现 对于目录，我们用类型 dir 表示，它首先是其所在目录的目录项，因此需要实现 fs.DirEntry 接口；其次目录也是文件，因此它需要实现 fs.File 接口。同时，读取目录的内容，即读取其目录项，不应该通过 Read 读取，而 fs.ReadDirFile 接口是用来读目录的，因此 dir 应该实现它。同样的，因为 fs.DirEntry 和 fs.File 都依赖 fs.FileInfo 接口，跟 file 一样，我们不单独实现，而是让 dir 直接实现它。因此内存文件系统的 dir 类型实现了以下接口： fs.DirEntry fs.File fs.ReadDirFile fs.FileInfo 因为目录涉及到有目录项，构成了一个树形结构。这里使用一个 map 来存放所有的目录项，key 是目录项的名称，value 是目录项的实例。 // dir 代表一个目录 type dir struct { name string modTime time.Time // 存放该目录下的子项，value 可能是 *dir 或 *file children map[string]fs.DirEntry } 因为 Read 对于目录来说没有实际价值，因此它的实现返回错误即可。dir 的难点在于实现 fs.ReadDirFile 接口中的 ReadDir 方法：给定一个目录，该方法需要返回该目录下的所有目录项。而且，根据 fs.ReadDirFile 中 ReadDir 方法的实现要求，它应该支持分步读取目录项。所以，在 dir 类型中增加一个字段：idx，用来表示当前读取到什么位置的目录项了。具体实现代码见后文。 fs.FS 接口的实现 对于内存文件系统，如何实现 Open 方法呢？我们需要根据参数 name 在文件系统的目录树中找到该文件所在位置。因此，我们将该文件用 / 分隔，从左到右，一部分一部分，从文件系统的根开始，在目录树中查找，直到找到对应的文件，然后返回该文件。如果没找到，返回错误。 具体来说，在遍历文件系统目录树时，如果某个目录项是文件，且是 name 的最后一部分，表示找到了该文件；如果某个目录项是目录，则递归遍历它的目录项。 创建目录和文件的实现 io/fs 没有定义创建目录和文件的接口，从这个维度看，io/fs 定义的文件系统是一个只读文件系统。但实际的文件系统，必然要有写入的接口。因此我们还需要实现创建目录和创建文件（写入内容）的功能。 先看创建目录的实现。 创建目录，实际上是构建一个层级关系。方法签名如下： func (fsys *FS) MkdirAll(path string) error 根据传入的 path，比如 x/y/z，能够创建对应的目录结构。因此我们将 path 通过 / 分隔，从左到右，一步步从文件系统的根开始在对应的层级创建目录。创建时，需要判断是否已经存在对应的目录。关键代码如下： cur := fsys.rootDir parts := strings.Split(path, \"/\") for _, part := range parts { child := cur.children[part] if child == nil { childDir := \u0026dir{ name: part, modTime: time.Now(), children: make(map[string]fs.DirEntry), } cur.children[part] = childDir cur = childDir } else { childDir, ok := child.(*dir) if !ok { return fmt.Errorf(\"%s is not directory\", part) } cur = childDir } } 文件的创键和内容写入通过 WriteFile 方法实现。签名如下： func (fsys *FS) WriteFile(name, content string) error 在非完善版本中，粗暴的直接将传递的文件名（包括路径）和 file 实例关联，没有处理目录层级关系。因此，这里的实现的关键是要找到该文件（name 对应）的目录 dir 实例。和上面创建目录的思路类似，一步步处理。 // getDir 通过一个路径获取其 dir 类型实例 func (fsys *FS) getDir(path string) (*dir, error) { parts := strings.Split(path, \"/\") cur := fsys.rootDir for _, part := range parts { child := cur.children[part] if child == nil { return nil, fmt.Errorf(\"%s is not exists\", path) } childDir, ok := child.(*dir) if !ok { return nil, fmt.Errorf(\"%s is not directory\", path) } cur = childDir } return cur, nil } 得到了文件应该放置的目录（dir）后，就可以构建一个 file 实例，并将该实例放置到其目录的目录项中。 filename := filepath.Base(name) dir.children[filename] = \u0026file{ name: filename, content: bytes.NewBufferString(content), modTime: time.Now(), } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:108:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"完整的实现代码 以下是 dir 类型的实现，代表一个目录，注意注释。 // dir 代表一个目录 type dir struct { name string modTime time.Time // 存放该目录下的子项，value 可能是 *dir 或 *file children map[string]fs.DirEntry // ReadDir 遍历用 idx int } // dir 虽然是一个目录，但根据一切皆文件的思想，目录也是文件，因此需要实现 fs.File 接口 // 这样，fs.FS 的 Open 方法可以对目录起作用。 func (d *dir) Read(p []byte) (int, error) { return 0, \u0026fs.PathError{ Op: \"read\", Path: d.name, Err: errors.New(\"is directory\"), } } func (d *dir) Stat() (fs.FileInfo, error) { return d, nil } func (d *dir) Close() error { return nil } // ReadDir 实现 fs.ReadDirFile 接口，方便遍历目录 func (d *dir) ReadDir(n int) ([]fs.DirEntry, error) { names := make([]string, 0, len(d.children)) for name := range d.children { names = append(names, name) } totalEntry := len(names) if n \u003c= 0 { n = totalEntry } dirEntries := make([]fs.DirEntry, 0, n) for i := d.idx; i \u003c n \u0026\u0026 i \u003c totalEntry; i++ { name := names[i] child := d.children[name] f, isFile := child.(*file) if isFile { dirEntries = append(dirEntries, f) } else { dirEntry := child.(*dir) dirEntries = append(dirEntries, dirEntry) } d.idx = i } return dirEntries, nil } // 因为 fs.Stat 对目录也是有效的，因此 dir 需要实现 fs.FileInfo 接口 func (d *dir) Name() string { return d.name } func (d *dir) Size() int64 { return 0 } func (d *dir) Mode() fs.FileMode { return fs.ModeDir | 0444 } func (d *dir) ModTime() time.Time { return d.modTime } func (d *dir) IsDir() bool { return true } func (d *dir) Sys() interface{} { return nil } // 因为 dir 是一个目录项，因此需要实现 fs.DirEntry 接口 func (d *dir) Type() fs.FileMode { return d.Mode() } func (d *dir) Info() (fs.FileInfo, error) { return d, nil } 接着是 file 的实现，代表一个文件，注意注释。 // file 代表一个文件 type file struct { name string // 存放文件内容 content *bytes.Buffer modTime time.Time closed bool } // 实现 fs.File 接口 func (f *file) Read(p []byte) (int, error) { if f.closed { return 0, errors.New(\"file closed\") } return f.content.Read(p) } func (f *file) Stat() (fs.FileInfo, error) { if f.closed { return nil, errors.New(\"file closed\") } return f, nil } // Close 关闭文件，可以调用多次。 func (f *file) Close() error { f.closed = true return nil } // 实现 fs.FileInfo 接口 func (f *file) Name() string { return f.name } func (f *file) Size() int64 { return int64(f.content.Len()) } func (f *file) Mode() fs.FileMode { // 固定为 0444 return 0444 } func (f *file) ModTime() time.Time { return f.modTime } func (f *file) IsDir() bool { return false } func (f *file) Sys() interface{} { return nil } // 文件也是某个目录下的目录项，因此需要实现 fs.DirEntry 接口 func (f *file) Type() fs.FileMode { return f.Mode() } func (f *file) Info() (fs.FileInfo, error) { return f, nil } 有了目录（dir）和文件（file），看 fs.FS 的实现。 // FS 是 fs.FS 的内存文件系统实现 type FS struct { rootDir *dir } // NewFS 创建一个内存文件系统的实例 func NewFS() *FS { return \u0026FS{ rootDir: \u0026dir{ children: make(map[string]fs.DirEntry), }, } } // Open 实现 fs.FS 的 Open 方法 func (fsys *FS) Open(name string) (fs.File, error) { // 1、校验 name if !fs.ValidPath(name) { return nil, \u0026fs.PathError{ Op: \"open\", Path: name, Err: fs.ErrInvalid, } } // 2、根目录处理 if name == \".\" || name == \"\" { // 重置目录的遍历 fsys.rootDir.idx = 0 return fsys.rootDir, nil } // 3、根据 name 在目录树中进行查找 cur := fsys.rootDir parts := strings.Split(name, \"/\") for i, part := range parts { // 不存在返回错误 child := cur.children[part] if child == nil { return nil, \u0026fs.PathError{ Op: \"open\", Path: name, Err: fs.ErrNotExist, } } // 是否是文件 f, ok := child.(*file) if ok { // 文件名是最后一项 if i == len(parts)-1 { return f, nil } return nil, \u0026fs.PathError{ Op: \"open\", Path: name, Err: fs.ErrNotExist, } } // 是否是目录 d, ok := child.(*dir) if !ok { return nil, \u0026fs.PathError{ Op: \"open\", Path: name, Err: errors.New(\"not a directory\"), } } // 重置，避免遍历问题 d.idx = 0 cur = d } return cur, nil } // MkdirAll 这不是 io/fs 的要求，但一个文件系统目录树需要可以构建 // 这个方法就是用来创建目录 func (fsys *FS) MkdirAll(path string) error { if !fs.ValidPath(path) { return errors.New(\"Invalid path\") } if path == \".\" { return nil } cur := fsys.rootDir parts := strings.Split(path, \"/\") for _, part := range parts { child := cur.children[part] if child == nil { childDir := \u0026dir{ name: part, modTime: time.No","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:108:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"验证正确性并学习 fs.WalkDir 用心的读者可能会发现，io/fs 包还有一个类型和函数没有介绍，那就是 fs.WalkDir 函数和 WalkDirFunc 类型。它们是遍历目录用的。这里通过验证上面内存文件系统的正确性来学习它们。 首先，我们使用 MkdirAll 和 WriteFile 创建如下的目录树： ├── a │ ├── b │ │ └── z ├── x │ └── y │ │ └── z │ └── name.txt 即执行如下代码： memFS := memfs.NewFS() memFS.MkdirAll(\"a/b/z\") memFS.MkdirAll(\"x/y/z\") memFS.WriteFile(\"x/name.txt\", \"This is polarisxu, welcome.\") 基于这个目录树，我们该怎么遍历它？ ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:109:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"自己实现遍历方法 遍历目录树也是一个面试常考的基础题目。熟悉的朋友应该知道，这需要用到递归。基于上面的内存文件系统 API，我们实现遍历目录树。 通过 io/fs 包的 ReadDir 函数读取目录下所有目录项，然后遍历这些目录项，如果某个目录项是目录，递归处理它。 func walk(fsys fs.FS, parent, base string) error { dirEntries, err := fs.ReadDir(fsys, filepath.Join(parent, base)) if err != nil { return err } for _, dirEntry := range dirEntries { name := dirEntry.Name() fmt.Println(name) if dirEntry.IsDir() { err = walk(fsys, filepath.Join(parent, base), name) } } return err } 然后用根目录调用它： walk(memFS, \"\", \".\") ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:109:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"使用 fs.WalkDir 实现 其实标准库为我们实现了这样的功能，通过它提供的方法可以很容易的实现遍历。 fs.WalkDir(memFS, \".\", func(path string, d fs.DirEntry, err error) error { fmt.Pritnln(path) return nil }) 是不是不要太简单？ 关于 fs.WalkDir 和 fs.WalkDirFunc 有一大段文字说明，介绍其中的一些细节。比如在回调函数中，如果返回 fs.SkipDir，则会停止该目录的遍历。这里细说了。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:109:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"小结 io/fs 包基本上是在 os 包的基础上抽象出来的。之所以抽象，是因为 Go1.16 的 embed 功能，它需要文件系统，但又不同于 os 的文件系统。所以做了这个抽象。 基于 io/fs 包的接口，标准库不少地方做了改动，以支持 fs.FS 接口。此外还有第三方实现了它的文件系统： https://github.com/jhchabran/gistfs：用于读取 GitHub gists 的文件； https://github.com/benbjohnson/hashfs：hash 文件，以便 HTTP Cache； https://github.com/psanford/memfs：内存文件系统的实现；本小节文件系统的实现参考了它。 第七章 数据持久存储与交换 现代程序离不开数据存储，现阶段很热的所谓大数据处理、云盘等，更是以存储为依托。有数据存储，自然需要进行数据交换，已达到数据共享等目的。 关系型数据库发展了很长一段时间，SQL/SQL-like 已经很成熟，使用也很广泛，Go 语言标准库提供了对 SQL/SQL-like 数据库的操作的标准接口，即 database/sql 包。 在数据交换方面，有很多成熟的协议可以使用，常用的有：JSON、XML 等，似乎 Java 社区更喜欢 XML，而目前似乎使用更多的是 JSON。在交换协议选择方面，考虑的主要这几个方面因素：性能、跨语言（通用性）、传输量等。因此，对于性能要求高的场景，会使用 protobuf、msgpack 之类的协议。由于 JSON 和 XML 使用很广泛，Go 语言提供了解析它们的标准库；同时，为了方便 Go 程序直接数据交换，Go 专门提供了 gob 这种交换协议。 7.1 database/sql — SQL/SQL-Like 数据库操作接口 这是 Go 提供的操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。本书使用的是 mysql 的驱动：github.com/go-sql-driver/mysql。 注：该包有一个子包：driver，它定义了一些接口供数据库驱动实现，一般业务代码中使用 database/sql 包即可，尽量避免使用 driver 这个子包。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:110:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"7.1.1 database/sql 是什么？ 很明显，database/sql 首先是 Go 标准库提供的一个包，用于和 SQL/SQL-Like 数据库 ( 关系或类似关系数据库）通讯。它提供了和 ODBC、Perl 的 DBI、Java 的 JDBC 和 PHP 的 PDO 类似的功能。然而，它的设计却不太一样，掌握了它有利于构建健壮、高性能的基于 database 的应用。 另一方面，database/sql 提供的是抽象概念，和具体数据库无关，具体的数据库实现，有驱动来做，这样可以很方便的更换数据库。 该包提供了一些类型（概括性的），每个类型可能包括一个或多个概念。 DB sql.DB 类型代表了一个数据库。这点和很多其他语言不同，它并不代表一个到数据库的具体连接，而是一个能操作的数据库对象，具体的连接在内部通过连接池来管理，对外不暴露。这点是很多人容易误解的：每一次数据库操作，都产生一个 sql.DB 实例，操作完 Close。 Results 定义了三种结果类型：sql.Rows、sql.Row 和 sql.Result，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 last insert id）。 Statements sql.Stmt 代表一个语句，如：DDL、DML 等。 Transactions sql.Tx 代表带有特定属性的一个事务。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:111:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"7.1.2 sql.DB 的使用 官方文档关于 DB 的描述： 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。 sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。一旦调用了 BD.Begin，返回的 Tx 会绑定到单个连接。当调用事务 Tx 的 Commit 或 Rollback 后，该事务使用的连接会归还到 DB 的闲置连接池中。连接池的大小可以用 SetMaxIdleConns 方法控制。 由于 DB 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可。所以，经常见到的示例代码： db, err := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\") if err != nil { panic(err) } defer db.Close() 实际中，defer db.Close() 可以不调用，官方文档关于 DB.Close 的说明也提到了：Close 用于关闭数据库，释放任何打开的资源。一般不会关闭 DB，因为 DB 句柄通常被多个 goroutine 共享，并长期活跃。当然，如果你确定 DB 只会被使用一次，之后不会使用了，应该调用 Close。 所以，实际的 Go 程序，应该在一个 go 文件中的 init 函数中调用 sql.Open 初始化全局的 sql.DB 对象，供程序中所有需要进行数据库操作的地方使用。 前面说过，sql.DB 并不是实际的数据库连接，因此，sql.Open 函数并没有进行数据库连接，只有在驱动未注册时才会返回 err != nil。 例如：db, err := sql.Open(\"mysql\", \"root:@tcp23(localhost233:3306)/test?charset=utf8\")。虽然这里的 dsn 是错误的，但依然 err == nil，只有在实际操作数据库（查询、更新等）或调用 Ping 时才会报错。 关于 Open 函数的参数，第一个是驱动名，为了避免混淆，一般和驱动包名一致，在驱动实现中，会有类似这样的代码： func init() { sql.Register(\"mysql\", \u0026MySQLDriver{}) } 其中 mysql 即是注册的驱动名。由于注册驱动是在 init 函数中进行的，这也就是为什么采用 _ \"github.com/go-sql-driver/mysql\" 这种方式引入驱动包。第二个参数是 DSN（数据源名称），这个是和具体驱动相关的，database/sql 包并没有规定，具体书写方式参见驱动文档。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:112:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"7.1.2.1 连接池的工作原理 获取 DB 对象后，连接池是空的，第一个连接在需要的时候才会创建。可以通过下面的代码验证这一点： db, _ := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\") fmt.Println(\"please exec show processlist\") time.Sleep(10 * time.Second) fmt.Println(\"please exec show processlist again\") db.Ping() time.Sleep(10 * time.Second) 在 Ping 执行之前和之后，show processlist 多了一条记录，即多了一个连接，Command 列是 Sleep。 连接池的工作方式：当调用一个函数，需要访问数据库时，该函数会请求从连接池中获取一个连接，如果连接池中存在一个空闲连接，它会将该空闲连接给该函数；否则，会打开一个新的连接。当该函数结束时，该连接要么返回给连接池，要么传递给某个需要该连接的对象，知道该对象完成时，连接才会返回给连接池。相关方法的处理说明（假设 sql.DB 的对象是 db）： db.Ping() 会将连接立马返回给连接池。 db.Exec() 会将连接立马返回给连接池，但是它返回的 Result 对象会引用该连接，所以，之后可能会再次被使用。 db.Query() 会传递连接给 sql.Rows 对象，直到完全遍历了所有的行或 Rows 的 Close 方法被调用了，连接才会返回给连接池。 db.QueryRow() 会传递连接给 sql.Row 对象，当该对象的 Scan 方法被调用时，连接会返回给连接池。 db.Begin() 会传递连接给 sql.Tx 对象，当该对象的 Commit 或 Rollback 方法被调用时，该链接会返回给连接池。 从上面的解释可以知道，大部分时候，我们不需要关心连接不释放问题，它们会自动返回给连接池，只有 Query 方法有点特殊，后面讲解如何处理。 注意：如果某个连接有问题（broken connection)，database/sql 内部会进行最多 2 次 的重试，从连接池中获取或新开一个连接来服务，因此，你的代码中不需要重试的逻辑。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:112:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"7.1.2.2 控制连接池 Go1.2.1 之前，没法控制连接池，Go1.2.1 之后，提供了两个方法来控制连接池（Go1.2 提供了控制，不过有 bug）。 db.SetMaxOpenConns(n int) 设置连接池中最多保存打开多少个数据库连接。注意，它包括在使用的和空闲的。如果某个方法调用需要一个连接，但连接池中没有空闲的可用，且打开的连接数达到了该方法设置的最大值，该方法调用将堵塞。默认限制是 0，表示最大打开数没有限制。 db.SetMaxIdleConns(n int) 设置连接池中能够保持的最大空闲连接的数量。默认值是 2 上面的两个设置，可以用程序实际测试。比如通过下面的代码，可以验证 MaxIdleConns 是 2： db, _ := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\") // 去掉注释，可以看看相应的空闲连接是不是变化了 // db.SetMaxIdleConns(3) for i := 0; i \u003c 10; i++ { go func() { db.Ping() }() } time.Sleep(20 * time.Second) 通过 show processlist 命令，可以看到有两个是 Sleep 的连接。 7.2 encoding/csv — 逗号分隔值文件 对 CSV 大家应该不陌生。因为它可以通过 Excel 打开（虽然 CSV 是纯文本格式），而且解析简单方便，因此，很多时候，我们做导出功能时，都会选择导出 CSV 格式。当然，导入我们也会期望使用 CSV 格式，这时往往会提供模板下载，让用户通过修改这个模板数据，然后导入。而这个模板往往也会采用 CSV 格式。通常，数据库数据导出也支持 CSV 格式。 关于 CSV 的解释： CSV，即逗号分隔值（Comma-Separated Values，CSV），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV 文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。 Go 语言标准库支持对 CSV 格式的读写。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:112:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"7.2.1 简述 csv 包用于读取和写入逗号分隔值（CSV）文件。CSV 文件类型有很多种，该包支持 RFC 4180 中描述的格式。 一个 csv 文件包含每个记录一到多个字段的零到多个记录。每条记录由换行符分隔。最后一条记录可以选择是否由换行符结束。 field1,field2,field3 空白视为字段的一部分。 第八章 数据压缩与归档 在计算机算法中，经常会有以空间换时间的做法；而无损压缩算法以压缩或解压缩数据花费的时间来换取存储空间。除此之外，压缩还有另外一个重要用途，那就是减少网络传输的数据量，进而减少网络传输的时间。 Go 标准库实现了一些最流行的压缩标准。zlib 和 gzip 提供了 GNU zip 库，bzip2 用于读写 bzip2 格式。这些格式都可以处理数据流而不考虑输入格式，并且提供了接口可以透明地读写压缩文件。除此之外，标准库还提供了 DEFLATE 压缩算法的实现，gzip 和 zlib 可以读取基于 DEFLATE 的文件格式。 标准库提供了 LZW 压缩算法（串表压缩算法）的实现，该算法常用的文件格式：GIF 和 PDF。另外，TIFF 文件格式使用和该算法类似，但和目前 LZW 算法版本不兼容。 标准库还提供一些包管理归档 (archive) 格式，将多个文件合并到一个文件，从而将其作为一个单元管理。archive/tar 读写 UNIX 磁带归档格式，这是一种老标准，但由于其灵活性，当前仍得到广泛使用。archive/zip 根据 zip 格式来处理归档，这种格式因 PC 程序 PKZIP 得以普及，原先在 MS-DOS 和 Windows 下使用，不过由于其 API 的简单性以及这种格式的可移植性，现在也用于其他平台。 flate - DEFLATE 压缩算法 DEFLATE 是同时使用了哈夫曼编码（Huffman Coding）与 LZ77 算法的一个无损数据压缩算法，是一种压缩数据流的算法。任何需要流式压缩的地方都可以用。目前 zip 压缩文件默认使用的就是该算法。 关于算法的原理，以及 哈夫曼编码（Huffman Coding）与 LZ77 算法，感兴趣的读者可以查询相关资料，这里推荐 GZIP 压缩原理分析——第五章 Deflate 算法详解 序列文章。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:113:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"使用预设字典提升压缩率 8.1 archive/tar — tar 档案读写 熟悉 Linux 的朋友，对于 tar 格式的文件应该不会陌生。 第九章 测试 Go 语言从开发初期就注意了测试用例的编写。特别是静态语言，由于调试没有动态语言那么方便，所以能最快最方便地编写一个测试用例就显得非常重要了。 本章内容涵盖了 Go 标准库中的 2 个包： testing 方便进行 Go 包的自动化单元测试、基准测试 net/http/httptest 提供测试 HTTP 的工具 testing - 单元测试 testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数： func TestXxx(*testing.T)\r注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。 在这些函数中，使用 Error、Fail 或相关方法来发出失败信号。 要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 go test 命令时将被包含。 有关详细信息，请运行 go help test 和 go help testflag 了解。 如果有需要，可以调用 *T 和 *B 的 Skip 方法，跳过该测试或基准测试： func TestTimeConsuming(t *testing.T) { if testing.Short() { t.Skip(\"skipping test in short mode.\") } ... } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:114:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"第一个单元测试 要测试的代码： func Fib(n int) int { if n \u003c 2 { return n } return Fib(n-1) + Fib(n-2) } 测试代码： func TestFib(t *testing.T) { var ( in = 7 expected = 13 ) actual := Fib(in) if actual != expected { t.Errorf(\"Fib(%d) = %d; expected %d\", in, actual, expected) } } 执行 go test .，输出： $ go test . ok chapter09/testing 0.007s 表示测试通过。 我们将 Sum 函数改为： func Fib(n int) int { if n \u003c 2 { return n } return Fib(n-1) + Fib(n-1) } 再执行 go test .，输出： $ go test . --- FAIL: TestSum (0.00s) t_test.go:16: Fib(10) = 64; expected 13 FAIL FAIL chapter09/testing 0.009s ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:115:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Table-Driven Test 测试讲究 case 覆盖，按上面的方式，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。 func TestFib(t *testing.T) { var fibTests = []struct { in int // input expected int // expected result }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.in) if actual != tt.expected { t.Errorf(\"Fib(%d) = %d; expected %d\", tt.in, actual, tt.expected) } } } 由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:116:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"T 类型 单元测试中，传递给测试函数的参数是 *testing.T 类型。它用于管理测试状态并支持格式化测试日志。测试日志会在执行测试的过程中不断累积，并在测试完成时转储至标准输出。 当测试函数返回时，或者当测试函数调用 FailNow、 Fatal、Fatalf、SkipNow、Skip、Skipf 中的任意一个时，则宣告该测试函数结束。跟 Parallel 方法一样，以上提到的这些方法只能在运行测试函数的 goroutine 中调用。 至于其他报告方法，比如 Log 以及 Error 的变种， 则可以在多个 goroutine 中同时进行调用。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:117:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"报告方法 上面提到的系列包括方法，带 f 的是格式化的，格式化语法参考 fmt 包。 T 类型内嵌了 common 类型，common 提供这一系列方法，我们经常会用到的（注意，这里说的测试中断，都是指当前测试函数）： 1）当我们遇到一个断言错误的时候，标识这个测试失败，会使用到： Fail : 测试失败，测试继续，也就是之后的代码依然会执行\rFailNow : 测试失败，测试中断\r在 FailNow 方法实现的内部，是通过调用 runtime.Goexit() 来中断测试的。 2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标识测试失败，会使用到： SkipNow : 跳过测试，测试中断\r在 SkipNow 方法实现的内部，是通过调用 runtime.Goexit() 来中断测试的。 3）当我们只希望打印信息，会用到 : Log : 输出信息\rLogf : 输出格式化的信息\r注意：默认情况下，单元测试成功时，它们打印的信息不会输出，可以通过加上 -v 选项，输出这些信息。但对于基准测试，它们总是会被输出。 4）当我们希望跳过这个测试，并且打印出信息，会用到： Skip : 相当于 Log + SkipNow\rSkipf : 相当于 Logf + SkipNow\r5）当我们希望断言失败的时候，标识测试失败，并打印出必要的信息，但是测试继续，会用到： Error : 相当于 Log + Fail\rErrorf : 相当于 Logf + Fail\r6）当我们希望断言失败的时候，标识测试失败，打印出必要的信息，但中断测试，会用到： Fatal : 相当于 Log + FailNow\rFatalf : 相当于 Logf + FailNow\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:117:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Parallel 测试 包中的 Parallel 方法表示当前测试只会与其他带有 Parallel 方法的测试并行进行测试。 下面例子将演示 Parallel 的使用方法： var ( data = make(map[string]string) locker sync.RWMutex ) func WriteToMap(k, v string) { locker.Lock() defer locker.Unlock() data[k] = v } func ReadFromMap(k string) string { locker.RLock() defer locker.RUnlock() return data[k] } 测试代码： var pairs = []struct { k string v string }{ {\"polaris\", \" 徐新华 \"}, {\"studygolang\", \"Go 语言中文网 \"}, {\"stdlib\", \"Go 语言标准库 \"}, {\"polaris1\", \" 徐新华 1\"}, {\"studygolang1\", \"Go 语言中文网 1\"}, {\"stdlib1\", \"Go 语言标准库 1\"}, {\"polaris2\", \" 徐新华 2\"}, {\"studygolang2\", \"Go 语言中文网 2\"}, {\"stdlib2\", \"Go 语言标准库 2\"}, {\"polaris3\", \" 徐新华 3\"}, {\"studygolang3\", \"Go 语言中文网 3\"}, {\"stdlib3\", \"Go 语言标准库 3\"}, {\"polaris4\", \" 徐新华 4\"}, {\"studygolang4\", \"Go 语言中文网 4\"}, {\"stdlib4\", \"Go 语言标准库 4\"}, } // 注意 TestWriteToMap 需要在 TestReadFromMap 之前 func TestWriteToMap(t *testing.T) { t.Parallel() for _, tt := range pairs { WriteToMap(tt.k, tt.v) } } func TestReadFromMap(t *testing.T) { t.Parallel() for _, tt := range pairs { actual := ReadFromMap(tt.k) if actual != tt.v { t.Errorf(\"the value of key(%s) is %s, expected: %s\", tt.k, actual, tt.v) } } } 试验步骤： 注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，同时注释掉测试代码中的 t.Parallel，执行测试，测试通过，即使加上 -race，测试依然通过； 只注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败（如果未失败，加上 -race 一定会失败）； 如果代码能够进行并行测试，在写测试时，尽量加上 Parallel，这样可以测试出一些可能的问题。 关于 Parallel 的更多内容，会在 子测试 中介绍。 当你写完一个函数，结构体，main 之后，你下一步需要的就是测试了。testing 包提供了很简单易用的测试包。 写一个基本的测试用例 测试文件的文件名需要以_test.go 为结尾，测试用例需要以 TestXxxx 的形式存在。 比如我要测试 utils 包的 sql.go 中的函数： func GetOne(db *sql.DB, query string, args ...interface{}) (map[string][]byte, error) {\r就需要创建一个 sql_test.go package utils import ( \"database/sql\" _ \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"strconv\" \"testing\" ) func Test_GetOne(t *testing.T) { db, err := sql.Open(\"mysql\", \"root:123.abc@tcp(192.168.33.10:3306)/test\") defer func() { db.Close() }() if err != nil { t.Fatal(err) } // 测试 empty car_brand, err := GetOne(db, \"select * from user where id = 999999\") if (car_brand != nil) || (err != nil) { t.Fatal(\"emtpy 测试错误 \") } } testing 的测试用例形式 测试用例有四种形式： TestXxxx(t *testing.T) // 基本测试用例\rBenchmarkXxxx(b *testing.B) // 压力测试的测试用例\rExample_Xxx() // 测试控制台输出的例子\rTestMain(m *testing.M) // 测试 Main 函数\r给个 Example 的例子 :（Example 需要在最后用注释的方式确认控制台输出和预期是不是一致的） func Example_GetScore() { score := getScore(100, 100, 100, 2.1) fmt.Println(score) // Output: // 31.1 } testing 的变量 gotest 的变量有这些： test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试 test.outputdir : 输出目录 test.coverprofile : 测试覆盖率参数，指定输出文件 test.run : 指定正则来运行某个 / 某些测试用例 test.memprofile : 内存分析参数，指定输出文件 test.memprofilerate : 内存分析参数，内存分析的抽样率 test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析 test.blockprofile : 阻塞事件的分析参数，指定输出文件 test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率 test.timeout : 超时时间 test.cpu : 指定 cpu 数量 test.parallel : 指定运行测试用例的并行数 testing 的结构体 B : 压力测试 BenchmarkResult : 压力测试结果 Cover : 代码覆盖率相关结构体 CoverBlock : 代码覆盖率相关结构体 InternalBenchmark : 内部使用的结构体 InternalExample : 内部使用的结构体 InternalTest : 内部使用的结构体 M : main 测试使用的结构体 PB : Parallel benchmarks 并行测试使用的结构体 T : 普通测试用例 TB : 测试用例的接口 testing 的通用方法 T 结构内部是继承自 common 结构，common 结构提供集中方法，是我们经常会用到的： 1）当我们遇到一个断言错误的时候，我们就会判断这个测试用例失败，就会使用到： Fail : case 失败，测试用例继续\rFailedNow : case 失败，测试用例中断\r2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标示测试用例失败，会使用到： SkipNow : case 跳过，测试用例不继续\r3）当我们只希望在一个地方打印出信息，我们会用到 : Log : 输出信息\rLogf : 输出有 format 的信息\r4）当我们希望跳过这个用例，并且打印出信息 : Skip : Log + SkipNow\rSkipf : Logf + SkipNow\r5）当我们希望断言失败的时候，测试用例失败，打印出必要的信息，但是测试用例继续： Error : Log + Fail\rErrorf : Logf + Fail\r6）当我们希望断言失败的时候，测试用例失败，打印出必要的信息，测试用例中断： Fatal : Log + FailNow\rFatalf : Logf + FailNow\r扩展阅读 GO 中如何进行单元测试 GoDoc - testing testing/testing.go 源代码 testing - 基准测试 在 _test.go 结尾的测试文件中，如下形式的函数： func BenchmarkXxx(*testing.B)\r被认为是基准测试，通过 go test 命令，加上 -bench 标志来执行。多个基准测试按照顺序运行。 基准测试函数的形式如下： func BenchmarkHello(b *testing.B) { for i := 0; i \u003c b.N; i++ { fmt.Sprintf(\"hello\") } } 基准函数会运行目标代码 b.N 次。在基准执行期间，程序会自动调整 b.N 直到基准测试函数持续足够长的时间。输出结果形如： BenchmarkHello 10000000 282 ns/op\r意味着循环执行了 10000000 次，每次循环花费 282 纳秒 (ns)。","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:117:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"基准测试示例 接着上一节的例子，我们对 Fib 进行基准测试： func BenchmarkFib10(b *testing.B) { for n := 0; n \u003c b.N; n++ { Fib(10) } } 执行 go test -bench=.，输出： $ go test -bench=. BenchmarkFib10-4 3000000 424 ns/op PASS ok chapter09/testing 1.724s 这里测试了 Fib(10) 的情况，我们可能需要测试更多不同的情况，这时可以改写我们的测试代码： func BenchmarkFib1(b *testing.B) { benchmarkFib(1, b) } func BenchmarkFib2(b *testing.B) { benchmarkFib(2, b) } func BenchmarkFib3(b *testing.B) { benchmarkFib(3, b) } func BenchmarkFib10(b *testing.B) { benchmarkFib(10, b) } func BenchmarkFib20(b *testing.B) { benchmarkFib(20, b) } func BenchmarkFib40(b *testing.B) { benchmarkFib(40, b) } func benchmarkFib(i int, b *testing.B) { for n := 0; n \u003c b.N; n++ { Fib(i) } } 再次执行 go test -bench=.，输出： $ go test -bench=. BenchmarkFib1-4 1000000000 2.58 ns/op BenchmarkFib2-4 200000000 7.38 ns/op BenchmarkFib3-4 100000000 13.0 ns/op BenchmarkFib10-4 3000000 429 ns/op BenchmarkFib20-4 30000 54335 ns/op BenchmarkFib40-4 2 805759850 ns/op PASS ok chapter09/testing 15.361s 默认情况下，每个基准测试最少运行 1 秒。如果基准测试函数返回时，还不到 1 秒钟，b.N 的值会按照序列 1,2,5,10,20,50,… 增加，同时再次运行基准测测试函数。 我们注意到 BenchmarkFib40 一共才运行 2 次。为了更精确的结果，我们可以通过 -benchtime 标志指定运行时间，从而使它运行更多次。 $ go test -bench=Fib40 -benchtime=20s BenchmarkFib40-4 30 838675800 ns/op ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:118:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"B 类型 B 是传递给基准测试函数的一种类型，它用于管理基准测试的计时行为，并指示应该迭代地运行测试多少次。 当基准测试函数返回时，或者当基准测试函数调用 FailNow、Fatal、Fatalf、SkipNow、Skip、Skipf 中的任意一个方法时，则宣告测试函数结束。至于其他报告方法，比如 Log 和 Error 的变种，则可以在其他 goroutine 中同时进行调用。 跟单元测试一样，基准测试会在执行的过程中积累日志，并在测试完毕时将日志转储到标准错误。但跟单元测试不一样的是，为了避免基准测试的结果受到日志打印操作的影响，基准测试总是会把日志打印出来。 B 类型中的报告方法使用方式和 T 类型是一样的，一般来说，基准测试中也不需要使用，毕竟主要是测性能。这里我们对 B 类型中其他的一些方法进行讲解。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:119:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"计时方法 有三个方法用于计时： StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，我们也可以在调用 StopTimer 之后恢复计时； StopTimer：停止对测试进行计时。当你需要执行一些复杂的初始化操作，并且你不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时； ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，这个方法不会产生任何效果。本节开头有使用示例。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:119:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"并行执行 通过 RunParallel 方法能够并行地执行给定的基准测试。RunParallel 会创建出多个 goroutine，并将 b.N 分配给这些 goroutine 执行，其中 goroutine 数量的默认值为 GOMAXPROCS。用户如果想要增加非 CPU 受限（non-CPU-bound）基准测试的并行性，那么可以在 RunParallel 之前调用 SetParallelism（如 SetParallelism(2)，则 goroutine 数量为 2*GOMAXPROCS）。RunParallel 通常会与 -cpu 标志一同使用。 body 函数将在每个 goroutine 中执行，这个函数需要设置所有 goroutine 本地的状态，并迭代直到 pb.Next 返回 false 值为止。因为 StartTimer、StopTime 和 ResetTimer 这三个方法都带有全局作用，所以 body 函数不应该调用这些方法； 除此之外，body 函数也不应该调用 Run 方法。 具体的使用示例，在本节开头已经提供！ ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:119:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"内存统计 ReportAllocs 方法用于打开当前基准测试的内存统计功能， 与 go test 使用 -benchmem 标志类似，但 ReportAllocs 只影响那些调用了该函数的基准测试。 测试示例： func BenchmarkTmplExucte(b *testing.B) { b.ReportAllocs() templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\")) b.RunParallel(func(pb *testing.PB) { // Each goroutine has its own bytes.Buffer. var buf bytes.Buffer for pb.Next() { // The loop body is executed b.N times total across all goroutines. buf.Reset() templ.Execute(\u0026buf, \"World\") } }) } 测试结果类似这样： BenchmarkTmplExucte-4 2000000 898 ns/op 368 B/op 9 allocs/op\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:119:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"基准测试结果 对上述结果中的每一项，你是否都清楚是什么意思呢？ 2000000 ：基准测试的迭代总次数 b.N 898 ns/op：平均每次迭代所消耗的纳秒数 368 B/op：平均每次迭代内存所分配的字节数 9 allocs/op：平均每次迭代的内存分配次数 testing 包中的 BenchmarkResult 类型能为你提供帮助，它保存了基准测试的结果，定义如下： type BenchmarkResult struct { N int // The number of iterations. 基准测试的迭代总次数，即 b.N T time.Duration // The total time taken. 基准测试的总耗时 Bytes int64 // Bytes processed in one iteration. 一次迭代处理的字节数，通过 b.SetBytes 设置 MemAllocs uint64 // The total number of memory allocations. 内存分配的总次数 MemBytes uint64 // The total number of bytes allocated. 内存分配的总字节数 } 该类型还提供了每次迭代操作所消耗资源的计算方法，示例如下： package main import ( \"bytes\" \"fmt\" \"testing\" \"text/template\" ) func main() { benchmarkResult := testing.Benchmark(func(b *testing.B) { templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\")) // RunParallel will create GOMAXPROCS goroutines // and distribute work among them. b.RunParallel(func(pb *testing.PB) { // Each goroutine has its own bytes.Buffer. var buf bytes.Buffer for pb.Next() { // The loop body is executed b.N times total across all goroutines. buf.Reset() templ.Execute(\u0026buf, \"World\") } }) }) // fmt.Printf(\"%8d\\t%10d ns/op\\t%10d B/op\\t%10d allocs/op\\n\", benchmarkResult.N, benchmarkResult.NsPerOp(), benchmarkResult.AllocedBytesPerOp(), benchmarkResult.AllocsPerOp()) fmt.Printf(\"%s\\t%s\\n\", benchmarkResult.String(), benchmarkResult.MemString()) } testing - 子测试与子基准测试 从 Go 1.7 开始，引入了一个新特性：子测试（subtests）与子基准测试（sub-benchmarks），它意味着您现在可以拥有嵌套测试，这对于过滤执行特定测试用例非常有用。 T 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 setup 和 tear-down 代码的方法： func TestFoo(t *testing.T) { // \u003csetup code\u003e t.Run(\"A=1\", func(t *testing.T) { ... }) t.Run(\"A=2\", func(t *testing.T) { ... }) t.Run(\"B=1\", func(t *testing.T) { ... }) // \u003ctear-down code\u003e } 每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 Run 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。 命令行标志 -run 和 -bench 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。因为参数是非固定的，一个空的表达式匹配任何字符串，所以下述例子中的 “匹配” 意味着 “顶层/子测试名称包含有”： go test -run '' # 执行所有测试。 go test -run Foo # 执行匹配 \"Foo\" 的顶层测试，例如 \"TestFooBar\"。 go test -run Foo/A= # 对于匹配 \"Foo\" 的顶层测试，执行其匹配 \"A=\" 的子测试。 go test -run /A=1 # 执行所有匹配 \"A=1\" 的子测试。 子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试： func TestGroupedParallel(t *testing.T) { for _, tc := range tests { tc := tc // capture range variable t.Run(tc.Name, func(t *testing.T) { t.Parallel() ... }) } } 在所有子测试并行运行完毕之前，Run 方法不会返回。下述例子提供了一种方法，用于在子测试并行运行完毕后清理资源： func TestTeardownParallel(t *testing.T) { // This Run will not return until the parallel tests finish. t.Run(\"group\", func(t *testing.T) { t.Run(\"Test1\", parallelTest1) t.Run(\"Test2\", parallelTest2) t.Run(\"Test3\", parallelTest3) }) // \u003ctear-down code\u003e } testing - 运行并验证示例 testing 包除了测试，还提供了运行并验证示例的功能。示例，一方面是文档的效果，是关于某个功能的使用例子；另一方面，可以被当做测试运行。 一个示例的例子如下： func ExampleHello() { fmt.Println(\"Hello\") // Output: Hello } 如果 Output: Hello 改为：Output: hello，运行测试会失败，提示： got: Hello want: hello 一个示例函数以 Example 开头，如果示例函数包含以 “Output:” 开头的行注释，在运行测试时，go 会将示例函数的输出和 “Output:” 注释中的值做比较，就如上面的例子。 有时候，输出顺序可能不确定，比如循环输出 map 的值，那么可以使用 “Unordered output:” 开头的注释。 如果示例函数没有上述输出注释，该示例函数只会被编译而不会被运行。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:119:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"命名约定 Go 语言通过大量的命名约定来简化工具的复杂度，规范代码的风格。对示例函数的命名有如下约定： 包级别的示例函数，直接命名为 func Example() { ... } 函数 F 的示例，命名为 func ExampleF() { ... } 类型 T 的示例，命名为 func ExampleT() { ... } 类型 T 上的 方法 M 的示例，命名为 func ExampleT_M() { ... } 有时，我们想要给 包 / 类型 / 函数 / 方法 提供多个示例，可以通过在示例函数名称后附加一个不同的后缀来实现，但这种后缀必须以小写字母开头，如： func Example_suffix() { ... } func ExampleF_suffix() { ... } func ExampleT_suffix() { ... } func ExampleT_M_suffix() { ... } 通常，示例代码会放在单独的示例文件中，命名为 example_test.go。可以查看 io 包中的 example_test.go 了解示例的编写。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:120:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实现原理 本节开头提到了示例的两个作用，它们分别是由 godoc 和 go test 这两个命令实现的。 在执行 go test 时，会运行示例。具体的实现原理，可以通过阅读 go test 命令源码和 testing 包中 example.go 文件了解。 testing - 其他功能 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:121:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"TestMain 在写测试时，有时需要在测试之前或之后进行额外的设置（setup）或拆卸（teardown）；有时，测试还需要控制在主线程上运行的代码。为了支持这些需求，testing 包提供了 TestMain 函数 : func TestMain(m *testing.M)\r如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。注意，在 TestMain 函数的最后，应该使用 m.Run 的返回值作为参数去调用 os.Exit。 另外，在调用 TestMain 时 , flag.Parse 并没有被调用。所以，如果 TestMain 依赖于 command-line 标志（包括 testing 包的标志），则应该显式地调用 flag.Parse。注意，这里的依赖是指，若 TestMain 函数内需要用到 command-line 标志，则必须显式地调用 flag.Parse，否则不需要，因为 m.Run 中调用 flag.Parse。 一个包含 TestMain 的例子如下： package mytestmain import ( \"flag\" \"fmt\" \"os\" \"testing\" ) var db struct { Dns string } func TestMain(m *testing.M) { db.Dns = os.Getenv(\"DATABASE_DNS\") if db.Dns == \"\" { db.Dns = \"root:123456@tcp(localhost:3306)/?charset=utf8\u0026parseTime=True\u0026loc=Local\" } flag.Parse() exitCode := m.Run() db.Dns = \"\" // 退出 os.Exit(exitCode) } func TestDatabase(t *testing.T) { fmt.Println(db.Dns) } 对 m.Run 感兴趣的可以阅读源码，了解其原理。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:122:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Test Coverage 测试覆盖率，这里讨论的是基于代码的测试覆盖率。 Go 从 1.2 开始，引入了对测试覆盖率的支持，使用的是与 cover 相关的工具（go test -cover、go tool cover）。虽然 testing 包提供了 cover 相关函数，不过它们是给 cover 的工具使用的。 关于测试覆盖率的更多信息，可以参考官方的博文：The cover story httptest - HTTP 测试辅助工具 由于 Go 标准库的强大支持，Go 可以很容易的进行 Web 开发。为此，Go 标准库专门提供了 net/http/httptest 包专门用于进行 http Web 开发测试。 本节我们通过一个社区帖子的增删改查的例子来学习该包。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:123:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"简单的 Web 应用 我们首先构建一个简单的 Web 应用。 为了简单起见，数据保存在内存，并且没有考虑并发问题。 // 保存 Topic，没有考虑并发问题 var TopicCache = make([]*Topic, 0, 16) type Topic struct { Id int `json:\"id\"` Title string `json:\"title\"` Content string `json:\"content\"` CreatedAt time.Time `json:\"created_at\"` } 对于 Topic 的增删改查代码很简单，可以查看完整代码。 接下来，是通过 net/http 包来实现一个 Web 应用。 func main() { http.HandleFunc(\"/topic/\", handleRequest) http.ListenAndServe(\":2017\", nil) } ... /topic/ 开头的请求都交由 handleRequest 处理，它根据不同的 Method 执行相应的增删改查，详细代码可以查看 server.go。 准备好 Web 应用后，我们启动它。 go run server.go data.go 通过 curl 进行简单的测试： 增：curl -i -X POST http://localhost:2017/topic/ -H ‘content-type: application/json’ -d ‘{“title”:“The Go Standard Library”,“content”:“It contains many packages.”}’ 查：curl -i -X GET http://localhost:2017/topic/1 改：curl -i -X PUT http://localhost:2017/topic/1 -H ‘content-type: application/json’ -d ‘{“title”:“The Go Standard Library By Example”,“content”:“It contains many packages, enjoying it.”}’ 删：curl -i -X DELETE http://localhost:2017/topic/1 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:124:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"通过 httptest 进行测试 上面，我们通过 curl 对我们的 Web 应用的接口进行了测试。现在，我们通过 net/http/httptest 包进行测试。 我们先测试创建帖子，也就是测试 handlePost 函数。 func TestHandlePost(t *testing.T) { mux := http.NewServeMux() mux.HandleFunc(\"/topic/\", handleRequest) reader := strings.NewReader(`{\"title\":\"The Go Standard Library\",\"content\":\"It contains many packages.\"}`) r, _ := http.NewRequest(http.MethodPost, \"/topic/\", reader) w := httptest.NewRecorder() mux.ServeHTTP(w, r) resp := w.Result() if resp.StatusCode != http.StatusOK { t.Errorf(\"Response code is %v\", resp.StatusCode) } } 首先跟待测试代码一样，配置上路由，对 /topic/ 的请求都交由 handleRequest 处理。 mux := http.NewServeMux() mux.HandleFunc(\"/topic/\", handleRequest) 因为 handlePost 的函数签名是 func handlePost(w http.ResponseWriter, r *http.Request) error，为了测试它，我们必须创建 http.ResponseWriter 和 http.Request 的实例。 接下来的代码就是创建一个 http.Request 实例 和一个 http.ResponseWriter 的实例。这里的关键是，通过 httptest.NewRecorder() 可以获得 httptest.ResponseRecorder 结构，而此结构实现了http.ResponseWriter 接口。 reader := strings.NewReader(`{\"title\":\"The Go Standard Library\",\"content\":\"It contains many packages.\"}`) r, _ := http.NewRequest(http.MethodPost, \"/topic/\", reader) w := httptest.NewRecorder() 准备好之后，可以测试目标函数了。这里，我们没有直接调用 handlePost(w, r)，而是调用 mux.ServeHTTP(w, r)，实际上这里直接调用 handlePost(w, r) 也是可以的，但调用 mux.ServeHTTP(w, r) 会更完整地测试整个流程。mux.ServeHTTP(w, r) 最终也会调用到 handlePost(w, r)。 最后，通过 go test -v 运行测试。 查、改和删帖子的接口测试代码类似，比如，handleGet 的测试代码如下： func TestHandleGet(t *testing.T) { mux := http.NewServeMux() mux.HandleFunc(\"/topic/\", handleRequest) r, _ := http.NewRequest(http.MethodGet, \"/topic/1\", nil) w := httptest.NewRecorder() mux.ServeHTTP(w, r) resp := w.Result() if resp.StatusCode != http.StatusOK { t.Errorf(\"Response code is %v\", resp.StatusCode) } topic := new(Topic) json.Unmarshal(w.Body.Bytes(), topic) if topic.Id != 1 { t.Errorf(\"Cannot get topic\") } } 注意：因为数据没有落地存储，为了保证后面的测试正常，请将 TestHandlePost 放在最前面。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:125:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"测试代码改进 细心的朋友应该会发现，上面的测试代码有重复，比如： mux := http.NewServeMux() mux.HandleFunc(\"/topic/\", handleRequest) 以及： w := httptest.NewRecorder() 这正好是前面学习的 setup 可以做的事情，因此可以使用 TestMain 来做重构。 var w *httptest.ResponseRecorder func TestMain(m *testing.M) { http.DefaultServeMux.HandleFunc(\"/topic/\", handleRequest) w = httptest.NewRecorder() os.Exit(m.Run()) } 总结 除了标准库提供的测试包，还有很多优秀的第三方测试包，比如 testify 可有助于 testing 进行单元测试，进行 mock 等，有机会会写文章介绍它的使用；再比如，ginkgo 有助于集成测试等等。 参考阅读：Testing Go at Stream 第十章 进程、线程和 goroutine 本章将研究 Go 语言进程、线程和 goroutine，会涉及到操作系统关于进程、线程的知识，同时研究 Go 语言提供的相关标准库 API；goroutine 作为 Go 的一个核心特性，本章会重点介绍。 虽然标准库中能操作进程、线程和 goroutine 的 API 不多，但它们是深入学习、理解 Go 语言必须掌握的知识。本章从操作系统和 Go 源码层面深入探讨它们。 10.1 创建进程 os 包及其子包 os/exec 提供了创建进程的方法。 一般的，应该优先使用 os/exec 包。因为 os/exec 包依赖 os 包中关键创建进程的 API，为了便于理解，我们先探讨 os 包中和进程相关的部分。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:126:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"进程的创建 在 Unix 中，创建一个进程，通过系统调用 fork 实现（及其一些变种，如 vfork、clone）。在 Go 语言中，Linux 下创建进程使用的系统调用是 clone。 很多时候，系统调用 fork、execve、wait 和 exit 会在一起出现。此处先简要介绍这 4 个系统调用及其典型用法。 fork：允许一进程（父进程）创建一新进程（子进程）。具体做法是，新的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段的拷贝。可将此视为把父进程一分为二。 exit(status)：终止一进程，将进程占用的所有资源（内存、文件描述符等）归还内核，交其进行再次分配。参数 status 为一整型变量，表示进程的退出状态。父进程可使用系统调用 wait() 来获取该状态。 wait(\u0026status) 目的有二：其一，如果子进程尚未调用 exit() 终止，那么 wait 会挂起父进程直至子进程终止；其二，子进程的终止状态通过 wait 的 status 参数返回。 execve(pathname, argv, envp) 加载一个新程序（路径名为 pathname，参数列表为 argv，环境变量列表为 envp）到当前进程的内存。这将丢弃现存的程序文本段，并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行一个新程序。 在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，提供了 syscall.ForkExec。如果想只调用 fork，得自己通过 syscall.Syscall(syscall.SYS_FORK, 0, 0, 0) 实现。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:127:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Process 及其相关方法 os.Process 存储了通过 StartProcess 创建的进程的相关信息。 type Process struct { Pid int handle uintptr // handle is accessed atomically on Windows isdone uint32 // process has been successfully waited on, non zero if true } 一般通过 StartProcess 创建 Process 的实例，函数声明如下： func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) 它使用提供的程序名、命令行参数、属性开始一个新进程。StartProcess 是一个低级别的接口。os/exec 包提供了高级别的接口，一般应该尽量使用 os/exec 包。如果出错，错误的类型会是 *PathError。 其中的参数 attr，类型是 ProcAttr 的指针，用于为 StartProcess 创建新进程提供一些属性。定义如下： type ProcAttr struct { // 如果 Dir 非空，子进程会在创建 Process 实例前先进入该目录。（即设为子进程的当前工作目录） Dir string // 如果 Env 非空，它会作为新进程的环境变量。必须采用 Environ 返回值的格式。 // 如果 Env 为 nil，将使用 Environ 函数的返回值。 Env []string // Files 指定被新进程继承的打开文件对象。 // 前三个绑定为标准输入、标准输出、标准错误输出。 // 依赖底层操作系统的实现可能会支持额外的文件对象。 // nil 相当于在进程开始时关闭的文件对象。 Files []*File // 操作系统特定的创建属性。 // 注意设置本字段意味着你的程序可能会执行异常甚至在某些操作系统中无法通过编译。这时候可以通过为特定系统设置。 // 看 syscall.SysProcAttr 的定义，可以知道用于控制进程的相关属性。 Sys *syscall.SysProcAttr } FindProcess 可以通过 pid 查找一个运行中的进程。该函数返回的 Process 对象可以用于获取关于底层操作系统进程的信息。在 Unix 系统中，此函数总是成功，即使 pid 对应的进程不存在。 func FindProcess(pid int) (*Process, error) Process 提供了四个方法：Kill、Signal、Wait 和 Release。其中 Kill 和 Signal 跟信号相关，而 Kill 实际上就是调用 Signal，发送了 SIGKILL 信号，强制进程退出，关于信号，后续章节会专门讲解。 Release 方法用于释放 Process 对象相关的资源，以便将来可以被再使用。该方法只有在确定没有调用 Wait 时才需要调用。Unix 中，该方法的内部实现只是将 Process 的 pid 置为 -1。 我们重点看看 Wait 方法。 func (p *Process) Wait() (*ProcessState, error) 在多进程应用程序的设计中，父进程需要知道某个子进程何时改变了状态 —— 子进程终止或因收到信号而停止。Wait 方法就是一种用于监控子进程的技术。 Wait 方法阻塞直到进程退出，然后返回一个 ProcessState 描述进程的状态和可能的错误。Wait 方法会释放绑定到 Process 的所有资源。在大多数操作系统中，Process 必须是当前进程的子进程，否则会返回错误。 看看 ProcessState 的内部结构： type ProcessState struct { pid int // The process's id. status syscall.WaitStatus // System-dependent status info. rusage *syscall.Rusage } ProcessState 保存了 Wait 函数报告的某个进程的信息。status 记录了状态原因，通过 syscal.WaitStatus 类型定义的方法可以判断： Exited()：是否正常退出，如调用 os.Exit； Signaled()：是否收到未处理信号而终止； CoreDump()：是否收到未处理信号而终止，同时生成 coredump 文件，如 SIGABRT； Stopped()：是否因信号而停止（SIGSTOP）； Continued()：是否因收到信号 SIGCONT 而恢复； syscal.WaitStatus 还提供了其他一些方法，比如获取退出状态、信号、停止信号和中断（Trap）原因。 因为 Linux 下 Wait 的内部实现使用的是 wait4 系统调用，因此，ProcessState 中包含了 rusage，用于统计进程的各类资源信息。一般情况下，syscall.Rusage 中定义的信息都用不到，如果实际中需要使用，可以查阅 Linux 系统调用 getrusage 获得相关说明 (getrusage(2))。 ProcessState 结构内部字段是私有的，我们可以通过它提供的方法来获得一些基本信息，比如：进程是否退出、Pid、进程是否是正常退出、进程 CPU 时间、用户时间等等。 实现类似 Linux 中 time 命令的功能： package main import ( \"fmt\" \"os\" \"os/exec\" \"path/filepath\" \"time\" ) func main() { if len(os.Args) \u003c 2 { fmt.Printf(\"Usage: %s [command]\\n\", os.Args[0]) os.Exit(1) } cmdName := os.Args[1] if filepath.Base(os.Args[1]) == os.Args[1] { if lp, err := exec.LookPath(os.Args[1]); err != nil { fmt.Println(\"look path error:\", err) os.Exit(1) } else { cmdName = lp } } procAttr := \u0026os.ProcAttr{ Files: []*os.File{os.Stdin, os.Stdout, os.Stderr}, } cwd, err := os.Getwd() if err != nil { fmt.Println(\"look path error:\", err) os.Exit(1) } start := time.Now() process, err := os.StartProcess(cmdName, []string{cwd}, procAttr) if err != nil { fmt.Println(\"start process error:\", err) os.Exit(2) } processState, err := process.Wait() if err != nil { fmt.Println(\"wait error:\", err) os.Exit(3) } fmt.Println() fmt.Println(\"real\", time.Now().Sub(start)) fmt.Println(\"user\", processState.UserTime()) fmt.Println(\"system\", processState.SystemTime()) } // go build main.go \u0026\u0026 ./main ls // Output: // // real 4.994739ms // user 1.177ms // system 2.279ms ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:127:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"运行外部命令 通过 os 包可以做到运行外部命令，如前面的例子。不过，Go 标准库为我们封装了更好用的包： os/exec，运行外部命令，应该优先使用它，它包装了 os.StartProcess 函数以便更容易的重定向标准输入和输出，使用管道连接 I/O，以及作其它的一些调整。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:128:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"查找可执行程序 exec.LookPath 函数在 PATH 指定目录中搜索可执行程序，如 file 中有 /，则只在当前目录搜索。该函数返回完整路径或相对于当前路径的一个相对路径。 func LookPath(file string) (string, error) 如果在 PATH 中没有找到可执行文件，则返回 exec.ErrNotFound。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:128:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Cmd 及其相关方法 Cmd 结构代表一个正在准备或者在执行中的外部命令，调用了 Run、Output 或 CombinedOutput 后，Cmd 实例不能被重用。 type Cmd struct { // Path 是将要执行的命令路径。 // 该字段不能为空（也是唯一一个不能为空的字段），如为相对路径会相对于 Dir 字段。 // 通过 Command 初始化时，会在需要时调用 LookPath 获得完整的路径。 Path string // Args 存放着命令的参数，第一个值是要执行的命令（Args[0])；如果为空切片或者 nil，使用 {Path} 运行。 // 一般情况下，Path 和 Args 都应被 Command 函数设定。 Args []string // Env 指定进程的环境变量，如为 nil，则使用当前进程的环境变量，即 os.Environ()，一般就是当前系统的环境变量。 Env []string // Dir 指定命令的工作目录。如为空字符串，会在调用者的进程当前工作目录下执行。 Dir string // Stdin 指定进程的标准输入，如为 nil，进程会从空设备读取（os.DevNull） // 如果 Stdin 是 *os.File 的实例，进程的标准输入会直接指向这个文件 // 否则，会在一个单独的 goroutine 中从 Stdin 中读数据，然后将数据通过管道传递到该命令中（也就是从 Stdin 读到数据后，写入管道，该命令可以从管道读到这个数据）。在 goroutine 停止数据拷贝之前（停止的原因如遇到 EOF 或其他错误，或管道的 write 端错误），Wait 方法会一直堵塞。 Stdin io.Reader // Stdout 和 Stderr 指定进程的标准输出和标准错误输出。 // 如果任一个为 nil，Run 方法会将对应的文件描述符关联到空设备（os.DevNull） // 如果两个字段相同，同一时间最多有一个线程可以写入。 Stdout io.Writer Stderr io.Writer // ExtraFiles 指定额外被新进程继承的已打开文件，不包括标准输入、标准输出、标准错误输出。 // 如果本字段非 nil，其中的元素 i 会变成文件描述符 3+i。 // // BUG: 在 OS X 10.6 系统中，子进程可能会继承不期望的文件描述符。 // http://golang.org/issue/2603 ExtraFiles []*os.File // SysProcAttr 提供可选的、各操作系统特定的 sys 属性。 // Run 方法会将它作为 os.ProcAttr 的 Sys 字段传递给 os.StartProcess 函数。 SysProcAttr *syscall.SysProcAttr // Process 是底层的，只执行一次的进程。 Process *os.Process // ProcessState 包含一个已经存在的进程的信息，只有在调用 Wait 或 Run 后才可用。 ProcessState *os.ProcessState } Command 一般的，应该通过 exec.Command 函数产生 Cmd 实例： func Command(name string, arg ...string) *Cmd 该函数返回一个 *Cmd，用于使用给出的参数执行 name 指定的程序。返回的 *Cmd 只设定了 Path 和 Args 两个字段。 如果 name 不含路径分隔符，将使用 LookPath 获取完整路径；否则直接使用 name。参数 arg 不应包含命令名。 得到 *Cmd 实例后，接下来一般有两种写法： 调用 Start()，接着调用 Wait()，然后会阻塞直到命令执行完成； 调用 Run()，它内部会先调用 Start()，接着调用 Wait()； Start func (c *Cmd) Start() error 开始执行 c 包含的命令，但并不会等待该命令完成即返回。Wait 方法会返回命令的退出状态码并在命令执行完后释放相关的资源。内部调用 os.StartProcess，执行 forkExec。 Wait func (c *Cmd) Wait() error Wait 会阻塞直到该命令执行完成，该命令必须是先通过 Start 执行。 如果命令成功执行，stdin、stdout、stderr 数据传递没有问题，并且返回状态码为 0，方法的返回值为 nil；如果命令没有执行或者执行失败，会返回 *ExitError 类型的错误；否则返回的 error 可能是表示 I/O 问题。 如果 c.Stdin 不是 *os.File 类型，Wait 会等待，直到数据从 c.Stdin 拷贝到进程的标准输入。 Wait 方法会在命令返回后释放相关的资源。 Output 除了 Run() 是 Start+Wait 的简便写法，Output() 更是 Run() 的简便写法，外加获取外部命令的输出。 func (c *Cmd) Output() ([]byte, error) 它要求 c.Stdout 必须是 nil，内部会将 bytes.Buffer 赋值给 c.Stdout，在 Run() 成功返回后，会将 Buffer 的结果返回（stdout.Bytes())。 CombinedOutput Output() 只返回 Stdout 的结果，而 CombinedOutput 组合 Stdout 和 Stderr 的输出，即 Stdout 和 Stderr 都赋值为同一个 bytes.Buffer。 StdoutPipe、StderrPipe 和 StdinPipe 除了上面介绍的 Output 和 CombinedOutput 直接获取命令输出结果外，还可以通过 StdoutPipe 返回 io.ReadCloser 来获取输出；相应的 StderrPipe 得到错误信息；而 StdinPipe 则可以往命令写入数据。 func (c *Cmd) StdoutPipe() (io.ReadCloser, error) StdoutPipe 方法返回一个在命令 Start 执行后与命令标准输出关联的管道。Wait 方法会在命令结束后会关闭这个管道，所以一般不需要手动关闭该管道。但是在从管道读取完全部数据之前调用 Wait 出错了，则必须手动关闭。 func (c *Cmd) StderrPipe() (io.ReadCloser, error) StderrPipe 方法返回一个在命令 Start 执行后与命令标准错误输出关联的管道。Wait 方法会在命令结束后会关闭这个管道，一般不需要手动关闭该管道。但是在从管道读取完全部数据之前调用 Wait 出错了，则必须手动关闭。 func (c *Cmd) StdinPipe() (io.WriteCloser, error) StdinPipe 方法返回一个在命令 Start 执行后与命令标准输入关联的管道。Wait 方法会在命令结束后会关闭这个管道。必要时调用者可以调用 Close 方法来强行关闭管道。例如，标准输入已经关闭了，命令执行才完成，这时调用者需要显示关闭管道。 因为 Wait 之后，会将管道关闭，所以，要使用这些方法，只能使用 Start+Wait 组合，不能使用 Run。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:128:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"执行外部命令示例 前面讲到，通过 Cmd 实例后，有两种方式运行命令。有时候，我们不只是简单的运行命令，还希望能控制命令的输入和输出。通过上面的 API 介绍，控制输入输出有几种方法： 得到 Cmd 实例后，直接给它的字段 Stdin、Stdout 和 Stderr 赋值； 通过 Output 或 CombinedOutput 获得输出； 通过带 Pipe 后缀的方法获得管道，用于输入或输出； 直接赋值 Stdin、Stdout 和 Stderr func FillStd(name string, arg ...string) ([]byte, error) { cmd := exec.Command(name, arg...) var out = new(bytes.Buffer) cmd.Stdout = out cmd.Stderr = out err := cmd.Run() if err != nil { return nil, err } return out.Bytes(), nil } 使用 Output func UseOutput(name string, arg ...string) ([]byte, error) { return exec.Command(name, arg...).Output() } 使用 Pipe func UsePipe(name string, arg ...string) ([]byte, error) { cmd := exec.Command(name, arg...) stdout, err := cmd.StdoutPipe() if err != nil { return nil, err } if err = cmd.Start(); err != nil { return nil, err } var out = make([]byte, 0, 1024) for { tmp := make([]byte, 128) n, err := stdout.Read(tmp) out = append(out, tmp[:n]...) if err != nil { break } } if err = cmd.Wait(); err != nil { return nil, err } return out, nil } 完整代码见 os_exec。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:128:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"进程终止 os.Exit() 函数会终止当前进程，对应的系统调用不是 _exit，而是 exit_group。 func Exit(code int) Exit 让当前进程以给出的状态码 code 退出。一般来说，状态码 0 表示成功，非 0 表示出错。进程会立刻终止，defer 的函数不会被执行。 10.2 进程属性和控制 每个进程都有一些属性，os 包提供了一些函数可以获取进程属性。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:129:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"进程 ID 每个进程都会有一个进程 ID，可以通过 os.Getpid 获得。同时，每个进程都有创建自己的父进程，通过 os.Getppid 获得。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:130:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"进程凭证 Unix 中进程都有一套数字表示的用户 ID(UID) 和组 ID(GID)，有时也将这些 ID 称之为进程凭证。Windows 下总是 -1。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:131:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实际用户 ID 和实际组 ID 实际用户 ID（real user ID）和实际组 ID（real group ID）确定了进程所属的用户和组。登录 shell 从 /etc/passwd 文件读取用户 ID 和组 ID。当创建新进程时（如 shell 执行程序），将从其父进程中继承这些 ID。 可通过 os.Getuid() 和 os.Getgid() 获取当前进程的实际用户 ID 和实际组 ID； ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:131:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"有效用户 ID 和有效组 ID 大多数 Unix 实现中，当进程尝试执行各种操作（即系统调用）时，将结合有效用户 ID、有效组 ID，连同辅助组 ID 一起来确定授予进程的权限。内核还会使用有效用户 ID 来决定一个进程是否能向另一个进程发送信号。 有效用户 ID 为 0（root 的用户 ID）的进程拥有超级用户的所有权限。这样的进程又称为特权级进程（privileged process）。某些系统调用只能由特权级进程执行。 可通过 os.Geteuid() 和 os.Getegid() 获取当前进程的有效用户 ID（effective user ID）和有效组 ID（effectvie group ID）。 通常，有效用户 ID 及组 ID 与其相应的实际 ID 相等，但有两种方法能够致使二者不同。一是使用相关系统调用；二是执行 set-user-ID 和 set-group-ID 程序。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:131:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Set-User-ID 和 Set-Group-ID 程序 set-user-ID 程序会将进程的有效用户 ID 置为可执行文件的用户 ID（属主），从而获得常规情况下并不具有的权限。set-group-ID 程序对进程有效组 ID 实现类似任务。（有时也将这程序简称为 set-UID 程序和 set-GID 程序。） 与其他文件一样，可执行文件的用户 ID 和组 ID 决定了该文件的所有权。在 6.1 os — 平台无关的操作系统功能实现 中提到过，文件还拥有两个特别的权限位 set-user-ID 位和 set-group-ID 位，可以使用 os.Chmod 修改这些权限位（非特权用户进程只能修改其自身文件，而特权用户进程能修改任何文件）。 文件设置了 set-user-ID 位后，ls -l 显示文件后，会在属主用户执行权限字段上看到字母 s（有执行权限时） 或 S（无执行权限时）；相应的 set-group-ID 则是在组用户执行位上看到 s 或 S。 当运行 set-user-ID 程序时，内核会将进程的有效用户 ID 设置为可执行文件的用户 ID。set-group-ID 程序对进程有效组 ID 的操作与之类似。通过这种方法修改进程的有效用户 ID 或组 ID，能够使进程（换言之，执行该程序的用户）获得常规情况下所不具有的权限。例如，如果一个可执行文件的属主为 root，且为此程序设置了 set-user-ID 权限位，那么当运行该程序时，进程会取得超级用户权限。 也可以利用程序的 set-user-ID 和 set-group-ID 机制，将进程的有效 ID 修改为 root 之外的其他用户。例如，为提供一个受保护文件的访问，可采用如下方案：创建一个具有对该文件访问权限的专有用户（组）ID，然后再创建一个 set-user-ID（set-group-ID）程序，将进程有效用户（组）ID 变更为这个专用 ID。这样，无需拥有超级用户的所有权限，程序就能访问该文件。 Linux 系统中经常使用的 set-user-ID 程序，如 passwd。 测试 set-user-ID 程序 在 Linux 的某个目录下，用 root 账号创建一个文件： echo \"This is my shadow, studygolang.\" \u003e my_shadow.txt 然后将所有权限都去掉：chmod 0 my_shadow.txt。 ls -l 结果类似如下： ---------- 1 root root 32 6 月 24 17:31 my_shadow.txt 这时，如果非 root 用户是无法查看文件内容的。 接着，用 root 账号创建一个 main.go 文件，内容如下： package main import ( \"fmt\" \"io/ioutil\" \"log\" \"os\" ) func main() { file, err := os.Open(\"my_shadow.txt\") if err != nil { log.Fatal(err) } defer file.Close() data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\"my_shadow:%s\\n\", data) } 就是简单地读取 my_shadow 文件内容。go build main.go 后，生成的 main 可执行文件，权限是：-rwxrwxr-x。 这时，切换到非 root 用户，执行 ./main，会输出： open my_shadow.txt: permission denied 因为这时的 main 程序生成的进程有效用户 ID 是当前用户的（非 root）。 接着，给 main 设置 set-user-ID 位：chmod u+s main，权限变为 -rwsrwxr-x，非 root 下再次执行 ./main，输出： my_shadow:This is my shadow, studygolang. 因为设置了 set-user-ID 位，这时 main 程序生成的进程有效用户是 main 文件的属主，即 root 的 ID，因此有权限读 my_shadow.txt。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:131:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"修改进程的凭证 os 包没有提供相应的功能修改进程的凭证，在 syscall 包对这些系统调用进行了封装。因为 https://golang.org/s/go1.4-syscall，用户程序不建议直接使用该包，应该使用 golang.org/x/sys 包代替。 该包提供了修改进程各种 ID 的系统调用封装，这里不一一介绍。 此外，os 还提供了获取辅助组 ID 的函数：os.Getgroups()。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:131:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"操作系统用户 包 os/user 允许通过名称或 ID 查询用户账号。用户结构定义如下： type User struct { Uid string // user id Gid string // primary group id Username string Name string HomeDir string } User 代表一个用户帐户。 在 POSIX 系统中 Uid 和 Gid 字段分别包含代表 uid 和 gid 的十进制数字。在 Windows 系统中 Uid 和 Gid 包含字符串格式的安全标识符（SID）。在 Plan 9 系统中，Uid、Gid、Username 和 Name 字段是 /dev/user 的内容。 Current 函数可以获取当前用户账号。而 Lookup 和 LookupId 则分别根据用户名和用户 ID 查询用户。如果对应的用户不存在，则返回 user.UnknownUserError 或 user.UnknownUserIdError。 package main import ( \"fmt\" \"os/user\" ) func main() { fmt.Println(user.Current()) fmt.Println(user.Lookup(\"xuxinhua\")) fmt.Println(user.LookupId(\"0\")) } // Output: // \u0026{502 502 xuxinhua /home/xuxinhua} \u003cnil\u003e // \u0026{502 502 xuxinhua /home/xuxinhua} \u003cnil\u003e // \u0026{0 0 root root /root} \u003cnil\u003e ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:131:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"进程的当前工作目录 一个进程的当前工作目录（current working directory）定义了该进程解析相对路径名的起点。新进程的当前工作目录继承自其父进程。 func Getwd() (dir string, err error) Getwd 返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（比如符号链接），Getwd 会返回其中一个。对应系统调用：getcwd。 func Chdir(dir string) error 相应的，Chdir 将当前工作目录修改为 dir 指定的目录。如果出错，会返回 *PathError 类型的错误。对应系统调用 chdir。 另外，os.File 有一个方法：Chdir，对应系统调用 fchidr（以文件描述符为参数），也可以改变当前工作目录。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:132:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"改变进程的根目录 每个进程都有一个根目录，该目录是解释绝对路径（即那些以 / 开始的目录）时的起点。默认情况下，这是文件系统的真是根目录。新进程从其父进程处继承根目录。有时可能需要改变一个进程的根目录（比如 ftp 服务就是一个典型的例子）。系统调用 chroot 能改变一个进程的根目录，Go 中对应的封装在 syscall.Chroot。 除此之外，在 fork 子进程时，可以通过给 syscall.SysProcAttr 结构的 Chroot 字段指定一个路径，来初始化子进程的根目录。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:133:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"进程环境列表 每个进程都有与其相关的称之为环境列表（environment list）的字符串数组，或简称环境（environment）。其中每个字符串都以 名称 = 值（name=value）形式定义。因此，环境是“名称 - 值”的成对集合，可存储任何信息。常将列表中的名称称为环境变量（environment variables）。 新进程在创建之时，会继承其父进程的环境副本。这是一种原始的进程间通信方式，却颇为常用。环境（environment）提供了将信息和父进程传递给子进程的方法。创建后，父子进程的环境相互独立，互不影响。 环境变量的常见用途之一是在 shell 中，通过在自身环境中放置变量值，shell 就可确保把这些值传递给其所创建的进程，并以此来执行用户命令。 在程序中，可以通过 os.Environ 获取环境列表： func Environ() []string 返回的 []string 中每个元素是 key=value 的形式。 func Getenv(key string) string Getenv 检索并返回名为 key 的环境变量的值。如果不存在该环境变量会返回空字符串。有时候，可能环境变量存在，只是值刚好是空。为了区分这种情况，提供了另外一个函数 LookupEnv()： func LookupEnv(key string) (string, bool) 如果变量名存在，第二个参数返回 true，否则返回 false。 func Setenv(key, value string) error Setenv 设置名为 key 的环境变量，值为 value。如果出错会返回该错误。（如果值之前存在，会覆盖） func Unsetenv(key string) error Unsetenv 删除名为 key 的环境变量。 func Clearenv() Clearenv 删除所有环境变量。 package main import ( \"fmt\" \"os\" ) func main() { fmt.Println(\"The num of environ:\", len(os.Environ())) godebug, ok := os.LookupEnv(\"GODEBUG\") if ok { fmt.Println(\"GODEBUG==\", godebug) } else { fmt.Println(\"GODEBUG not exists!\") os.Setenv(\"GODEBUG\", \"gctrace=1\") fmt.Println(\"after setenv:\", os.Getenv(\"GODEBUG\")) } os.Clearenv() fmt.Println(\"clearenv, the num:\", len(os.Environ())) } // Output: // The num of environ: 25 // GODEBUG not exists! // after setenv: gctrace=1 // clearenv, the num: 0 另外，ExpandEnv 和 Getenv 功能类似，不过，前者使用变量方式，如： os.ExpandEnv(\"$GODEBUG”) 和 os.Getenv(“GODEBUG”) 是一样的。 实际上，os.ExpandEnv 调用的是 os.Expand(s, os.Getenv)。 func Expand(s string, mapping func(string) string) string Expand 能够将 ${var} 或 $var 形式的变量，经过 mapping 处理，得到结果。 10.3 线程 与进程类似，线程是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域。 同一进程中的多个线程可以并发执行。在多处理器环境下，多个线程可以同时并行。如果一个线程因等待 I/O 操作而遭阻塞，那么其他线程依然可以继续运行。 在 Linux 中，通过系统调用 clone() 来实现线程的。从前面的介绍，我们知道，该系统调用也可以用来创建进程。实际上，从内核的角度来说，它并没有线程这个概念。Linux 把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个使用某些共享资源的进程。所以，在内核中，它看起来就是一个普通的进程（只是该进程和其他一些进程共享某些资源，如地址空间）。 在 Go 中，通过 clone() 系统调用来创建线程，其中的 clone_flags 为： cloneFlags = _CLONE_VM | /* share memory */ _CLONE_FS | /* share cwd, etc */ _CLONE_FILES | /* share fd table */ _CLONE_SIGHAND | /* share sig handler table */ _CLONE_THREAD /* revisit - okay for now */ 也就是说，父子俩共享了地址空间 (_CLONE_VM)、文件系统资源 (_CLONE_FS)、文件描述符 (_CLONE_FILES) 和信号处理程序 (_CLONE_SIGHAND)。而 _CLONE_THREAD 则会将父子进程放入相同的线程组。这样一来，新建的进程和父进程都叫做线程。 10.3 进程间通信 进程之间用来相互通讯和同步 第十三章 应用构建 与 debug 本章我们来研究应用程序构建相关的标准库，包括用于命令行参数解析的 flag 包，简单的日志记录包 log（以及 syslog)，公共变量标准接口 expvar 包，以及运行时的调试工具 runtime/debug 包。 13.1 flag - 命令行参数解析 在写命令行程序（工具、server）时，对命令参数进行解析是常见的需求。各种语言一般都会提供解析命令行参数的方法或库，以方便程序员使用。如果命令行参数纯粹自己写代码解析，对于比较复杂的，还是挺费劲的。在 go 标准库中提供了一个包：flag，方便进行命令行解析。 注：区分几个概念 命令行参数（或参数）：是指运行程序提供的参数 已定义命令行参数：是指程序中通过 flag.Xxx 等这种形式定义了的参数 非 flag（non-flag）命令行参数（或保留的命令行参数）：后文解释 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:134:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"使用示例 我们以 nginx 为例，执行 nginx -h，输出如下： nginx version: nginx/1.10.0 Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/nginx/) -c filename : set configuration file (default: conf/nginx.conf) -g directives : set global directives out of configuration file 我们通过 flag 实现类似 nginx 的这个输出，创建文件 nginx.go，内容如下： package main import ( \"flag\" \"fmt\" \"os\" ) // 实际中应该用更好的变量名 var ( h bool v, V bool t, T bool q *bool s string p string c string g string ) func init() { flag.BoolVar(\u0026h, \"h\", false, \"this help\") flag.BoolVar(\u0026v, \"v\", false, \"show version and exit\") flag.BoolVar(\u0026V, \"V\", false, \"show version and configure options then exit\") flag.BoolVar(\u0026t, \"t\", false, \"test configuration and exit\") flag.BoolVar(\u0026T, \"T\", false, \"test configuration, dump it and exit\") // 另一种绑定方式 q = flag.Bool(\"q\", false, \"suppress non-error messages during configuration testing\") // 注意 `signal`。默认是 -s string，有了 `signal` 之后，变为 -s signal flag.StringVar(\u0026s, \"s\", \"\", \"send `signal` to a master process: stop, quit, reopen, reload\") flag.StringVar(\u0026p, \"p\", \"/usr/local/nginx/\", \"set `prefix` path\") flag.StringVar(\u0026c, \"c\", \"conf/nginx.conf\", \"set configuration `file`\") flag.StringVar(\u0026g, \"g\", \"conf/nginx.conf\", \"set global `directives` out of configuration file\") // 改变默认的 Usage flag.Usage = usage } func main() { flag.Parse() if h { flag.Usage() } } func usage() { fmt.Fprintf(os.Stderr, `nginx version: nginx/1.10.0 Usage: nginx [-hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives] Options: `) flag.PrintDefaults() } 执行：go run nginx.go -h，（或 go build -o nginx \u0026\u0026 ./nginx -h）输出如下： nginx version: nginx/1.10.0 Usage: nginx [-hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives] Options: -T test configuration, dump it and exit -V show version and configure options then exit -c file set configuration file (default \"conf/nginx.conf\") -g directives set global directives out of configuration file (default \"conf/nginx.conf\") -h this help -p prefix set prefix path (default \"/usr/local/nginx/\") -q suppress non-error messages during configuration testing -s signal send signal to a master process: stop, quit, reopen, reload -t test configuration and exit -v show version and exit 仔细理解以上例子，如果有不理解的，看完下文的讲解再回过头来看。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:135:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"flag 包概述 flag 包实现了命令行参数的解析。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:136:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"定义 flags 有两种方式 1）flag.Xxx()，其中 Xxx 可以是 Int、String 等；返回一个相应类型的指针，如： var ip = flag.Int(\"flagname\", 1234, \"help message for flagname\")\r2）flag.XxxVar()，将 flag 绑定到一个变量上，如： var flagvar int flag.IntVar(\u0026flagvar, \"flagname\", 1234, \"help message for flagname\") ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:136:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"自定义 Value 另外，还可以创建自定义 flag，只要实现 flag.Value 接口即可（要求 receiver 是指针），这时候可以通过如下方式定义该 flag： flag.Var(\u0026flagVal, \"name\", \"help message for flagname\")\r例如，解析我喜欢的编程语言，我们希望直接解析到 slice 中，我们可以定义如下 Value： type sliceValue []string func newSliceValue(vals []string, p *[]string) *sliceValue { *p = vals return (*sliceValue)(p) } func (s *sliceValue) Set(val string) error { *s = sliceValue(strings.Split(val, \",\")) return nil } func (s *sliceValue) Get() interface{} { return []string(*s) } func (s *sliceValue) String() string { return strings.Join([]string(*s), \",\") } 之后可以这么使用： var languages []string flag.Var(newSliceValue([]string{}, \u0026languages), \"slice\", \"I like programming `languages`\") 这样通过 -slice \"go,php\" 这样的形式传递参数，languages 得到的就是 [go, php]。 flag 中对 Duration 这种非基本类型的支持，使用的就是类似这样的方式。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:136:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"解析 flag 在所有的 flag 定义完成之后，可以通过调用 flag.Parse() 进行解析。 命令行 flag 的语法有如下三种形式： -flag // 只支持 bool 类型\r-flag=x\r-flag x // 只支持非 bool 类型\r其中第三种形式只能用于非 bool 类型的 flag，原因是：如果支持，那么对于这样的命令 cmd -x *，如果有一个文件名字是：0 或 false 等，则命令的原意会改变（之所以这样，是因为 bool 类型支持 -flag 这种形式，如果 bool 类型不支持 -flag 这种形式，则 bool 类型可以和其他类型一样处理。也正因为这样，Parse() 中，对 bool 类型进行了特殊处理）。默认的，提供了 -flag，则对应的值为 true，否则为 flag.Bool/BoolVar 中指定的默认值；如果希望显示设置为 false 则使用 -flag=false。 int 类型可以是十进制、十六进制、八进制甚至是负数；bool 类型可以是 1, 0, t, f, true, false, TRUE, FALSE, True, False。Duration 可以接受任何 time.ParseDuration 能解析的类型。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:136:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"类型和函数 在看类型和函数之前，先看一下变量。 ErrHelp：该错误类型用于当命令行指定了 · -help` 参数但没有定义时。 Usage：这是一个函数，用于输出所有定义了的命令行参数和帮助信息（usage message）。一般，当命令行参数解析出错时，该函数会被调用。我们可以指定自己的 Usage 函数，即：flag.Usage = func(){} ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:137:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"函数 go 标准库中，经常这么做： 定义了一个类型，提供了很多方法；为了方便使用，会实例化一个该类型的实例（通用），这样便可以直接使用该实例调用方法。比如：encoding/base64 中提供了 StdEncoding 和 URLEncoding 实例，使用时：base64.StdEncoding.Encode() 在 flag 包使用了有类似的方法，比如 CommandLine 实例，只不过 flag 进行了进一步封装：将 FlagSet 的方法都重新定义了一遍，也就是提供了一序列函数，而函数中只是简单的调用已经实例化好了的 FlagSet 实例：CommandLine 的方法。这样，使用者是这么调用：flag.Parse() 而不是 flag. CommandLine.Parse()。（Go 1.2 起，将 CommandLine 导出，之前是非导出的） 这里不详细介绍各个函数，在类型方法中介绍。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:137:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"类型（数据结构） 1）ErrorHandling type ErrorHandling int\r该类型定义了在参数解析出错时错误处理方式。定义了三个该类型的常量： const ( ContinueOnError ErrorHandling = iota ExitOnError PanicOnError ) 三个常量在源码的 FlagSet 的方法 parseOne() 中使用了。 2）Flag // A Flag represents the state of a flag. type Flag struct { Name string // name as it appears on command line Usage string // help message Value Value // value as set DefValue string // default value (as text); for usage message } Flag 类型代表一个 flag 的状态。 比如，对于命令：./nginx -c /etc/nginx.conf，相应代码是： flag.StringVar(\u0026c, \"c\", \"conf/nginx.conf\", \"set configuration `file`\")\r则该 Flag 实例（可以通过 flag.Lookup(\"c\") 获得）相应各个字段的值为： \u0026Flag{ Name: c, Usage: set configuration file, Value: /etc/nginx.conf, DefValue: conf/nginx.conf, } 3）FlagSet // A FlagSet represents a set of defined flags. type FlagSet struct { // Usage is the function called when an error occurs while parsing flags. // The field is a function (not a method) that may be changed to point to // a custom error handler. Usage func() name string // FlagSet 的名字。CommandLine 给的是 os.Args[0] parsed bool // 是否执行过 Parse() actual map[string]*Flag // 存放实际传递了的参数（即命令行参数） formal map[string]*Flag // 存放所有已定义命令行参数 args []string // arguments after flags // 开始存放所有参数，最后保留 非 flag（non-flag）参数 exitOnError bool // does the program exit if there's an error? errorHandling ErrorHandling // 当解析出错时，处理错误的方式 output io.Writer // nil means stderr; use out() accessor } 4）Value 接口 // Value is the interface to the dynamic value stored in a flag. // (The default value is represented as a string.) type Value interface { String() string Set(string) error } 所有参数类型需要实现 Value 接口，flag 包中，为 int、float、bool 等实现了该接口。借助该接口，我们可以自定义 flag。（上文已经给了具体的例子） ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:137:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"主要类型的方法（包括类型实例化） flag 包中主要是 FlagSet 类型。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"实例化方式 NewFlagSet() 用于实例化 FlagSet。预定义的 FlagSet 实例 CommandLine 的定义方式： // The default set of command-line flags, parsed from os.Args. var CommandLine = NewFlagSet(os.Args[0], ExitOnError) 可见，默认的 FlagSet 实例在解析出错时会退出程序。 由于 FlagSet 中的字段没有 export，其他方式获得 FlagSet 实例后，比如：FlagSet{} 或 new(FlagSet)，应该调用 Init() 方法，以初始化 name 和 errorHandling，否则 name 为空，errorHandling 为 ContinueOnError。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"定义 flag 参数的方法 这一序列的方法都有两种形式，在一开始已经说了两种方式的区别。这些方法用于定义某一类型的 flag 参数。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"解析参数（Parse） func (f *FlagSet) Parse(arguments []string) error\r从参数列表中解析定义的 flag。方法参数 arguments 不包括命令名，即应该是 os.Args[1:]。事实上，flag.Parse() 函数就是这么做的： // Parse parses the command-line flags from os.Args[1:]. Must be called // after all flags are defined and before flags are accessed by the program. func Parse() { // Ignore errors; CommandLine is set for ExitOnError. CommandLine.Parse(os.Args[1:]) } 该方法应该在 flag 参数定义后而具体参数值被访问前调用。 如果提供了 -help 参数（命令中给了）但没有定义（代码中没有），该方法返回 ErrHelp 错误。默认的 CommandLine，在 Parse 出错时会退出程序（ExitOnError）。 为了更深入的理解，我们看一下 Parse(arguments []string) 的源码： func (f *FlagSet) Parse(arguments []string) error { f.parsed = true f.args = arguments for { seen, err := f.parseOne() if seen { continue } if err == nil { break } switch f.errorHandling { case ContinueOnError: return err case ExitOnError: os.Exit(2) case PanicOnError: panic(err) } } return nil } 真正解析参数的方法是非导出方法 parseOne。 结合 parseOne 方法，我们来解释 non-flag 以及包文档中的这句话： Flag parsing stops just before the first non-flag argument (”-” is a non-flag argument) or after the terminator “–”. 我们需要了解解析什么时候停止。 根据 Parse() 中 for 循环终止的条件（不考虑解析出错），我们知道，当 parseOne 返回 false, nil 时，Parse 解析终止。正常解析完成我们不考虑。看一下 parseOne 的源码发现，有两处会返回 false, nil。 1）第一个 non-flag 参数 s := f.args[0] if len(s) == 0 || s[0] != '-' || len(s) == 1 { return false, nil } 也就是，当遇到单独的一个 “-” 或不是 “-” 开始时，会停止解析。比如： ./nginx - -c 或 ./nginx build -c 这两种情况，-c 都不会被正确解析。像该例子中的 “-” 或 build（以及之后的参数），我们称之为 non-flag 参数。 2）两个连续的 “–” if s[1] == '-' { num_minuses++ if len(s) == 2 { // \"--\" terminates the flags f.args = f.args[1:] return false, nil } } 也就是，当遇到连续的两个 “-” 时，解析停止。 *说明：这里说的 “-” 和 “–\"，位置和 “-c” 这种的一样。*也就是说，下面这种情况并不是这里说的： ./nginx -c – 这里的 “–” 会被当成是 c 的值 parseOne 方法中接下来是处理 -flag=x 这种形式，然后是 -flag 这种形式（bool 类型）（这里对 bool 进行了特殊处理），接着是 -flag x 这种形式，最后，将解析成功的 Flag 实例存入 FlagSet 的 actual map 中。 另外，在 parseOne 中有这么一句： f.args = f.args[1:]\r也就是说，每执行成功一次 parseOne，f.args 会少一个。所以，FlagSet 中的 args 最后留下来的就是所有 non-flag 参数。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Arg(i int) 和 Args()、NArg()、NFlag() Arg(i int) 和 Args() 这两个方法就是获取 non-flag 参数的；NArg() 获得 non-flag 的个数；NFlag() 获得 FlagSet 中 actual 长度（即被设置了的参数个数）。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Visit/VisitAll 这两个函数分别用于访问 FlatSet 的 actual 和 formal 中的 Flag，而具体的访问方式由调用者决定。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"PrintDefaults() 打印所有已定义参数的默认值（调用 VisitAll 实现），默认输出到标准错误，除非指定了 FlagSet 的 output（通过 SetOutput() 设置） ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:6","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Set(name, value string) 设置某个 flag 的值（通过 name 查找到对应的 Flag） ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:138:7","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"总结 使用建议：虽然上面讲了那么多，一般来说，我们只简单的定义 flag，然后 parse，就如同开始的例子一样。 如果项目需要复杂或更高级的命令行解析方式，可以使用 https://github.com/urfave/cli 或者 https://github.com/spf13/cobra 这两个强大的库。 13.3 expvar - 公共变量的标准化接口 expvar 挺简单的，然而，它也是很有用的。但不幸的是，貌似了解它的人不多。来自 godoc.org 的数据表明，没有多少人知道这个包。截止目前（2017-6-18），该包被公开的项目 import 2207 次，相比较而言，连 image 包都被 import 3491 次之多。 如果你看到了这里，希望以后你的项目中能使用上 expvar 这个包。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:139:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"包简介 包 expvar 为公共变量提供了一个标准化的接口，如服务器中的操作计数器。它以 JSON 格式通过 /debug/vars 接口以 HTTP 的方式公开这些公共变量。 设置或修改这些公共变量的操作是原子的。 除了为程序增加 HTTP handler，此包还注册以下变量： cmdline os.Args\rmemstats runtime.Memstats\r导入该包有时只是为注册其 HTTP handler 和上述变量。 要以这种方式使用，请将此包通过如下形式引入到程序中： import _ \"expvar\"\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:140:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"例子 在继续介绍此包的详细信息之前，我们演示使用 expvar 包可以做什么。以下代码创建一个在监听 8080 端口的 HTTP 服务器。每个请求到达 hander() 后，在向访问者发送响应消息之前增加计数器。 package main import ( \"expvar\" \"fmt\" \"net/http\" ) var visits = expvar.NewInt(\"visits\") func handler(w http.ResponseWriter, r *http.Request) { visits.Add(1) fmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:]) } func main() { http.HandleFunc(\"/\", handler) http.ListenAndServe(\":8080\", nil) } 导入 expvar 包后，它将为 http.DefaultServeMux 上的 PATH /debug/vars 注册一个处理函数。此处理程序返回已在 expvar 包中注册的所有公共变量。运行代码并访问 http://localhost:8080/debug/vars，您将看到如下所示的内容（输出被截断以增加可读性）： {\r\"cmdline\": [\r\"/var/folders/qv/2jztyc09357ddtxn_bvgh8j00000gn/T/go-build146580631/command-line-arguments/_obj/exe/test\"\r],\r\"memstats\": {\r\"Alloc\": 414432,\r\"TotalAlloc\": 414432,\r\"Sys\": 3084288,\r\"Lookups\": 13,\r\"Mallocs\": 5111,\r\"Frees\": 147,\r\"HeapAlloc\": 414432,\r\"HeapSys\": 1703936,\r\"HeapIdle\": 835584,\r\"HeapInuse\": 868352,\r\"HeapReleased\": 0,\r\"HeapObjects\": 4964,\r\"StackInuse\": 393216,\r\"StackSys\": 393216,\r\"MSpanInuse\": 15504,\r\"MSpanSys\": 16384,\r\"MCacheInuse\": 4800,\r\"MCacheSys\": 16384,\r\"BuckHashSys\": 2426,\r\"GCSys\": 137216,\r\"OtherSys\": 814726,\r\"NextGC\": 4473924,\r\"LastGC\": 0,\r\"PauseTotalNs\": 0,\r\"PauseNs\": [\r0,\r0,\r],\r\"PauseEnd\": [\r0,\r0\r],\r\"GCCPUFraction\": 0,\r\"EnableGC\": true,\r\"DebugGC\": false,\r\"BySize\": [\r{\r\"Size\": 16640,\r\"Mallocs\": 0,\r\"Frees\": 0\r},\r{\r\"Size\": 17664,\r\"Mallocs\": 0,\r\"Frees\": 0\r}\r]\r},\r\"visits\": 0\r}\r信息真不少。这是因为默认情况下该包注册了 os.Args 和 runtime.Memstats 两个指标。因为我们还没有访问到增加 visits 的路径，所以它的值仍然为 0。现在通过访问 http:// localhost:8080/golang 来增加计数器，然后返回。计数器不再为 0。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:141:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"expvar.Publish 函数 expvar 包相当小且容易理解。它主要由两个部分组成。第一个是函数 expvar.Publish(name string，v expvar.Var)。该函数可用于在未导出的全局注册表中注册具有特定名称（name）的 v。以下代码段显示了具体实现。接下来的 3 个代码段是从 expvar 包的源代码中截取的。 先看下全局注册表： var ( mutex sync.RWMutex vars = make(map[string]Var) varKeys []string // sorted ) 全局注册表实际就是一个 map：vars。 Publish 函数的实现： // Publish declares a named exported variable. This should be called from a // package's init function when it creates its Vars. If the name is already // registered then this will log.Panic. func Publish(name string, v Var) { mutex.Lock() defer mutex.Unlock() // Check if name has been taken already. If so, panic. if _, existing := vars[name]; existing { log.Panicln(\"Reuse of exported var name:\", name) } // vars is the global registry. It is defined somewhere else in the // expvar package like this: // // vars = make(map[string]Var) vars[name] = v // 一方面，该包中所有公共变量，放在 vars 中，同时，通过 varKeys 保存了所有变量名，并且按字母序排序，即实现了一个有序的、线程安全的 map varKeys = append(varKeys, name) sort.Strings(varKeys) } expvar 包内置的两个公共变量就是通过 Publish 注册的： Publish(\"cmdline\", Func(cmdline))\rPublish(\"memstats\", Func(memstats))\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:142:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"expvar.Var 接口 另一个重要的组成部分是 expvar.Var 接口。 这个接口只有一个方法： // Var is an abstract type for all exported variables. type Var interface { // String returns a valid JSON value for the variable. // Types with String methods that do not return valid JSON // (such as time.Time) must not be used as a Var. String() string } 所以你可以在有 String() string 方法的所有类型上调用 Publish() 函数，但需要注意的是，这里的 String() 要求返回的是一个有效的 JSON 字符串。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:143:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"expvar.Int 类型 expvar 包提供了其他几个类型，它们实现了 expvar.Var 接口。其中一个是 expvar.Int，我们已经在演示代码中通过 expvar.NewInt(“visits”) 方式使用它了，它会创建一个新的 expvar.Int，并使用 expvar.Publish 注册它，然后返回一个指向新创建的 expvar.Int 的指针。 func NewInt(name string) *Int { v := new(Int) Publish(name, v) return v } expvar.Int 包装一个 int64，并有两个函数 Add(delta int64) 和 Set(value int64)，它们以线程安全的方式（通过 atomic 包实现）修改包装的 int64。另外通过 Value() int64 函数获得包装的 int64。 type Int struct { i int64 } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:144:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"其他类型 除了 expvar.Int，该包还提供了一些实现 expvar.Var 接口的其他类型： expvar.Float expvar.String expvar.Map expvar.Func 前两个类型包装了 float64 和 string。后两种类型需要稍微解释下。 expvar.Map 类型可用于使公共变量出现在某个名称空间下。可以这样用： var stats = expvar.NewMap(\"http\") var requests, requestsFailed expvar.Int func init() { stats.Set(\"req_succ\", \u0026requests) stats.Set(\"req_failed\", \u0026requestsFailed) } 这段代码使用名称空间 http 注册了两个指标 req_succ 和 req_failed。它将显示在 JSON 响应中，如下所示： {\r\"http\": {\r\"req_succ\": 18,\r\"req_failed\": 21\r}\r}\r当要注册某个函数的执行结果到某个公共变量时，您可以使用 expvar.Func。假设您希望计算应用程序的正常运行时间，每次有人访问 http://localhost:8080/debug/vars 时，都必须重新计算此值。 var start = time.Now() func calculateUptime() interface { return time.Since(start).String() } expvar.Publish(\"uptime\", expvar.Func(calculateUptime)) 实际上，内置的两个指标 cmdline 和 memstats 就是通过这种方式注册的。注意，函数签名有如下要求：没有参数，返回 interface{} type Func func() interface{}\r","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:145:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"关于 Handler 函数 本文开始时提到，可以简单的导入 expvar 包，然后使用其副作用，导出路径 /debug/vars。然而，如果我们使用了一些框架，并非使用 http.DefaultServeMux，而是框架自己定义的 Mux，这时直接导入使用副作用可能不会生效。我们可以按照使用的框架，定义自己的路径，比如也叫 /debug/vars，然后，这对应的处理程序中，按如下的两种方式处理： 1）将处理直接交给 expvar.Handler，比如： handler := expvar.Handler()\rhandler.ServeHTTP(w, req)\r2）自己遍历 expvar 中的公共变量，构造输出，甚至可以过滤 expvar 默认提供的 cmdline 和 memstats，我们看下 expvarHandler 的源码就明白了：（通过 expvar.Do 函数来遍历的） func expvarHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\") fmt.Fprintf(w, \"{\\n\") first := true Do(func(kv KeyValue) { if !first { fmt.Fprintf(w, \",\\n\") } first = false fmt.Fprintf(w, \"%q: %s\", kv.Key, kv.Value) }) fmt.Fprintf(w, \"\\n}\\n\") } Go 语言中文网 因为使用了 Echo 框架，使用第 1 种方式来处理的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:146:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"定义自己的 expvar.Var 类型 expvar 包提供了 int、float 和 string 这三种基本数据类型的 expvar.Var 实现，以及 Func 和 Map。有时，我们自己有一个复杂的类型，想要实现 expvar.Var 接口，怎么做呢？ 从上面的介绍，应该很容易实现吧，如果您遇到了具体的需求，可以试试。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:147:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"总结 综上所述，通过 expvar 包，可以非常容易的展示应用程序指标。建议您在您的每个应用程序中使用它来展示一些指示应用程序运行状况的指标，通过它和其他的一些工具来监控应用程序。 第十四章 运行时特性 运行时（runtime）是 Go 语言最重要的部分，关于它包含的内容，比如内存分配、调度、高级数据结构的实现等，都是高级进阶内容，超出了本书的范围。 本章主要着重介绍使用方面，在日常开发中可能会用到 runtime 包或子包中的某些功能，它们也是标准库的一部分。 14.2 io — 基本的 IO 接口 15.2 — 非类型安全操作 unsafe库徘徊在“类型安全”边缘，由于它们绕过了 Golang 的内存安全原则，一般被认为使用该库是不安全的。但是，在许多情况下，unsafe库的作用又是不可替代的，灵活地使用它们可以实现对内存的直接读写操作。在reflect库、syscall库以及其他许多需要操作内存的开源项目中都有对它的引用。 unsafe库源码极少，只有两个类型的定义和三个方法的声明。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:148:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Arbitrary 类型 官方导出这个类型只是出于完善文档的考虑，在其他的库和任何项目中都没有使用价值，除非程序员故意使用它。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:149:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Pointer 类型 这个类型比较重要，它是实现定位欲读写的内存的基础。官方文档对该类型有四个重要描述： （1）任何类型的指针都可以被转化为 Pointer （2）Pointer 可以被转化为任何类型的指针 （3）uintptr 可以被转化为 Pointer （4）Pointer 可以被转化为 uintptr 举例来说，该类型可以这样使用： func main() { i := 100 fmt.Println(i) // 100 p := (*int)unsafe.Pointer(\u0026i) fmt.Println(*p) // 100 *p = 0 fmt.Println(i) // 0 fmt.Println(*p) // 0 } ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:150:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Sizeof 函数 该函数的定义如下： func Sizeof(v ArbitraryType) uintptr\rSizeof 函数返回变量 v 占用的内存空间的字节数，该字节数不是按照变量 v 实际占用的内存计算，而是按照 v 的“ top level ”内存计算。比如，在 64 位系统中，如果变量 v 是 int 类型，会返回 16，因为 v 的“ top level ”内存就是它的值使用的内存；如果变量 v 是 string 类型，会返回 16，因为 v 的“ top level ”内存不是存放着实际的字符串，而是该字符串的地址；如果变量 v 是 slice 类型，会返回 24，这是因为 slice 的描述符就占了 24 个字节。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:151:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Offsetof 函数 该函数的定义如下： func Offsetof(v ArbitraryType) uintptr\r该函数返回由 v 所指示的某结构体中的字段在该结构体中的位置偏移字节数，注意，v 的表达方式必须是“ struct.filed ”形式。 举例说明，在 64 为系统中运行以下代码： type Datas struct{ c0 byte c1 int c2 string c3 int } func main(){ var d Datas fmt.Println(unsafe.Offset(d.c0)) // 0 fmt.Println(unsafe.Offset(d.c1)) // 8 fmt.Println(unsafe.Offset(d.c2)) // 16 fmt.Println(unsafe.Offset(d.c3)) // 32 } 如果知道的结构体的起始地址和字段的偏移值，就可以直接读写内存： d.c3 = 13 p := unsafe.Pointer(\u0026d) offset := unsafe.Offsetof(d.c3) q := (*int)(unsafe.Pointer(uintptr(p) + offset)) fmt.Println(*q) // 13 *p = 1013 fmt.Println(d.c3) // 1013 sync - 处理同步需求 golang 是一门语言级别支持并发的程序语言。golang 中使用 go 语句来开启一个新的协程。 goroutine 是非常轻量的，除了给它分配栈空间，它所占用的内存空间是微乎其微的。 但当多个 goroutine 同时进行处理的时候，就会遇到比如同时抢占一个资源，某个 goroutine 等待另一个 goroutine 处理完某一个步骤之后才能继续的需求。 在 golang 的官方文档上，作者明确指出，golang 并不希望依靠共享内存的方式进行进程的协同操作。而是希望通过管道 channel 的方式进行。 当然，golang 也提供了共享内存，锁，等机制进行协同操作的包。sync 包就是为了这个目的而出现的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:152:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"锁 sync 包中定义了 Locker 结构来代表锁。 type Locker interface { Lock() Unlock() } 并且创造了两个结构来实现 Locker 接口：Mutex 和 RWMutex。 Mutex 就是互斥锁，互斥锁代表着当数据被加锁了之后，除了加锁的程序，其他程序不能对数据进行读操作和写操作。 这个当然能解决并发程序对资源的操作。但是，效率上是个问题。当加锁后，其他程序要读取操作数据，就只能进行等待了。 这个时候就需要使用读写锁。 读写锁分为读锁和写锁，读数据的时候上读锁，写数据的时候上写锁。有写锁的时候，数据不可读不可写。有读锁的时候，数据可读，不可写。 互斥锁就不举例子，读写锁可以看下面的例子： package main import ( \"sync\" \"time\" ) var m *sync.RWMutex var val = 0 func main() { m = new(sync.RWMutex) go read(1) go write(2) go read(3) time.Sleep(5 * time.Second) } func read(i int) { m.RLock() time.Sleep(1 * time.Second) println(\"val: \", val) time.Sleep(1 * time.Second) m.RUnlock() } func write(i int) { m.Lock() val = 10 time.Sleep(1 * time.Second) m.Unlock() } 返回： val: 0 val: 10 但是如果我们把 read 中的 RLock 和 RUnlock 两个函数给注释了，就返回了 : val: 10 val: 10 这个就是由于读的时候没有加读锁，在准备读取 val 的时候，val 被 write 函数进行修改了。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:153:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"临时对象池 当多个 goroutine 都需要创建同一个对象的时候，如果 goroutine 过多，可能导致对象的创建数目剧增。 而对象又是占用内存的，进而导致的就是内存回收的 GC 压力徒增。造成“并发大－占用内存大－ GC 缓慢－处理并发能力降低－并发更大”这样的恶性循环。 在这个时候，我们非常迫切需要有一个对象池，每个 goroutine 不再自己单独创建对象，而是从对象池中获取出一个对象（如果池中已经有的话）。 这就是 sync.Pool 出现的目的了。 sync.Pool 的使用非常简单，提供两个方法 :Get 和 Put 和一个初始化回调函数 New。 看下面这个例子（取自gomemcache）： // keyBufPool returns []byte buffers for use by PickServer's call to // crc32.ChecksumIEEE to avoid allocations. (but doesn't avoid the // copies, which at least are bounded in size and small) var keyBufPool = sync.Pool{ New: func() interface{} { b := make([]byte, 256) return \u0026b }, } func (ss *ServerList) PickServer(key string) (net.Addr, error) { ss.mu.RLock() defer ss.mu.RUnlock() if len(ss.addrs) == 0 { return nil, ErrNoServers } if len(ss.addrs) == 1 { return ss.addrs[0], nil } bufp := keyBufPool.Get().(*[]byte) n := copy(*bufp, key) cs := crc32.ChecksumIEEE((*bufp)[:n]) keyBufPool.Put(bufp) return ss.addrs[cs%uint32(len(ss.addrs))], nil } 这是实际项目中的一个例子，这里使用 keyBufPool 的目的是为了让 crc32.ChecksumIEEE 所使用的[]bytes 数组可以重复使用，减少 GC 的压力。 但是这里可能会有一个问题，我们没有看到 Pool 的手动回收函数。 那么是不是就意味着，如果我们的并发量不断增加，这个 Pool 的体积会不断变大，或者一直维持在很大的范围内呢？ 答案是不会的，sync.Pool 的回收是有的，它是在系统自动 GC 的时候，触发 pool.go 中的 poolCleanup 函数。 func poolCleanup() { for i, p := range allPools { allPools[i] = nil for i := 0; i \u003c int(p.localSize); i++ { l := indexLocal(p.local, i) l.private = nil for j := range l.shared { l.shared[j] = nil } l.shared = nil } p.local = nil p.localSize = 0 } allPools = []*Pool{} } 这个函数会把 Pool 中所有 goroutine 创建的对象都进行销毁。 那这里另外一个问题也凸显出来了，很可能我上一步刚往 pool 中 PUT 一个对象之后，下一步 GC 触发，导致 pool 的 GET 函数获取不到 PUT 进去的对象。 这个时候，GET 函数就会调用 New 函数，临时创建出一个对象，并存放到 pool 中。 根据以上结论，sync.Pool 其实不适合用来做持久保存的对象池（比如连接池）。它更适合用来做临时对象池，目的是为了降低 GC 的压力。 连接池性能测试 package main import ( \"sync\" \"testing\" ) var bytePool = sync.Pool{ New: newPool, } func newPool() interface{} { b := make([]byte, 1024) return \u0026b } func BenchmarkAlloc(b *testing.B) { for i := 0; i \u003c b.N; i++ { obj := make([]byte, 1024) _ = obj } } func BenchmarkPool(b *testing.B) { for i := 0; i \u003c b.N; i++ { obj := bytePool.Get().(*[]byte) _ = obj bytePool.Put(obj) } } 文件目录下执行 go test -bench . E:\\MyGo\\sync\u003ego test -bench . testing: warning: no tests to run PASS BenchmarkAlloc-4 50000000 39.3 ns/op BenchmarkPool-4 50000000 25.4 ns/op ok _/E_/MyGo/sync 3.345s 通过性能测试可以清楚地看到，使用连接池消耗的 CPU 时间远远小于每次手动分配内存。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:154:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Once 有的时候，我们多个 goroutine 都要过一个操作，但是这个操作我只希望被执行一次，这个时候 Once 就上场了。比如下面的例子 : package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var once sync.Once onceBody := func() { fmt.Println(\"Only once\") } for i := 0; i \u003c 10; i++ { go func() { once.Do(onceBody) }() } time.Sleep(3e9) } 只会打出一次 “Only once”。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:155:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"WaitGroup 和 Cond 一个 goroutine 需要等待一批 goroutine 执行完毕以后才继续执行，那么这种多线程等待的问题就可以使用 WaitGroup 了。 package main import ( \"fmt\" \"sync\" ) func main() { wp := new(sync.WaitGroup) wp.Add(10); for i := 0; i \u003c 10; i++ { go func() { fmt.Println(\"done \", i) wp.Done() }() } wp.Wait() fmt.Println(\"wait end\") } 还有个 sync.Cond 是用来控制某个条件下，goroutine 进入等待时期，等待信号到来，然后重新启动。比如： package main import ( \"fmt\" \"sync\" \"time\" ) func main() { locker := new(sync.Mutex) cond := sync.NewCond(locker) done := false cond.L.Lock() go func() { time.Sleep(2e9) done = true cond.Signal() }() if (!done) { cond.Wait() } fmt.Println(\"now done is \", done); } 这里当主 goroutine 进入 cond.Wait 的时候，就会进入等待，当从 goroutine 发出信号之后，主 goroutine 才会继续往下面走。 sync.Cond 还有一个 BroadCast 方法，用来通知唤醒所有等待的 gouroutine。 package main import ( \"fmt\" \"sync\" \"time\" ) var locker = new(sync.Mutex) var cond = sync.NewCond(locker) func test(x int) { cond.L.Lock() // 获取锁 cond.Wait() // 等待通知 暂时阻塞 fmt.Println(x) time.Sleep(time.Second * 1) cond.L.Unlock() // 释放锁，不释放的话将只会有一次输出 } func main() { for i := 0; i \u003c 40; i++ { go test(i) } fmt.Println(\"start all\") cond.Broadcast() // 下发广播给所有等待的 goroutine time.Sleep(time.Second * 60) } 主 gouroutine 开启后，可以创建多个从 gouroutine，从 gouroutine 获取锁后，进入 cond.Wait 状态，当主 gouroutine 执行完任务后，通过 BroadCast 广播信号。 处于 cond.Wait 状态的所有 gouroutine 收到信号后将全部被唤醒并往下执行。需要注意的是，从 gouroutine 执行完任务后，需要通过 cond.L.Unlock 释放锁， 否则其它被唤醒的 gouroutine 将没法继续执行。 通过查看 cond.Wait 的源码就明白为什么需要需要释放锁了 func (c *Cond) Wait() { c.checker.check() if raceenabled { raceDisable() } atomic.AddUint32(\u0026c.waiters, 1) if raceenabled { raceEnable() } c.L.Unlock() runtime_Syncsemacquire(\u0026c.sema) c.L.Lock() } Cond.Wait 会自动释放锁等待信号的到来，当信号到来后，第一个获取到信号的 Wait 将继续往下执行并从新上锁，如果不释放锁， 其它收到信号的 gouroutine 将阻塞无法继续执行。 由于各个 Wait 收到信号的时间是不确定的，因此每次的输出顺序也都是随机的。 sync/atomic - 原子操作 对于并发操作而言，原子操作是个非常现实的问题。典型的就是 i++ 的问题。 当两个 CPU 同时对内存中的 i 进行读取，然后把加一之后的值放入内存中，可能两次 i++ 的结果，这个 i 只增加了一次。 如何保证多 CPU 对同一块内存的操作是原子的。 golang 中 sync/atomic 就是做这个使用的。 具体的原子操作在不同的操作系统中实现是不同的。比如在 Intel 的 CPU 架构机器上，主要是使用总线锁的方式实现的。 大致的意思就是当一个 CPU 需要操作一个内存块的时候，向总线发送一个 LOCK 信号，所有 CPU 收到这个信号后就不对这个内存块进行操作了。 等待操作的 CPU 执行完操作后，发送 UNLOCK 信号，才结束。 在 AMD 的 CPU 架构机器上就是使用 MESI 一致性协议的方式来保证原子操作。 所以我们在看 atomic 源码的时候，我们看到它针对不同的操作系统有不同汇编语言文件。 如果我们善用原子操作，它会比锁更为高效。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:156:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"CAS 原子操作中最经典的 CAS(compare-and-swap) 在 atomic 包中是 Compare 开头的函数。 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) CAS 的意思是判断内存中的某个值是否等于 old 值，如果是的话，则赋 new 值给这块内存。CAS 是一个方法，并不局限在 CPU 原子操作中。 CAS 比互斥锁乐观，但是也就代表 CAS 是有赋值不成功的时候，调用 CAS 的那一方就需要处理赋值不成功的后续行为了。 这一系列的函数需要比较后再进行交换，也有不需要进行比较就进行交换的原子操作。 func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:157:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"增加或减少 对一个数值进行增加或者减少的行为也需要保证是原子的，它对应于 atomic 包的函数就是 func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:158:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"读取或写入 当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。在 atomic 包中就是 Load 开头的函数群。 func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) 好了，读取我们是完成了原子性，那写入呢？也是同样的，如果有多个 CPU 往内存中一个数据块写入数据的时候，可能导致这个写入的数据不完整。 在 atomic 包对应的是 Store 开头的函数群。 func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) os/signal - 信号 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:159:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"基本概念 信号是事件发生时对进程的通知机制。有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号到达的精确时间。 因为一个具有合适权限的进程可以向另一个进程发送信号，这可以称为进程间的一种同步技术。当然，进程也可以向自身发送信号。然而，发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令（除 0，引用无法访问的内存区域）。 用户键入了能够产生信号的终端特殊字符。如中断字符（通常是 Control-C）、暂停字符（通常是 Control-Z）。 发生了软件事件。如调整了终端窗口大小，定时器到期等。 针对每个信号，都定义了一个唯一的（小）整数，从 1 开始顺序展开。系统会用相应常量表示。Linux 中，1-31 为标准信号；32-64 为实时信号（通过 kill -l 可以查看）。 信号达到后，进程视具体信号执行如下默认操作之一。 忽略信号，也就是内核将信号丢弃，信号对进程不产生任何影响。 终止（杀死）进程。 产生 coredump 文件，同时进程终止。 暂停（Stop）进程的执行。 恢复进程执行。 当然，对于有些信号，程序是可以改变默认行为的，这也就是 os/signal 包的用途。 兼容性问题：信号的概念来自于 Unix-like 系统。Windows 下只支持 os.SIGINT 信号。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:160:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Go 对信号的处理 程序无法捕获信号 SIGKILL 和 SIGSTOP （终止和暂停进程），因此 os/signal 包对这两个信号无效。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:161:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Go 程序对信号的默认行为 Go 语言实现了自己的运行时，因此，对信号的默认处理方式和普通的 C 程序不太一样。 SIGBUS（总线错误）, SIGFPE（算术错误）和 SIGSEGV（段错误）称为同步信号，它们在程序执行错误时触发，而不是通过 os.Process.Kill 之类的触发。通常，Go 程序会将这类信号转为 run-time panic。 SIGHUP（挂起）, SIGINT（中断）或 SIGTERM（终止）默认会使得程序退出。 SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT 或 SIGSYS 默认会使得程序退出，同时生成 stack dump。 SIGTSTP, SIGTTIN 或 SIGTTOU，这是 shell 使用的，作业控制的信号，执行系统默认的行为。 SIGPROF（性能分析定时器，记录 CPU 时间，包括用户态和内核态）， Go 运行时使用该信号实现 runtime.CPUProfile。 其他信号，Go 捕获了，但没有做任何处理。 信号可以被忽略或通过掩码阻塞（屏蔽字 mask）。忽略信号通过 signal.Ignore，没有导出 API 可以直接修改阻塞掩码，虽然 Go 内部有实现 sigprocmask 等。Go 中的信号被 runtime 控制，在使用时和 C 是不太一样的。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:161:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"改变信号的默认行为 这就是 os/signal 包的功能。 Notify 改变信号处理，可以改变信号的默认行为；Ignore 可以忽略信号；Reset 重置信号为默认行为；Stop 则停止接收信号，但并没有重置为默认行为。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:161:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"SIGPIPE 文档中对这个信号单独进行了说明。如果 Go 程序往一个 broken pipe 写数据，内核会产生一个 SIGPIPE 信号。 如果 Go 程序没有为 SIGPIPE 信号调用 Notify，对于标准输出或标准错误（文件描述符 1 或 2），该信号会使得程序退出；但其他文件描述符对该信号是啥也不做，当然 write 会返回错误 EPIPE。 如果 Go 程序为 SIGPIPE 调用了 Notify，不论什么文件描述符，SIGPIPE 信号都会传递给 Notify channel，当然 write 依然会返回 EPIPE。 也就是说，默认情况下，Go 的命令行程序跟传统的 Unix 命令行程序行为一致；但当往一个关闭的网络连接写数据时，传统 Unix 程序会 crash，但 Go 程序不会。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:161:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"cgo 注意事项 如果非 Go 代码使用信号相关功能，需要仔细阅读掌握 os/signal 包中相关文档：Go programs that use cgo or SWIG 和 Non-Go programs that call Go code ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:161:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"signal 中 API 详解 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:0","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Ignore 函数 func Ignore(sig ...os.Signal) 忽略一个、多个或全部（不提供任何信号）信号。如果程序接收到了被忽略的信号，则什么也不做。对一个信号，如果先调用 Notify，再调用 Ignore，Notify 的效果会被取消；如果先调用 Ignore，在调用 Notify，接着调用 Reset/Stop 的话，会回到 Ingore 的效果。注意，如果 Notify 作用于多个 chan，则 Stop 需要对每个 chan 都调用才能起到该作用。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:1","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Notify 函数 func Notify(c chan\u003c- os.Signal, sig ...os.Signal) 类似于绑定信号处理程序。将输入信号转发到 chan c。如果没有列出要传递的信号，会将所有输入信号传递到 c；否则只传递列出的输入信号。 channel c 缓存如何决定？因为 signal 包不会为了向 c 发送信息而阻塞（就是说如果发送时 c 阻塞了，signal 包会直接放弃）：调用者应该保证 c 有足够的缓存空间可以跟上期望的信号频率。对使用单一信号用于通知的 channel，缓存为 1 就足够了。 相关源码： // src/os/signal/signal.go process 函数\rfor c, h := range handlers.m {\rif h.want(n) {\r// send but do not block for it\rselect {\rcase c \u003c- sig:\rdefault: // 保证不会阻塞，直接丢弃\r}\r}\r}\r可以使用同一 channel 多次调用 Notify：每一次都会扩展该 channel 接收的信号集。唯一从信号集去除信号的方法是调用 Stop。可以使用同一信号和不同 channel 多次调用 Notify：每一个 channel 都会独立接收到该信号的一个拷贝。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:2","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Stop 函数 func Stop(c chan\u003c- os.Signal) 让 signal 包停止向 c 转发信号。它会取消之前使用 c 调用的所有 Notify 的效果。当 Stop 返回后，会保证 c 不再接收到任何信号。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:3","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"Reset 函数 func Reset(sig ...os.Signal) 取消之前使用 Notify 对信号产生的效果；如果没有参数，则所有信号处理都被重置。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:4","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"使用示例 注：syscall 包中定义了所有的信号常量 package main\rimport (\r\"fmt\"\r\"os\"\r\"os/signal\"\r\"syscall\"\r)\rvar firstSigusr1 = true\rfunc main() {\r// 忽略 Control-C (SIGINT)\r// os.Interrupt 和 syscall.SIGINT 是同义词\rsignal.Ignore(os.Interrupt)\rc1 := make(chan os.Signal, 2)\r// Notify SIGHUP\rsignal.Notify(c1, syscall.SIGHUP)\r// Notify SIGUSR1\rsignal.Notify(c1, syscall.SIGUSR1)\rgo func() {\rfor {\rswitch \u003c-c1 {\rcase syscall.SIGHUP:\rfmt.Println(\"sighup, reset sighup\")\rsignal.Reset(syscall.SIGHUP)\rcase syscall.SIGUSR1:\rif firstSigusr1 {\rfmt.Println(\"first usr1, notify interrupt which had ignore!\")\rc2 := make(chan os.Signal, 1)\r// Notify Interrupt\rsignal.Notify(c2, os.Interrupt)\rgo handlerInterrupt(c2)\r}\r}\r}\r}()\rselect {}\r}\rfunc handlerInterrupt(c \u003c-chan os.Signal) {\rfor {\rswitch \u003c-c {\rcase os.Interrupt:\rfmt.Println(\"signal interrupt\")\r}\r}\r}\r编译后运行，先后给该进程发送如下信号：SIGINT、SIGUSR1、SIGINT、SIGHUP、SIGHUP，看输出是不是和你预期的一样。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:5","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["golang"],"content":"关于信号的额外说明 查看 Go 中 Linux/amd64 信号的实现，发现大量使用的是 rt 相关系统调用，这是支持实时信号处理的 API。 C 语言中信号处理涉及到可重入函数和异步信号安全函数问题；Go 中不存在此问题。 Unix 和信号处理相关的很多系统调用，Go 都隐藏起来了，Go 中对信号的处理，signal 包中的函数基本就能搞定。 ","date":"2024-06-13","objectID":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/:162:6","tags":["golang"],"title":"Golang标准库例子","uri":"/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%8B%E5%AD%90/"},{"categories":["WeChat"],"content":"微信数据库解密 ","date":"2024-04-23","objectID":"/%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%AF%86/:0:0","tags":["WeChat"],"title":"微信数据库解密","uri":"/%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%AF%86/"},{"categories":["WeChat"],"content":"介绍 微信数据库采用的加密算法是256位的AES-CBC。数据库的默认的页大小是4096字节即4KB，其中每一个页都是被单独加解密的。加密文件的每一个页都有一个随机的初始化向量，它被保存在每一页的末尾。加密文件的每一页都存有着消息认证码，算法使用的是HMAC-SHA1（安卓数据库使用的是SHA512）。它也被保存在每一页的末尾。每一个数据库文件的开头16字节都保存了一段唯一且随机的盐值，作为HMAC的验证和数据的解密。用来计算HMAC的key与解密的key是不同的，解密用的密钥是主密钥和之前提到的16字节的盐值通过PKCS5_PBKF2_HMAC1密钥扩展算法迭代64000次计算得到的。而计算HMAC的密钥是刚提到的解密密钥和16字节盐值异或0x3a的值通过PKCS5_PBKF2_HMAC1密钥扩展算法迭代2次计算得到的。为了保证数据部分长度是16字节即AES块大小的整倍数，每一页的末尾将填充一段空字节，使得保留字段的长度为48字节。综上，加密文件结构为第一页4KB数据前16字节为盐值，紧接着4032字节数据，再加上16字节IV和20字节HMAC以及12字节空字节；而后的页均是4048字节长度的加密数据段和48字节的保留段。 ","date":"2024-04-23","objectID":"/%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%AF%86/:1:0","tags":["WeChat"],"title":"微信数据库解密","uri":"/%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%AF%86/"},{"categories":["WeChat"],"content":"数据库结构 MSG（聊天记录核心数据库）,字段如下： localId：字面意思消息在本地的 ID，暂未发现其功用 TalkerId：消息所在房间的 ID（该信息为猜测，猜测原因见 StrTalker 字段），与Name2ID对应。 MsgSvrID：猜测 Srv 可能是 Server 的缩写，代指服务器端存储的消息 ID Type：消息类型，具体对照见表1 SubType：消息类型子分类，暂时未见其实际用途 IsSender：是否是自己发出的消息，也就是标记消息展示在对话页左边还是右边，取值0或1 CreateTime：消息创建时间的秒级时间戳。此处需要进一步实验来确认该时间具体标记的是哪个时间节点，个人猜测的规则如下： 从这台电脑上发出的消息：标记代表的是每个消息点下发送按钮的那一刻 从其它设备上发出的/收到的来自其它用户的消息：标记的是本地从服务器接收到这一消息的时间 Sequence：次序，虽然看起来像一个毫秒级时间戳但其实不是。这是CreateTime 字段末尾接上三位数字组成的，通常情况下为000，如果在出现两条- CreateTime 相同的消息则最后三位依次递增。需要进一步确认不重复范围是在一个会话内还是所有会话。CreateTime 相同的消息则最后三位依次递增。需要进一步确认不重复范围是在一个会话内还是所有会话。 StatusEx、FlagEx、Status、MsgServerSeq、MsgSequence：这五个字段个人暂时没有分析出有效信息 StrTalker：消息发送者的微信号。特别说明，从这里来看的话，上面的TalkerId 字段大概率是指的消息所在的房间ID，而非发送者ID，当然也可能和TalkerId属于重复内容，这一点待确认。 StrContent：字符串格式的数据。特别说明的是，除了文本类型的消息外，别的大多类型这一字段都会是一段 XML 数据标记一些相关信息。通过解析xml可以得到更多的信息，例如图片的宽高、语音的时长等等。 DisplayContent：对于拍一拍，保存拍者和被拍者账号信息 Reserved0~6：这些字段也还没有分析出有效信息，也有的字段恒为空 CompressContent：字面意思是压缩的数据，实际上也就是微信任性不想存在 StrContent 里的数据在这里（例如带有引用的文本消息等；采用lz4压缩算法压缩） BytesExtra：额外的二进制格式数据 BytesTrans：目前看这是一个恒为空的字段 表1：MSG.Type字段数值与含义对照表（可能可以扩展到其它数据库中同样标记消息类型这一信息的字段） 分类Type 子分类SubType 对应类型 1 0 文本 3 0 图片 34 0 语音 43 0 视频 47 0 动画表情（第三方开发的表情包） 49 1 类似文字消息而不一样的消息，目前只见到一个阿里云盘的邀请注册是这样的。估计和57子类的情况一样 49 5 卡片式链接，CompressContent 中有标题、简介等，BytesExtra 中有本地缓存的封面路径 49 6 文件，CompressContent 中有文件名和下载链接（但不会读），BytesExtra 中有本地保存的路径 49 8 用户上传的 GIF 表情，CompressContent 中有CDN链接，不过似乎不能直接访问下载 49 19 合并转发的聊天记录，CompressContent 中有详细聊天记录，BytesExtra 中有图片视频等的缓存 49 33/36 分享的小程序，CompressContent 中有卡片信息，BytesExtra 中有封面缓存位置 49 57 带有引用的文本消息（这种类型下 StrContent 为空，发送和引用的内容均在 CompressContent 中） 49 63 视频号直播或直播回放等 49 87 群公告 49 88 视频号直播或直播回放等 49 2000 转账消息（包括发出、接收、主动退还） 49 2003 赠送红包封面 10000 0 系统通知（居中出现的那种灰色文字） 10000 4 拍一拍 10000 8000 系统通知（特别包含你邀请别人加入群聊） ","date":"2024-04-23","objectID":"/%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%AF%86/:2:0","tags":["WeChat"],"title":"微信数据库解密","uri":"/%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%AF%86/"},{"categories":["Golang"],"content":"Golang内存模型 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:0:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"介绍 Golang内存模型是Golang程序员必须了解的一个重要概念，它定义了Golang程序中的内存访问规则，保证了Golang程序的正确性。Golang内存模型是基于happens-before关系的，happens-before关系是一个偏序关系，它定义了程序中事件的顺序关系。在Golang内存模型中，happens-before关系定义了内存访问的顺序关系，保证了Golang程序的正确性。 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"happens-before关系 happens-before是很多语言都拥有的一个术语，定义通常是：假设A和B表示一个多线程的程序执行的两个操作。如果A happens-before B，那么A操作对内存的影响 将对执行B的线程(且执行B之前)可见。 它有几个特点： A happens-before B并不意味着A在B之前发生 A在B之前发生并不意味着A happens-before B 具有传递性：如果A happens-before B，B happens-before C，那么A happens-before C 注意：happens-before并不是指时序关系，并不是说A happens-before B就表示操作A在操作B之前发生，它就是一个术语，就像光年不是时间单位一样 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"happens-before关系在Golang中的场景定义 如果操作A和B在相同的线程中执行，并且A操作的声明在B之前，那么A happens-before B。（这条规则基本上大部分语言都适用） 初始化：main.init happens-before main.main goroutine：如果操作A是一个goroutine的创建操作，操作B是对应goroutine的启动操作，那么A happens-before B。 goroutine：如果操作A是一个goroutine的启动操作，操作B是对应goroutine的销毁操作，那么A happens-before B。 channel：如果 ch 是一个 buffered channel，则 ch\u003c-val(写) happens-before val \u003c- ch(读) channel: 如果 ch 是一个 buffered channel 则 close(ch) happens-before val \u003c- ch(读) \u0026 val == isZero(val) channel: 如果 ch 是一个 unbuffered channel 则，val\u003c-ch(读) happens-before ch\u003c-val(写) once: f() 在 once.Do(f)中的调用 happens-before once.Do(f)的返回 ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:3:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"实例 package main var a string var done bool func setup() { a = \"hello, world\" done = true } func main() { go setup() for !done { } print(a) } 问：上面的代码会输出什么？\r1. 第一种情况：输出hello, world\r2. 第三种情况：输出空字符串\r3. 第二种情况：死循环\r","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:4:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"参考链接 https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html https://go.cyub.vip/concurrency/memory-model/ https://research.swtch.com/plmm https://go.dev/ref/mem https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/mem/ ","date":"2024-04-18","objectID":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:5:0","tags":["内存模型"],"title":"Golang内存模型","uri":"/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Debian","Btrfs"],"content":"Debian Sid配置Btrfs文件系统 ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"安装Debian Testing 安装时选择Advanced options -\u003e Expert install 当提示“设置用户和密码”时，不允许以 root 身份登录。这样我们的用户将被自动设置在“sudo”组中。 其他选择和正常安装一样，直到到达Partition disks(磁盘分区)界面，选择手动分区 选择gpt 创建一个EFI分区，大小为512M，文件系统为EFI System Partition 创建一个/boot分区，大小为1024M，文件系统为ext4（如果需要加密则创建此分区） 剩下的空间创建一个根分区，文件系统为btrfs，分区完成。 当询问是否要返回并创建 SWAP 分区时，选择“否”，我们不需要磁盘上的 SWAP 分区，因为我们将使用 ZRAM 进行 SWAP 在选择Install the base system之前，按alt+ctrl+F2(笔记本可能是： alt+ctrl+fn+F2)切换到tty2，执行以下命令 df umount /target/boot/efi/ # 可选 umount /target/boot/ umount /target/ # 根据df命令选择对应的分区 mount /dev/sda2 /mnt cd /mnt mv @rootfs @ # 创建其他子卷 btrfs su cr @snapshots btrfs su cr @home btrfs su cr @opt btrfs su cr @log btrfs su cr @cache btrfs su cr @crash btrfs su cr @tmp btrfs su cr @spool btrfs su cr @images btrfs su cr @containers # GNOME related subvolumes，如果不使用GNOME则不需要，在安装gnome桌面前不能挂载此2个子卷，否则会出现fstab挂载错误 btrfs su cr @AccountsService btrfs su cr @gdm # 挂载子卷 mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@ /dev/mapper/sda2 /target # 创建其他子卷挂载目录 cd /target mkdir -p .snapshots mkdir -p home mkdir -p opt mkdir -p var/log mkdir -p var/cache mkdir -p var/crash mkdir -p var/tmp mkdir -p var/spool mkdir -p var/lib/libvirt/images mkdir -p var/lib/containers # 如果不安装GNOME则不需要此步骤 mkdir -p var/lib/AccountsService mkdir -p var/lib/gdm3 # 挂载子卷到指定目录 mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@snapshots /dev/mapper/sda2 /target/.snapshots mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@home /dev/mapper/sda2 /target/home mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@home /dev/mapper/sda2 /target/opt mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@log /dev/mapper/sda2 /target/var/log mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@cache /dev/mapper/sda2 /target/var/cache mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@crash /dev/mapper/sda2 /target/var/crash mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@tmp /dev/mapper/sda2 /target/var/tmp mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@spool /dev/mapper/sda2 /target/var/spool mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@images /dev/mapper/sda2 /target/var/lib/libvirt/images mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@containers /dev/mapper/sda2 /target/var/lib/containers # 下面两个步骤先不执行，等安装GNOME桌面后再执行 # mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@AccountsService /dev/mapper/sda2 /target/var/lib/AccountsService # mount -o noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@gdm /dev/mapper/sda2 /target/var/lib/gdm3 # 再挂载BOOT分区，EFI分区 # mount /dev/sda2 boot mount /dev/sda1 boot/efi # 持久化挂载 nano etc/fstab /dev/mapper/$VOLUME_GROUP / btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@ 0 0 /dev/mapper/$VOLUME_GROUP /.snapshots btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@snapshots 0 0 /dev/mapper/$VOLUME_GROUP /home btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@home 0 0 /dev/mapper/$VOLUME_GROUP /opt btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@opt 0 0 /dev/mapper/$VOLUME_GROUP /var/log btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@log 0 0 /dev/mapper/$VOLUME_GROUP /var/cache btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@cache 0 0 /dev/mapper/$VOLUME_GROUP /var/crash btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@crash 0 0 /dev/mapper/$VOLUME_GROUP /var/tmp btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@tmp 0 0 /dev/mapper/$VOLUME_GROUP /var/spool btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@spool 0 0 /dev/mapper/$VOLUME_GROUP /var/lib/libvirt/images btrfs noatime,space_cache=v2,compress=zstd:1,ssd,discard=async,subvol=@images 0 0 /","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"配置ZRAM 执行命令安装zram sudo apt update \u0026\u0026 sudo apt upgrade sudo apt install zram-tools 更改配置文件sudo nano /etc/default/zramswap将ALGORITHM改为zstd，将SIZE改为8192(即8GB)的内存大小 ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"配置Snapper 安装工具 sudo apt install snapper inotify-tools git make 执行配置 # 因为snapper创建配置时会在当前执行目录下面一个.snapshots子卷和.snapshots目录，而我们希望将/.snapshots挂载到@shapshots子卷，所以需要先卸载@shapshots子卷 cd sudo umount /.snapshots sudo rm -rf .snapshots # 创建配置 sudo snapper -c root create-config / # 删除snapper自己创建/.snapshots子卷,并将/.snapshots挂载到@snapshots子卷 sudo btrfs subvolume delete /.snapshots sudo mkdir /.snapshots sudo mount -av 配置Snapper自动快照 关闭开机快照 sudo systemctl disable snapper-boot.timer 关闭timeline快照 sudo snapper -c root set-config 'TIMELINE_CREATE=no' 开启apt pre/post快照,并优化打印信息 snapper会自动开启apt pre/post快照，但是默认打印命令不够详细，可以通过以下命令优化 3.1 修改/etc/apt/apt.conf.d/80snapper文件内容为 # https://gist.github.com/imthenachoman/f722f6d08dfb404fed2a3b2d83263118 # https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=770938 DPkg::Pre-Invoke { \"/path/to/dpkg-pre-post-snapper.sh pre\"; }; DPkg::Post-Invoke { \"/path/to/dpkg-pre-post-snapper.sh post\"; }; 3.2 创建/path/to/dpkg-pre-post-snapper.sh文件内容为 #!/bin/bash # this script is an enhancement of https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=770938 # we need to work up the process tree to find the apt command that triggered the call to this script # get the initial PID PID=$$ # find the apt command by working up the process tree # loop until # - PID is empty # - PID is 1 # - or PID command is apt while [[ -n \"$PID\" \u0026\u0026 \"$PID\" != \"1\" \u0026\u0026 \"$(ps -ho comm \"${PID}\")\" != \"apt\" ]] ; do # the current PID is not the apt command so go up one by getting the parent PID of hte current PID PID=$(ps -ho ppid \"$PID\" | xargs) done SNAPPER_DESCRIPTION=\"apt\" # assuming we found the apt command, get the full args if [[ \"$(ps -ho comm \"${PID}\")\" = \"apt\" ]] ; then SNAPPER_DESCRIPTION=\"$(ps -ho args \"${PID}\")\" fi # main event # source /etc/default/snapper if it exists if [ -e /etc/default/snapper ] ; then . /etc/default/snapper fi # what action are we taking if [ \"$1\" = \"pre\" ] ; then # pre, so take a pre snapshot # if snapper is installed # and if snapper snapshots are not being disabled using the DISABLE_APT_SNAPSHOT variable # and if /etc/snapper/configs/root exists if [ -x /usr/bin/snapper ] \u0026\u0026 [ ! x$DISABLE_APT_SNAPSHOT = 'xyes' ] \u0026\u0026 [ -e /etc/snapper/configs/root ] ; then # delete any lingering temp files rm -f /var/tmp/snapper-apt || true # create a snapshot # and save the snapshot number for reference later snapper create -d \"${SNAPPER_DESCRIPTION}\" -c number -t pre -p \u003e /var/tmp/snapper-apt || true # clean up snapper snapper cleanup number || true fi elif [ \"$1\" = \"post\" ] ; then # post, so take a post snapshot # if snapper is installed # and if snapper snapshots are not being disabled using the DISABLE_APT_SNAPSHOT variable # and if the temp file with the snapshot number from the pre snapshot exists if [ -x /usr/bin/snapper ] \u0026\u0026 [ ! x$DISABLE_APT_SNAPSHOT = 'xyes' ] \u0026\u0026 [ -e /var/tmp/snapper-apt ] then # take a post snapshot and link it to the # of the pre snapshot snapper create -d \"${SNAPPER_DESCRIPTION}\" -c number -t post --pre-number=`cat /var/tmp/snapper-apt` || true # clean up snapper snapper cleanup number || true fi fi 配置sudo使用snapper使用权限 sudo snapper -c root set-config 'ALLOW_GROUPS=sudo' 'SYNC_ACL=yes' 配置GRUB-BTRFS 5.1 安装 GRUB-BTRFS在Debian上不可用,所以需要编译安装 cd git clone https://github.com/Antynea/grub-btrfs.git cd grub-btrfs sudo make install 5.2 配置 # To start the daemon run: sudo systemctl start grub-btrfsd # To activate it during system startup, run: sudo systemctl enable grub-btrfsd 5.3 下载的grub-btrfs代码可以清除了 cd .. sudo rm -rf grub-btrfs/ grub-btrfs可以在GRUB中显示当前系统中的所有快照,如果系统出问题了,可以从grub选择之前正常的快照回滚到可以正常启动的系统 ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Debian","Btrfs"],"content":"安装Gnome桌面 sudo apt install gnome-core ","date":"2024-03-30","objectID":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:4:0","tags":["btrfs"],"title":"Debian配置Btrfs文件系统","uri":"/debian%E9%85%8D%E7%BD%AEbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["kotlin"],"content":"Kotlin程序设计初级篇 注意： 在开始学习之前，推荐各位小伙伴有一定的编程语言基础，前置课程：《JavaSE 教程》或《C 语言程序设计》如果没有其他语言的基础，在学习Kotlin时会非常吃力，这门语言语法糖多到爆炸。 Kotlin是一种现代但已经成熟的编程语言，旨在让开发人员更快乐。它简洁、安全、可与Java和其他语言互操作，并提供了许多在多个平台之间重用代码的方法。它由JetBrains公司于2011年设计和开发，并在2016年正式发布。Kotlin旨在解决Java语言在编码效率和代码质量方面存在的问题，并且与Java语言完全兼容。Kotlin通过简化语法、提供更强大的功能以及减少样板代码的编写，使得开发者能够更高效地编写清晰、简洁而又安全的代码。 Kotlin语言名字的来源是基于一个古老斯拉夫部落的名字。JetBrains开发Kotlin的初衷是为了在Android开发上取代Java，并且作为一门通用的编程语言。Kotlin通过减少样板代码和增加现代化的语言特性，提供了更好的工具和库来简化Android应用开发。由于Kotlin的设计理念和特性吸引了广泛的开发者关注，它也迅速被接受并得到了广泛的使用。现在，Kotlin已成为一门流行的编程语言，被许多开发者用于Android应用开发、服务器端开发以及其他领域的软件开发中。 官方网站：https://www.jetbrains.com/opensource/kotlin/ Kotlin 是一种现代化的静态类型编程语言，具有以下优势： 与Java互操作性强：Kotlin 可以与现有的 Java 代码无缝地互操作，允许开发者在现有的项目中逐步采用 Kotlin，而不需要重写整个项目。这使得 Kotlin 成为 Android 应用开发的理想选择。 简洁易读：Kotlin 的语法简洁并具有更好的可读性，减少了样板代码的编写。相比 Java，Kotlin 可以使用更少的代码来实现同样的功能，从而提高开发效率。 空安全性：Kotlin 对空值进行了更好的处理。在 Kotlin 中，变量默认是非空的，如果需要使用可能为空的值，需要显式声明类型为可空。这有助于减少空指针异常的发生。 函数式编程支持：Kotlin 支持函数式编程的特性，如高阶函数、lambda 表达式和函数式编程的集合操作等。这些特性可以让开发者编写更简洁、可维护的代码，并提高代码的表达能力。 扩展函数：Kotlin 允许开发者为某个类添加新的方法，而不需要修改该类的源代码。这种扩展函数的特性可以为开发者提供更灵活的方式来扩展现有的类库。 协程支持：Kotlin 引入了协程（coroutine）机制，使得异步操作更易于管理和编写。通过使用协程，开发者可以使用顺序的方式编写并发代码，并避免了回调地狱的问题。 总的来说，Kotlin 是一门功能丰富、可读性高、与 Java 无缝互操作的编程语言，适用于 Android、Web 后端开发等多种场景。 正是因为Kotlin与Java的高度兼容性，再加上简洁、安全、互操作性强等特点，让Kotlin一度成为Android开发的官方指定语言。并且随着时代的发展，现在它不仅仅可以开发安卓应用程序，也可以开发iOS程序，甚至开发Java后端、开发桌面应用程序等。其简洁高效的语法也受到一众开发者追捧。 从下节课开始，我们就来正式学习一下Kotlin语言，Kotlin，启动！ ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:0:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"走进新语言 欢迎大家进入到Kotlin程序设计的学习中，我们将从开发环境配置开始，为各位小伙伴讲解。 编程语言可以被视为人与计算机之间进行交流的方式。它是一种用于编写计算机程序的形式化语言，用于描述计算机任务的操作步骤、算法和数据结构。简单来说，就是以计算机能听懂的语言告诉计算机我们要做什么，然后让计算机来做我们想做的事情，从而解决我们生活中各种各样的问题。 编程语言可以分为多种类型，包括低级语言和高级语言。低级语言（如汇编语言）与计算机硬件更接近，对计算机底层操作进行更精细的控制，但编写和理解起来较为复杂。高级语言（如Java、Python等）则更加易读、易写，并提供了更高层次的抽象，使得程序员能够更专注于问题的解决和算法的设计。而我们这里要学习的Kotlin语言，也属于高级语言的一种，能够使用我们人类更容易理解的语法来编写程序。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"开发环境配置 要开发Kotlin程序，我们首先需要安装Java环境，我们一般使用Kotlin都是在JVM平台上进行开发（Kotlin同样可以开发系统原生程序、JavaScript程序、安卓程序、iOS程序等）因为Java支持跨平台，能在编译后再任意平台上运行，因此，我们将JVM环境中学习Kotlin程序的开发，接下来我们要安装两个环境： Java 8 环境 Kotlin 1.9.0 环境 首先我们来安装Java 8 环境，这里我们需要去下载JDK，这里推荐安装免费的ZuluJDK：https://www.azul.com/downloads/?version=java-8-lts\u0026package=jdk 在这里选择自己的操作系统对应的安装包： 比如Windows下，我们就选择.msi的安装包即可（MacOS、Linux下同样选择对应的即可） 下载完成后，我们直接双击安装： **注意，这里不建议各位小伙伴去修改安装的位置！**新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。 剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以） 我们直接输入java命令即可： 如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。 输入java -version可以查看当前安装的JDK版本： 只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。 接着是Kotlin 1.9.0 环境，我们需要前往：https://github.com/JetBrains/kotlin/releases 下载最新的Kotlin编译器并进行安装： 这里我们可以直接解压然后拖入到刚刚Java安装的同级目录下，我这里是 C:\\Program Files 文件夹，也可以自定义位置，但是不推荐，因为很多小伙伴配环境直接配到自闭。 然后我们需要手动配置一下环境变量，打开系统环境变量配置： 添加路径 C:\\Program Files\\kotlinc\\bin 到Path环境变量下即可，然后我们依然打开CMD查看是否安装成功，输入kotlinc -version来查看安装情况： 这样我们就完成了所有环境的安装，我们可以来体验一下编写并且编译运行一个简单的Kotlin程序，我们新建一个文本文档，命名为Main.txt（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容： fun main() { println(\"Hello, World!\") } 现在看不懂代码没关系，直接用就行，我们后面会一点一点讲解的。 编辑好之后，保存退出，接着我们将文件的后缀名称修改为.kt这是Java源程序文件的后缀名称： 此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径： 我们使用cd命令先进入到这个目录下： 要编译一个Kotlin程序，我们需要使用kotlinc命令来进行，将我们的程序编译为jar包，并包含Kotlin的运行时依赖： kotlinc Main.kt -include-runtime -d Main.jar 执行后，可以看到目录下多出来了一个.jar文件，这是一个打包好的标准Java程序： 接着我们就可以将其交给JVM运行了，我们直接使用java -jar命令即可： 可以看到打印了一个 Hello World! 字样，这样我们的第一个Kotlin程序就成功运行了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"IDEA安装与使用 前面我们介绍了Kotlin开发环境的安装以及成功编译运行了我们的第一个Kotlin应用程序。 但是我们发现，如果我们以后都使用记事本来进行Kotlin程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：IntelliJ IDEA（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好） IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。 下载地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE 我们直接点击下载即可，注意要下载下面的社区版，不要下载到终极版了： 这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，功能更强大，体验更友好） 下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！ 这里勾选一下创建桌面快捷方式就行： 安装完成后，我们直接打开就可以了： 此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可： 我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了： 如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题，我们还可以在下面的设置中开启新UI以及更换各种字体、字体大小等个性化内容。 如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下： 接下来，我们来看看如何使用IDEA编写Kotlin程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目： 此时来到创建页面： 名称： 你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。 位置： 项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。 语言： IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。 构建系统： 在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。 JDK： 就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦） 当然，如果JDK这里没有自动识别到，那么就手动添加一下： 没问题之后，我们直接创建项目： 进入之后，可以看到已经自动帮助我们创建好了一个kt源文件，跟我们之前的例子是一样的。要编译运行我们的Kotlin程序，只需要直接点击左边的三角形（启动按钮）即可： 点击之后，会在下方自动开始构建： 完成之后，就可以在控制台看到输出的内容了： 我们可以看到新增加了一个out目录，这里面就是刚刚编译好的.class文件，这种文件是Java的字节码文件，可以直接运行在JVM中： IDEA非常强大，即使是编译之后的字节码文件，也可以反编译回原代码的样子： 如果我们想写一个新的Kotlin项目，可以退出当前项目重新创建： 此时项目列表中就有我们刚刚创建的Java项目了： 如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习： 会有一个专门的引导教程项目，来教你如何使用各项功能： 熟悉了IDEA的使用之后，下节课我们就可以正式地开始学习Kotlin语言的语法了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"程序代码基本结构 还记得我们之前使用的示例代码吗？ fun main() { println(\"Hello World!\") } 这段代码要实现的功能很简单，就是将 Hello World 这段文本信息输出到控制台。 在编写代码时，注意需要区分大小写，Kotlin语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错： 只要源代码中存在报错的地方，就无法正常完成编译得到字节码文件，强行运行会提示构建失败： 注意这里包括的花括号是成对出现的，并且一一对应。 所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是： fun main() { } 可以看到外面使用花括号前添加了fun main()，这是我们整个程序的入口点，我们的Kotlin程序也是从这里开始从上往下执行的。而其中的println语句就是用于打印其括号中包裹的文本，我们可以看到这个文本信息使用了\"\"进行囊括，否则会报错： println(\"Hello World!\") 这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上。 比如下面的代码，我们就可以实现先打印Hello World!，然后再打印 KFC vivo 50 到控制台： fun main() { println(\"Hello World!\") println(\"KFC vivo 50\") } 效果如下： 注意我们上面编写的打印语句其实是函数的调用（后续会进行讲解）不能写到同一行中，否则编译器会认为是同一句代码，同样会导致编译不通过： 如果实在要写到同一行，那么我们需要在上一句代码最后添加;来表示上一段的结束： 再比如下面的代码： 这里我们尝试在中途换行或是添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意换行或是添加没必要的空格。注意随意换行和空格仅限于可分割区域，比如println本身是一个函数的完整名称，这就不能从中间直接断开，否则语义就完全不一样了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"程序注释编写 我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思： 但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。 这种情况，我们就需要告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了： 添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了： 那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记： 多行可以使用/*和*/的组合来囊括需要编写的注释内容。 当然还有一种方式就是使用/**来进行更加详细的文档注释： 这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。 这样，我们编写Kotlin程序的基本规则就讲解完毕了，从下一个小节开始，我们将先给各位小伙伴介绍我们的基本数据类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"变量与基本类型 我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。那么，什么是变量呢？我们在数学中其实已经学习过变量了： 变量，指值可以变的量。变量以非数字的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。 比如一个公式 x + 2 = 6 此时x就是一个变量，变量往往代表着某个值，比如这里的x就代表的是4这个值。在Kotlin中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的，在程序中，我们也可以使用变量，并且变量具有类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"计算机中的二进制表示（选学） 进入到变量的学习之前，我们需要先补充一下计算机的底层知识，否则各位小伙伴后面听起来会很困难。 在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。 注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。 十进制的7 -\u003e 在二进制中为 111 = 2^2 + 2^1 + 2^0 现在有4个bit位，最大能够表示多大的数字呢？ 最小：0000 =\u003e 0 最大：1111 =\u003e 23+22+21+20 =\u003e 8 + 4 + 2 + 1 = 15 在Kotlin中，无论是小数还是整数，他们可以带有符号，因此，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）： 最小：1111 =\u003e -(22+21+2^0) =\u003e -7 最大：0111 =\u003e +(22+21+2^0) =\u003e +7 =\u003e 7 现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例： 1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！） 我们得创造一种更好的表示方式！于是我们引入了反码： 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法： 1+(-1) = 0001 + 1110 = 1111 =\u003e -0 （直接相加，这样就简单多了！） 思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下： 正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8） 对补码再求一次补码就可得该补码对应的原码。 比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。 所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算： 1+(-1) = 0001 + 1111 = (1)0000 =\u003e +0 （现在无论你怎么算，也不会有-0了！） 所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Kotlin使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"变量的声明与使用 要声明一个变量，我们需要使用以下格式： var [变量名称] : [数据类型] 这里的数据类型我们会在下节课开始逐步讲解，比如整数就是Int类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像x一样，这个名称我们可以随便起一个，但是注意要满足以下要求： 标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。 变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。 不能有空格、@、#、+、-、/ 等符号。 应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。 不可以是 true 和 false。 不能与Kotlin语言的关键字或是基本数据类型重名 当然各位小伙伴没必要刻意去进行记忆有哪些关键字，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如： 深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。 比如现在我们想要定义一个整数（Int）类型的变量a，那么就可以这样编写： fun main() { var a : Int } 但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量： fun main() { var a : Int = 10 } 不过由于变量在一开始就被赋值为10这个整数，此时类型是确定的，Kotlin的编译器非常聪明，它支持自动推断类型，这里会自动将变量a的类型推断为Int类型，我们可以直接省略掉后面的Int类型： fun main() { var a = 10 } 或者我们可以在使用时再对其进行赋值： fun main() { var a : Int a = 10 } 是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台： fun main() { var a = 10 println(a) } 变量的值也可以在中途进行修改： fun main() { var a = 666 a = 777 println(a) //这里打印得到的就是777 } 变量的值也可以直接指定为其他变量的值： fun main() { var a = 10 var b = a //直接让b等于a，那么a的值就会给到b println(b) //这里输出的就是10了 } 我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）： fun main() { var a = 9 //a初始值为9 a = a + 1 //a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧 println(a) //最后得到的结果就是10了 } 对于那些只读的变量，我们可以将其表示为一个常量，使用val关键字： fun main() { val a = 666 //使用val关键字，表示这是一个常量 a = 777; //常量的值不允许发生修改 } 编译时得到报错： 常量的值只有第一次赋值可以修改，其他任何情况下都不行： fun main() { val a: Int a = 777; } 至此，声明变量和常量我们就介绍完毕了，下一部分我们将介绍常见的一些数据类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数字类型介绍 前面我们了解了如何创建变量，并进行使用，但是我们知道，不同的数据往往对应着不同的类型，比如整数我们使用的就是Int，而这一部分我们将学习更多的基本数据类型。 Kotlin提供了一组表示数字的内置类型，对于整数，有四种不同大小的类型，因此，值范围： 类型 大小（位） 最小值 最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-2^31) 2,147,483,647（2^31-1） Long 64 -9,223,372,036,854,775,808 (-2^63) 9,223,372,036,854,775,807（2^63 - 1） 为什么不同的数据类型有着值范围呢？这是因为我们的计算机底层是采用0和1表示数据的，并且数据的表示位数有限，我们以二进制来计算，就像下面这样： 1 + 1 = 10 可能很多小伙伴会好奇，为什么1 + 1得到的结果是数字十？这是因为二进制中只有0和1，因此只要满二就进一，所以就变成这样的结果了，如果各位是初次学习，可能会不太好理解。 这里以上面的8位大小的Byte类型为例，在计算机底层存储数据时，只有8个bit位（一个bit位就可以表示一个0或1）来存储它，那么它能表示的最大值和最小值就是： 00000000 ~ 11111111 转换为十进制就是 0 ~ 255 不过为了能够表示负数，计算机一般使用补码进行表示，所以，上面的最小值和最大值就变成了-128 ~ 127了。 默认情况下，我们使用的常量数字都是Int类型，除非它的大小已经超出Int类型能够表示的最大范围，在超出Int类型可以表示的最大范围之后，默认为Long类型： val one = 1 // Int val threeBillion = 3000000000 // Long val oneLong = 1L // 我们也可以在数字后面添加大写字母L来表示这是一个Long类型的数值 val oneByte: Byte = 1 //Int类型数据也可以在符合其他类型范围时自动转换 对于一些比较长的数字，我们可能需要使用类似于分隔符一类的东西来方便我们计数，比如： 银行往往把1000000000这种长数字记为1,000,000,000，这样看起来会更直观 在Kotlin中也可以像这样去编写： val a = 1_000_000_000 数字类型不仅可以写成十进制，也可以以十六进制或是二进制表示（Kotlin不支持八进制表示）只需要添加对应的前缀即可，比如一个十六进制数据： val a = 0xAF 因为十六进制中大于等于十的数据没有对应的阿拉伯数字可以表示，所以在计算机中就以ABCDEF来替代这无法表示的6个数字。并且我们需要在数字前面添加0x表示这是16进制的数字，接下来是2进制： val a = 0b1001 //0b前缀表示二进制数据，后面的1010对应着十进制的9 除了整数类型外，Kotlin还为无符号整数提供以下类型： UByte：一个无符号8位整数，范围从0到255 UShort：无符号16位整数，范围从0到65535 UInt：一个无符号32位整数，范围从0到2^32 - 1 ULong：一个无符号64位整数，范围从0到2^64 - 1 为了使无符号整数更易于使用，Kotlin同样提供了用后缀标记，该后缀表示无符号类型（类似于上面的Long类型添加L字母） 使用u或U字母作为后缀表示无符号整数。而具体的类型是根据前面变量的类型确定的，如果变量没有提供类型，编译器将根据数字的大小使用UInt或ULong： val b: UByte = 1u // UByte类型, 由变量提供的类型 val s: UShort = 1u // UShort类型, 由变量提供的类型 val l: ULong = 1u // ULong类型, 由变量提供的类型 val a1 = 42u // UInt类型，根据数字大小自动推断得到 val a2 = 0xFFFF_FFFF_FFFFu // ULong类型，根据数字大小自动推断得到 uL和UL可以将文字直接标记为无符号Long类型： val a = 1UL // ULong类型，直接使用后缀标记 对于小数来说，Kotlin提供符合IEEE 754标准的浮点类型Float和Double，Float为IEEE 754标准中的单精度数据，而`Double位标准中的双精度数据，对于单双精度，本质上就是能够表示的小数位精度，双精度比单精度的小数精度更高。 这些类型的大小不同，并为不同精度的浮点数提供存储： 类型 大小（位） 符号与尾数位数 阶码位数 小数位数 Float 32 24 8 6-7 Double 64 53 11 15-16 我们也可以直接创建小数类型的Double和Float变量，小数部分与整数部分由一个小数点（.）隔开，编译器默认情况下会将所有的小数自动推断为推断Double类型： val pi = 3.1415 // 默认推断为Double类型 val one: Double = 1 // 这种写法是错误的，因为1不是小数，无法编译通过 val one: Double = 1.0 // 但是这种写法就是对的，因为这样表示就是小数，即使小数位是0 由于默认是Double类型，如果我们要明确指定值为Float类型，那么需要添加后缀f或F，并且由于精度问题，如果该值包含超过6-7位小数，则会丢失一部分精度： val e = 2.7182818284 // Double类型的数值 val e: Float = 2.7182818284f // 这里表示为Float会导致精度折损，得到2.7182817 与其他一些语言不同，Kotlin中的数字类型没有隐式转换的操作，例如，一个Double类型的变量无法将其值赋值给Int类型变量： 如果需要将一个整数转换为小数，我们会在后面学习函数之后再给各位小伙伴讲解如何调用函数进行显示类型转换。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数字类型的运算 Kotlin支持数学上标准的算术运算集，例如：+，-，*，/，% 并且这些运算符都是通过运算符重载实现的具体功能，我们会在后续的章节中讲解Kotlin的运算符重载机制，这里各位小伙伴就当做是普通的运算操作即可。 Kotlin支持运算符重载，运算符重载是一种允许程序员重新定义运算符的语言特性，通过运算符重载，您可以为自定义的类或数据类型定义一些特定操作的行为。 其中加减乘除操作这里就不做介绍了，而%符号用于取余操作，也就是计算前面的数整除后面的数得到的余数： println(1 + 2) //计算1加上2的结果 println(2_500_000_000L - 1L) //计算2500000000减去1的结果 println(3.14 * 2.71) //计算3.14与2.71的乘积 println(10.0 / 3) //计算10除以3得到的结果 println(10 / 3) //10除以3得到的余数为1 以上运算都比较简单，但是注意在除法运算中，只有两个操作数中出现小数，除法的结果才是小数，如果两个操作数都是整数，那么得到的结果也是整数，并且直接丢失小数位（不会四舍五入） println(5 / 2) //结果是2，而不是2.5 同样的，除了直接使用字面量来进行运算，我们也可以将定义的变量参与到运算中： fun main() { val a = 10 println(a / 2) } 注意，在Kotlin中不同的算数运算符，它们的优先级也不一样： println(1 + 2 * 3) 在数学中，乘法运算的优先级比加法运算更高，因此我们需要先计算乘法，再计算加法，而在Kotlin中是一样的，乘法和除法运算符的优先级是高于加法运算符的，所以说上面算出来的结果是7，同样的，我们数学中使用括号来提升某些运算的优先级，在Kotlin中同样可以，比如： println((1 + 1) * 3) //使用小括号来强制提升优先级 有些时候，我们可能想要让某个变量的值增加一定数值，比如下面这样： var a = 10 a = a + 9 //让a等于a+9的结果 对于这种让变量本身加减乘除某个值的情况，可以使用赋值运算符简化： a += 9 //等价于 a = a + 9 a /= 9 //等价于 a = a / 9 a %= 2 //等价于 a = a % 2 如果我们只是希望某个变量自增或自减1，那么我们可以像这样去写： fun main() { var a = 10 a++ //使用两个++表示自增1 println(a) //打印得到11 a-- //使用两个--表示自减1 } 不过，这个双++符号，可以放在变量的前后，都能实现自增操作： var a = 10 ++a //最终效果等价于a++ 但是他们有一个本质区别，就是++在前面，a是先自增再得到结果，而++在后面，是a先得到结果，再进行自增，比如： fun main() { var a = 10 println(a++) //这里++在后面，打印a的值依然是10，但是结束之后a的值就变成11了 println(++a) //这里++在前面，打印a的值是这里先自增之后的结果，就是12了 } 对于新手来说，这个很容易搞混，所以说一定要记清楚。 Kotlin提供了一组整数的位运算操作，可以直接在二进制层面上与数字表示的位进行操作，不过只适用于Int和Long类型的数据： shl(bits)– 有符号左移 shr(bits)– 有符号右移 ushr(bits)– 无符号右移 and(bits)– 按位与 or(bits)– 按位或 xor(bits)– 按位异或 inv()– 取反 这里我们从按位与开始讲解，比如下面的两个数： fun main() { val a = 9 val b = 3 val c = a and b //进行按位与运算 println(c) } 按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0： a = 9 = 1001 b = 3 = 0011 c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0） 同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1： fun main() { val a = 9 val b = 3 val c = a or b println(c) } a = 9 = 1001 b = 3 = 0011 c =11= 1011（只要上下有一个是1或者都是1，那结果就是1） 按位异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况： a = 9 = 1001 b = 3 = 0011 c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0） 按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1： 127 = 01111111 -128 = 10000000 所以说计算的结果就是-128了。 除了以上的四个运算符之外，还有位移运算符，比如： fun main() { val c = 1 shl 2 //shl表示左移运算 println(c) } 1 = 00000001 4 = 00000100（左移两位之后，1跑到前面去了，尾部使用0填充，此时就是4） 我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用*进行乘2的运算之外，我们也可以使用左移操作来完成。 同样的，右移操作就是向右移动每一位咯： fun main() { val c = 8 shr 2 //shr表示右移运算 println(c) } 跟上面一样，右移操作可以快速进行除以2的计算。对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响： fun main() { val c = -8 shr 2 //这里得到的依然是个负数 println(c) } 我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动： fun main() { val c = -1 ushr 1 //无符号右移是ushr，移动会直接考虑符号位 println(c) } 比如： -1 = 11111111 11111111 11111111 11111111 右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位） 此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移操作。 最后我们再总结一下不同运算符的优先级，对应的优先级从上往下依次减弱： 一元运算符：例如 ++、–、+、-、!、~ 乘法和除法运算符：*、/、% 加法和减法运算符：+、- 位移运算符：shl、shr、ushr 按位与运算符：and 按位或运算符：or 按位异或运算符：xor 逻辑运算符：\u0026\u0026、|| 比较运算符：\u003e、\u003e=、\u003c、\u003c=、==、!= 区间运算符：.. 赋值运算符：=、+=、-=、*=、/=、%= 当然，这里列出的部分运算符各位小伙伴可能还没有遇到，不过在后续的学习中，我们会慢慢认识的，届时各位小伙伴可以回顾一下这里。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"布尔类型介绍 布尔类型是Kotlin中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态： true - 真 false - 假 布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true） val a: Boolean = true 如果给一个其他的值，会无法编译通过： 布尔值除了可以直接赋值得到，也可以通过一些关系运算得到，常见的关系运算有大于、小于以及等于，所有的关系运算在下方： 判断两个数是否相等：a == b和a != b 判断数之间大小：a \u003c b，a \u003e b，a \u003c= b，a \u003e= b 判断数是否在指定范围中：a..b，x in a..b，x !in a..b 比如我们想判断变量a和变量b的值是否相同： fun main() { val a = 10 val b = 8 println(a == b) //判断a是否等于b（注意等号要写两个，因为单等号为赋值运算） println(a \u003e= b) //判断a是否大于等于b println(a \u003c b) //判断a是否小于b val c: Boolean = a != b //判断a是否不等于b并将结果赋值给变量c } 可以看到，通过逻辑运算得到的结果，都是true或false，也就是我们这里学习的Boolean类型值。在Kotlin中，我们为了快速判断某个数是否在一个区间内，可以直接使用 a..b 来表示一个数学上[a, b]这样的闭区间，比如我们这里要判断变量a的值是否在1~10之间： fun main() { val a = 10 println(a in 1..10) //这里1..10表示1~10这个闭区间，使用in关键字来进行判断 println(a in 1..\u003c10) //这里1..\u003c10表示1~10这个前闭后开区间，使用in关键字来进行判断 println(a !in 1..10) //相反的，使用!in判断是否不在这个区间 } 对于Boolean类型的变量之间，也有一些逻辑运算符用于进行组合条件判断： ||– 逻辑或运算 \u0026\u0026– 逻辑与运算 !– 取反运算 其中取反运算最好理解，它可以让true变成false，false变为true，比如： fun main() { val a = 10 val b = 20 val c = a \u003e b //这里很明显c应该为false println(!c) //这里进行了取反操作并打印，那么结果就是true了 } 对于逻辑与和逻辑或运算，我们可以像这样去使用： fun main() { val a = 10 val b = 0 println(100 \u003e= a \u0026\u0026 b \u003e= 60) //我们可以使用与运算符连接两个判断表达式，只有两边都为true结果才是true println(100 \u003e= a || b \u003e= 60) //我们可以使用或运算符连接两个判断表达式，只要两边任意一个为true结果就是true } 与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，而或运算就是要求两边只要有一边为真，结果就是真，除非两边同时为false，那么就没戏了。 不过需要注意的是，在与运算中，第一个判断表达式得到了false之后，此时不会再继续运行第二个表达式，而是直接得到结果false（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）同样的，或运算下当发现第一个判断表达式为true时，也不会继续向后执行了，因为结果已经是顶真了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"字符类型介绍 字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）字符由Char类型表示，字符值用单引号：'1'囊括： val c: Char = 'A' println(c) 注意，字符只能表示一单个字符，我们之前遇到的字符串跟字符不一样，关于字符串我们会在下节课进行介绍。 我们打印出来的也是单个字符： 那么可能会有小伙伴好奇，字符类型在计算机底层是怎么进行存储的呢？实际上每个字符在计算机中都会对应一个字符码，首先我们需要介绍ASCII码： 比如我们的英文字母A要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，我们可以使用.code来获取某个字符对应的ASCII码，比如下面这样： fun main() { val c: Char = 'A' println(c.code) //这里就会打印字符对应的ASCII码 } 得到结果为： 字符型占据2个字节的空间用于存放数据： char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535 不过，这里的字符表里面不就128个字符吗，那char干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文，这时，我们就需要扩展字符集了。 Unicode是一个用于表示文本字符的标准字符集。它包含了世界上几乎所有的已知字符，包括不同国家和地区的字母、数字、标点符号、符号图形以及特殊的控制字符。 与Unicode不同，ASCII（American Standard Code for Information Interchange）是一个只包含128个字符的字符集。它最初是为了在计算机系统中传输基本英语字符而设计的。ASCII字符集包含了常见的拉丁字母、数字、标点符号以及一些特殊字符。 Unicode采用了一个更加广泛的字符编码方案，包括了不同的字符集编码，比如UTF-8和UTF-16等。UTF-8是一种可变长度的编码方案，它可以用来表示Unicode中的任意字符，且向后兼容ASCII字符集。而UTF-16则是一种固定长度的编码方案，它使用两个字节来表示一个Unicode字符。 与ASCII相比，Unicode的主要优势在于它能够表示各种不同的语言和字符，而不仅仅限于英语字符。这使得Unicode成为全球通用的字符编码标准，为不同国家和地区的语言提供了统一的编码方式。 所以，一个Char就能表示几乎所有国家语言的字符，这样就很方便了。 接着我们来介绍一下转译字符，对于一些我们平时很难直接通过键盘或是输入法打出来的字符，比如一些特殊符号： 这些符号我们没办法直接打出来，但是现在我们又想要表示它们，该怎么做呢？我们可以使用转义来将这些字符对应的Unicode编码转换为对应的字符，只需要在前面加上\\u即可，比如✓这个符号： fun main() { val c = '\\u2713' //符号✓对应的Unicode编码为10003，这里需要转换为16进制表示，结果为0x2713 println(c) } 除了能像这样表示一个特殊字符，我们也可以使用一些其他的转义字符来表示各种东西： \\t – 选项卡 \\b – 退格 \\n – 换行（LF） \\r – 回车（CR） \\' – 单引号 \\\" – 双引号 \\\\ –反斜杠 \\$ – 美元符号 这些转义字符都是为了防止在特殊情况下无法表示某些字符，而给我们的替代方案，后续各位小伙伴在使用时可以回来参考一下。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"字符串类型介绍 字符串类是一个比较特殊的类型，它用于保存字符串。我们知道，基本类型Char可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列，它的类型名称为String。 字符串通常由双引号\"\"囊括，它可以表示一整串字符： val str: String = \"Hello World\" 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。 如果我们需要再字符串中换行，需要用到转义字符，字符串中同样支持使用转义字符： fun main() { val text = \"Hello\\nWorld\" println(text) } 不过，字符串只能写一行，有时候有点不太够用，可能我们想要打印多行文本，我们除了用\\n转义字符来换行之外，也可以直接使用三个双引号\"\"\"来表示一个原始字符串，但是原始字符串无法使用转义字符： fun main() { val text = \"\"\" 这是第一行 这第二行 别\\n了，没用 真牛逼啊，这功能隔壁Java15才有 \"\"\" println(text) } 效果如下： 可以看到确实是够原始的，把我代码里面的缩进都给打印出来了，这样肯定不是我们希望的样子，我们希望的仅仅是一个简单换行而已，那这里该怎么去处理呢？后面我们在讲解函数之后，会额外补充这里的内容。 有时候为了方便，我们可以将不同的字符串拼接使用： fun main() { val str1 = \"Hello\" val str2 = \"World\" val str = str1 + str2 println(str) //使用 + 来拼接两个字符串，得到的结果就是两个字符串合在一起的结果 } 字符串除了和字符串拼接之外，也可以和其他类型进行拼接： fun main() { val a = 10 val text = \"这是拼接的值\" + a println(text) //打印出来就是与其他类型的拼接结果 } 但是我们需要注意字符串拼接的顺序，只能由字符串拼接其他类型，如果是其他类型拼接字符串，可能会出现问题： 但是现在我们就是希望其他类型的数据拼在最前面，这里应该怎么做呢？我们可以使用字符串模版来完成： fun main() { val a = 10 val text = \"这是拼接的值$a\" //这里的$为模版表达式，可以直接将后面跟着的变量或表达式以字符串形式替换到这个位置 println(text) } 如果要添加到前面： val text = \"$a 这是拼接的值\" //注意这里$a之后必须空格，否则会把后面的整个字符串认为这个变量的名字 出现这种情况除了用空格去解决之外，我们也可以添加一个花括号： val text = \"${a}这是拼接的值\" //添加花括号就可以消除歧义了 val text = \"${a \u003e 0}这是拼接的值\" //花括号中也可以写成表达式 由于美元符用于模版表达式了，所以说如果我们希望在字符串中仅仅表示$这个字符，那么我们需要用到转义： val text = \"\\$这是美元符\" //普通字符串直接使用\\$表示 //原始字符串要套个娃 val str = \"\"\" ${'$'}这是美元符 \"\"\" 至此，关于Kotlin的变量与基本类型的内容我们就暂时告一段落了，不过在后面学习了更多知识后，我们还会回顾这些基本类型，了解他们的更多用法，并且认识我们唯一没有在这一部分介绍的数组类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"流程控制 经过前面的学习，我们知道，程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。 在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断，以及实现流程控制。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"选择结构（if-else） 某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下if语句： if (条件判断) 判断成功执行的代码; if的小括号中需要我们传入一个Boolean类型的结果，可以是一个Boolean变量，也可以是一个判断语句，反正只能接受true和false两种结果，比如下面的这个例子： fun main() { val a = 10 if(a == 12) //只有当a判断等于12时，才会执行下面的打印语句 println(\"Hello World!\") println(\"我是后续的语句\") //if只会对紧跟着的一行代码生效，后续的内容无效 } if会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起，使用花括号囊括）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的，就像下面这样： fun main() { val a = 15 if (a \u003e 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 println(\"a大于10\") println(\"a的值为：$a\") } println(\"我是外层\") } 如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句： fun main() { val a = 15 if (a \u003e 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 println(\"a大于10\") println(\"a的值为：$a\") } else { //当判断不成功时，会执行else代码块中的代码 println(\"a小于10\") println(\"a的值为：$a\") } println(\"我是外层\") } if-else语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。 那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成： fun main() { val score = 2 if (score \u003e= 90) //90分以上才是优秀 println(\"优秀\") else if (score \u003e= 70) //当上一级if判断失败时，会继续判断这一级 println(\"良好\") else if (score \u003e= 60) println(\"及格\") else //当之前所有的if都判断失败时，才会进入到最后的else语句中 println(\"不及格\") } 当然，if分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套： fun main() { val score = 2 if (score \u003c 60) { //先判断不及格 if (score \u003e 30) //在内层再嵌套一个if语句进行进一步的判断 println(\"学习C++\") else println(\"学习Java\") } } 除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用if来进行各种条件判断了。 除了直接执行语句之外，我们也可以将if和else用作结果判断，比如： fun main() { val score = 2 //这里判断socre是否大于60，是就得到Yes，否就得到No，并且可以直接赋值给变量 val res = if (score \u003e 60) \"Yes\" else \"No\" } 这类似于其他语言，如Java和C中的三元运算，不过Kotlin中没有那样的三元运算符，只能使用上面的表达式，对于多行代码块的情况，默认最后一行作为返回的结果： fun main() { val score = 2 val res = if (score \u003e 60) { println(\"不错啊期末没挂科\") \"Yes\" //代码块默认最后一行作为返回结果 } else { println(\"不会有人Java期末还要挂科吧\") \"No\" } } 注意，如果需要这种返回结果的表达式，那么必须要存在else分支，否则不满足条件岂不是没结果了？ ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"选择结构（when） 前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用when语句来实现，它更适用于多分支的情况： when定义具有多个分支的条件表达式。它类似于类似Java和C语言中的switch语句，它简单的形式看起来像这样： when (目标) { 匹配值1 -\u003e 代码... //我们需要传入一个目标，比如变量，或是计算表达式等 匹配值2 -\u003e 代码... //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 else -\u003e { 代码... //如果以上条件都不满足，就进入else中（可以没有），类似于之前的if-elseif-else } } 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级： fun main() { val c = 'A' when (c) { 'A' -\u003e println(\"去尖子班！准备冲刺985大学！\") 'B' -\u003e println(\"去平行班！准备冲刺一本！\") 'C' -\u003e println(\"去职高深造。\") } } 如果将when用作表达式，则else分支必须存在，除非编译器能推断出所有可能的情况都包含分支条件，比如下面的例子： fun main() { val c = 'A' val numericValue = when (c) { 'B' -\u003e 0 'A' -\u003e 1 else -\u003e 2 //还有其他情况，这里必须添加else，不然其他情况岂不是没返回的东西？ } } 以下情况就可以不需要else语句： fun main() { val c = true val numericValue = when (c) { false -\u003e 0 true -\u003e 1 // 由于Boolean只具备真和假条件，这里的'else' 就不再强制要求 // 这同样适用于比如枚举类等 } } 在when语句中，遇到以下情况，携带else分支是必须的： when分支中仅有一个Boolean类型、枚举 或 密封，以及用于判断的目标变量是可空的情况（后面会讲解） when分支没有包括该判断目标的所有可能的值。 有时候我们可能希望某些值都属于同一个情况，可以使用逗号将其条件组合成一行： when (x) { 0, 1 -\u003e print(\"x == 0 or x == 1\") else -\u003e print(\"otherwise\") } 我们也可以使用任意表达式（不仅仅是常量）作为分支条件，比如之前的if-else案例中我们判断学生成绩： fun main() { val score = 10 val grade = when(score) { //使用in判断目标变量值是否在指定范围内 in 100..90 -\u003e \"优秀\" in 89..80 -\u003e \"良好\" in 79..70 -\u003e \"及格\" in 69..60 -\u003e \"牛逼\" else -\u003e \"不及格\" } } 包括我们之后学习的类型判断is表达式、函数调用等，都可以在这里作为分支条件。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"循环结构（for） 通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。 我们在某些时候，可能需要批量执行某些代码： fun main() { println(\"大烟杆嘴里塞，我只抽第五代\") //把这句话给我打印三遍 println(\"大烟杆嘴里塞，我只抽第五代\") println(\"大烟杆嘴里塞，我只抽第五代\") } 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？ 现在，要解决这种问题，我们可以使用for循环语句来多次执行： for (遍历出来的单个目标变量 in 可遍历目标) 循环体 这里的可遍历目标有很多，比如： 数组 区间 任何实现了运算符重载函数iterator的类 这里我们只学习了区间，我们来看看如何使用，比如我们要打印一段话3遍： fun main() { for (i in 1..3) //这里直接写入1..3表示1~3这个区间 println(\"大烟杆嘴里塞，我只抽第五代：$i\") } 打印结果为： 可以看到，每一次遍历出来的变量i，其实就是每次遍历的下一个目标，比如这里是1..3的区间，那么得到的依次就是1、2、3这三个结果了，唯一需要注意的是，这里的i是局部的，只在for循环内部可用（包括嵌套的内部）并不是整个main中都可以使用： 默认情况下，每一轮循环都会向后+1，我们也可以自由控制每一轮增加多少，也就是步长： fun main() { for (i in 1..10 step 2) { println(i) } } 这样，打印出来的数据会按照步长进行增长： 那如果我们需要从10到1倒着进行遍历呢？我们可以将..替换为downTo来使用： fun main() { for (i in 10 downTo 1) { println(i) //这里得到的就是10到1倒着排列的范围了 } } 我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值： 调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug） 调试开始时，我们可以看到程序在断点位置暂停了： 此时我们可以观察到当前的变量i的值，也可以直接在下方的调试窗口中查看： 随着循环的进行，i的值也会逐渐自增。 和之前的if一样，for循环同样支持嵌套使用： fun main() { for (i in 0..2) //外层循环执行3次 for (j in 0..2) //内层循环也执行3次 println(\"外层$i，内层$j\") } 上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。 我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字： for (i in 0..2) { if (i == 1) continue //比如我们希望当i等于1时跳过这一轮，不执行后面的打印 println(\"在这么冷的天\") println(\"当前i的值为：$i\") } 我们可以使用continue关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行continue进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。 在某些情况下，我们可能希望提前结束循环： fun main() { for (i in 0..2) { if (i == 1) break //我们希望当i等于1时提前结束 println(\"伞兵一号卢本伟准备就绪！\") println(\"当前i的值为：$i\") } } 我们可以使用break关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。 虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）： fun main() { for (i in 1..3) { for (j in 1..3) { if (i == j) continue //当i == j时加速循环 println(\"$i, $j\") } } } 这里的continue加速的对象并不是外层的for，而是离它最近的内层for循环，break也是同样的规则： fun main() { for (i in 1..3) { for (j in 1..3) { if (i == j) break //当i == j时终止循环 println(\"$i, $j\") } } } 那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记： fun main() { outer@ for (i in 1..3) { //在循环语句前，添加 标签@ 来进行标记 inner@ for (j in 1..3) { if (i == j) break@outer //break后紧跟要结束的循环标记，当i == j时终止外层循环 println(\"$i, $j\") } } } 关于for语句的更多用法，我们会在后续的学习中继续认识。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"循环结构（while） 前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们给一个可遍历的目标，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如： while(循环条件) 循环体; 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。 fun main() { var i = 100 //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i \u003e 0) { //现在唯一知道的是循环条件，只要大于0那么就可以继续除 println(i) i /= 2 //每次循环都除以2 } } 上面的这种情况就非常适合使用while循环。 和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用： fun main() { var i = 100 while (i \u003e 0) { if (i \u003c 10) break println(i) i /= 2 } } 我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句： fun main() { var i = 0 //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 do { //无论满不满足循环条件，先执行循环体里面的内容 println(\"Hello World!\") i++ } while (i \u003c 10) //再做判断，如果判断成功，开启下一轮循环，否则结束 } Kotlin程序设计中级篇 我们在前面已经学习了Kotlin程序设计的基础篇，本章我们将继续介绍更多Kotlin特性，以及面向对象编程。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"函数 其实函数我们在一开始就在使用了： fun main() { println(\"Hello World\") } 我们程序的入口点就是main函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不过这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的println也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数： println(\"Hello World!\"); //直接通过 函数名称(参数...) 的形式调用函数 那么，函数的具体定义是什么呢？ 函数是完成特定任务的独立程序代码单元。 其实简单来说，函数是为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况： fun main() { var a = 10 println(\"H\") //比如下面这三行代码就是我们要做的任务 println(\"A\") a += 10 if (a \u003e 20) { println(\"H\") //这里我们还需要执行这个任务 println(\"A\") a += 10 } when (a) { 30 -\u003e { println(\"H\") //这里又要执行这个任务 println(\"A\") a += 10 } } } 我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？ 这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。 我们来看看，如何创建和使用函数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"创建和使用函数 Kotlin函数使用fun关键字声明： fun 函数名称([函数参数...]): 返回值类型 { //函数体 } 其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，我们同样可以将函数返回的结果赋值给变量或是参与运算等等，当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以不填，我们先从最简单的开始： //这个函数用于打印一段文本 fun hello(): Unit { //本质上应该是返回Unit类型，这个类型表示空，类似于Java中的void，默认情况下可以省略 println(\"PHP是世界上最好的语言.kt\") } 我们要调用这个函数也很简单，只需要像下面这样就可以了： fun main() { hello() //调用函数只需使用 函数名() 即可 } 不过，有些时候，我们可能需要外部传入一些参数来使用，比如： fun say(message: String){ //在定义函数时，可以将参数写到 println(\"我说：$message\") } 这里我们在函数的小括号中填入的就是形式参数，这代表调用函数时需要传入的数据，比如这里就是我们要打印的字符串，而实际在调用函数时，填入的内容就是实际参数： fun main() { //在调用带参数的函数时，必须填写实参，否则无法编译通过 //这里填入的内容就是实际参数 say(\"你干嘛\") //也可以将变量作为实际参数传入 val str: String = \"哎哟\" say(str) } 还有一些时候，我们的函数可能需要返回一个计算的结果给调用者，我们也可以设定函数的返回值： //这个函数用于计算两个Int数之和 fun sum(a: Int, b: Int) : Int { return a + b //使用return语句将结果返回 } 带返回值的函数，调用之后得到的返回值，可以由变量接收，或是直接作为其他函数的参数： fun main() { var result = sum(1, 2) //获取函数返回值 println(result) println(sum(2, 4)) //直接打印函数返回值 } 注意这个return关键字在执行之后，是不会继续执行之后的内容的： fun main() { println(test(-2)) println(test(10)) } fun test(i: Int): String{ if(i \u003e 0) return \"Hello\" println(\"继续\") return \"World\" //如果满足上面条件，在执行return之后，后续无论有没有执行完，都不会再往下了 } 有些时候，我们也可以设计一些参数带有默认值的函数，如果在调用函数时不填入参数，那么就使用我们一开始设置好的默认值作为实际传入的参数： fun main() { test() //调用函数时，如果对应参数有默认值，可以不填 } fun test(text: String = \"我是默认值\"){ println(text) } 在调用函数时，我们可以手动指定传入的参数对应的是哪一个形式参数： fun main() { test(b = 3) //这里如果只想填写第二个参数b，我们可以直接指定吧实参给到哪一个形参 test(3) //这种情况就是只填入第一个实参 } fun test(a: Int = 6, b: Int = 10): Int { return a + b } 对于一些内容比较简单的函数，比如上面仅仅是计算两个参数的和，我们可以直接省略掉花括号，像这样编写： fun test(a: Int = 6, b: Int = 10): Int = a + b //函数的结果直接缩减为 = a + b 效果跟之前是一样的 fun test(a: Int = 6, b: Int = 10) = a + b //返回类型可以自动推断，这里可以吧返回类型省掉 这里还需要注意一下，函数的形式参数默认情况下为常量，无法进行修改，只能使用： 比较奇葩的是，函数内部也可以定义函数： fun outer(){ fun inner(){ //函数内部定义的函数，无限套娃 } } 函数内的函数作用域是受限的，我们只能在函数内部使用： fun outer(){ fun inner(){ } inner() } 内部函数可以访问外部函数中的变量： fun outer(){ val a = 10; fun inner(){ println(a) } } 最后，我们不能同时编写多个同名函数，这会导致冲突： 但是，如果多个同名函数的参数不一致，是允许的： fun test() = println(\"A\") fun test(str: String) = println(\"B\") //参数列表不一致 我们在调用这个函数时，编译器会根据我们传入的实参自动匹配使用的函数是哪一个： ... fun main() { test(\"\") //结果为B } 以上适用于形参列表不同的情况，如果仅仅是返回值类型不同的情况，同样是不允许的： 像这种编写同名但不同参数的函数，我们称为函数的重载。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"再谈变量 前面我们学习了如何使用变量，只不过当时我们仅仅是在main函数中使用的局部变量，我们也可以将变量的作用域进行提升，将其直接变成一个顶级定义： var str: String = \"尊嘟假嘟\" //跟定义函数一样，直接写在Kt文件中 fun main() { ... } 此时，这个变量可以被所有的函数使用： var str: String = \"尊嘟假嘟\" fun main() = println(str) //作用域的提升，使得变量可以被随意使用 fun test() = println(str) 以上也只是对变量的一些简单使用，现在变量的作用域被提升到顶层，它可以具有更多的一些特性，那么，我们就再来重新认识一下变量，声明一个变量的完整语法如下： var \u003cpropertyName\u003e[: \u003cPropertyType\u003e] [= \u003cproperty_initializer\u003e] [\u003cgetter\u003e] [\u003csetter\u003e] 前面的我们知道，但是这个getter和setter是个什么鬼？对于这种顶层定义的变量（包括后面类中会用到的成员属性变量）可以具这两个可选的函数，它们本质上是一个get和set函数： getter：用于获取这个变量的值，默认情况下直接返回当前这个变量的值 setter：用于修改这个变量的值，默认情况下直接对这个变量的值进行修改 我们在使用这种全局变量时，对于变量的获取和设定，本质上都是通过其getter和setter函数来完成的，只不过默认情况下不需要我们去编写，程序编译之后，有点像这样的结果： var name: String = \"小明\" fun getName() : String { //编译时自动生成了对应变量的get函数 return this.name } fun setName(name: String) { //编译时自动生成了set函数 this.name = name; } 而对于其使用，在编译之后，会变成这样： fun main() { println(getName()) //获取name时本质上是调用getName函数 } 是不是感觉好神奇，一个变量都能搞这么多花样，这其实是为了后续多态的一些性质而设计的（下一章讲解） 可以看到，在默认情况下，变量的获取就是直接返回，设置就是直接修改，不过有些时候我们可能希望修改这些变量获取或修改时执行的操作，我们可以手动编写： var str: String = \"尊嘟假嘟\" get() = field + field //使用filed代表当前这个变量(字段)的值，这里返回值拼接的结果 这里使用的field准确的说应该是Kotlin提供的\"后备字段\"，因为我们使用getter和setter本质上替代了原有的获取和修改方式，使其变得更像是函数的调用，因此，为了能够继续像之前使用一个变量那样去操作它本身，就有了这个后备字段。 最后得到的就是： 甚至还可以写成这样，在获取的时候执行一些操作： var str: String = \"尊嘟假嘟\" get() { println(\"获取变量的值：\") //获取的时候打印一段文本 return field + \"666\" } fun main() = println(str) 同样的，设置的时候也可以自定义： var str: String = \"尊嘟假嘟\" get() = field + field set(value) { //这里的value就是给过来的值 println(\"设置变量的值\") field = value //注意，对于val类型的变量，没有set函数，因为不可变 } 因此，一个变量有些时候可能会写成这样： val str get() = \"你干嘛\" 当然，默认情况下其实没有必要去重写get和set除非特殊需求。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"递归函数 我们前面学习了如何调用函数，实际上函数自己也可以调用自己。 fun test(){ test() //我自己调用自己 } 肯定会有小伙伴疑问，函数自己调用自己有什么意义？反而还会导致函数无限的调用下去，无穷无尽，确实，如果不加限制地让函数自己调用自己： 就会出现这种爆栈的情况，这是因为程序的内存是有限的，不可能无限制的继续调用下去，因此，在自我调用到一定的深度时，会被强制终止。所以说这玩意有啥用呢？如果我们对递归函数加以一些限制，或许会有意想不到的发现： fun main() { test(5) //计算0-5的和 } //这个函数实现了计算0-n的和的功能 fun test(n: Int): Int{ if(n \u003c= 0) return 0 //当n等于0的时候就不再向下，而是直接返回0 return n + test(n - 1) //n不为0就返回当前的n加上test参数n-1的和 } 这个函数最终调用起来就像这样： test(5) = 5 + test(4) = 5 + 4 + test(3) = … = 5 + 4 + 3 + 2 + 1 + 0 可以看到，只要合理使用递归函数，加以一定的结束条件，反而能够让我们以非常简洁的形式实现一个需要循环来完成的操作。 我们可以再来看一个案例： 斐波那契数列是一个非常经典的数列，它的定义是：前两个数是1和1，之后的每个数都是前两个数的和。 斐波那契数列的前几个数字依次是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … 对于求解斐波那契数列第N个数这类问题，我们也可以使用递归来实现： fun main() { println(fib(5)) } fun fib(n: Int): Int{ if(n \u003c= 2) return 1 //我们知道前两个一定是1，所以直接返回 return fib(n - 1) + fib(n - 2) //当前fib(n)的结果就是前两个结果之和，直接递归继续找 } 是不是感觉递归函数非常神奇？它甚至可以解决一些动态规划问题、一些分治算法等。 不过，这种函数的效率就非常低了，相比循环来说，使用递归解决斐波那契问题，时间复杂度会呈指数倍增长，且n大于20时基本可以说很卡了（可以想象一下，每一个fib(n)都会分两个出去，实际上这个中间存在大量重复的计算） 那么，有没有办法可以将这种尾部作为返回值进行递归的操作优化一下呢？我们可以使用tailrec关键字来实现： tailrec fun test(n: Int, sum: Int = 0): Int { if(n \u003c= 0) return sum //到底时返回累加的结果 return test(n - 1, sum + n) //不断累加 } 实际上在编译之后，会变成这样： 可以看到它变成了一个普通的循环操作，这也是编译器的功劳，同样的，对于斐波那契数列： tailrec fun fib(n: Int, prev: Int = 0, next: Int = 1): Int { return if (n == 0) prev else fib(n - 1, next, prev + next) //从0和1开始不断向后，直到n为0就返回 } ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"实用库函数介绍 Kotlin为我们内置了大量实用的库函数，我们可以使用这些库函数来快速完成某些操作。 比如我们前面使用的println就是Kotlin提供的库函数，我们可以使用这个函数快速进行数据打印： fun main() { println(\"Hello World\") //这里其实就是在调用函数，传入了一个String类型的参数 } 那既然现在有输出，能不能让用户输入，然后我们来读取呢？ fun main() { val text = readln() println(\"读取到用户输入：$text\") } 我们可以在控制台输入一段文本，然后回车结束： Kotlin提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。 import kotlin.math.* //我们需要使用import来引入某些库，这样才能使用库函数 fun main() { 1.0.pow(4.0) //我们可以使用pow方法直接计算a的b次方 abs(-1); //abs方法可以求绝对值 max(19, 20); //快速取两个数的最大值 min(2, 4); //快速取最小值 sqrt(9.0); //求一个数的算术平方根 } 当然，三角函数肯定也是安排上了的： fun main() { //这里我们可以直接使用库中预设好的PI sin(PI / 2); //求π/2的正弦值，这里我们可以使用预置的PI进行计算 cos(PI); //求π的余弦值 tan(PI / 4); //求π/4的正切值 asin(1.0); //三角函数的反函数也是有的，这里是求arcsin1的值 acos(1.0); atan(0.0); } 可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果： fun main() { println(sin(Math.PI)); } 正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是： 1.2246467991473532×10−161.2246467991473532×10−16 其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。 我们也可以计算对数函数： fun main() { ln(E) //e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e log10(100.0) //10为底的对数函数 log2(8.0) //2为底的对数函数 //利用换底公式，我们可以弄出来任何我们想求的对数函数 val a = ln(4.0) / ln(2.0) //这里是求以2为底4的对数，log(2)4 = ln4 / ln2 println(a) } 还有一些比较特殊的计算： fun main() { ceil(4.5) //通过使用ceil来向上取整 floor(5.6) //通过使用floor来向下取整 } 向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"高阶函数与lambda表达式 注意： 这一部分比较难理解，如果看不懂可以后面回来看。 Kotlin中的函数属于一等公民，它支持很多高级特性，甚至可以被存储在变量中，可以作为参数传递给其他高阶函数并从中返回，就想使用普通变量一样。 为了实现这一特性，Kotlin作为一种静态类型的编程语言，使用了一系列函数类型来表示函数，并提供了一套特殊的语言结构，例如lambda表达式。 那么这里说的高阶函数是什么，lambda表达式又是什么呢？ 正是得益于函数可以作为变量的值进行存储，因此，如果一个函数接收另一个函数作为参数，或者返回值的类型就是一个函数，那么该函数称为高阶函数。 要声明函数类型，需要按照以下规则： 所有函数类型都有一个括号，并在括号中填写参数类型列表和一个返回类型，比如：(A, B) -\u003e C 表示一个函数类型，该类型表示接受类型A和B的两个参数并返回类型C的值的函数。参数类型列表可为空的，比如() -\u003e A，注意，即使是Unit返回类型也不能省略。 我们可以像下面这样编写： //典型的函数类型 (参数...) -\u003e 类型 小括号中间是一个剪头一样的符号，然后最后是返回类型 var func0: (Int) -\u003e Unit //这里的 (Int) -\u003e Unit 表示这个变量存储的是一个有一个int参数并且没有返回值的函数 var func1: (Double, Double) -\u003e String //同理，代表两个Double参数返回String类型的函数 同样的，作为函数的参数也可以像这样表示： fun test(other: (Int) -\u003e String){ } 函数类型的变量，我们可以将其当做一个普通的函数进行调用： fun test(other: (Int) -\u003e String){ println(other(1)) //这里提供的函数接受一个Int参数返回string，那么我们可以像普通函数一样传入参数调用它 } 由于函数可以接受函数作为参数，所以说你看到这样的套娃场景也不奇怪： var func: (Int) -\u003e ((String) -\u003e Double) 不过这样写可能有些时候不太优雅，我们可以为类型起别名来缩短名称： typealias HelloWorld = (String) -\u003e Double fun main() { var func: HelloWorld } 那么，函数类型我们知道如何表示了，如何具体表示一个函数呢？我们前面都是通过fun来声明函数： fun test(str: String): Int { return 666 } 而现在我们的变量也可以直接表示这个函数： fun main() { //这个变量表示的也是(String) -\u003e Int这种类型的函数 var func: (String) -\u003e Int = ::test //使用双冒号来引用一个现成的函数（包括我们后续会学习的成员函数、构造函数等） } //这个函数正好与上面的变量表示的函数类型一致 fun test(str: String): Int { return 666 } 除了引用现成的函数之外，我们也可以使用匿名函数，这是一种没有名称的函数： fun main() { val func: (String) -\u003e Int = fun(str: String): Int { //这里写了fun关键字后，并没有编写函数名称，这种函数就是匿名函数，因为在这里也不需要什么名字，只需要参数列表函数体 println(\"这是传入的内容$str\") return 666 } } 匿名函数除了没名字之外，其他的用法跟函数是一样的。 最后，我们来看看今天的重量级嘉宾，不要小看了Kotlin的语法，我们也可以使用Lambda表达式来表示一个函数实例： fun main() { var func: (String) -\u003e Int = { //一个Lambda表达式只需要直接在花括号中编写函数体即可 println(\"这是传入的参数$it\") //默认情况下，如果函数只有一个参数，我们可以使用it代表传入的参数 666 //跟之前的if表达式一样，默认最后一行为返回值 } func(\"HelloWorld!\") } 是不是感觉特别简便？ 对于参数有多个的情况，我们也可以这样进行编写： fun main() { val func: (String, String) -\u003e Unit = { a, b -\u003e //我们需要手动添加两个参数这里的形参名称，不然没法用他两 println(\"这是传入的参数$a, 第二个参数$b\") //直接使用上面的形参即可 } val func2: (String, String) -\u003e Unit = { _, b -\u003e println(\"这是传入的第二个参数$b\") //假如这里不使用第一个参数，也可以使用_下划线来表示不使用 } func(\"Hello\", \"World\") } 是不是感觉玩的非常高级？还有更高级的在后面呢！ 我们接着来看，如果我们现在想要调用一个高阶函数，最直接的方式就是下面这样： fun main() { val func: (Int) -\u003e String = { \"收到的参数为$it\" } test(func) } fun test(func: (Int) -\u003e String) { println(func(66)) } 当然我们也可以直接把一个Lambda作为参数传入作为实际参数使用： fun main() { test({ \"收到的参数为$it\" }) } 不过这样还不够简洁，在Kotlin中，如果函数的最后一个形式参数是一个函数类型，可以直接写在括号后面，就像下面这样： test() { \"收到的参数为$it\" } 由于小括号里面此时没有其他参数了，还能继续省，直接把小括号也给干掉： test { \"收到的参数为$it\" } //干脆连小括号都省了，这语法真的绝 当然，如果在这之前有其他的参数，只能写成这样了： fun main() { test(1) { \"收到的参数为$it\" } } //这里两个参数，前面还有一个int类型参数，但是同样的最后一个参数是函数类型 fun test(i: Int, func: (Int) -\u003e String) { println(func(66)) } 这种语法也被称为 尾随lambda表达式，能省的东西都省了，不过只有在最后一个参数是函数类型的情况下才可以，如果不是最后一位，就没办法做到尾随了。 最后需要特别注意的是，在Lambda中没有办法直接使用return语句返回结果，而是需要用到之前我们学习流程控制时用到的标签： fun main() { val func: (Int) -\u003e String = test@{ //比如这里判断到it大于10就提前返回结果 if(it \u003e 10) return@test \"我是提前返回的结果\" println(\"我是正常情况\") \"收到的参数为$it\" } test(func) } fun test(func: (Int) -\u003e String) { println(func(66)) } 如果是函数调用的尾随lambda表达式，默认的标签名字就是函数的名字： fun main() { testName { //默认使用函数名称 if(it \u003e 10) return@testName \"我是提前返回的结果\" println(\"我是正常情况\") \"收到的参数为$it\" } } fun testName(func: (Int) -\u003e String) { println(func(66)) } 不过，为什么要这么麻烦呢，还要打标签才能返回，这不多此一举么？这个问题我们会在下一节内联函数中进行讲解。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"内联函数 使用高阶函数会可能会影响运行时的性能：每个函数都是一个对象，而且函数内可以访问一些局部变量，但是这可能会在内存分配（用于函数对象和类）和虚拟调用时造成额外开销。 为了优化性能，开销可以通过内联Lambda表达式来消除。使用inline关键字会影响函数本身和传递给它的lambdas，它能够让方法的调用在编译时，直接替换为方法的执行代码，什么意思呢？比如下面这段代码： fun main() { test() } //添加inline表示内联函数 inline fun test(){ println(\"这是一个内联函数\") println(\"这是一个内联函数\") println(\"这是一个内联函数\") } 由于test函数是内联函数，在编译之后，会原封不动地把代码搬过去： fun main() { println(\"这是一个内联函数\") //这里是test函数第一行，直接搬过来 println(\"这是一个内联函数\") println(\"这是一个内联函数\") } 同样的，如果是一个高阶函数，效果那就更好了： fun main() { test { println(\"打印：$it\") } } //添加inline表示内联函数 inline fun test(func: (String) -\u003e Unit){ println(\"这是一个内联函数\") func(\"HelloWorld\") } 由于test函数是内联的高阶函数，在编译之后，不仅会原封不动地把代码搬过去，还会自动将传入的函数参数贴到调用的位置： fun main() { println(\"这是一个内联函数\") //这里是test函数第一行 val it = \"HelloWorld\" //这里是函数内传入的参数 println(\"打印：$it\") //第二行是调用传入的函数，自动贴过来 } 内联会导致编译出来的代码变多，但是同样的换来了性能上的提升，不过这种操作仅对于高阶函数有显著效果，普通函数实际上完全没有内联的必要，也提升不了多少性能。 注意，内联函数中的函数形参，无法作为值给到变量，只能调用： 同样的，由于内联，导致代码被直接搬运，所以Lambda中的return语句可以不带标签，这种情况会导致直接返回： fun main() { test { return } //内联高阶函数的Lambda参数可以直接写return不指定标签 println(\"调用上面方法之后\") } inline fun test(func: (String) -\u003e Unit){ func(\"HelloWorld\") println(\"调用内联函数之后\") } 上述代码的运行结果就是，直接结束，两句println都不会打印，这种情况被称为非局部返回。 回到上一节最后我们提出的问题，实际上，在Kotlin中Lambda表达式支持一个叫做\"标签返回\"（labeled return）的特性，这使得你能够从一个Lambda表达式中返回一个值给外围函数，而不是简单地返回给Lambda表达式所在的最近的封闭函数，就像下面这样： fun main() { test { return@main } //标签可以直接指定为外层函数名称main来提前终止整个外部函数 println(\"调用上面方法之后\") } inline fun test(func: (String) -\u003e Unit){ func(\"HelloWorld\") println(\"调用内联函数之后\") } 效果跟上面是完全一样的，为了避免这种情况，我们也可以像之前一样将标签写为@test来防止非局部返回。 fun main() { test { return@test } //这样就只会使test返回，而不会影响到外部函数了 println(\"调用上面方法之后\") } 有些时候，可能一个内联的高阶函数中存在好几个函数参数，但是我们希望其中的某一个函数参数不使用内联，能够跟之前一样随意当做变量使用： fun main() { test({ println(\"我是一号：$it\") }, { println(\"我是二号：$it\") }) } //在不需要内联的函数形参上添加noinline关键字，来防止此函数的调用内联 inline fun test(func: (String) -\u003e Unit, noinline func2: (Int) -\u003e Unit){ println(\"这是一个内联函数\") func(\"HelloWorld\") var a = func2 //这样就不会报错，但是不会内联了 func2(666) } 最后编译出来的结果，类似于： fun main() { println(\"这是一个内联函数\") val it = \"HelloWorld\" println(\"打印：$it\") //第二个参数由于不是内联，这里依然作为Lambda使用 val func2: (Int) -\u003e Unit = { println(\"我是二号：$it\") } func2(666) } 由于目前知识的学习还不太够，函数我们只能先暂时告一段落，在后续的学习中我们会继续认识更多函数的特性。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:4:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类与对象 在之前，我们一直在使用顶层定义： val a = 20 //直接在kt文件中定义变量 fun message() { //直接在kt文件中定义函数 println(\"我是测试方法\") } 而学习了类之后，这些内容也可以定义到类中，作为类的属性存在。 类的概念我们在生活中其实已经听说过很多了。 人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。 对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。 所以说，类就是抽象概念的人，而对象，就是具体的某一个人。 A：是谁拿走了我的手机？ B：是个人。（某一个类型） A：我还知道是个人呢，具体是谁呢？ B：是XXX。（具体某个对象） 而在Kotlin中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象，像这种编程方式，我们称为面向对象编程，我们除了去使用Kotlin给我们提供的类型之外，我们也可以使用自己定义的类。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的定义与对象创建 前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。 Kotlin中的类使用关键字class声明，我们可以直接在默认的Main.kt文件中编写： class Student { //在没有任何内容时，花括号可以省略 } 我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。 除了直接在某个.kt文件中直接编写之外，为了规范，我们一般将一个类单独创建一个文件，我们可以右键src目录： 这里选择新建，然后选择Kotlin类/文件选项，然后创建一个类： 文件创建完成后，默认也会为我们生成类的定义，并且类名称与创建的类文件是一模一样的： 这是一个非常简单的类，但是肯定远远不够。 既然是学生类，那么肯定有学生相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？我们需要指定类的构造函数，构造函数也是函数的一种，但是它是专用于对象的创建，Kotlin中的类可以添加一个主构造函数和一个或多个次要构造函数。主构造函数是类定义的一部分，像下面这样编写： class Student constructor(name: String, age: Int) { //比如学生有name和age属性，那么我们可以在类名后面constructor的括号中编写，并用逗号隔开 //这里跟定义变量差不多，也是变量名称:类型，这些作为类的成员属性，后续可以在类中使用 } 如果主构造函数没有任何注释或可见性修饰符，则可以省略constructor关键字，如果类中没有其他内容要写，可以直接省略花括号，最后就变成这样了： class Student(name: String, age: Int) 但是，这里仅仅是定义了构造函数的参数，这还不是类的属性，那么我们要怎么才能定义为类的属性呢？我们可以为这些属性添加var或val关键字来表示这个属性是可变还是不变的： class Student(var name: String, val age: Int) 这跟我们之前使用变量基本一致： val：不可变属性 var：可变属性 这样才算是定义了类的属性，我们也可以给这些属性设置初始值： class Student(var name: String, val age: Int = 18) //默认每个学生18岁 除了将属性添加到构造函数中，我们也可以将这些属性直接作为类的成员变量写到类中，但是这种情况必须要配一个默认值，否则无法通过编译： class Student { var name: String = \"\" //必须配一个默认值 var age: Int = 0 } 这样我们就可以不编写主构造函数也能定义属性，但是这里仍然会隐式生成一个无参的构造函数，为了构造函数能够方便地传值初始化，也可以像这样写： class Student(name: String, age: Int) { var name: String = name //通过构造函数传递过来 var age: Int = age } 当然，如果各位不希望这些属性在一开始就有初始值，而是之后某一个时刻去设定初始值，我们也可以为其添加懒加载： class Student { lateinit var name: String //懒加载的属性可以不用在一开始赋值，但是在下一次使用之前一定要先完成赋值，否则报错 var age: Int = 0 } 并且，像这样编写的类成员变量，也可以自定义对应的getter和setter属性： class Shape(var width: Int, var height: Int) { val area get() = width * height } 那么，现在我们定义了主构造函数之后，该怎么去使用它呢？ 跟我们调用普通函数一样，这里的函数名称就是类的名称，如果一个类没有编写构造函数，那么这个类默认情况下使用一个无参构造函数创建： fun main() { //我们可以直接使用 类名() 的形式创建对象 Student() } 如果是有构造函数的类，我们只需要填写需要的参数即可，调用之后，类的属性就是这里我们给进去的参数了： fun main() { //我们可以直接使用 类名(参数, 参数...) 的形式创建 Student(\"小明\", 18) } 这样，我们就成功创建出了一个名字为小明的学生类型对象，但是这个对象仅仅是创建出来还不行，我们肯定需要去使用它。 实际上，我们可以像之前使用基本类型一样，使用对象，我们也可以使用一个变量去接收生成出来的对象： fun main() { //使用Student类型的变量接收构造方法得到的对象 var stu: Student = Student(\"小明\", 18) } 有一个我们需要注意的点，这里的stu存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象。 fun main() { val p1 = Student(\"小明\", 18) val p2 = p1 } 这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在） 我们可以来测试一下： fun main() { val s1 = Student(\"小明\", 18) val s2 = s1 println(s1 === s2) //使用 === 可以判断两个变量引用的是不是同一个对象 } 但是如果我们像这样去编写： fun main() { val s1 = Student(\"小明\", 18) val s2 = Student(\"小明\", 18) //即使名字和年龄一样，但是由于这里重新创建了一次对象 println(s1 === s2) //这里比较的就不是同一个对象了 } 我们可以使用.运算符来访问对象的属性，比如我们要访问小明这个学生对象的属性： fun main() { val stu = Student(\"小明\", 18) println(\"对象的name = ${stu.name}, age = ${stu.age}\") } 获取和修改都是可以的： fun main() { val stu = Student(\"小明\", 18) stu.name = \"大明\" stu.age = 10 //由于age属性是val，所以说无法修改，只能读取 } 注意，不同对象的属性是分开独立存放的，虽然都是统一由类完成定义，但是每个对象都有一个自己的空间，修改一个对象的属性并不会影响到另一个相同类型的对象： fun main() { val stu1 = Student(\"小明\", 18) val stu2 = Student(\"小明\", 18) stu1.name = \"小红\" println(\"${stu1.name}, ${stu2.name}\") } 除了直接使用主构造函数创建对象外，我们也可以添加一些次要构造函数，比如我们的学生可以只需要一个名字就能完成创建，我们可以直接在类中编写一个次要构造函数： class Student(var name: String, val age: Int) { constructor(name: String) : this(name, 18) } 如果该类有一个主构造函数，则每个次要构造函数需要通过另一个次要构造函数直接或间接委托给主构造函数。委托到同一类的另一个构造函数是this关键字完成的： class Student(var name: String, val age: Int) { //这里可以使用constructor关键字继续声明次要构造函数 //次要构造函数中的参数仅仅是表示传入的参数，不能像主构造函数那样定义属性 //这里的this表示是当前这个类，this()就是调用当前类的构造函数 constructor(name: String) : this(name, 18) //这里其实是调用主构造函数，并且参数只有name，年龄直接给个默认值18 } 如果一个类没有主构造函数，那么我们也可以直接在在类中编写次要构造函数，但是不需要主动委托一次主构造函数，他这里会隐式包含，所以说我们直接写就行了： class Student { constructor(name: String) //注意，这里的参数不是类属性，仅仅是一个形参！ } 次要构造函数和主构造函数一样，都可以用于对象的创建： fun main() { val stu1 = Student(\"小明\", 18) val stu2 = Student(\"小红\") } 并且次要构造函数可以编写自定义的函数体： open class Student { constructor(str: String) { //在使用辅助构造函数初始化对象时，会执行里面的内容 println(\"我的名字是: $str\") } } 因此，主构造函数相比次要（辅助）构造函数： 主构造函数： 可以直接在主构造函数中定义类属性，使用更方便，但是主构造函数只能存在一个，并且无法编写函数体，只有为类属性做初始化赋值的效果。 辅助（次要）构造函数： 可以存在多个，并且可以自定义函数体，但是无法像主构造函数那样定义类属性，并且当类具有主构造函数时，所有次要构造函数必须直接或间接地调用主构造函数。 Kotlin语言本身比较灵活，类中并不是一定需要主构造函数，全部写辅助构造函数","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"对象的初始化 在对象创建时，我们可能需要做一些初始化工作，我们可以使用初始化代码块来完成，初始化代码块使用init关键字来完成。假如我们希望对象在创建的时候，如果年龄不足18岁，那么就设定为18岁： class Student(var name: String, var age: Int) { //由于主构造函数无法编写函数体 //因此我们可以在init的花括号中编写初始化代码 //注意这段初始化代码块，是在上面的类属性被赋值之后才执行的，所以说能拿到已经赋值的age属性 init { println(\"我是初始化操作\") if(age \u003c 18) age = 18 println(\"初始化操作结束\") } } 这样，我们在创建对象的时候，就会在创建的时候自动执行初始化代码块里面的代码： fun main() { val stu = Student(\"小明\", 15) println(stu.age) } 可以看到初始化操作开始执行了： 初始化操作不仅仅可以有一个，也可以有很多个： class Student { //注意，多个初始化操作时，从上往下按顺序执行 init { println(\"我是一号初始化操作\") } init { println(\"我是二号初始化操作\") } } 对于将成员属性写到类中的情况，同样是按照顺序向下执行，比如： 因为成员变量a是在初始化代码块的后面才初始化的，这里会报错。 如果一个类具有次要构造函数，那么我们也可以直接在次要构造函数中编写一些初始化代码： class Student(var name: String, var age: Int) { constructor(name: String) : this(name, 18) { println(\"我是次要构造函数中的语句\") } } 当我们使用对应的次要构造函数时，就会执行次要构造函数中的初始化代码了。 这里需要注意一下，次要构造函数实际上需要先执行主构造函数，而在执行主构造函数时，会优先将之前我们讲解的初始化代码块执行，比如下面的代码： class Student(var name: String, var age: Int) { init { println(\"我是初始化代码块\") } constructor(name: String) : this(name, 18) { println(\"我是次要构造函数\") } } 无论是有主构造函数还是没有主构造函数（会生成一个默认的无参构造函数）都会先执行。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的成员函数 现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。 而对象也可以做出一些行为，我们可以通过定义函数来实现，类的函数和我们之前编写的函数有一些区别，它是属于这个类的，我们之前使用的函数都是直接编写在Kt文件中，它们都是顶级函数。 class Student(var name: String, var age: Int) { //这个函用于跟大家打招呼 fun hello(){ println(\"大家好啊\") } } 要使用类的成员函数，我们只能通过对象来进行调用： fun main() { val stu = Student(\"小明\", 18) //调用类中的成员方法，同样使用.运算符即可 stu.hello() //让小明这个对象给大家打招呼 } 是不是稍微有一些体会了？好像真的是我们在让对象执行一个动作一样。在类的成员函数中，我们可以直接访问当前类对象中的一些属性，比如我们这里的用户名和年龄： class Student(var name: String, var age: Int) { fun hello(){ println(\"大家好啊，我叫$name，今年${age}岁了\") } } 注意，这里我们访问的name和age属性，是当前这个对象的name和age属性。比如： fun main() { val stu = Student(\"小明\", 18) stu.hello() //让小明这个对象给大家打招呼 val stu2 = Student(\"小红\", 17) stu2.hello() //让小红这个对象给大家打招呼 } 注意，下面这种情况，我们需要特殊处理： class Student(var name: String, var age: Int) { //此时函数的参数也有一个name变量，而类的成员也有一个name属性 fun hello(name: String){ //这里得到的name是哪一个？ println(\"大家好啊，我叫$name，今年${age}岁了\") } } 如果函数中的变量存在歧义，那么优先使用作用域最近的一个，比如函数形参的name作用域更近，那么这里的name拿到的一个是形参name，而不是类的成员属性name。 如果我们需要获取的是类中的成员属性，需要使用this关键字来表示当前类： fun hello(name: String){ //使用this关键字表示当前对象，这样就可以指定这里是类中的this了 println(\"大家好啊，我叫${this.name}，今年${age}岁了\") } 默认情况下，如果作用域不冲突，使用类中属性this可以省略。 在类中，我们同样可以定义多个同名但不同参数的函数实现重载： class Student(private var name: String, private var age: Int) { fun hello() = println(\"大家好啊，我叫${this.name}，今年${age}岁了\") fun hello(gender: String) = println(\"大家好啊，我叫${this.name}，今年${age}岁了，性别${gender}\") } 实际上类中的函数使用起来跟我们之前定义的大差不差，只不过多了更多用法而已。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"再谈基本类型 在Kotlin中，万物皆为对象，实际上我们在上一章学习的全部基本类型，都是官方为我们提供的类。 现在我们学习了类与对象的知识，就可以来重新认识一下这些基本类型，实际上这些基本类型同样是类，也具有一些属性，以及一些类中的成员函数。实际上在上一章中，我们就已经开始使用类和对象了，我们对这些基本类型的操作同样是在操作对象： fun main() { var a = 10 //这里其实是一个Int类型的对象，值为10，而a持有的是对这个Int对象的引用 var b = a //这里的b复制了对上面Int类型对象的引用 } 特别说明： 在Kotlin中，虽然编码时万物皆对象，但是在最终编译时，会根据上下文进行优化性能，大部分情况下会优先编译为Java原生基本数据类型（不是对象）而另一部分情况下才会编译为Java中的Integer包装类型。因此很容易出现以下迷惑行为： val a: Int = 12345 val b: Int = 12345 println(a === b) //true val a: Int? = 12345 val b: Int? = 12345 println(a === b) //false 各位小伙伴可以在完整学习Java和后续Kotlin内容之后再来探究这个问题。 既然这些基本类型也是类，那么肯定同样具有成员属性和成员函数，我们可以使用这些成员方法方便我们的项目开发，比如我们之前遇到的一个很麻烦的问题，不同类型的数无法相互转换： 这些时候可能我们需要将对应类型的数据转换为其他类型，那么该怎么办呢，实际上，在这些基本类型中都提供了对应类型转换成员函数，这里我们可以使用toInt来直接将Double类型的数据转换为Int类型： fun main() { var a: Int = 1.25.toInt() //使用类中的类型转换函数 } 这样就可以编译通过了。同样的，每个基本类型都有对应的类型转换函数，而且非常全面，比如Int类型： 有了这些成员函数，就大幅度方便了我们的类型转换，再比如我们常见的String类型，也有很多函数可以使用： fun main() { val a = \"HelloWorld\" //使用lowercase和uppercase可以快速将字符串中的字母进行大小写转换 println(a.lowercase()) println(a.uppercase()) } 不过需要注意的是，我们在前面就说过，字符串一旦创建就是不可变的，因此，字符串中所有的函数得到的新字符串，都是重新创建的一个新的对象，而不是在原本的字符串上进行修改。 我们继续来看看一些有意思的函数，比如我们想批量替换字符串中的某些内容： fun main() { val a = \"Hello World!\" println(a.replace(\"o\", \"a\")) } 将字符串中所有的字母o替换为a，直接使用replace函数就能直接生成替换之后的字符串了。又比如我们要判断某个字符串是否以指定文本开头： fun main() { val a = \"Hello World!\" println(a.startsWith(\"Hel\")) } 可以看到这里经过判断得到了一个Boolean类型的结果，还有很多用于判断字符串是否为空、是否有空格等等的函数： fun main() { val a = \"Hello World!\" a.isBlank() a.isEmpty() } 我们还发现，这些基本类型中有一些比较特殊的函数，比如plus函数： 这个函数在类中定义长这样： public operator fun plus(other: Long): Long 这个函数添加了一个operator关键字，这个是什么呢？这其实是运算符重载，能够自定义运算符实现的功能，我们之前使用这些数字进行运算，比如加减乘除，实际上都是这些基本类型在类中重载了运算符实现的，下一部分，我们就来介绍一下运算符重载函数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"运算符重载函数 Kotlin支持为程序中已知的运算符集提供自定义实现，这些运算符具有固定的符号表示（如+或*）以及对应的优先级，要实现运算符重载，请为相应类型提供具有对应运算符指定名称的成员函数，而当前的类对象，则直接作为对应运算符左边的操作数，如果是一元运算符（比如++自增运算符，只需要本事）则直接作为操作数参与运算。 比如，现在我们想要为我们自定义的类型支持加法运算： 我们可以直接在类定义中添加一个固定名称（名称是预设好的，不能自己想写什么写什么）的函数，这里的加法运算就是plus函数，我们直接开始编写就可以了： class Student(var name: String, var age: Int) { //注意，二元运算符必须带一个形参，表示右侧的操作数，返回值为计算出来的结果 //形参和结果可以是任意类型，我们还可以提供多次编写同名的运算符重载函数来适配不同的类型 operator fun plus(another: Student): Student{ //比如这里我们希望两个学生对象相加，得到的结果为名字相加，年龄相加的一个新学生 return Student(this.name + another.name, this.age + another.age) } } 这样，我们就成功重载了加法运算符，可以直接上手使用： fun main() { val a = Student(\"小米\", 18) val b = Student(\"华为\", 19) val c = a + b println(\"运算之后得到的新学生，名称：${c.name}，年龄：${c.age}\") } 是不是感觉很简单？只需要将我们需要的对应运算符直接重载，编写好对应的计算规则，就可以直接使用对应的运算符进行计算。 我们也可以试试看重载一些一元运算符，比如取反运算符： class Student(var name: String, var age: Int) { //比如取反操作就是把当前学生的名字反过来 operator fun not() : Student { this.name = this.name.reversed() //这里可以直接在当前对象上进行操作，然后返回当前对象 return this } } 我们来尝试使用一下： fun main() { //直接在这里使用!运算符 val a = !Student(\"小米\", 18) println(\"运算之后得到的新学生，名称：${a.name}，年龄：${a.age}\") } 最后，我们列出常见的一些运算符对应的函数名称，首先是一元运算符： 符号 对应的函数名称 +a a.unaryPlus() -a a.unaryMinus() !a a.not() a-- a.dec()+见下文 a++ a.inc()+见下文 其中inc()和dec()函数比较特殊，它们必须返回一个值，该值将分配给使用++或--操作的变量，而不是改变执行inc或dec操作的对象，意思就是执行后应该得到一个新生成的对象，然后变量的值直接引用到这个新的对象，因为Int类型就是这样的，比如a++的操作步骤如下： 将a的初始值存储到临时存储a0。 将a0.inc()的结果分配给a。 返回a0作为表达式的结果。 同样的，++a的操作步骤如下： 将a.inc()的结果分配给a。 作为表达式的结果返回a的新值。 认识完了一元运算符，我们接着来看一些基本二元运算符： 符号 对应的函数名称 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) a..\u003cb a.rangeUntil(b) 符号 对应的函数名称 a in b b.contains(a) a !in b !b.contains(a) 对于in这种运算，必须返回Boolean类型的结果。 还有一些自增简化运算符： 符号 对应的函数名称 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b) 这类运算符都是将运算结果赋值给左边的操作数，比如a = a + b等价于a += b，这种情况可能会与上面的基本操作产生歧义，比如下面的情况： class Student(var name: String, var age: Int) { //同时定义plus和plusAssign operator fun plus(another: Student) : Student { return this } operator fun plusAssign(another: Student) : Unit{ } } 可以看到，上面的函数中，plus运算符在重载之后，运算结果与当前类型是相同的，这种情况下，就会出现一个问题： plus： 算式 a = a + b 可以成立，因为返回类型相同，可以重新赋值给a plusAssign：为算式 a = a + b 的缩写，与plus的功能完全一致 此时，两个函数都匹配这里的运算符使用，编译器不知道该用哪一个了，因此就会出现歧义： 比较运算符只需要实现一个函数即可： 运算符 对应的函数名称 a \u003e b a.compareTo(b) \u003e 0 a \u003c b a.compareTo(b) \u003c 0 a \u003e= b a.compareTo(b) \u003e= 0 a \u003c= b a.compareTo(b) \u003c= 0 所有比较都会转换为compareTo函数调用，此函数返回Int值，这个值用于判断是否满足条件。 Kotlin非常强大，甚至连小括号都能重载： 运算符 对应的函数名称 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ..., i_n) a.invoke(i_1, ..., i_n) 直接使用变量名称+()来进行使用，感觉很像函数的调用，但是又不是，就很奇怪，不过确实很强大就是了。 还有一些运算符，以我们目前所学知识还无法进行讲解，后续在各位小伙伴学习之后，可以回顾一下： 运算符 对应的函数名称 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, ..., i_n] a.get(i_1, ..., i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, ..., i_n] = b a.set(i_1, ..., i_n, b) 这是索引访问运算符，使用方括号进行表示。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"中缀函数 实际上中缀函数在我们之前很多时候都有出现，比如位运算： println(i shl 1) 这里的shl并不是一个运算符，而是一段自定义的英文单词，像这种运算符是怎么做到的呢？ 这其实是中缀函数，用infix关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，Infix函数必须满足以下要求： 必须是成员函数。 只能有一个参数。 参数不能有默认值。 我们可以像下面这样编写： class Student(var name: String, var age: Int) { //这个中缀函数实现了将给定字符串与当前对象的名字拼接并返回 infix fun test(string: String) : String{ return name + string } } 我们在使用时，也非常方便，真的就像在使用一个运算符一样： fun main() { val student = Student(\"小明\", 18) println(student test \"我爱你\") } 得到的结果显而易见： 当然，我们也可以把它当做一个普通的函数进行调用，效果是完全等价的： fun main() { val student = Student(\"小明\", 18) println(student.test(\"崴泥\")) } 这里需要注意一下： 中缀函数调用的优先级低于算术运算符、类型转换和rangeTo运算符，例如以下表达式就是等效的： 1 shl 2 + 3相当于1 shl (2 + 3) 0 until n * 2相当于0 until (n * 2) xs union ys as Set\u003c*\u003e相当于xs union (ys as Set\u003c*\u003e)（类型转换会在下一章多态进行介绍） 另一方面，infix函数调用的优先级高于布尔运算符\u0026\u0026和||、is-和in-checks以及其他一些运算符的优先级。这些表达式也是等价的： a \u0026\u0026 b xor c相当于a \u0026\u0026 (b xor c) a xor b in c相当于(a xor b) in c 同时，如果需在类中使用中缀函数，必须明确函数的调用方（接收器）比如： class MyStringCollection { infix fun add(s: String) { /*...*/ } fun build() { this add \"abc\" // 正确 add(\"abc\") // 正确 //add \"abc\" // 错误: 没有指定调用方或无法隐式表达 } } 对于中缀函数的使用还是比较简单的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"空值和空类型 所有的变量除了引用一个具体的值之外，还有一种特殊的值可以使用，那就是null，它代表空值，也就是不引用任何对象。 在其他语言中，比如Java中null是一个非常常见的值，因为在某些情况下，引用类型的变量默认值就是null，这就经常会导致程序中出现一些空指针导致的异常，在Kotlin中，对空值处理是非常严格的，正常情况下，我们的变量是不能直接赋值为null的，否则会报错，无法编译通过： 这是因为所有的类型默认都是非空类型，非空类型的变量是不允许被赋值为null的，这直接在编译阶段就避免了其他语言中经常存在的空指针问题。 那么，如果我们希望某个变量在初始情况下使用null而不去引用某一个具体对象，该怎么做呢，此时我们需要将变量的类型修改为可空类型，只需在类型名称的后面添加一个?即可： fun main() { var str: String? = null } 既然现在是可空类型，那么很多问题就会出现了，比如当一个变量为null时，此时如果使用类中的一些成员方法或是获取成员属性时，会出现一些问题： 这里由于我们操作的是一个空类型，它有可能值为null，我们可以想象一下，如果一个变量不引用任何对象，此时我们又去让对象做一些事情（执行函数）这不是在搞笑吗，压根就没这个对象，难道让空气去执行操作吗？这显然是不对的，这样就会导致我们上面所说的空指针异常。 此时，为了安全，我们就需要对变量进行判断，看看其是否为null然后才能去做一些正常情况下该做的事情： fun main() { var str: String? = null //这里直接通过if语句判断str变量是否为null，如果不是才执行 if (str != null) { println(str.length) //现在就可以编译通过了 } } 可以看到，我们只要能确保某个空类型变量的值不为空，那么就可以正常执行操作。当然，实际上在这个if内部，因为已经判断不为null了，所以str被智能类型转换为非空类型，这也是Kotlin语言非常人性化的地方。 不过在有些情况下，我们可能已经非常清楚，这里的str一定不为null，即使它是一个可空类型变量，我们可以像这样做，来告诉编译器，我们这里一定是安全的，只管执行就好： fun main() { var str: String? = null //使用非空断言操作符!!.来明确不会出现null问题 println(str!!.length) } 虽然使用非空断言操作符能够进行强制操作，但是这样实际上并不安全，它同样存在安全问题，也许我们有没考虑到的情况会导致这里为null呢，也说不定吧？对于一些我们拿不定具体会不会出现null的情况，有没有更好的解决办法呢？ Kotlin为我们提供了一种更安全的空类型操作，要安全地访问可能包含null值的对象的属性，请使用安全调用运算符?.，如果对象的属性为null则安全调用运算符返回null，像下面这样： fun main() { var str: String? = null println(str?.length) } 这里的调用结果存在两种情况： 如果str为null，那么这里得到的结果就是null，并且不会正常执行后面的操作 如果str不为null，那就正常返回这里本应该得到的结果 因此，使用安全调用运算符后，如果遇到null的情况，那么这里不会正常进行原本的操作，而是直接返回null作为结果，这在有些时候非常好用，比如我们希望一个学生类型的变量在为null时就不执行对应的语句： fun main() { val stu: Student? = null stu?.hello() } 不过在有些时候，可能我们希望如果变量为null，在使用安全调用运算符时，返回一个我们自定义的结果，而不是null，这时该怎么做呢？我们可以使用Elvis运算符： fun main() { val str: String? = null //Elvis运算符 ?: 左侧为空值检测目标，右侧为检测到null时返回的结果 val len: Int = str?.length ?: 0 } 这里我们使用了Elvis运算符来判断左侧是否为null，如果左侧为null，那么这里直接得到右侧的自定义值，这个运算符长得巨像其他语言里面的三元运算符，Kotlin拿来干这事了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"解构声明 有时候，我们在使用对象时可能需要访问它们内部的一些属性： fun main() { val student = Student(\"小明\", 18) println(student.name) //访问name属性 println(student.age) } 这样看起来不太优雅，有没有更好的方式呢，比如这里能不能直接得到Student对象内部的name和age熟悉作为变量使用？当然是可以的，我们可以直接像下面这样编写： fun main() { val student = Student(\"小明\", 18) val (a, b) = student //从Student对象中将其属性解构出来，很优雅 println(\"名字: $a, 年龄: $b\") } 要让一个类的属性支持解构，我们只需添加约定的函数即可，在Kotlin中，我们可以自定义解构出来的结果，而具体如何获取，需要定义一个componentN函数并通过返回值的形式返回解构的结果： class Student(var name: String, var age: Int) { operator fun component1() = name //使用component1表示解构出来的第一个参数 operator fun component2() = age //使用component2表示解构出来的第二个参数 operator fun component3... //以此类推 } 添加用于解构的函数在之后，我们就可以使用解构操作了： val (a, b) = student //解构出来的参数按顺序就是componentN的结果了 如果我们只想要使用第二个参数，而第一个参数不需要，可以直接使用_来忽略掉： val (_, b) = student println(\"年龄: $b\") 解构同样可以用在Lambda表达式中： val func: (Student) -\u003e Unit = { (a, b) -\u003e //使用括号包括结构出来的两个参数 println(\"名字: $a, 年龄: $b\") } val func2: (Student, Int) -\u003e Unit = { (a, b), i -\u003e println(\"名字: $a, 年龄: $b\") println(i) } val func3: (Student, Int) -\u003e Unit = { (_, b), i -\u003e println(\"名字: $a, 年龄: $b\") println(i) } 解构语法在遍历集合类和数组时同样适用，我们会在后面进行讲解。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:8","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"包和导入 在之前，无论我们创建的是Kotlin源文件还是Kotlin类文件，都是在默认的包下进行的，也就是直接在kotlin/src目录创建的。 但是有些时候，我们可能希望将一些模块按功能进行归类，而不是所有的kt文件都挤在一起，这个时候我们就需要用到包了。 我们可以直接右键新建一个软件包，软件包的包名建议以域名格式进行命名，例如： com.baidu cn.itbaima 这类似于我们平时在浏览器中访问的网站地址，只不过是反过来的，这样就能很明确是哪一家公司或哪一个人制作的产品了。 这里我们随便创建一个： 我们可以将kt文件直接创建在这个包中： 所有不在默认包下kt文件，必须在顶部声明所属的包，比如这里的Test.kt就放在com.test这个包中，因此顶部必须使用package关键字进行包声明，IDEA非常智能，在创建时就自动帮助我们生成好了。我们可以继续像之前一样，编写类或是函数： package com.test var a = 20 fun message() { println(\"我是测试方法\") } class User 不过，由于现在kt文件存放在了一个明确的包中，如果我们要在这个包以外的其他地方使用，会出现一些问题： 当我们使用其他包中kt文件定义的类或函数时，会直接提示未解析的引用，这是因为默认情况下只有同包内的内容可以相互使用，而现在我们使用的是其他包中的内容，我们需要先进行导入操作： import com.test.User //使用import关键字进行导入，导入时需要输入 包名.类型/顶级函数名称 来完成 import com.test.message import com.test.a fun main() { val user = User() message() } 这样，我们在导入之后就可以正常使用了，当然，如果一个包中定义的内容太多，我们需要大量使用，也可以使用*一次性导入全部内容： import com.test.* //导入此包下的全部内容 fun main() { val user = User() message() } 实际上官方提供的库，也是来自于不同的包，但是Kotlin在默认情况下会自动导入一些包，不需要我们明确指定： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 比如我们之前用到的一些基本类型，都是在kotlin这个包中定义的。 注意：在不同的平台下，还会有更多默认导入的包，比如Java平台下，就会默认导入java.lang.*和kotlin.jvm.*这两个包。 在有些情况下，可能会出现名称冲突的情况： import com.test.message fun main() { message() //这里调用的，到底是导入的message函数，还是当前kt文件定义的函数呢？ } fun message(){ println(\"Goodbye World!\") } 结果显而易见，这里会优先使用导入的函数，而不是在当前文件中定义的同名函数。那么该如何去解决这种冲突的情况呢？我们可以使用as关键字来为导入的内容起个新的名字： import com.test.message as outer //将导入的message函数名字改为outer fun main() { message() //此时这里调用的就是下面的message函数了 } fun message(){ println(\"Goodbye World!\") } 这样就可以很好地消除存在歧义的情况了，最后总结一下，使用import关键字支持导入以下内容： 顶级函数和属性 在单例对象中声明的函数和属性（下一章介绍） 枚举常量（下一章介绍） ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:9","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"访问权限控制 有些时候，我们可能不希望别人使用我们的所有内容，比如： package com.test fun message() { println(\"我是测试方法\") } fun inner(){ //我们不希望这个函数能够在其他地方被调用 } 在上面的例子中，有一个函数是我们不希望被外部调用的，但是经过前面的学习，我们只需要使用import关键字就能直接导入，那有没有办法能够控制一下其他地方对于当前文件一些可能私有函数或是其他内容的访问呢？我们可以使用可见性控制来处理。 在类、对象、接口、构造函数和函数，以及属性上，可以为其添加 可见性修饰符 来控制其可见性，在Kotlin中有四个可见性修饰符，它们分别是：private、protected、internal和public，默认可见性是public，在使用顶级声明时，不同可见性的访问权限如下： 如果不使用可见性修饰符，则默认使用public，这意味着这里声明的内容将在任何地方可访问。 如果使用private修饰符，那么声明的内容只能在当前文件中可访问。 如果使用internal修饰符，它将在同一模块中可见（当前的项目中可以随意访问，与public没大差别，但是如果别人引用我们的项目，那么无法使用） 顶级声明不支持使用protected修饰符。 因此，在默认情况下，我们定义的内容都是可以访问的，而想要实现上面的效果，我们可以为其添加private修饰符： private fun inner(){ //我们不希望这个函数能够在其他地方被调用 } 这样，当其他地方使用时，就会报错： 在类中定义成员属性时，不同可见性的访问权限如下： private意味着该成员仅在此类中可见（包括其所有成员） protected与private的可见性类似，外部无法使用，但在子类中可以使用（子类会在下一章中介绍） internal意味着本项目中任何地方都会看到其internal成员，但是别人引用我们项目时不行。 public意味着任何地方都可以访问。 比如下面的例子： class Student(private var name: String, //name属性无法被外部访问，因为是私有的 internal var age: Int) { //age可以被外部访问，但是无法再其他项目中访问到 private constructor() : this(\"\", 10) //这个无参构造无法被外部访问，因为是私有的 } 有了访问控制，我们就可以更加明确地表示哪些内容是可以访问，而哪些是内部使用的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:5:10","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"封装、继承和多态 封装、继承和多态是面向对象编程的三大特性。 封装，把对象的属性和函数结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。 继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和函数，并根据实际需求扩展出新的行为。 多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的函数。 正是这三大特性，能够让我们的Kotlin程序更加生动形象。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的封装 封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个程序带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter函数来查看和设置变量。从这里开始，我们前面学习的权限访问控制就开始起作用了。 我们可以将之前的类进行改进： class Student(private var name: String, private var age: Int) { fun getName(): String = name fun getAge(): Int = age } 现在，外部需要获取一个学生对象的属性时，只能使用特定的函数进行获取，而不像之前一样可以随意访问对象的属性： fun main() { var student = Student(\"\", 1) //student.name 这样就不行了 println(student.getName()) } 这样的好处显而易见，其他地方只能拿到在内部某个成员属性引用的对象，而没办法像之前那样直接修改Student对象中某个成员属性。 同样的，如果要运行外部对对象中的属性进行修改，那么我们也可以提供对应的set函数： class Student(private var name: String, private var age: Int) { ... fun setName(name: String){ //使用set函数来修改 this.name = name } } 等等，这不就是我们之前讲的属性的getter和setter函数吗，没错，哪怕我们不手动编写，成员属性也会存在默认的。但是，除了直接赋值之外我们也可以设置更多参数才能给学生改名字： class Student(private var name: String, private var age: Int) { fun setName(name: String, upper: Boolean){ //判断是否upper来决定最终赋值的名字大写还是小写 this.name = if (upper) name.uppercase() else name.lowercase() } } 我们自己封装好的名字设置方法暴露给外部使用，而不让外部直接操作名字。 我们甚至还可以将主构造函数改成私有的，需要通过其他的构造函数来构造： class Student private constructor(private var name: String, private var age: Int) { constructor() : this(\"\", 18) } 封装思想其实就是把实现细节给隐藏了，外部只需知道这个函数是什么作用，如何去用，而无需关心实现，要用什么由类自己提供好，而不需要外面来操作类内部的东西去完成（你让我做一件事情，我自己的事情自己做，不要你来帮我安排）封装就是通过访问权限控制来实现的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的继承 前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。 在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，根据前面的访问权限等级，子类可以使用父类中所有非私有的成员。 比如说我们一开始使用的学生，那么实际上学生根据专业划分，所掌握的技能也会不同，比如体育生会运动，美术生会画画，土木生会搬砖，计算机生会因为互联网寒冬找不到工作，因此，我们可以将学生这个大类根据不同的专业进一步地细分出来： 虽然我们划分出来这么多的类，但是其本质上还是学生，也就是说学生具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。就好比大学里的学生无论什么专业都会打游戏，都会睡觉，逃课，考试抄答案，四六级过不了，只不过他们专业不同，学的的方向不一样，也就掌握了其他专业不具备的技能。 在Kotlin中，我们可以使用继承操作来实现这样的结构，默认情况下，Kotlin类是“终态”的（不能被任何类继承）要使类可继承，请用open关键字标记需要被继承的类： open class Student { //被继承的类我们称为父类 val xxx = \"学生证\" fun hello() = println(\"我会打招呼\") } 我们可以像下面这样来创建一个继承学生的类： class ArtStudent : Student() { //以调用构造函数的形式进行声明 //这个类就是Student类的子类 fun draw() = println(\"我会画画\") //子类中也可以继续编写自己独有的函数 } 类的继承可以不断向下，但是同时只能继承一个类，在Kotlin中不支持多继承，只不过套娃还是可以的： open class Student open class ArtStudent: Student() //继承了一级，相当于Student的儿子 open class SuperArtStudent: ArtStudent() //继承了两级，相当于Student的孙子 class SuperBigArtStudent: SuperArtStudent() //继承了三级，相当于Student的祖孙 当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为private，那么子类将无法访问（但是依然是继承了这个属性的）比如下面的例子： fun main() { var student = ArtStudent() student.hello() //虽然这里是ArtStudent对象，但是由于其继承的是Student，因此包含Student中的属性 student.draw() //自己的属性也可以使用 print(student.xxx) //不止函数，父类中的成员字段也是没有问题的 } 是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。这里需要特别注意一下，因为子类相当于是父类的扩展，但是依然保留父类的特性，所以说，在对象创建并初始化的时候，不仅会对子类进行初始化，也会优先对父类进行初始化： open class Student() { init { println(\"父类初始化\") } fun hello() = println(\"我会打招呼\") } class ArtStudent() : Student() { init { println(\"子类初始化\") } fun draw() = println(\"我会画画\") } 实际上这里就是在构造这个子类对象之前，调用了一次父类的构造函数，而我们用于继承指定的构造函数，就是会被调用的那一个。 因此，如果父类存在一个有参构造函数，子类同样必须在构造函数中调用： open class Student(name: String, age: Int) { fun hello() = println(\"我会打招呼\") } //子类必须适配其父类的构造函数，因为需要先对父类进行初始化 //其实就是去调用一次父类的构造函数，填入需要的参数即可，这里的参数可以是当前子类构造方法的形参，也可以是直接填写的一个参数 class ArtStudent(name: String, age: Int) : Student(name, 18) { fun draw() = println(\"我会画画\") } 如果父类存在多个构造函数，可以任选一个： open class Student() { constructor(str: String) : this() constructor(str: String, age: Int) : this() fun hello() = println(\"我会打招呼\") } class ArtStudent : Student(\"小明\", 18) { //任选一个父类构造函数即可 fun draw() = println(\"我会画画\") } 当子类只存在辅助构造函数时，需要使用super关键字来匹配父类的构造函数： open class Student { constructor(str: String) constructor(str: String, age: Int) fun hello() = println(\"我会打招呼\") } //子类不写主构造函数时，可以直接在冒号后面添加父类类名 class ArtStudent : Student { constructor(str: String) : super(str) //使用super来调用父类构造函数,super表示父类（超类） constructor(str: String, age: Int) : super(str, age) fun draw() = println(\"我会画画\") } 也可以去匹配子类中其他构造函数： class ArtStudent : Student { constructor(str: String) : this(str, 18) //也可以调用子类其他构造函数，但是其他构造函数依然要间接或直接调用父类构造函数 constructor(str: String, age: Int) : super(str, age) fun draw() = println(\"我会画画\") } 如果子类既有主构造函数，也有辅助构造函数，那么其他辅助构造函数只能直接或间接调用主构造函数： open class Student() { constructor(str: String) : this() constructor(str: String, age: Int) : this() fun hello() = println(\"我会打招呼\") } class ArtStudent() : Student() { constructor(str: String) : this() //正确，必须直接或间接调用主构造函数 constructor(str: String, age: Int) : super(str, age) //报错，不能绕过主构造函数去匹配父类构造函数 fun draw() = println(\"我会画画\") } 是不是感觉玩法太多，都眼花缭乱了？实际上只要各位小伙伴心里面清楚下面的规则，就很好理解上面这一堆写法了： 构造函数相当于是这个类初始化的最基本函数，在构造对象时一定要调用 主构造函数因为可能存在一些类的属性，所以说必须在初始化时调用，不能让这些属性初始化时没有初始值 子类因为是父类的延展，因此，子类在初始化时，必须先初始化父类，就好比每个学生都有学生证，这是属于父类的属性，如果子类在初始化时可以不去初始化父类，那岂不是美术生可以没有学生证？显然是不对的。 优先级关系：父类初始化 \u003e 子类主构造 \u003e 子类辅助构造 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"属性的覆盖 有些时候，我们可以希望子类继承父类的某些属性，但是我们可能希望去修改这些属性的默认实现。比如，美术生虽然也是学生，也会打招呼，但是可能他们打招呼的方式跟普通的学生不太一样，我们能否对打招呼这个函数的默认实现进行修改呢？ 我们可以使用override关键字来表示对于一个属性的重写（覆盖）就像这样： open class Student { //注意，跟类一样，函数必须添加open关键字才能被子类覆盖 open fun hello() = println(\"我会打招呼\") } class ArtStudent : Student() { fun draw() = println(\"我会画画\") //在子类中编写一个同名函数，并添加override关键字，我们就可以在子类中进行覆盖了，然后编写自己的实现 override fun hello() = println(\"哦哈哟\") } 覆盖之后，当我们使用子类进行打招呼时，函数会按照我们覆盖的内容执行，而不是原本的： 同样的，类的某个变量也是可以进行覆盖的： open class Student { open val test: String = \"测试\" fun hello() = println(\"我会打招呼: $test\") //这里拿到的test就会变成被覆盖掉的 } class ArtStudent : Student() { //对父类的变量进行覆盖，类型必须一样 override val test: String = \"干嘛\" fun draw() = println(\"我会画画\") } 是不是感觉很神奇？不过对于可变的变量，似乎下面这样来的更方便？ open class Student { var test: String = \"测试\" fun hello() = println(\"我会打招呼: $test\") } class ArtStudent : Student() { init { test = \"干嘛\" } fun draw() = println(\"我会画画\") } 有些时候为了方便，比如在父类中的属性，我们可以直接在子类的主构造函数中直接覆盖： open class Student { open val name: String = \"大明\" fun hello() = println(\"我会打招呼，我叫: $name\") } //在主构造函数中覆盖，也是可以的，这样会将构造时传入的值进行覆盖 class ArtStudent(override val name: String) : Student() { fun draw() = println(\"我会画画\") } fun main() { val student = ArtStudent(\"小红\") student.hello() } 虽然现在已经很方便了，但是现在又来了一个新的需求，打招呼不仅要有子类的特色，同时也要保留父类原有的实现，这个时候该怎么办呢？我们可以使用super关键字来完成： open class Student { open fun hello() = println(\"我会打招呼\") } class ArtStudent : Student() { fun draw() = println(\"我会画画\") override fun hello() { //覆盖父类函数 super.hello() //使用super.xxx来调用父类的函数实现，这里super同样表示父类 println(\"哦哈哟\") //再写自己的逻辑 } } 这样，我们在覆盖原本的函数时，也可以执行原本的实现，在一些对函数内容进行增强的常见，这种用法非常常见： 不过，由于存在我们之前讲解的的初始化顺序，下面的这种情况需要特别注意： open class Student { open val name: String = \"小明\" init { println(\"我的名字是: ${name.length}\") } //这里拿到的name实际上是还未初始化的子类name } class ArtStudent : Student() { override val name = \"大明\" } fun main() { val student = ArtStudent() } 由于父类初始化在子类之前，此时子类还未开始初始化，其覆盖的属性此时没有初始值，根据不同平台的实现，可能会出现一些问题，比如JVM平台下，没有初始化的对象引用默认为null，那么这里就会直接报空指针异常： 很神奇对吧，这里的name属性明明是一个非可空的String类型，居然还会出现null的情况报空指针，因此，对于这些使用了open关键字的属性（函数、变量等）只要是在初始化函数、构造函数中使用，IDEA都会给出警告： 我们接着来讲一个很绕的东西，在使用一些子类的时候，我们实际上可以将其当做其父类来进行使用： fun main() { val student: Student = ArtStudent() //使用Student类型的变量接收一个ArtStudent类型的对象引用 } 之所以支持这样去使用，是因为子类本身就是对父类的延伸，因此将其当做父类使用，也是没有问题的。就好比我们无论是美术生还是体育生，都可以当做学生来用，都可以送去厂里实习打螺丝，不然不给毕业证。 只不过，如果我们将一个对象作为其父类使用，那么在使用时也只能使用其父类的一些属性，就相当于我们在使用一个父类的对象： 即使我们很清楚这里引用的对象是一个美术生，但是只能当做普通学生来用，这在后面的集合类中会经常用到，因为集合类往往存在多种不同的实现，但是我们只需要关心怎么用就行了，并且为了方便更换实现，所以一般使用集合类对应的接口来作为变量的类型。 那么，如果子类重写了父类的某个函数，此时我们以父类的形式去使用，结果会怎么样？ open class Student { open fun hello() = println(\"大家好\") } class ArtStudent : Student() { override fun hello() = println(\"我姓🐴我叫🐴牛逼\") } 可以看到，虽然当做父类来使用，但是其本质是不会变的，所以说，这里执行的结果依然是子类的覆盖实现。 那么，如果项目中很多这种明明是子类但是拿来当做父类用，我们怎么去判断使用的对象到底是什么类型的呢？我们可以使用is关键字来进行类型判断，以下面的三个类为例： open class Student class ArtStudent : Student() class SportStudent : Student() 现在我们进行类型判断： fun main() { val student: Student = ArtStudent() println(student is ArtStudent) //true，因为确实是这个类型 println(student is SportStudent) //false，因为不是这个类型 println(student is Student) //true，因为是这个类型的子类 } 可以看到，使用is关键字可以精准地对类型进行判断，只要判断的对象是这个类或是这个类的子类，那么就会返回true作为结果。 如果我们明确某个变量引用的对象是什么类型，可以使用as关键字来进行强制类型转换： fun main() { val student: Student = ArtStudent() if(student is ArtStudent) { val artStudent = student as ArtStudent; artStudent.draw() //强制类型转换之后，可以直接变回原本的类型去使用 } } 不过，编译器非常智能，它可以根据当前的语境判断的类型自动进行类型转换： val student: Student = ArtStudent() if(student is ArtStudent) { student.draw() } 此时IDEA中会出现提示： 不仅仅是if判断的场景、包括when、while，以及\u0026\u0026 || 等运算符都支持智能转换，只要上下文语境符合就能做到： fun main() { val student: Student? = ArtStudent() //很明显这里是当student为ArtStudent时，根据语境直接智能转换 while (student is ArtStudent) student.draw() //很明显如果这前面已经判断为真了，那肯定是这个类型，后面也可以智能转换 if(student is ArtStudent \u0026\u0026 student.draw()) } 不仅仅是这种场景，比如我们前面讲解的可空类型，同样支持这样的智能转换： fun main() { val student: Student? = ArtStudent() student?.hello() if (student != null) //判断到如果不为null student.hello() //根据语境student智能转换为了非空Student类型 } 在处理一些可空类型时，为了防止出现异常，我们可以使用更加安全的as?运算符： fun main() { val student: Student? = ArtStudent() val artStuden","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"顶层Any类 在我们不继承任何类的情况下，实际上Kotlin会有一个默认的父类，所有的类默认情况下都是继承自Any类的。 这个类的定义如下： /** * Kotlin类继承结构中的根类. 所有Kotlin中的类都会直接或间接将Any作为父类 */ public open class Any { /** * 判断某个对象是否\"等于\"当前对象，这里同样是对运算符\"==\"的重载，而具体判断两个对象相等的操作需要由子类来定义 * 在一些特定情况下，子类在重写此函数时应该保证以下要求: * * 可反身: 对于任意非空值 `x`, 表达式 `x.equals(x)` 应该返回true * * 可交换: 对于任意非空值 `x` 和 `y`, `x.equals(y)` 当且仅当 `y.equals(x)` 返回true时返回true * * 可传递: 对于任意非空值 `x`, `y`, 和 `z`, 如果 `x.equals(y)` 和 `y.equals(z)` 都返回true, 那么 `x.equals(z)` 也应该返回真 * * 一致性: 对于任意非空值 `x` 和 `y`, 在多次调用 `x.equals(y)` 函数时，只要不修改在对象的“equals”比较中使用的信息，那么应当始终返回同样的结果 * * 永不等于空: 对于任意非空值 `x`, `x.equals(null)` 应该始终返回false */ public open operator fun equals(other: Any?): Boolean /** * 返回当前对象的哈希值，它具有以下约束: * * * 对同一对象多次调用该函数时，只要不修改对象上的equals比较中使用的信息，那么此函数就必须始终返回相同的整数 * * 如果两个对象通过`equals`函数判断为true，那么这两个对象的哈希值也应该相同 */ public open fun hashCode(): Int /** * 将此对象转换为一个字符串，具体转换为什么样子的字符串由子类自己决定 */ public open fun toString(): String } 由于默认情况下类都是继承自Any，因此Any中定义的函数也是被继承到子类中了。 首先我们来看这个equals函数，它实际上是对==这个运算符的重载，我们之前在使用一些基本类型的时候，就经常使用==来判断这些类型是否相同，比如Int类型的数据： fun main() { val a = 10 val b = 20 println(a == b) println(a.equals(b)) //跟上面的写法完全一样 } 经过前面的学习，我们知道这些基本类型本质上也是定义的类，实际上它们也是通过重写这个函数来实现这些比较操作的（一些基本类型会根据不同的平台进行编译优化，没法看源码） 我们可以看到，这个函数接受的参数类型是一个Any?类型： public open operator fun equals(other: Any?): Boolean //我们上节课说到一个子类也可以被当做父类类型的变量去使用，所以说equals判断接受的参数为了满足不同的类型变量之间进行比较，直接使用顶层Any作为参数（考虑到会用到可空类型，所以说直接用了Any?作为参数类型） 到目前为止，我们认识了Kotlin中两种相等的判断方式： 结果上 相等 (== 等价于 equals()) 引用上 相等 (=== 判断两个变量是否都是引用的同一个对象) 我们在使用equals比较两个可空对象是否相等时，就像这样： a == b 实际上会被翻译为： a?.equals(b) ?: (b === null) //a如果为null那就直接判断b是不是也为null，否则直接调用a的equals函数并让b作为参数 当然可能会有小伙伴疑问，那不等于判断呢？实际上是一样的： fun main() { val a = \"10\" val b = \"20\" println(a != b) println(!a.equals(b)) //等价于上面的写法 } 我们也可以为我们自己编写的类型重写equals函数，比如我们希望Student类型当名字和年龄相等时，就可以使用==来判断为true，我们可以像这样编写： class Student(val name: String, val age: Int) { override fun equals(other: Any?): Boolean { if(this === other) return true //如果引用的是同一个对象，肯定是true不多逼逼 if(other !is Student) return false //如果要判断的对象根本不是Student类型的，那也不用继续了 if(name != other.name) return false //判断名字是否相同 if(age != other.age) return false //判断年龄是否相同 return true //都没问题，那就是相等了 } } 此时我们已经将其比较操作重写，我们可以来试试看： fun main() { val a = Student(\"小明\", 18) val b = Student(\"小红\", 17) val c = Student(\"小明\", 18) println(a == a) //返回true因为就是自己 println(a == b) //返回false因为名字和年龄不一样 println(a == c) //返回true因为名字和年龄完全一样 } 默认情况下，如果我们不重写类的equals函数，那么会直接对等号两边的变量进行引用判断===判断是否为同一个对象。只不过，可以很清楚地看到IDEA提示我们： 实际上在我们重写类的equals函数时，根据约定，必须重写对于的hashCode函数，至于为什么，我们会在后续的集合类部分中进行介绍，这里我们暂时先不对hashCode函数进行讲解。 接着我们来看下一个，toString函数用于快速将对象转换为字符串，只不过默认情况下，会像这样： fun main() { val a = Student(\"小明\", 18) println(a.toString()) println(a) //println默认情况下会直接调用对象的toString并打印，所以跟上面是一样的 } 可以看到打印的结果是对象的类型@十六进制哈希值的形式，在某些情况下，可能我们更希望的是转换对象的一些成员属性，这样我们可以更直观的看到对象的属性具有什么值： class Student(val name: String, val age: Int) { override fun toString(): String { //直接重写toString函数 return \"Student(name='$name', age=$age)\" } } 现在得到的结果，就是我们自定义的结果了： ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"抽象类 有些情况下，我们设计的类可能仅仅是作为给其他类继承使用的类，而其本身并不需要创建任何实例对象，比如： open class Student protected constructor() { //无法构造这个父类，要求使用子类 open fun hello() = println(\"Hello World!\") } class ArtStudent: Student() { override fun hello() = println(\"原神\") //两个子类都对hello进行了实现，采用各自的方式 } class SportStudent: Student() { override fun hello() = println(\"启动\") } 可以看到，在上面这个例子中，Student类的hello函数在子类中都会被重写，所以说除非在子类中调用父类的默认实现，否则一般情况下，父类中定义的函数永远都不会被调用。 就像我们说一个学生会怎么考试一样，实际上学生怎么考试是一个抽象的概念，但是由于学生的种类繁多，美术生怎么考试和体育生怎么考试，才是具体的一个实现。所以说，我们可以将学生类进行进一步的抽象，让某些函数或字段完全由子类来实现，父类中不需要提供实现。我们可以使用abstract关键字来将一个类声明为抽象类： //使用abstract表示这个是一个抽象类 abstract class Student { abstract val type: String //抽象类中可以存在抽象成员属性 abstract fun hello() //抽象类中可以存在抽象函数 //注意抽象的属性不能为private，不然子类就没法重写了 } 当一个子类继承自抽象类时，必须要重写抽象类中定义的抽象属性和抽象函数： class ArtStudent: Student() { override val type: String = \"美术生\" override fun hello() = println(\"原神，启动！\") } 这是强制要求的，如果不进行重写将无法通过编译。同时，抽象类是不允许直接构造对象的，只能使用其子类： 当然，抽象类不仅可以具有抽象的属性，同时也具有普通类的性质，同样可以定义非抽象的属性或函数： abstract class Student { abstract val type: String abstract fun hello() fun test() = println(\"不会有人玩到大三了才开始学Java吧\") //定义非抽像属性或函数，在子类中不强制要求重写 } 同时，抽象类也可以继承自其他的类（可以是抽象类也可以是普通类） open class Test //直接继承一个普通的类 abstract class Student: Test(){ ... } 虽然抽象类可以继承一个普通的类，但是这依然不改变它是抽象类的本质，子类依然要按照上面的要求进行编写。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"接口 由于Kotlin中不存在多继承的操作，我们可以使用接口来替代。 前面我们认识了抽象类，它可以具有一些定义而不实现的内容，而接口比抽象类还要抽象，一般情况下，他只代表某个确切的功能！也就是只能包含函数或属性的定义，所有的内容只能是abstract的，它不像类那样完整。接口一般只代表某些功能的抽象，接口包含了一系列内容的定义，类可以实现这个接口，表示类支持接口代表的功能。 比如，学生具有以下功能： 打游戏 睡懒觉 逃课 考试作弊 我们可以将这一系列功能拆分成一个个的接口，然后让学生实现这些接口，来表示学生支持这些功能。 在Kotlin中，要声明接口，我们可以使用interface关键字： interface A { val x: String //接口中所有属性默认都是abstract的（可省略关键字） fun sleep() //接口中所有函数默认都是abstract的（可省略关键字） } interface B { fun game() } class Student: A, B { //接口的实现与类的继承一样，直接写到后面，多个接口用逗号隔开 override val x: String = \"测试\" //跟抽象类一样，接口中的内容是必须要实现的 override fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") override fun game() = println(\"读大学就该玩游戏玩到爽\") } 可以看到，接口相比于抽象类来说，更加的纯粹，它不像类那样可以具有什么确切的属性，一切内容都是抽象的，只能由子类来实现。 只不过，在接口中声明的属性可以是抽象的，也可以为Getter提供默认实现。在接口中声明的属性无法使用field后背字段，因此在接口中声明的Setter无法使用field进行赋值： interface A { val x: String get() = \"666\" //只能重写getter，不能直接赋值，因为默认情况下getter是返回的field的值，但是接口里不让用 } interface A { var x: String get() = \"666\" set(value) { /* 默认的setter会直接报错，因为使用了field字段 */ } } 为了应对变化多端的需求，接口也可以为函数编写默认实现： interface A { //接口中的函数可以具有默认实现，默认情况下是open的，除非private掉 fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") } 这样一看，这函数可以写默认的实现那接口似乎变得不那么抽象了？这用着感觉好像跟抽象类没啥区别啊？接口跟类的最大区别其实就是状态的保存，这从上面的成员属性我们就可以看的很清楚。 接口也可以继承自其他接口，直接获得其他接口中的定义： interface A{ fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") } interface B{ fun game() = println(\"读大学就该玩游戏玩到爽\") } interface C: A, B //接口的继承写法是一样的，并且接口继承接口是支持多继承的 class Student: C //直接获得ABC三个接口的功能 是不是感觉接口的玩法非常有意思？只不过玩的过程中，可能也会遇到一些麻烦，比如下面的这种情况： interface A{ fun sleep() = println(\"管他什么早八不早八的，睡舒服再说\") } interface B{ fun sleep() = println(\"7点起床学Java了，不能再睡了\") } class Student: A, B //由于A和B都具有sleep函数，那现在到底继承谁的呢？ 这种情况下，我们需要手动解决冲突，比如我们希望Student类采用接口B的默认实现： class Student: A, B { override fun sleep() { //手动重写sleep函数，自行决定如何处理冲突 super\u003cB\u003e.sleep() //使用super关键字然后添加尖括号指定对应接口，并手动调用接口对应函数 } } 对于接口，我们可以像之前一样，将变量的类型设定为一个接口的类型，当做某一个接口的实现来使用，同时也支持is、as等关键字进行类型判断和转换： fun main() { val a: A = Student() a.sleep() //直接当做A接口用（只能使用A接口中定义的内容） println(a is B) //判断a引用的对象是否为B接口的实现类 } 是不是感觉跟之前使用起来是差不多的？其实只要前面玩熟悉了，后面还是很简单的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类的扩展 Kotlin提供了扩展类或接口的操作，而无需通过类继承或使用装饰器等设计模式，来为某个类添加一些额外的函数或是属性，我们只需要通过一个被称为扩展的特殊声明来完成。 例如，您可以从无法修改的第三方库中为类或接口编写新函数，这些函数可以像类中其他函数那样进行调用，就像它们是类中的函数一样，这种机制被称为扩展函数。还有扩展属性，允许您为现有类定义新属性。 比如我们想为String类型添加一个自定义的操作： //为官方的String类添加一个新的test函数，使其返回自定义内容 fun String.test() = \"666\" fun main() { val text = \"Hello World\" println(text.test()) //就好像String类中真的有这个函数一样 } 是不是感觉很神奇？通过这种机制，我们可以将那些第三方类不具备的功能强行进行扩展，来方便我们的操作。 注意，类的扩展是静态的，实际上并不会修改它们原本的类，也不会将新成员插入到类中，仅仅是将我们定义的功能变得可调用，使用起来就像真的有一样。同时，在编译时也会明确具体调用的扩展函数： open class Shape class Rectangle: Shape() fun Shape.getName() = \"Shape\" fun Rectangle.getName() = \"Rectangle\" //虽然这里同时扩展了父类和子类的getName函数 fun printClassName(s: Shape) { //但由于这里指定的类型是Shape，因此编译时也只会使用Shape扩展的getName函数 println(s.getName()) } fun main() { printClassName(Rectangle()) } 由于类的扩展是静态的，因此在编译出现歧义时，只会取决于形参类型。 如果是类本身就具有同名同参数的函数，那么扩展的函数将失效： class Test { fun hello() = println(\"你干嘛\") } fun Test.hello() = println(\"哎哟\") fun main() { Test().hello() //你干嘛 } 不过，我们如果通过这种方式实现函数的重载，是完全没有问题的： class Test { fun hello() = println(\"你干嘛\") } fun Test.hello(str: String) = println(str) //重载一个不同参数的同名函数 fun main() { Test().hello(\"不错\") //有效果 } 同样的，类的属性也是可以通过这种形式来扩展的，但是有一些小小的要求： 可以看到直接扩展属性是不允许的，前面我们说过，扩展并不是真的往类中添加属性，因此，扩展属性本质上也不会真的插入一个成员字段到类的定义中，这就导致并没有变量去存储我们的数据，我们只能明确定义一个getter和setter来创建扩展属性，才能让它使用起来真的像是类的属性一样： val Student.gender: String get() = \"666\" fun main() { val stu = Student() println(stu.gender) } 由于扩展属性并没有真正的变量去存储，而是使用get和set函数来实现，所以，像前面认识的field这种后备字段，就无法使用了。 还有一个需要注意的时，我们在不同包中定义的扩展属性，同样会受到访问权限控制，需要进行导入才可以使用： import com.test.gender fun main() { val stu = Student() println(stu.gender) } 除了直接在顶层定义类的扩展之外，我们也可以在一个类中定义其他类的扩展，并且在定义时可以直接使用其他类提供的属性： class A { fun hello() = \"Hello World\" } class B { fun A.test() { hello() //直接在类A的扩展函数中调用A中定义的函数 } } 像这种扩展，由于是在类中定义，因此也仅限于类内部使用，比如： class A { fun hello() = \"Hello World\" } class B (private val a: A){ private fun A.test() = hello() + \"!!!\" fun world() = println(a.test()) //只能在类中通过A的实例使用扩展函数 } fun main() = B(A()).world() 扩展属性无法访问那些本就不应该被当前作用域访问的类属性，即使它是对某个类的扩展，比如下面这种情况： 在名称发生冲突时，需要特别处理： class A { fun hello() = \"Hello World\" } class B (private val a: A){ private fun A.test() { hello() //直接使用优先匹配被扩展类中的方法 this.hello() //扩展函数中的this依然指的是被扩展的类对象 this@B.hello() //这里调用的才是下面的 } fun hello() = \"Bye World\" } 定义在类中的扩展也可以跟随类的继承结构，进行重写： open class A { open fun Student.test() = \"AAA\" fun hello() = println(Student().test()) } class B : A() { override fun Student.test() = \"BBB\" //对父类定义的扩展函数进行重写 } fun main() { A().hello() B().hello() } 局部扩展也是可以的，我们可以在某个函数里面编写扩展，但作用域仅限于当前函数： fun main() { fun String.test() = \"\" \"\".test() } 如果我们将一个扩展函数作为参数给到一个函数类型变量，那么同样需要再具体操作之前增加类型名称才可以： fun main() { //因为是对String类型的扩展函数，需要String.前缀 val func: String.() -\u003e Int = { this.length //跟上面一样，扩展函数中的this依然指的是被扩展的类对象 } println(\"sahda\".func()) //可以直接对符合类型的对象使用这个函数 func(\"Hello\") //如果是直接调用，那么必须要传入对应类型的对象作为首个参数，此时this就指向我们传入的参数 } 可以看到，此函数的类型是String.() -\u003e Int ，也就是说它是专门针对于String类型编写的扩展函数，没有参数，返回值类型为Int，并使用Lambda表达式进行赋值，同时这个函数也是属于String类型的，只能由对象调用，或是主动传入一个相同类型的对象作为参数才能直接调用。可能这里会有些绕不太好理解，需要同学们多去思考。 总结一下，扩展属性更像是针对于原本类编写的外部工具函数，而绝不是对原有类的修改。 Kotlin程序设计高级篇 在学习了前面的内容之后，相信各位小伙伴应该对Kotlin这门语言有了一些全新的认识，我们已经了解了大部分的基本内容，从本章开始，就是对我们之前所学的基本内容的进一步提升。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:6:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"泛型 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入，从泛型开始，再到我们的集合类学习，循序渐进。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"什么是泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？ 现在的问题就是，成绩可能是String类型，也可能是Int类型，如何才能更好的去存可能出现的两种类型呢？ class Score(var name: String, var id: String, var value: Any) { //因为Any是所有类型的父类，因此既可以存放Int也能存放String } fun main() { Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\") //文字和数字都可以存 Score(\"计算机操作系统\", \"EP074533\", 95) } 虽然这样看起来很不错，但是Any毕竟是所有类型的顶级父类，在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： fun main() { val score = Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\") ... val a: Int = score.value as Int //获取成绩需要进行强制类型转换 } 使用Any类型作为引用虽然可以做到任意类型存储，但是对于使用者来说，由于是Any类型，所以说并不能直接判断存储的类型到底是String还是Int，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺。 所以说这种解决办法虽然可行，但并不是最好的方案，我们需要使用一个更好的东西来实现： 泛型 泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型，Kotlin中的类可以具有类型参数： class Score\u003cT\u003e(var name: String) //这里的T就是一个待定的类型，同样是这个类具有的，我们称为泛型参数 可以看到，它相比普通的类型，仅仅多了一个\u003cT\u003e表示类型参数，那么如何使用呢？ fun main() { //在创建对象时，再来明确使用的是什么类型，同样使用尖括号填写 val score = Score\u003cInt\u003e(\"数据结构与算法\") } 既然可以做到使用时明确，那现在我们应该怎么去设计这个类呢？ class Score\u003cT\u003e(var name: String, var id: String, var value: T) //我们在定义类型参数后，T就是一个待定类型，我们可以直接将value属性的类型定义为T fun main() { val score = Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\") //在使用时，使用\u003cString\u003e来明确Score的值类型，此时value的类型也会变成String val value: String = score.value //得到的直接就是String类型的结果 } 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译，同时，如果我们这里填入的参数明确是一个String类型的值，创建时不需要指定T的类型也会自动匹配： val score = Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\") //自动匹配为String类型 而泛型类型在类内部使用时，由于无法确定具体类型，也只能当做Any类去使用： 因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象： 还有，由于泛型在创建时就已经确定，因此即使都是Score类，由于类型参数的不同也会导致不通用： 有了泛型之后，我们再来使用一些类型就非常方便了，并且泛型并不是每个类只能存在一个，我们可以一次性定义多个类型参数： class Test\u003cK, V\u003e(val key: K, val value: V) 多个不同的类型参数代表不同的类型，这些都可以在使用时明确，并且互不影响。 Kotlin还提供了下划线运算符可以自动推断类型： fun \u003cK: Comparable\u003cV\u003e, V\u003e test() { } //类型参数中第一个类型参数可以直接推断得到 fun main() { test\u003cInt, _\u003e() //由于前面的类型本身就是Comparable\u003cInt\u003e的子类，已经明确了V的类型，后面就没必要再写一次了，直接使用下划线运算符进行推断即可 } 感觉使用场景应该比较少，了解就行。 当然，不只是类，包括接口、抽象类，都是可以支持泛型的： interface Test\u003cT\u003e { } 子类在继承时，可以选择将父类的泛型参数给明确为某一类型，或是使用子类定义的泛型参数作为父类泛型参数的实参使用： abstract class A\u003cT\u003e { abstract fun test(): T } class B: A\u003cString\u003e() { //子类直接明确为String类型 override fun test(): String = \"Hello World\" //明确后所有用到泛型的地方都要变成具体类型 } abstract class C\u003cD\u003e: A\u003cD\u003e() { //子类也有泛型参数D abstract override fun test(): D } fun main() { val b = B() println(b.test()) } 除了在类上定义泛型之外，我们也可以在函数上定义： //在函数名称前添加\u003cT\u003e来增加类型参数，之后函数的返回值或是参数都可以使用这个类型 fun \u003cT\u003e test(t: T): T = t fun main() { val value: String = test(\"Hello World\") //调用函数时自动明确类型 } 甚至在使用函数类型的参数时，我们可以使用泛型来代表不确定的类型： fun \u003cT\u003e test(func: (Int) -\u003e T) : T { //只要是有类型的地方都可以用T代替 ... } fun \u003cT\u003e test2(func: T.() -\u003e Unit) { //甚至还可以是T类型的扩展函数 ... } 在这之后，我们还会遇到更多官方提供的泛型函数，尤其是下一章的数组和集合部分。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"官方高阶扩展函数 为了我们开发的便利，官方提供了一系列内置的高阶函数，大部分都是通过扩展函数形式定义，我们可以使用来简化我们的代码。 我们之前在使用时或许就已经发现了： 那么怎么依靠它们来简化我们的代码呢？比如下面的代码： class Student(var name: String, var age: Int) { fun hello() = println(\"大家好，我是$name\") } fun test(student: Student?): Student? { student?.name = \"小明\" //不优雅！！！！ student?.age = 18 student?.hello() returun student; } 由于传入的是一个可空类型，这导致我们在使用时非常不方便，每次都需要进行判断，有没有更优雅一点的方式来处理呢？ fun test(student: Student?): Student? = student?.apply { this.name = \"小明\" this.age = 18 this.hello() } 太优雅了，同样的操作，原本繁杂的调用直接简化成了简单的几句代码，真是舒服啊！ 我们来介绍一下这些函数时如何使用的，这里以apply为例，这个函数功能是简化我们对某个对象的操作并在最后返回对象本身，在Standard.kt中是这样定义的： public inline fun \u003cT\u003e T.apply(block: T.() -\u003e Unit): T { ... block() //调用我们传入的函数 return this //返回当前T类型对象本身 } 可以看到，这个函数也是以扩展函数定义的T可以代表任何类型，所有的类都可以使用这个预设的扩展函数，并且它的参数是一个T.() -\u003e Unit函数类型的，很明显这是一个高阶函数，并且最后一个参数就是函数类型，后续可以结合我们之前讲解的简化代码。 这个参数非常有意思，比如我们原来需要这样编写： fun main() { val student: Student = Student(\"小明\", 18) student.name = \"大明\" student.hello() } 我们现在可以进行代码优化： fun main() { Student(\"小明\", 18).apply { this.name = \"大明\" }.hello() } 什么鬼，怎么突然就变得这么简单了？我们一个一个来看： Student(\"小明\", 18).apply{ } //调用Apply后，我们需要传入一个Lambda表达式，也就是我们要如何操作这个对象 我们可以直接将对这个对象全部的操作搬进来，然后在一个Lambda里面就能完成，接着我们对这个对象的其他操作，可以直接在后续编写，因为返回的也是这个对象本身，所以，使用这些预设的高阶函数，在很多情况下都能省掉我们不少代码量。 这里我们来看几个比较常用的： let：用于执行一个lambda表达式并将得到的结果作为返回值返回。 //对当前对象进行操作，得到一个新的类型值并作为结果返回 public inline fun \u003cT, R\u003e T.let(block: (T) -\u003e R): R { ... return block(this) //调用我们传入的函数，并将结果作为let返回值 } also：用于执行一个lambda表达式并返回对象本身，跟apply功能一致像，但是采用的是it参数形式传递给Lambda当前对象。 //对当前对象进行操作，并返回当前对象本身 public inline fun \u003cT\u003e T.also(block: (T) -\u003e Unit): T { ... block(this) //调用我们传入的函数 return this //返回当前T类型对象本身 } run：用于执行一个lambda表达式并将得到的结果作为返回值返回，它跟let一样，使用this传递当前对象，可以看到接受的参数是一个扩展函数。 public inline fun \u003cT, R\u003e T.run(block: T.() -\u003e R): R { ... return block() } 由此可见，let和run功能相近，apply和also功能相近，只是它们传递对象方式不同，所以说这个就别搞混了。 还有一个比较好用的是，有时候我们可能需要对象满足某些条件才处理，我们可以使用takeIf来完成： public inline fun \u003cT\u003e T.takeIf(predicate: (T) -\u003e Boolean): T? { ... return if (predicate(this)) this else null //传入一个用于判断的函数，根据结果返回对象本身或是null } public inline fun \u003cT\u003e T.takeUnless(predicate: (T) -\u003e Boolean): T? { ... return if (!predicate(this)) this else null //跟上面相反 } 对于takeIf的使用就像下面这样： fun main() { val str = \"Hello World\" //判断字符串长度是否大于7，大于就返回一个重复一次的字符串，否则原样返回 val myStr = str.takeIf { it.length \u003e 7 }?.let { it + it } ?: str } 一个很复杂的工作，可能需要很多行代码才能搞定，但是现在借助这些预设的高阶扩展函数，我们就可以以更简短的代码完成。 还有一个比较有意思的： public inline fun \u003cT, R\u003e with(receiver: T, block: T.() -\u003e R): R { ... return receiver.block() //手动传入一个现有的变量，然后通过这个变量去调用传入的Lamdba } 用起来就像这样： fun main() { val str = \"Hello World\" val len = with(str) { this.length } } 除了我们上面提到的这些，其实在Standard.kt还提供了更多有意思的工具函数，由于篇幅有限，还请各位小伙伴自行探索。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"协变与逆变* 注意： 这一部分相当有难度，请务必将前面的泛型概念理解到位，否则很难继续学习。 我们在前面介绍了泛型的基本使用，实际上就是一个待定的类型，我们在使用时可以指定具体的类型，并在编译时检查类型是否匹配，保证运行时类型的安全性，就像下面这样： class Test\u003cT\u003e(var data: T) fun main() { val test1: Test\u003cString\u003e = Test(\"Hello\") val test2: Test\u003cInt\u003e = Test(10) } 一旦泛型变量类型确定，后续将一直固定使用此类型，并且不兼容其他类型： 但是现在存在这样一个问题，我们如果使用某个类型的父类呢，会不会出现类型不匹配的情况？ 可以看到，即使是Int类型的父类Number，也无法接收其子类类型的结果，这就很奇怪了，我们前面说过一个类可以被当做其父类使用（因为父类具有属性什么子类一定也有）会自动完成隐式类型转换，但是为什么到了泛型这里就不行了呢？ 为了探究这个问题，我们先从几个概念开始说起，假设Int类型是Number类型的子类，正常情况下只能子类转换为父类，泛型类型Test\u003cT\u003e存在以下几种形变： 协变 (Covariance)：因为Int是Number的子类，所以Test\u003cInt\u003e同样是Test\u003cNumber\u003e的子类，可以直接转换 逆变(Contravariance)：跟上面相反，Test\u003cNumber\u003e可以直接转换为Test\u003cInt\u003e，前置是后者的子类 抗变 (Invariant)：Test\u003cInt\u003e跟Test\u003cNumber\u003e没半毛钱关系，无法互相转换 而在Kotlin的泛型中，默认就是抗变的，即使两个类型存在父子关系，到编译器这里也不认账，但是实际上我们需要的可能是协变或是逆变，为了处理这种情况，Kotlin提供了两个关键字供我们使用： out 关键字用于标记一个类型参数作为协变，可以实现子类到父类的转换。 in 关键字用于标记一个类型参数作为逆变，可以实现父类到子类的转换。 那么该怎么使用呢，非常简单： fun main() { val test1: Test\u003cInt\u003e = Test(888) //使用out关键字使得此类型协变，可以代表Number及其子类 val test2: Test\u003cout Number\u003e = test1 //此时就可以正常接受子类Int了 } 虽然看上去非常难理解，但是简单来说，其实就是为类型添加一个可以转换子类的性质，out作用就是使类型支持协变，可以支持泛型从父类转换为子类，但是不能子类转父类，比如这里使用Any就没法成功接受。相反的，如果我们标记某个类型为in，那么这个类型就是逆变的，可以由父类向下转化： fun main() { val test1: Test\u003cAny\u003e = Test(888) //使用in关键字使得此类型逆变，可以代表Number及其父类 val test2: Test\u003cin Number\u003e = test1 //Any是Number的父类，逆变 } 用树形图展示，关系如下： 在使用这种协变或逆变类型时，具体使用的类型就变得不确定了，导致不同的界限会有不同的效果，比如下面： fun main() { //协变类型在使用时会变成上界，因为无论子类是什么，都是继承自上界类型的 val test: Test\u003cout Number\u003e = Test(888) var data: Number = test.data } fun main() { //逆变类型在使用时由于没有上界，具体使用哪个父类也不清楚，所以只能是Any?类型了 val test: Test\u003cin Number\u003e = Test(888) var data: Any? = test.data } 在使用out和in之后，类型的使用就可以更加灵活，但是这样会存在一定的安全隐患，比如下面的代码： open class A class B: A() class C: A() fun main() { val test1: Test\u003cB\u003e = Test(B()) //这里存放的都是B类型的数据 val test2: Test\u003cout A\u003e = test1 //此时test2与test1是同一个对象，但是test2是out A test2.data = C() //由于C是A的子类，按照正常情况来说可以直接用（但实际上这句会报错） val data: B = test1.data //这下搞笑了，拿到的类型应该是C，结果接收的类型是B } 为了解决这种情况，Kotlin对于out或in的类型进行了限制，比如设置了out的情况下： 属性的setter操作被限制，无法通过编译，因为这可能会导致不安全的操作发生，而in也是同理的： fun main() { val test1: Test\u003cA\u003e = Test(B()) //这里存的是B类型的对象 val test2: Test\u003cin C\u003e = test1 //直接使用in C接收得到 val data: C = test2.data //此时得到的结果应该也可以是C才对，那肯定是错的 } 因此，在使用in时，属性的getter操作被限制，会提示类型不匹配，得到的类型也是Any? 无法通过编译，同样是因为可能存在不安全的操作。不仅仅是属性，包括所有函数的参数、返回值，都会受到限制： fun main() { val test1: Test\u003cB\u003e = Test(B()) val test2: Test\u003cout A\u003e = test1 test2.test(C()) //报错，因为这里存在消费行为 } 因此，对于in和out来说，协变和逆变的属性将其限制为了生产者和消费者： 使用out修饰的泛型不能用作函数的参数，对应类型的成员变量setter也会被限制，只能当做一个生产者使用。 使用in修饰的泛型不能用作函数的返回值，对应类型的成员变量getter也会被限制，只能当做一个消费者使用。 在了解了这么多泛型的知识之后，相信各位小伙伴已经感受到泛型的巧妙而又复杂的设计了。 最后，在有些时候，我们可能并不在乎到底使用哪一个类型，我们希望一个变量可以接受任意类型的结果，而不是去定义某一个特定的上界或下界。在Kotlin泛型中，星号（*）代表了一种特殊的类型投影，可以代表任意类型： fun main() { var test: Test\u003c*\u003e = Test(888) //由于此时使用了*表示任意类型，无论类型如何变化，都可以被此变量接收 test = Test(\"Hello\") } 同样的，由于不确定具体类型，使用时只能是Any?类型，跟上面in的情况一样，这里就不做演示了，下一章我们还会继续探讨更多*的默认情况。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"泛型界限* 注意： 这一部分相当有难度，请务必将前面的泛型概念理解到位，否则很难继续学习。 前面我们介绍了协变和逆变，使得泛型的类型可以灵活变化使用，而我们在定义类的时候，在类型参数位置也可以进行限制。 比如有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，这又该怎么去实现呢？ //设定类型参数上界，必须是Number或是Number的子类 class Score\u003cT : Number\u003e(private val name: String, private val id: String, val value: T) 使用类似于继承的语法来完成类型的上界限制，定义后，使用时的具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型，否则一律报错： 在默认情况下，如果我们不指定，那么上界类型就是Any?，而现在，我们在使用时就只能将类型指定为Number的子类了。 如果我们需要设定多个上界，比如必须同时是某两个类型的子类（或接口实现）像这样多个约束设定，我们需要使用where关键字： class Score\u003cT\u003e(private val name: String, private val id: String, val value: T) where T : Comparable\u003cT\u003e, T : Number //where后跟上多个需要同时匹配的类型 fun main() { //由于Int同时实现了Comparable接口以及继承自Number，所以满足多个条件，可以使用 var score: Score\u003cInt\u003e = Score(\"数据结构与算法\", \"EP710214\", 6) } 通过设定上界，能够更加规范类的使用。 有时候为了方便，我们也可以直接在类定义的时候直接将类型参数指定为out或是in来使得其协变或逆变： interface Test\u003cout T\u003e { fun test(): T //使用T类型作为返回值 } interface Test\u003cin T\u003e { fun test(t: T) //使用T类型作为参数 } 这样我们使用时就可以实现类型自动适应： interface Test\u003cout T\u003e { fun test(): T } fun test(test: Test\u003cInt\u003e) { val a: Test\u003cNumber\u003e = test //协变 } 同样的，我们前面说了在添加in或out后会限制相应的行为来保证类型的安全性，在定义类的一些函数或属性的时候都会得到警告： 在了解了类型界限相关内容之后，我们再来看看*类型投影在不同情况下的默认类型，比如： 对于Foo\u003cout T : TUpper\u003e，其中T是与上界TUpper的协变类型参数，Foo\u003c*\u003e等价于Foo\u003cout TUpper\u003e，就像下面这样： class Test\u003cout T : Number\u003e(val data: T) //因为限制了out，因此作为生产者，这里只能使用val fun main() { val test: Test\u003c*\u003e = Test(10) //虽然使用了*表示不确定，但是由于类型参数本身存在上界 var data: Number = test.data //所以类型读取后可以直接当做上界类型Number使用 } 对于Foo\u003cin T\u003e，其中T是逆变类型参数，Foo\u003c*\u003e等价于Foo\u003cin Nothing\u003e，无法安全地将属性给到消费者消费： class Test\u003cin T\u003e { fun set(t: T) { } //因为限制了in，因此只能作为消费者，这里用函数的形式 } fun main() { val test: Test\u003c*\u003e = Test\u003cInt\u003e() test.set(10) //编译错误，set中参数类型为Nothing，不允许任何值 } 对于Foo\u003cT : TUpper\u003e，其中T是具有上界TUpper的抗变类型参数，在读取数据时Foo\u003c*\u003e等价于Foo\u003cout TUpper\u003e，写入数据时等价于Foo\u003cin Nothing\u003e，就像这样： class Test\u003cT: Number\u003e(var data: T) fun main() { val test: Test\u003c*\u003e = Test(10) var data: Number = test.data //正常通过 test.data = 10 //编译错误，Setter for 'data' is removed by type projection } 如果一个泛型类有多个类型参数，每个类型参数都可以独立使用*表示不确定，例如类型为interface Function\u003cin T, out U\u003e，您可以使用以下星形投影： Function\u003c*, String\u003e等价于Function\u003cin Nothing, String\u003e。 Function\u003cInt, *\u003e等价于Function\u003cInt, out Any?\u003e。 Function\u003c*, *\u003e等价于Function\u003cin Nothing, out Any?\u003e。 泛型的使用可以很简单也可以很复杂，想要完全把这个搞明白还是需要多练多理解才能达到。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"类型擦除* 注意： 这一部分相当有难度，请务必将前面的泛型概念理解到位，否则很难继续学习。 前面我们介绍了泛型的使用，以及各种高级功能，但是实际上，泛型的类型检查仅仅只存在于编译阶段，在源代码编译之后，实际上并不会保留任何关于泛型类型的内容，这便是类型擦除。 比如下面的类型： class Test\u003cT\u003e(private var data: T) { fun test(t: T) : T { val tmp = data data = t return tmp } } 在编译时候，会自动擦除类型： class Test(private var data: Any?) { //最后还是全部变成Any?类型了 fun test(t: Any?) : Any? { val tmp = data data = t return tmp } } 如果存在上界，那么擦除后会是上界的类型： class Test\u003cT : Number\u003e(private var data: T) class Test(private var data: Number) //擦除后类型变成上界类型 由于在运行时不存在泛型的概念，因此，很多操作都是不允许的，比如类型判断： class Test\u003cT\u003e(private var data: T) { fun isType(obj: Any) : Boolean { return obj is T //编译错误，由于类型擦除，运行时根本不存在T的类型 } } 包括我们在使用这个泛型类时： fun main() { val test: Test\u003cInt\u003e = Test(10) println(test is Test\u003cDouble\u003e) //编译错误，由于类型擦除，无法判断具体的类型 println(test is Test) //编译通过，判断是不是这个类还是没问题的 } 因此，正是为了保证类型擦除之后程序能够安全运行，才有了上面这么多限制。 对于内联函数，泛型擦除的处理会有一些不同，得益于它的内联性质，内联函数的代码是在编译时期直接插入到调用处的，在编译之后具体类型必须要存在，否则会出现问题（因为类型可以明确）因此其泛型参数的具体类型信息是可用的，编译器可以使用这些信息来生成更具体的字节码。这意味着，对于内联函数的泛型参数，并不会像非内联函数那样发生类型擦除。 inline fun \u003cT\u003e test(value: T): T { val value2 : T = value return value2 } fun main() { val data: String = test(\"Hello World!\") } 内联函数编译后，类型直接保留： fun main() { val value: String = \"Hello World!\" val value2: String = value //直接以String类型变量编译到程序中 val data: String = value2 } Kotlin的内联函数还有一个功能是可以使用具化的类型参数（reified 关键字）具化类型参数允许在函数体内部检测泛型类型，因为这些类型信息会被编译器内嵌在调用点。但是，这只适用于内联函数，因为类型信息在编译时是可知的，并且实际类型会被编译到使用它们的地方，使用也很简单： //添加reified关键字具化类型参数 inline fun \u003creified T\u003e isType(value: Any): Boolean { return value is T //这样就可以在函数里面使用这个类型了 } fun main() { println(isType\u003cString\u003e(\"666\")) } 具化类型参数仅适用于内联函数。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:7:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数组 前面我们介绍了泛型，它可以实现在编写代码阶段的类型检查，现在我们就可以正式进入到数组的学习当中了。 假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。 在Kotlin中，数组是Array类型的对象。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"创建数组 数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容，其中存放的每一个数据称为数组的一个元素，我们来看看如何创建一个数组，在Kotlin中有两种创建方式： 官方预设工具函数，如arrayOf()、arrayOfNulls()以及emptyArray() 使用类Array构造函数创建。 比如我们要创建一个包含5个数字的数组，那么我们可以像这样： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) //直接在arrayOf函数中添加每一个元素 这里得到的结果类型为Array，它是一个泛型类 public class Array\u003cT\u003e { //构造函数，包括数组大小、元素初始化函数 public inline constructor(size: Int, init: (Int) -\u003e T) //重载[]运算符 public operator fun get(index: Int): T public operator fun set(index: Int, value: T): Unit //当前数组大小（可以看到是val类型的，一旦确定不可修改） public val size: Int //迭代运算重载（后面讲解） public operator fun iterator(): Iterator\u003cT\u003e } 可以看到，数组本质就是一个Array类型的对象，其类型参数就是我们存储的元素类型，由于使用构造函数创建数组稍微有些复杂，我们将其放到后面进行介绍。 注意： 数组在创建完成之后，数组容量和元素类型是固定不变的，后续无法进行修改。 fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) array.size = 10 //编译错误，长度不可修改 val arr: Array\u003cString\u003e = array //编译错误，类型不匹配 } 既然现在创建好了数组，那么该如何去访问数组里面的内容呢？ fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) println(array[0]) //使用[]运算符来访问指定下标上的元素 } 由于数组存放的是一组元素，我们在访问每个元素时需要告诉程序我们要访问的是哪一个，而每个元素都有一个自己的下标地址，下标从0开始从左往右依次递增排列，比如我们要访问第一个元素那么下标就是0，第三个元素下标就是2，以此类推： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) println(\"数组中的第二个元素是${array[1]}\") } 注意，在使用数组时，我们只能访问数组可以访问的范围，如果我们获取一个范围之外的元素，会得到错误，比如当前的数组的大小是5那么也就只能包含5个元素，此时我们去访问第六个元素，显然是错误的： println(\"数组中的第六个元素是${array[5]}\") //已经超出可访问范围了 println(\"数组中的第?个元素是${array[-1]}\") //下标从0开始，怎么可能有-1呢 我们也可以使用[]修改数组中指定下标元素的值： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) array[0] = 10 //修改第一个元素的值 println(\"数组中的第一个元素是${array[0]}\") } 还有一个要注意的是，我们直接打印这个数组对象并不能得到数组里面每个元素的值，而是一堆看不懂的东西： 具体原因可以通过学习Java后进行了解，如果各位小伙伴需要打印数组中的每一个元素，我们只能一个一个打印，可以使用一个for循环语句来完成： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for (i in 0..\u003carray.size) { //从0循环到array.size前一位 println(array[i]) //每一个依次打印即可 } } 不过，在Kotlin中，这样编写并不优雅，我们有更好的方式去遍历数组中的每一个元素，在之前我们学习for循环语句时，谈到使用in来遍历一个可遍历的目标，而数组就是满足这个条件的，我们可以直接遍历它： fun main() { val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for (element in array) { println(element) //从第一个元素开始依次遍历，element就是每一个元素了 } } 当然，如果我们还是希望按照数组的索引进行遍历，也可以使用： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for (i in array.indices) { //indices返回的是数组的有效索引范围，这里就是0 ~ 4 println(array[i]) } 如果你想同时遍历索引和元素本身，也可以使用withIndex函数，它会生成一系列IndexedValue对象： //关于data class我们会在下一篇中讲解 public data class IndexedValue\u003cout T\u003e(public val index: Int, public val value: T) //包含元素本身和索引 在使用forin时，我们也可以对待遍历的元素进行结构操作，当然，前提是这些对象类型支持解构，比如这里的IndexedValue就支持解构，所以我们可以在遍历时直接使用解构之后的变量进行操作： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) for ((index, item) in array.withIndex()) { //使用withIndex解构后可以同时遍历索引和元素 println(\"元素$item，位置: $index\") } 如果需要使用Lambda表达式快速处理里面的每一个元素，也可以使用forEach高阶函数： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) array.forEach { println(it) } //只带元素的 array.forEachIndexed { index, item -\u003e //同时带索引和元素的 println(\"元素$item，位置: $index\") } 如果只是想打印数组里面的内容，快速查看，我们可以使用： val array: Array\u003cInt\u003e = arrayOf(7, 3, 9, 1, 6) println(array.joinToString()) //使用joinToString将数组中的元素转换为字符串，默认使用逗号隔开：7, 3, 9, 1, 6 println(array.joinToString(\" - \", \"\u003e \", \" \u003c\")) //自定义分隔符，前后缀: \u003e 7 - 3 - 9 - 1 - 6 \u003c println(array.joinToString(limit = 1, truncated = \"...\")) //甚至可以限制数量，多余的用自定义的字符串...代替: 7, ... println(array.joinToString() { (it * it).toString() }) //自定义每一个元素转换为字符串的结果 我们接着来看一下如何使用构造函数来创建数组，首先构造函数时这样定义的： /** * size: 不必多说，数组的大小 * init: 初始化操作，这个操作会根据数组大小，循环调用传入的函数size次，并且将对应的下标作为参数，我们需要在函数中返回当前数组元素类型的结果，这样就会自动填充到数组的对应位置上 */ public inline constructor(size: Int, init: (Int) -\u003e T) 比如我们希望创建一个字符串数组： fun main() { val array: Array\u003cString\u003e = Array(5) { \"我是元素$it\" } //其中返回值为自定义的字符串，这样就会自动填充到对应位置 for (s in array) { println(s) } } 利用这种特性，我们可以快速创建一个全是同一个值的数组： val array: Array\u003cDouble\u003e = Array(5) { 1.5 } // 1.5, 1.5, 1.5, 1.5 ... 还可以快速搞一个平方数数组： val array: Array\u003cInt\u003e = Array(10) { it * it } // 0, 1, 4, 9, 16 ... 不过，其实一般情况下使用arrayOf都可以解决大部分情况了，还有它的变种，大概介绍一下： val array: Array\u003cInt\u003e = emptyArray\u003cInt\u003e() //创建容量为0的数组 val array: Array\u003cInt?\u003e = arrayOfNulls(10) //创建元素可空的数组 下一节课我们接着学习更多数组的操作。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"使用数组 现在我们已经学习了如何创建数组，实际上官方库提供了很多数组的扩展函数，方便我们对于数组的使用，我们现在就来看看吧。 对于两个数组来说，如果我们要比较它们之间是否包含相同的内容，需要使用特殊的比较函数： fun main() { val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) //两个内容相同的数组 val array2: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) println(array1 == array2) //不可以使用==来判断数组内容是否相同，不支持 println(array1.contentEquals(array2)) //需要使用扩展函数contentEquals来进行内容比较 } 要拷贝一个数组的内容并生成一个新的数组，可以： fun main() { val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) val array2: Array\u003cInt\u003e = array1.copyOf() //使用copyOf来拷贝数据内容并创建一个新的数组存储 println(array2 === array1) //false，不是同一个对象 } copyOf函数可以指定拷贝的长度或是拷贝的范围，使用更加灵活一些： val array2: Array\u003cInt?\u003e = array1.copyOf(10) //在拷贝时指定要拷贝的长度，如果小于数组长度则只保留前面一部分内容，如果大于则在末尾填充null，因此返回的类型是Int?可空 val array2: Array\u003cInt\u003e = array1.copyOfRange(1, 3) //从第二个元素开始拷贝到第四个元素前为止，共2个元素 //使用copyOfRange拷贝指定下标范围上的元素 还有一个比较类似操作，但是可以使用Range进行分割： val array1 = arrayOf(1, 2, 3, 4, 5) val array2 = array1.sliceArray(1..3) //从第二个元素到第四个元素共三个元素的数组 两个数组也可以直接拼接到一起，形成一个长度为10的新数组，按顺序拼接： val array1 = arrayOf(1, 2, 3, 4, 5) val array2 = arrayOf(6, 7, 8, 9, 10) val array3 = array1 + array2 快速查找元素肯定也是不在话下的： val array = arrayOf(13, 16, 27, 32, 38) println(array.contains(13)) //判断数组中是否包含3这个元素 println(array in 13) //跟contains函数效果一样，判断数组中是否包含3这个元素 println(array.indexOf(26)) //寻找指定元素的下标位置 println(array.binarySearch(16)) //二分搜索某个元素的下标位置（效率吊打上面那个函数，但是需要数组元素有序，具体原因可以学习数据结构与算法了解） 不过，可能会有小伙伴好奇，这里的contains函数传入的对象，是如何进行判断的？比如我要删除某一个元素，程序是如何将数组内的对象与传入的对象进行比较得出是相同的元素呢？我们来看下面这个例子： class Student(val name: String, val age: Int) fun main() { val array = arrayOf(Student(\"小明\", 18), Student(\"小红\", 17)) println(array.contains(Student(\"小明\", 18))) //结果为false } 怎么回事？我们这明明传入的是两个内容一样的对象啊，为什么是false呢？直接看源码： public operator fun \u003c@kotlin.internal.OnlyInputTypes T\u003e Array\u003cout T\u003e.contains(element: T): Boolean { return indexOf(element) \u003e= 0 //调用内部indexOf函数看看能不能找到这个元素的下标 } public fun \u003c@kotlin.internal.OnlyInputTypes T\u003e Array\u003cout T\u003e.indexOf(element: T): Int { if (element == null) { ... } else { for (index in indices) { //直接通过遍历的形式对数组内的元素一个一个进行判断 if (element == this[index]) { //可以看到，这里判断使用的是==运算符，这下就好说了 return index } } } return -1 } 我们在前面介绍过，使用==的判断实际上取决于equals函数的重写，如果要让两个对象实现我们自定义的判断，需要重写对应类型的equals函数，否则无法实现自定义比较，默认情况下判断的是两个对象是否为同一个对象，所以，我们可以尝试重写一下： class Student(val name: String, val age: Int) { override fun equals(other: Any?): Boolean { if(this === other) return true //如果引用的是同一个对象，肯定是true不多逼逼 if(other !is Student) return false //如果要判断的对象根本不是Student类型的，那也不用继续了 if(name != other.name) return false //判断名字是否相同 if(age != other.age) return false //判断年龄是否相同 return true //都没问题，那就是相等了 } } 现在得到的结果就是我们希望的样子了。 也可以快速判断和获取元素： val array = arrayOf(1, 2, 3, 4, 5) println(array.any()) //判断数组是否为空数组（容量为0） println(array.first()) //快速获取首个元素 println(array.last()) //快速获取最后一个元素 我们也可以快速将一个数组的内容进行倒序排放： val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) val array2: Array\u003cInt\u003e = array1.reversedArray() //翻转数组元素顺序，并生成新的数组 val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) array1.reverse() //直接在原数组上进行元素顺序翻转 array1.reverse(1, 3) //仅翻转指定下标范围内的元素 如果我们想要直接将数组中元素打乱，也有一个快速洗牌的函数将所有元素顺序重新随机分配： val array1: Array\u003cInt\u003e = arrayOf(1, 2, 3, 4, 5) array1.shuffle() //使用shuffle函数将数组中元素顺序打乱 打乱了想重新还原成有序的数组咋办？ array1.sort() //使用sort函数对数组中元素进行排序，排序规则可以自定义 array1.sort(1, 3) //仅排序指定下标范围内的元素 array1.sortDescending() //按相反顺序排序 注意，排序操作并不是任何类型上来就支持的，由于这里我们使用的是基本类型Int，它默认实现了Comparable接口，这个接口用于告诉程序我们的排序规则，所以，如果数组中的元素是未实现Comparable接口的类型，那么无法支持排序操作。 我们可以来尝试实现一下： //首先类型需要实现Comparable接口，泛型参数T填写为当前类型 class Student(private val name: String, private val age: Int) : Comparable\u003cStudent\u003e { //接口中就这样一个函数需要实现，这个是比较的核心算法，要参数是另一个需要比较的元素，然后返回值是一个Int //使用当前对象this和给定对象other进行比较，如果返回小于0的数，说明当前对象应该排在前面，反之排后面，返回0表示同样的级别 override fun compareTo(other: Student): Int = this.age - other.age override fun toString(): String = \"$name ($age)\" } 这样，我们自定义的类型就支持比较和排序了： val array1 = arrayOf(Student(\"小明\", 18), Student(\"小红\", 17)) array1.sort() 还有可以快速填充数组内容的函数： val array1 = arrayOf(1, 2, 3, 4, 5) array1.fill(10) //重新将数组内部元素全部填充为10 好了，就先介绍这么多吧，到这里也才介绍了数组操作的一半，后面到了集合类我们再来介绍更多使用的扩展函数，因为集合数组都是支持的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"可变长参数 前面我们介绍了数组的使用，不知道各位小伙伴有没有疑惑，在使用arrayOf时，里面的参数为什么可以随意填写不同数量？ arrayOf(1, 2, 3, 4, 5) arrayOf(1, 2, 3) arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9) 函数的参数数量不是固定的吗？怎么还能动态加？难道我们前面学的是假的函数？这其实是因为这个函数使用了可变长参数的原因，它可以实现同一个类型的参数任意填写： fun test(vararg strings: String) { //使用vararg关键字将参数标记为可变长参数 } fun main() { test(\"AAA\", \"BBB\", \"CCC\") //在使用时，只要是同类型的参数可以填写任意数量 } 但是需要注意的事，可变长参数在函数的形参列表里面只能存在一个，下面这几种情况： fun test(vararg strings: String, a: Int) { ... } //编译通过 fun test(a: Int, vararg strings: String) { ... } //编译通过 fun test(vararg a: Int, vararg strings: String) { ... } //编译错误，存在多个可变长参数 那么，这种可变长参数在函数中如何使用呢？我们可以将其当做一个Array来使用： fun test(vararg strings: String) { var str: Array\u003cout String\u003e = strings //在函数中得到的是一个Array\u003cout String\u003e类型的数组 } 这样一看就简单多了，可变长参数本质就是一个数组。 那么既然可变长参数是一个数组，我们可不可以直接把数组作为参数给到一个可变长参数中呢？ fun main() { val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") test(array) //编译错误，这里需要的是多个String，但是传入的类型是Array\u003cString\u003e } 这就有点不太合理了，反正都是数组为啥我不能直接传个数组进去当做实参呢，因此Kotlin给我们提供了一个扩展运算符（*）此运算符将数组的每个元素作为单个参数传递： fun main() { val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") test(*array) //编译通过，虽然看起来有点像C语言的指针 } 别急，你以为这样就结束了吗，它还可以混着用： val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") test(\"111\", *array, \"DDD\", \"EEE\") //前面后面甚至还能继续写 因此，如果我们需要将一个数组的内容复制到一个新的数组中，直接这样操作就好了： val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") val array2 = arrayOf(*array) ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"原生类型数组 在之前，我们使用了大量基本类型数组，比如Array\u003cInt\u003e、Array\u003cDouble\u003e、Array\u003cChar\u003e等等，这些包含基本类型的数组往往在编译时可以得到优化（比如JVM平台会直接编译为基本类型数组，如int[]、double[]等，可以免去装箱拆箱开销）Kotlin提供了预设的原生类型数组： 原生类型数组 相当于Java BooleanArray boolean[] ByteArray byte[] CharArray char[] DoubleArray double[] FloatArray float[] IntArray int[] LongArray long[] ShortArray short[] 这些类型与Array类型没有任何继承关系，但是它们有同样的方法属性集，使用起来区别不大，优先使用基本类型数组，可以使得程序免得到一定优化，增加效率： fun main() { //使用arrayOf的变种intArrayOf快速生成IntArray val array: IntArray = intArrayOf(7, 3, 9, 1, 6) array.forEach { println(it) } } 这些原生类型数组也有一些额外的扩展，比如快速求和： val array: IntArray = intArrayOf(7, 3, 9, 1, 6) println(array.sum()) //快速求和操作，获得数组中所有元素之和 还有求平均值之类的： val array: IntArray = intArrayOf(7, 3, 9, 1, 6) println(array.average()) //求整个数组的平均数 快速获取最大值和最小值： val array: IntArray = intArrayOf(7, 3, 9, 1, 6) println(array.min()) println(array.max()) 其他使用基本一致，这里就不多进行介绍了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"嵌套数组 有些时候，单个维度的数组似乎无法满足我们的需求。比如我们现在6个元素为一组存储，现在共需要存储4组这样的数据，我们不可能去定义4个一样的数组吧？这个时候就需要用到嵌套数组了。 存放数组的数组，相当于将维度进行了提升，比如下面的就是一个2x10的数组： 二维数组看起来更像是一个平面，同理，三维数组就是一个立方体空间，四位数组就进入到我们人类无法理解的范围了，由很多个三维组成（物理上解释或许是时间轴？） 那么像这样的多维度数组如何创建呢？这里我们以二维数组为例，三维四维同理： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) 可以看到，我们使用arrayOf去囊括多个IntArray，这样，最外层的Array相当于是保存多个IntArray的Array，也就实现了我们上面的二维数组效果了。当然像这样也是可以的： //存放9个Array\u003cInt\u003e数组的数组，其中每个Array\u003cInt\u003e的长度为4，内容为0填充 // { {0,0,0,0}, {0,0,0,0}, {0,0,0,0} ... } val arr: Array\u003cArray\u003cInt\u003e\u003e = Array(9) { Array(4) { 0 } } 嵌套数组看起来可能有些绕，但是其实仔细分析之后还是比较简单的。 我们在使用二维数组时： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) val array: IntArray = arr[0] //获取二维数组的第一个元素，得到内层存放的数组 val item: Int = array[0] //再从内存存放的数组中拿到第一个元素 所以，如果我们要获取位于整个二维矩阵左上角的第一个元素，可以像这样： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) //这里使用了两个[]运算符，第一个处理最外层数组，第二个才是对内层数组的操作 val item: Int = arr[0][0] 对于这种二维数组，如果需要遍历，我们同样可以使用for循环来完成，不过需要两层for才可以搞定： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) for (ints in arr) { //最外层遍历外层数组中存放的每一个内层数组 for (int in ints) { //内层循环遍历每一个内层数组 println(int) //得到每一个内层数组的值 } } 由于现在数组内存放的是数组，我们在比较两个嵌套数组的内容是否相同时，需要使用深度比较： fun main() { val arr1: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) val arr2: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 2), intArrayOf(3, 4), intArrayOf(5, 6)) println(arr1.contentEquals(arr2)) //此函数只会简单比较里面的每一个元素，当里面每个元素是数组时不会再继续去比较第二层第三层等 println(arr1.contentDeepEquals(arr2)) //此函数会一直深入比较每一层，多维使用这个比较 } 这里还有一个知识误区，虽然我们使用的看起来确实类似于二维数组，但是每一个数组的长度并不需要是相同的： val arr: Array\u003cIntArray\u003e = arrayOf(intArrayOf(1, 3, 4, 5), intArrayOf(2, 9)) //这里第一个数组长度为4，第二个为2 甚至类型也可以不一样： //只要内层使用Any类型，就可以接收所有类型的嵌套数组 val arr: Array\u003cArray\u003cout Any\u003e\u003e = arrayOf(arrayOf(1, 3, 4, 5), arrayOf(\"AAA\", \"BBB\")) 不过正常情况下，我们还是会按照标准的二维数组来使用，这样更加规范一些。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:8:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"集合类 前面我们学习了数组的使用，虽然数组可以很方便地存储一组数据，但是它存在诸多限制： 长度是固定的，无法扩展 无法做到在数组中像列表那样插入或者删除元素 显然，在很多情况下，数组虽然可以存储一组数据，但是它并不好用，我们需要借助更加强大的集合类来实现更多高级功能。在Kotlin中，默认提供了以下类型的集合： List： 有序的集合，通过索引访问元素，可以包含重复元素，比如电话号码：它就是一组数字，并且顺序很重要，而且数字可以重复。 Set： 不包含重复元素的集合，它更像是数学中的集合，一般情况下不维护元素顺序，例如，彩票上的数字：都是独一无二的，并且它们的顺序不重要。 Map： 是一组键值对，其中每一个键不可重复存在，每个键都映射到恰好一个值（值可以重复存在）这跟数学上的映射关系很像。它经常用于存储（员工ID -\u003e 员工具体信息）这样的结构。 所有集合类都是继承自Collection接口（Map除外）我们可以看看这个接口的定义： public interface Collection\u003cout E\u003e : Iterable\u003cE\u003e { //继承了可迭代接口（后面讲解） //集合的大小 public val size: Int //判断集合是否为空 public fun isEmpty(): Boolean //集合是否包含某个元素，可用in运算符判断 public operator fun contains(element: @UnsafeVariance E): Boolean //生成迭代器（后面讲解） override fun iterator(): Iterator\u003cE\u003e //是否包含另一个集合中所有的内容 public fun containsAll(elements: Collection\u003c@UnsafeVariance E\u003e): Boolean } 这个接口定义了集合的基本操作，以及核心属性，而由集合顶层接口衍生的不同集合类，也都有自己的定义。集合类一般都是以接口类型的变量进行使用，因为不同的集合可能存在不同的集合实现类，为了使用起来更加通用，我们往往会使用集合类的接口进行操作。 下面就让我们一个一个认识吧。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"List集合 List就像它的名字一样，就是一个列表，它存储一组有序的数据，比如我们看到的餐厅菜单，还有游戏的排行榜，每一道菜、每一个玩家都是按顺序向下排列的，并且根据情况，我们可以自由地在某个位置插入或删除一个新的元素，列表的长度也会动态发生变化，List集合就是为了这些功能而生的。 要创建一个List集合非常简单，就跟我们之前创建数组一样： fun main() { val list: MutableList\u003cString\u003e = mutableListOf(1, 2, 3, 4) //使用mutableListOf来创建一个可修改的List集合 list[0] = 10 //修改某个位置上的元素 println(list[1]) //获取某个位置上的元素 println(list) //打印出来的结果也是非常标准的: [10, 2, 3, 4] } 我们发现，使用List集合之后，很多操作其实跟数组是基本一样的，它同样可以存储一组元素，以及修改。 除了可以使用数组支持的操作之外，为了能够作为列表使用，还有很多新的操作，比如我们希望在末尾添加一个新的元素到列表中： val list = mutableListOf(1, 2, 3, 4) list.add(5) //使用add函数添加一个新的元素到列表末尾 println(list) //列表自动增长，得到[1, 2, 3, 4, 5] 我们可以在整个列表之间的任意位置插入，但是同样不能出现越界的情况： val list = mutableListOf(1, 2, 3, 4) list.add(2, 666) //将666插入到第三个元素的位置上去 既然可以插入元素，同样的也可以删除元素： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\", \"DDD\") list.removeAt(2) //使用removeAt可以删除指定位置上的元素 list.remove(\"DDD\") //使用remove可以删除指定元素 可以看到，列表相比我们传统的数组来说，完整地支持了增删改查这四个操作，使用起来也会更加方便。 当然，有些时候可能我们希望获取一个只读的列表： val list: List\u003cString\u003e = listOf(\"AAA\", \"BBB\", \"CCC\", \"DDD\") //使用listOf生成的列表是只读的 list[0] = \"XXX\" //在修改时会直接提示不支持 类似于数组，还有多种列表创建函数： val array = arrayOf(\"AAA\", null, \"CCC\", \"DDD\") val list: List\u003cString\u003e = listOfNotNull(*array) //使用listOfNotNull可以自动去除所有null的元素，再创建只读列表 val list: List\u003cString\u003e = emptyList() //返回空列表 或是使用构造函数来创建一个列表： val list: List\u003cString\u003e = List(3){ \"TZ\" } //跟数组一样，不多说了 println(list) 如果我们需要遍历一个列表，同样很简单，跟数组完全一样： val list: List\u003cString\u003e = listOf(\"AAA\", \"BBB\", \"CCC\", \"DDD\") for (s in list) { //使用forin来快速遍历数组中的每一个元素 println(s) } for ((index, item) in list.withIndex()) { println(\"元素$item, 下标: $index\") } 集合也支持加法和减法运算： fun main() { val l1 = listOf(\"AAA\", \"DDD\", \"CCC\") val l2 = listOf(\"BBB\", \"CCC\", \"EEE\") println(l1 + l2) //合并两个List的内容，顺序直接在后面拼接: [AAA, DDD, CCC, BBB, CCC, EEE] println(l1 - l2) //让前面的集合减去与后面集合存在重复内容的部分: [AAA, DDD] } 使用还是非常简单的。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"Set集合 Set集合非常特殊，虽然它也可以保存一组数据，但是它不允许存在重复元素，我们无法让Set集合中同时存在两个一样的元素，这在一些需要去重的场景中非常实用，这跟数学中定义的集合非常相似。 创建一个Set集合很简单： fun main() { //使用mutableSetOf来创建一个Set集合 val set: Set\u003cString\u003e = mutableSetOf(\"AAA\", \"BBB\", \"BBB\", \"CCC\") println(set) //由于不允许出现重复元素，得到 [AAA, BBB, CCC] } 与列表一样，可以随意插入元素，元素默认在尾部插入，顺序为插入顺序： val set: MutableSet\u003cString\u003e = mutableSetOf(\"AAA\", \"DDD\", \"CCC\") set.add(\"BBB\") 不过Set默认不支持在指定位置插入元素，只能尾插，同时我们也不能通过下标去访问Set中的元素，这是因为Set底层采用的并不是线性数据结构存储，而是用了哈希表或是树形结构（感兴趣的小伙伴可以看一下另一期数据结构与算法篇教程）而内部元素的顺序则是采用的其他形式进行维护的。 不过，我们到是可以借助迭代器来获取当前顺序上的第N个元素： val set = linkedSetOf(\"AAA\", \"DDD\", \"CCC\") println(set.elementAt(1)) //elementAt是通过迭代器的遍历顺序取得对应位置的元素 有关迭代器的知识，我们放在后面进行讲解。 同时，由于Set更接近于数学上的集合概念，Kotlin为我们准备了很多集合之间的操作： val set1 = mutableSetOf(\"AAA\", \"DDD\", \"CCC\") val set2 = mutableSetOf(\"BBB\", \"CCC\", \"EEE\") println(set1 union set2) //求两个集合的并集: [AAA, DDD, CCC, BBB, EEE] Set的+运算与这个效果一样 println(set1 intersect set2) //求两个集合的交集: [CCC] println(set1 subtract set2) //求集合1在集合2中的的差集: [AAA, DDD] Set的-运算与这个效果一样 println((set1 - set2) union (set2 - set1)) //并集减去交集 虽然集合相关操作也可以应用于List集合，但是计算得到的结果始终是Set集合： fun main() { val l1 = listOf(\"AAA\", \"DDD\", \"CCC\") val l2 = listOf(\"BBB\", \"CCC\", \"EEE\") val set: Set\u003cString\u003e = l1 union l2 //得到的结果是一个Set集合 println(set) } 对于Set集合，官方也有很多预设的函数用于创建： val set = hashSetOf(\"AAA\", \"DDD\", \"BBB\") //创一个不重复且无序的Set集合 println(set) //遍历顺序并不是添加顺序: [AAA, BBB, DDD] val set = linkedSetOf(\"AAA\", \"DDD\", \"BBB\") //跟mutableSetOf一样得到一个不重复且有序的Set集合 println(set) val set1 = setOf(\"AAA\", \"DDD\", \"BBB\") //只读的Set集合 val set2 = setOfNotNull(\"AAA\", \"DDD\", \"BBB\", null) //自动过滤Null元素的Set集合 val set = sortedSetOf(\"AAA\", \"DDD\", \"BBB\") //元素自动排序的Set集合，可以自定义排序规则 val hashSet = HashSet\u003cString\u003e() //创一个不重复且无序的Set集合 val linkedHashSet = LinkedHashSet\u003cString\u003e() //跟mutableSetOf一样得到一个不重复且有序的Set集合 最后我们来讲解一个前面就买下伏笔的问题，这里我们创建了一个Student类型的Set集合： class Student(private val name: String, private val age: Int) { override fun toString(): String = \"$name ($age)\" } fun main() { val set = mutableSetOf(Student(\"小明\", 18)) set.add(Student(\"小明\", 18)) println(set) } 虽然我们插入了两个相同的数据，但是它们本质上是两个对象，只是内容相同，所以，Set中会认为它们不同，同时得到保存： 为了解决这种问题，我们之前采用的是重写equals函数来重新定义比较规则，这样就可以实现内容相同判断为同一个了： class Student(private val name: String, private val age: Int) { override fun toString(): String = \"$name ($age)\" override fun equals(other: Any?): Boolean { //跟之前一样，添加自定义的比较方式 if(this === other) return true if(other !is Student) return false if(name != other.name) return false if(age != other.age) return false return true } } 再次执行程序，我们发现似乎没什么卵用： 什么鬼，这明明都把比较规则给自定义了，怎么还是不能判断为同一个呢？我们之前难道学的是个假的吗？我们注意到类上有一个警告，提示我们没有重写了eq函数但是没有定义hashCode： 这个hashCode是什么鬼？实际上Set集合默认采用的是哈希表进行数据存储（详情请看数据结构与算法篇视频教程）而哈希表在存储数据时，需要通过一个哈希函数计算出对象的哈希值，如果两个对象的哈希值相同，那么在哈希表中就会认定为是同一个元素，如果不相同，那么会认定为不同的两个元素，因此，这里我们仅仅重写equals只能满足部分集合类的使用，而到了Set这里包括后面的Map就开始不行了。 我们可以看到，在Any类中确实定义了一个hashCode函数，这个就是用于计算对象的哈希值的： /** * 计算并返回对象的哈希值，哈希函数的计算结果需要满足以下标准: * * * 标准1: 对同一个对象调用此函数时，应该始终返回同一个哈希值，除非重写过类的equals函数，修改过比较方式 * * 标准2: 如果两个对象使用equals函数判断的结果为相同，那么它们计算得到的哈希值也应该相同 */ public open fun hashCode(): Int 在默认情况下，对象的哈希值得到的结果是对象在内存中存放的地址，以Int类型表示： println(Any().hashCode()) //结果为内存地址位置: 295530567 因此，上面两个对象由于存放在不同的地址，所以得到的哈希值肯定是不一样的，既然现在我们仅仅只是比较对象的名称和年龄是否相同，我们可以修改一下哈希函数的计算规则： class Student(private val name: String, private val age: Int) { ... override fun hashCode(): Int { var result = name.hashCode() //仅计算name和age属性的哈希值 result = 31 * result + age.hashCode() return result //这样，当name和age的哈希值与另一个对象的一致时，得到的结果就是一样的了 } } 现在再次进行操作： 所以，以后我们在重写equals函数时，为了能够适配所有的集合类，我们还需将其hashCode函数一并重写，来保证一致性。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"Map映射 Map是一个非常特殊的集合类型，它存储了一些的键值对，那么什么是键值对呢？ 可以看到，学校里面的学号对应了每一个学生，我们只需要知道某一个学生的学号，就可以快速查找这个学生的姓名、年龄、性别等信息，而Map就是为了存储这样的映射关系而存在的。 首先我们来看，如何定义一个键值对，官方为我们提供了一个非常方便的中缀函数： public infix fun \u003cA, B\u003e A.to(that: B): Pair\u003cA, B\u003e = Pair(this, that) 我们只需要指定： val pair: Pair\u003cInt, String\u003e = 10001 to \"小明\" //得到一个由学号指向学生名称的键值对 这样，我们就成功创建出了一个映射关系，但是这仅仅是单个映射，如果我们想要存储所有学生的学号映射关系，需要使用Map来实现，使用Map也非常简单： val map: MutableMap\u003cInt, Student\u003e = mutableMapOf( 10001 to Student(\"小明\", 18), 10002 to Student(\"小红\", 17), 10003 to Student(\"小刚\", 19) ) //使用mutableMapOf可以放入多个键值对，并生成一个Map对象 这样我们就成功地将所有的键值对存储在Map中了，我们接着来看看如何去访问，比如现在我们要查找指定学号的学生： val student: Student? = map[10001] //使用[]运算符通过Key查找Value 可以看到，使用方式与前面的集合类和数组非常类似，只不过访问的不再是下标，而是对应的Key。同时，这里得到的结果是一个可空类型的对象，为什么会像这样呢？ val student1: Student? = map[10001] //得到小明这个对象 val student2: Student? = map[10005] //Map中根本没有键为10005的键值对，得到的结果是null 当Map中不存在指定Key时，会直接得到null作为结果，因此我们在处理从Map返回的Value时，需要考虑空指针问题。 map.contains(1) //判断是否包含指定Key map.containsKey(1) //同上 10001 in map //同上 map.containsValue(Student(\"小明\", 18)) //判断是包含指定Value 注意： Map中的键值对存储，只能通过Key去访问Value，而不能通过Value来反向查找Key，映射关系是单向的。 我们可以直接获取到Key和Value的集合： val keys: MutableSet\u003cInt\u003e = map.keys //以Set形式存储的[10001, 10002, 10003] val value: Collection\u003cStudent\u003e = map.values //以Collection接口类型返回的 [小明 (18), 小红 (17), 小刚 (19)] 具体类型是Map的内部类实现的 遍历一个Map也很简单： map.forEach { (k, v) -\u003e println(\"键: $k, 值 $v\") } //forEach提供两个参数，key和value for (entry in map) { //使用for循环也可以直接安排，这里得到的是一个entry entry.key entry.value } for ((key, value) in map) { //也可以可以直接写成这样 println(\"键: $key, 值 $value\") } 我们再来看看如何向Map中添加新的键值对： map[10004] = Student(\"小强\", 18) //跟之前一样，直接对着赋值就行了 map.put(10004, Student(\"小强\", 18)) //使用函数也可以，跟上面效果一样 你甚至还能像这样添加： val newMap = map + (10004 to Student(\"小强\", 18)) //添加新的键值对并生成一个新的Map map += (10004 to Student(\"小强\", 18)) //直接添加键值对到当前Map里面 map += mapOf(10004 to Student(\"小强\", 18)) //或者添加其他Map到此Map中 map.putAll(mapOf(10004 to Student(\"小强\", 18))) //跟上面一样 map.putAll(setOf(10004 to Student(\"小强\", 18))) //键值对集合也可以的 不过需要注意的是，在Map中同样的Key只能存在一个，这跟Set是一样的： map[10003] = Student(\"小强\", 18) //此时Map中已经存在Key为10003的键值对了，这会导致之前的结果被覆盖 println(map) //结果为 {10001=小明 (18), 10002=小红 (17), 10003=小强 (18)} 当插入一个键值对时，如果存在相同Key会直接覆盖掉之前的键值对，我们可以通过函数的返回值来得到被覆盖的结果： val old = map.put(10003, Student(\"小强\", 18)) //put的返回值如果没有覆盖元素返回null，否则返回被覆盖的元素 println(\"被覆盖的$old\") //被覆盖的小刚 (19) 我们也可以直接移除不需要的键值对，同样是通过Key进行移除： val old = map.remove(10001) //使用remove函数移除指定键值对 println(\"被移除的$old\") 各种花式移除： map -= 10001 //等价于 map.remove(10001) map -= listOf(10001, 10002) //是的你没猜错，这个是批量移除 如果我们需要直接移除Value为某个Key的键值对，可以像这样： map.values.remove(Student(\"小明\", 18)) //直接从values中移除，会使得整个键值对被移除 val map: MutableMap\u003cInt, Student\u003e = mutableMapOf( 10001 to Student(\"小明\", 18), 10002 to Student(\"小红\", 17), 10003 to Student(\"小明\", 18) //这里存在两个一样的元素 ) map.values.remove(Student(\"小明\", 18)) //通过这种方式移除也只会移除按顺序下来的第一个 println(map) // {10002=小红 (17), 10003=小明 (18)} 有些时候，Map返回的结果是可空类型给我们造成了很多麻烦，可以通过以下方式解决： //使用getOrDefault在没有结果时返回给定的默认值 var student: Student = map.getOrDefault(10004, Student(\"小强\", 16)) //跟上面一样，只不过是使用函数式返回默认值 var student: Student = map.getOrElse(10004){ Student(\"小强\", 16) } //这个不仅能返回默认值，还能顺手把默认值给加到Map里面去，很方便 var student: Student = map.getOrPut(10004){ Student(\"小强\", 16) } println(map) //结果为 {10001=小明 (18), 10002=小红 (17), 10003=小刚 (19), 10004=小强 (16)} 有了Map之后，我们在处理一些映射关系的时候就很方便了。跟Set一样，官方也提供了多种多样的集合： val map1 = mapOf(1 to \"AAA\") //只读Map val map2 = hashMapOf(1 to \"AAA\") //不保存Key顺序的Map val map3 = linkedMapOf(1 to \"AAA\") //保存Key顺序的Map，跟mutableMapOf一样 val map4 = sortedMapOf(1 to \"AAA\") //根据排序规则自动对Key排序的Map val map5 = emptyMap\u003cInt, String\u003e() //空Map val hashMap = HashMap\u003cInt, String\u003e() //采用构造函数创建的HashMap，不保存Key顺序的Map，同map2 val linkedHashSet = LinkedHashMap\u003cInt, String\u003e() //采用构造函数创建的LinkedHashMap，保存Key顺序的Map，同map3 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"迭代器 我们在一开始提到，集合类型的顶层接口都是一个叫做Collection的接口： public interface Collection\u003cout E\u003e : Iterable\u003cE\u003e { //继承自Iterable接口 ... } 而在Iterable接口中，就定义了一个用于生成迭代器的函数： public interface Iterable\u003cout T\u003e { /** * Returns an iterator over the elements of this object. */ public operator fun iterator(): Iterator\u003cT\u003e } 不仅仅是集合类，甚至在Array类中也定义了这样的函数： public class Array\u003cT\u003e { ... /** * Creates an [Iterator] for iterating over the elements of the array. */ public operator fun iterator(): Iterator\u003cT\u003e } 迭代器是每个集合类、数组都可以生成的东西，它的作用很简单，就是用于对内容的遍历： val list = listOf(\"AAA\", \"BBB\", \"CCC\") val iterator: Iterator\u003cString\u003e = list.iterator() //通过iterator函数得到迭代器对象 那么这个迭代器该如何使用呢？先来看接口定义： public interface Iterator\u003cout T\u003e { //获取下一个待遍历元素 public operator fun next(): T //如果还有元素没有遍历，那么返回true否则返回false，而这个函数也是运算符重载函数正好对应着 for in 操作 public operator fun hasNext(): Boolean } 通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是： 一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针： 每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。 实际上迭代器的功能设计非常纯粹，就是看有没有下一个，有的话就拿出来，所以使用迭代器可以直接用一个while循环搞定： val iterator: Iterator\u003cString\u003e = list.iterator() while (iterator.hasNext()) { //使用while不断判断是否存在下一个 println(iterator.next()) //每次循环都取出一个 } 迭代器的出现，使得无论我们使用哪一种集合，都可以使用同样的方式对元素进行遍历，这统一了遍历操作的使用： fun \u003cT\u003e forEach(iterator: Iterator\u003cT\u003e) { //统一接收迭代器对象 while (iterator.hasNext()) { println(iterator.next()) } } fun main() { //现在无论什么集合/数组都可以按照统一的方式去进行处理 forEach(listOf(\"AAA\", \"BBB\", \"CCC\").iterator()) forEach(setOf(\"AAA\", \"BBB\", \"CCC\").iterator()) forEach(arrayOf(\"AAA\", \"BBB\", \"CCC\").iterator()) forEach(mapOf(1 to \"AAA\", 2 to \"BBB\",3 to \"CCC\").iterator()) } 注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。 只要是重写了operator fun iterator()函数的类型，都可以使用for..in这样的语法去进行遍历： for (s in listOf(\"AAA\", \"BBB\", \"CCC\")) { ... } 因此，数组和集合类都支持使用for循环遍历也就不奇怪了，哪怕是我们自己定义的类，只要实现这个函数都是支持的： class Test : Iterable\u003cString\u003e { //这个接口实不实现其实都无所谓 //实现这个运算符重载函数iterator是必须要的，否则不支持 override operator fun iterator(): Iterator\u003cString\u003e = TestIterator() class TestIterator: Iterator\u003cString\u003e { //自己随便写一个迭代器实现 override fun hasNext(): Boolean = true override fun next(): String = \"666\" } } fun main() { val test = Test() for (s in test) { println(s) } } 包括我们前面使用的Range语法，其本身也是一个支持生成迭代器的类： val range: IntRange = 1..3 val iterator: Iterator\u003cInt\u003e = range.iterator() 实际上，所有使用for..in语法的操作，最后都会被编译为使用迭代器的while操作： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") //编译前 for (s in list) { list.add(\"DDD\") } val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") //编译后 val iterator: Iterator\u003cString\u003e = list.iterator() while (iterator.hasNext()) { val next = iterator.next() println(next) } 是不是突然觉得有点豁然开朗？至此，我们已经完成解释清楚for..in操作的原理了。 特别的，对于List来说，它还有一个非常特殊的ListIterator迭代器： val iterator: ListIterator\u003cString\u003e = list.listIterator() //使用listIterator函数来获取ListIterator println(iterator.next()) //不仅可以正着迭代 println(iterator.nextIndex()) //还可以直接告诉你下一个迭代的是List的第几个元素 println(iterator.previous()) //还能反着来 ListIterator迭代器是普通迭代器的强化版本，它可以实现列表中元素的双向遍历，并且可以得到当前迭代的元素下标。 最后，我们再来探讨一个之前可能遇到过的问题： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") for (s in list) { //在遍历List时，不断往里面添加新的元素 list.add(\"DDD\") } 此程序运行会直接得到一个报错： 在JVM环境下，Kotlin默认不支持在迭代时修改集合里面的内容，无论是插入新的元素还是移除元素，都会触发并发修改异常。为了解决这个问题，Kotlin为所有的MutableCollection（所有非只读集合类）提供了一个特殊的用于生成MutableIterator的函数，只要我们使用的不是只读的集合类，都可以获得这个特殊的迭代器，它支持在遍历时对元素进行删除： val list = mutableListOf(\"AAA\", \"BBB\", \"CCC\") val iterator: MutableIterator\u003cString\u003e = list.iterator() while (iterator.hasNext()) { iterator.next() iterator.remove() //删除当前迭代器已经遍历的最后一个元素 } 有关迭代器的相关知识就先到这里了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"集合与数组扩展操作 前面我们介绍了Kotlin提供的几个常用集合类，我们在使用这些集合类的时候，为了更加方便，官方提供了很多用于集合、数组类型的扩展操作，我们来学习一下吧，因为这些扩展操作数组和集合都可以使用，我们就尽量以List为例进行讲解。 首先是数组跟集合的联动，有些时候我们可能拿到的是一个数组对象，但是我们希望将其转换为集合类进行操作，我们可以使用数组提供的集合快速转换函数来进行转换： val array = arrayOf(\"AAA\", \"BBB\", \"CCC\") val list: List\u003cString\u003e = array.toList() val list: MutableList\u003cString\u003e = array.toMutableList() val set: Set\u003cString\u003e = array.toSet() val set: MutableSet\u003cString\u003e = array.toMutableSet() 这样，如果我们发现数组无法满足我们对于其元素的操作，可以直接转换为集合类进行操作，方便你我。 接下来是映射操作（注意这里说的map跟我们前面说的集合Map是两个概念，别搞混了）它可以将集合类、数组的元素类型进行转换，比如我们现在有一个字符串集合，但是我们现在希望把它变成记录每一个字符串长度的Int集合，该怎么做呢？ val list = listOf(\"AAA\", \"BB\", \"CCCCC\") val lenList: List\u003cInt\u003e = list.map { it.length } //使用map函数，传入自定义的转换操作函数，就可以对元素进行转换了 我们可以利用这种操作来为里面的每一个元素添加编号： val list = listOf(\"AAA\", \"BBB\", \"CCC\") //使用mapIndexed还可以额外附带一个index参数 val mapList: List\u003cString\u003e = list.mapIndexed { index, it -\u003e \"$index.${it}\" } println(mapList) //结果 [0.AAA, 1.BBB, 2.CCC] 快速编号操作 利用映射操作，我们可以快速对集合中是元素依次进行修改，也可以对集合中的元素进行类型转换，非常方便。 对于Map类型，我们还可以单独对所有Key或是Value进行操作： val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3) println(numbersMap.mapKeys { it.key.uppercase() }) //对所有的Key进行Map操作 println(numbersMap.mapValues { it.value + it.key.length }) 我们接着来看下一个，压缩操作，它可以将当前集合元素和另一个集合中具有相同索引的元素组合起来，生成一个装满Pair的列表： val list1 = listOf(1, 2, 3) val list2 = listOf(\"AAA\", \"BBB\", \"CCC\") val pairs: List\u003cPair\u003cInt, String\u003e\u003e = list1.zip(list2) println(pairs) 利用压缩操作我们可以快速将两个List集合揉成一个Map集合： val map = mutableMapOf\u003cInt, String\u003e() map.putAll(list1.zip(list2)) println(map) //结果 {1=AAA, 2=BBB, 3=CCC} 既然能压缩还能解压： val list = listOf(1 to \"AAA\", 2 to \"BBB\", 3 to \"CCC\") //把合在一起的Pair每个元素都分开 val unzipList: Pair\u003cList\u003cInt\u003e, List\u003cString\u003e\u003e = list.unzip() //转换出来是一个存放两个List的Pair println(unzipList) 有些时候我们还可以使用另一种方式将普通集合转换为Map映射，比如associate操作： val list = listOf(\"AAA\", \"BBB\", \"CCC\") //使用associateWith快速构建以列表中每个元素为Key的Map映射 val associate: Map\u003cString, Int\u003e = list.associateWith { it.length } //提供一个函数，返回值作为生成的Map对应Key的Value println(associate) //结果 {AAA=3, BBB=3, CCC=3} 还有对应的反向操作： val list = listOf(\"AAA\", \"BBB\", \"CCC\") //使用associateBy快速构建以列表中每个元素为Value的Map映射 val associate: Map\u003cInt, String\u003e = list.associateBy { it.length } //提供一个函数，返回值作为生成的Map对应Value的Key println(associate) //结果{3=CCC}，因为上面生产出来的Key全是3，覆盖完只剩下最后一个了 如果你觉得以上两种方式都不是很灵活，你也可以自己根据情况自行构建一个Pair作为结果返回： val associate: Map\u003cString, Int\u003e = list.associate { it to it.length } //返回一个Pair 我们接着来看，对于一些嵌套集合和数组来说，有时候处理里面的数据会变得很棘手： val list = listOf(listOf(\"AAA\", \"BBB\"), listOf(\"CCC\", \"DDD\")) //现在我们想要遍历这个嵌套List中的每一个元素，需要两层for循环 list.forEach { it.forEach { item -\u003e println(item) } } 那么有没有办法能够把这个嵌套的集合内所有的集合全部拆出来，全部存在一个不嵌套的集合中呢？我们可以使用扁平化操作： val list = listOf(listOf(\"AAA\", \"BBB\"), listOf(\"CCC\", \"DDD\")) val flatten: List\u003cString\u003e = list.flatten() //使用flatten函数将嵌套集合扁平化 println(flatten) //可以看到内容自动被展平了 [AAA, BBB, CCC, DDD] 结合之前学习的映射操作，我们还可以在展平元素的同时对元素进行映射，非常适合下面这种情况： //把下面这个给展平 val list = listOf(Container(listOf(\"AAA\", \"BBB\")), Container(listOf(\"CCC\", \"DDD\"))) 可以看到，这个List很恶心，它内层存放的集合是被套在一个对象中的，更准确的说，这是一个List\u003cContainer\u003e类型的列表，但是现在我们希望的是取出里面每一个对象存储的List然后拿来展平，可以像这样： //使用flatMap函数进行操作，支持自定义获取列表然后再进行扁平化操作 val flatList: List\u003cString\u003e = list.flatMap { it.list } //通过Lambda将每一个Container映射为List println(flatList) //结果为：[AAA, BBB, CCC, DDD] 其实还有一个joinToString函数，但是前面数组部分已经讲解过了，使用方式是一样的，这里就不做介绍了。 有时候我们想要移除集合中某些不满足条件的元素，我们可以使用过滤操作来完成： val list = listOf(\"AAA\", \"BB\", \"CCC\") //使用filter来过滤不满足条件的元素，这里的意思是只保留长度大于2的字符串 val filterList: List\u003cString\u003e = list.filter { it.length \u003e 2 } println(filterList) //结果为：[AAA, CCC] val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11) //Map同样支持这样的操作 val filteredMap = numbersMap.filter { (key, value) -\u003e key.endsWith(\"1\") \u0026\u0026 value \u003e 10} println(filteredMap) 还有快速过滤所有空值的操作： val list = listOf(\"AAA\", null, \"BBB\", null) val filterList: List\u003cString\u003e = list.filterNotNull() println(filterList) //结果 [AAA, BBB] 甚至还可以快速过滤出指定类型的集合： val list = listOf(\"AAA\", Any(), \"BBB\", 123, 3.14) val filterList: List\u003cString\u003e = list.filterIsInstance\u003cString\u003e() //快速过滤出所有的String元素 println(filterList) //结果 [","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"序列 除了集合，Kotlin标准库还包含另一种类型：序列（Sequence）与集合不同，序列不包含元素，它在运行时生成元素，Sequence与Iterable接口功能相似，接口定义如下，同样只包含一个生成迭代器的函数： public interface Sequence\u003cout T\u003e { public operator fun iterator(): Iterator\u003cT\u003e } 那既然功能一样，为什么要专门搞一个序列呢？这不是多此一举吗？序列实际上是一个延迟获取数据的集合，只有需要元素时才会生产元素并提供给外部，包括所有对元素操作，并不是一次性全部处理，而是根据情况选择合适的元素进行操作。使用序列能够在处理大量数据时获得显著的性能提升。 要创建一个序列非常简单，使用generateSequence函数即可： val sequence: Sequence\u003cInt\u003e = generateSequence { println(\"生成一个新的元素\") 10 //返回值就是生成的元素 } 可以看到generateSequence得到的结果并没有在一开始执行println，因为序列的数据处理是惰性的，在我们添加 sequence.forEach { println(it) } 此时控制台才开始打印生成的Lambda函数。同样的，所有扩展操作同样是惰性的，我们可以来比较一下： val list = listOf(\"AA\", \"BBB\", \"CCC\", \"DD\", \"EEE\", \"FF\", \"GGG\", \"HH\") //以下操作用于获取前两个长度大于2的字符串，并进行小写转换操作 val result = list.filter { println(\"进行过滤操作: $it\") it.length \u003e 2 }.map { println(\"进行小写转换操作\") it.lowercase() }.take(2) 可以看到，在直接使用集合的情况下，整个工序是按照顺序在向下执行的，并且每一道工序都会对所有的元素依次进行操作，但是实际上根据我们的要求，最后只需要两个满足条件的即可，如果这个是一个数据量非常庞大的集合，会导致执行效率很低。我们现在换成序列试试看： //使用asSequence函数将集合转换为一个序列 val result = list.asSequence().filter { println(\"进行过滤操作: $it\") it.length \u003e 2 }.map { println(\"进行小写转换操作\") it.lowercase() }.take(2) println(result) //如果这句不执行，不获取元素，以上整个操作都是不会进行的 可以看到，序列根据我们的操作流程，对数据的操作也进行了优化，执行次数明显减少，并且使用序列后只有我们从序列读取数据时才会开始执行我们定义好的工序，可见，序列执行的各种操作，仅仅是记录到序列中，并没有在一开始就执行，而是需要的时候才开始获取，因此才可以做到上面这样的操作。 这与Java中的Stream非常相似。 当然，序列并不是随时随地都可以使用的，我们还是要根据实际情况决定是否要使用序列，如果在数据量特别庞大的情况下，使用序列处理会更好，但是如果数据量很小，使用序列反而会增加开销。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:9:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"特殊类型介绍 除了我们之前学习的普通class类型之外，Kotlin还为我们提供了更多种类的类型，以应对不同的情况。 这些特殊类型本质上依然是class但是存在一些限制或是特殊情况。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数据类型 对于那些只需要保存数据的类型，我们常常需要为其重写toString、equals等函数，针对于这种情况下，Kotlin为我们提供了专门的数据类，数据类不仅能像普通类一样使用，并且自带我们需要的额外成员函数，比如打印到输出、比较实例、复制实例等。 声明一个数据类非常简单： //在class前面添加data关键字表示为一个数据类 data class User(val name: String, val age: Int) 数据类声明后，编译器会根据主构造函数中声明的所有属性自动为其生成以下函数： .equals()/.hashCode() .toString()生成的字符串格式类似于\"User(name=John, age=42)\" .componentN()与按声明顺序自动生成用于解构的函数 .copy()用于对对象进行拷贝 我们可以来试试看： fun main() { val user1 = User(\"小明\", 18) val user2 = User(\"小明\", 18) println(user1) //打印出来就是格式化的字符串 User(name=小明, age=18) println(user1 == user2) //true，因为自动重写了equals函数 val (name, age) = user1 //自动添加componentN函数，因此支持解构操作 println(\"名称: $name, 年龄: $age\") } 当然，为了确保生成代码的一致性和有效性，数据类必须满足以下要求： 主构造函数中至少有一个参数。 主构造函数中的参数必须标记为val或var。 数据类不能是抽象的、开放的、密封的或内部的。 此外，数据类的成员属性生成遵循有关成员继承的以下规则： 如果数据类主体中.equals() .hashCode()或.toString()等函数存在显式（手动）实现，或者在父类中有final实现，则不会自动生成这些函数，并使用现有的实现。 data class User(val name: String, val age: Int) { //如果已经存在toString的情况下，不会自动生成 override fun toString(): String = \"我是自定义的toString\" } fun main() { val user = User(\"小明\", 18) println(user) //结果: 我是自定义的toString } 如果超类型具有open .componentN()函数并返回兼容类型，则为数据类生成相应的函数，并覆盖超类型的函数。如果由于一些关键字导致无法重父类对应的函数会导致直接报错。 abstract class AbstractUser { //此函数必须是open的，否则无法被数据类继承 open operator fun component1() = \"卢本伟牛逼\" } data class User(val name: String, val age: Int): AbstractUser() //自动覆盖掉父类的component1函数 不允许为.componentN()和.copy()函数提供显式实现。 注意，编译器会且只会根据主构造函数中定义的属性生成对应函数，如果有些时候我们不希望某些属性被添加到自动生成的函数中，我们需要手动将其移出主构造函数： data class Person(val name: String) { var age: Int = 0 //age属性不会被处理 } 此时生成的所有函数将不会再考虑age属性： fun main() { val person1 = Person(\"John\") val person2 = Person(\"John\") person1.age = 10 person2.age = 20 println(\"person1 == person2: ${person1 == person2}\") // person1 == person2: true println(\"person1 with age ${person1.age}: $person1\") // person1 年龄为 10: Person(name=John) println(\"person2 with age ${person2.age}: $person2\") // person2 年龄为 20: Person(name=John) } 数据类自带一个拷贝对象的函数，使用.copy()函数复制对象，允许您更改其一些属性，而其余的保持不变。此函数对上述User类的实现如下： data class User(val name: String, val age: Int) fun main() { val user = User(\"小明\", 18) val copyUser = user.copy() //使用拷贝函数生成一个内容完全一样的新对象 println(user == copyUser) println(user === copyUser) } 在copy函数还可以在拷贝过程中手动指定属性的值： val user = User(\"小明\", 18) println(user.copy(age = 17)) //结果为 User(name=小明, age=17) ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"枚举类型 我们知道，在Kotlin中有一个Boolean类型，它只有两种结果，要么为false要么为true，这代表它的两种状态真和假。有些时候，可能两种状态并不能满足我们的需求，比如一个交通信号灯，它具有三种状态：红灯、黄灯和绿灯。 如果我们想要存储和表示自定义的多种状态，使用枚举类型就非常合适： //在类前面添加enum表示这是一个枚举类型 enum class LightState { GREEN, YELLOW, RED //直接在枚举类内部写上所有枚举的名称，一般全部用大写字母命名 } 枚举类的值只能是我们在类中定义的那些枚举，不可以存在其他的结果，枚举类型同样也是一个普通的类，只是存在值的限制。 要使用一个枚举类的对象，可以通过类名直接获取定义好的枚举： fun main() { val state: LightState = LightState.RED //直接得到红灯 println(state.name) //自带name属性，也就是我们编写的枚举名称，这里是RED } 同样的，枚举类也可以具有成员： //同样可以定义成员变量，但是不能命名为name，因为name拿来返回枚举名称了 enum class LightState(val color: String) { GREEN(\"绿灯\"), YELLOW(\"黄灯\"), RED(\"红灯\"); //枚举在定义时也必须填写参数，如果后面还要编写成员函数之类的其他内容，还需在末尾添加分号结束 fun isGreen() = this == LightState.GREEN //定义一个函数也是没问题的 } 我们可以像普通类那样正常使用枚举类的成员： val state: LightState = LightState.RED println(\"信号灯的颜色是: ${state.color}\") println(\"信号灯是否可以通行: ${state.isGreen()}\") 枚举类型可以用于when表达式进行判断，因为它的状态是有限的： val state: LightState = LightState.RED val message: String = when(state) { LightState.RED -\u003e \"禁止通行\" LightState.YELLOW -\u003e \"减速通行\" LightState.GREEN -\u003e \"正常通行\" } println(message) //结果为: 禁止通行 在枚举类中也可以编写抽象函数，抽象函数需要由枚举自行实现： enum class LightState(val color: String) { GREEN(\"绿灯\"){ override fun test() = println(\"我是绿灯，表示可以通过\") }, YELLOW(\"黄灯\") { override fun test() = println(\"我是黄灯，是让你减速，不是让你踩油门加速过去\") }, RED(\"红灯\") { override fun test() = println(\"我是红灯，禁止通行\") }; abstract fun test() //抽象函数 } fun main() { val state: LightState = LightState.RED state.test() //调用函数: 我是红灯，禁止通行 } 如果枚举类实现了某个接口，同样可以像这样去实现： interface Message { fun test() } enum class LightState(val color: String) : Message { GREEN(\"绿灯\"){ override fun test() = println(\"我是绿灯，表示可以通过\") }, YELLOW(\"黄灯\") { override fun test() = println(\"我是黄灯，是让你减速，不是让你踩油门加速过去\") }, RED(\"红灯\") { override fun test() = println(\"我是红灯，禁止通行\") }; } enum class LightState(val color: String) : Message { GREEN(\"绿灯\"), YELLOW(\"黄灯\"), RED(\"红灯\"); override fun test() = println(\"\") } 枚举类也为我们准备了很多的函数： val state: LightState = LightState.valueOf(\"RED\") //通过valueOf函数以字符串名称的形式转换为对应名称的枚举 val state: LightState = enumValueOf\u003cLightState\u003e(\"RED\") //同上 println(state) println(state.ordinal) //枚举在第几个位置 println(state.name) //枚举名称 val entries: EnumEntries\u003cLightState\u003e = LightState.entries //一键获取全部枚举，得到的结果是EnumEntries类型的，他是List的子接口，因此可以当做List来使用 val values: Array\u003cLightState\u003e = enumValues\u003cLightState\u003e() //或者像这样以Array形式获取到所有的枚举 println(entries) ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"匿名类和伴生对象 有些时候，可能我们并不需要那种通过class关键字定义的对象，而是以匿名的形式创建一个临时使用的对象，在使用完之后就不再需要了，这种情况完全没有必要定义一个完整的类型，我们可以使用匿名类的形式去编写。 val obj = object { //使用object关键字声明一个匿名类并创建其对象，可以直接使用变量接收得到的对象 val name: String = \"\" override fun toString(): String = \"我是一个匿名类\" //匿名类默认继承于Any，可以直接重写其toString } println(obj) 可以看到，匿名类除了没名字之外，也可以定义成员，只不过这种匿名类不能定义任何构造函数，因为它是直接创建的，这种写法我们也可以叫做对象表达式。 匿名类不仅可以直接定义，也可以作为某个类的子类定义，或是某个接口的实现： interface Person { fun chat() } fun main() { val obj: Person = object : Person { //直接实现Person接口 override fun chat() = println(\"牛逼啊\") } obj.chat() //当做Person的实现类使用 } interface Person open class Human(val name: String) fun main() { val obj: Human = object : Human(\"小明\"), Person { //继承类时，同样需要调用其构造函数 override fun toString() = \"我叫$name\" //因为是子类，直接使用父类的属性也是没问题的 } println(obj) } 可以看到，平时我们无法直接实例化的接口或是抽象类，可以通过匿名类的形式得到一个实例化对象。 我们再来看下面这种情况： interface KRunnable { fun invoke() //此类型是一个接口且只包含一个函数 } 根据我们上面学习的用法，如果我们想要使用其匿名类，可以像这样编写： fun main() { val runnable = object : KRunnable { //使用匿名类的形式编写KRunnable的实现类对象 override fun invoke() { println(\"我是函数invoke的实现\") } } runnable.invoke() } 特别的，对于只存在一个抽象函数的接口称为函数式接口或单一抽象方法（SAM）接口，函数式接口可以有N个非抽象成员，但是只能有一个抽象成员。对于函数式接口，可以使用我们前面介绍的Lambda表达式来使代码更简洁： fun interface KRunnable { //在接口声明前面添加fun关键字 fun invoke() } ... fun main() { val runnable = KRunnable { //支持使用Lambda替换 println(\"我是函数invoke的实现\") } runnable.invoke() } 我们再来看下面这种情况： fun interface Printer { fun print() } fun test(printer: Printer) { //需要Printer接口实现对象 printer.print() } 我们在调用test时，也可以写的非常优雅： fun main() { test { //直接Lambda一步到位 println(\"Hello World\") } } 正是因为有了匿名类，所以有些时候我们通过函数得到的结果，可能并不是某个具体定义的类型，也有可能是直接采用匿名形式创建的匿名类对象： open class Human(val name: String) fun test() = object: Human(\"小明\") { //返回的一个匿名类对象 val age: Int = 10 override fun toString() = \"我叫$name\" } fun main() { println(test().name) println(test().age) //编译错误，因为返回的类型是Human，由于其匿名特性，只能当做Human使用 } object关键字除了用于声明匿名类型，也可以用于声明单例类。单例类是什么意思呢？就像它的名字一样，在整个程序中只能存在一个对象，也就是单个实例，不可以创建其他的对象，始终使用的只能是那一个对象。 object Singleton { //声明的一个单例类 private var name = \"你干嘛\" override fun toString() = \"我叫$name\" } fun main() { val singleton = Singleton //通过类名直接得到此单例类的对象 //不可以通过构造函数的形式创建对象 println(singleton) } object Singleton { fun test() = println(\"原神，启动！\") } fun main() { Singleton.test() //单例定义的函数直接使用类名即可调用 } 用起来与Java中的静态属性挺像的，只不过性质完全不一样。单例类的这种性质在很多情况下都很方便，比如我们要编写某些工具操作，可以直接使用单例类的形式编写。 现在我们希望一个类既支持单例类那样的直接调用，又支持像一个普通class那样使用，这时该怎么办呢？ 我们可以使用半生对象来完成，实际上就是将一个单例类写到某个类的内部： class Student(val name: String, val age: Int) { //使用companion关键字在内部编写一个伴生对象，它同样是单例的 companion object Tools { //伴生对象定义的函数可以直接通过外部类名调用 fun create(name: String, age: Int) = Student(name, age) } } fun main() { //现在Student不仅具有对象的函数，还可以通过类名直接调用其伴生对象通过的函数 val student = Student.create(\"小明\", 18) println(student.toString()) } 伴生对象在Student类加载的时候就自动创建好了，因此我们可以实现直接使用。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"委托模式 在有些时候，类的继承在属性的扩展上起到了很大的作用，通过继承我们可以直接获得某个类的全部属性，而不需要再次进行编写，不过，现在有了一个更好的继承替代方案，那就是委托模式（在设计模式中也有提及）名字虽然听着很高级，但是其实很简单，比如我们现在有一个接口： interface Base { fun print() } 正常情况下，我们需要编写一个它的实现类： class BaseImpl(val x: Int) : Base { override fun print() = println(x) } 现在我们换一个思路，我们再来创建一个实现类： class Derived(val base: Base): Base { //将一个Base的实现类作为属性保存到类中，同样实现Base接口 override fun print() = base.print() //真正去实现这个接口的，实际上并不是当前类，而是被拉进来的那个替身 } 这就是一个非常典型的委托模型，且大量实践已证明委托模式是实现继承的良好替代方案。 Kotlin对于这种模式同样给予了原生支持： interface Base { fun print() } class BaseImpl(val x: Int) : Base { override fun print() = println(x) } class Derived(val b: Base): Base by b //使用by关键字将所有接口待实现操作委托给指定成员 这样就可以轻松实现委托模式了。 除了类可以委托给其他对象之外，类的成员属性也可以委托给其他对象： import kotlin.reflect.KProperty class Example { var p: String by Delegate() //属性也可以使用by关键字委托给其他对象 } // 委托的类 class Delegate { //需要重载属性的获取和设置两个运算 operator fun getValue(thisRef: Any?, property: KProperty\u003c*\u003e): String { return \"$thisRef, 这里委托了 ${property.name} 属性\" } operator fun setValue(thisRef: Any?, property: KProperty\u003c*\u003e, value: String) { println(\"$thisRef 的 ${property.name} 属性赋值为 $value\") } } fun main() { println(Example().p) } 不过，自己去定义一个类来进行委托实在是太麻烦了，Kotlin在标准库中也为我们提供了大量的预设函数： class Example { val p: String by lazy { \"牛逼啊\" } //lazy为我们生成一个委托对象，这样在获取属性值的时候就会执行lazy里面的操作了，看起来效果就像是延迟执行一样，由于只能获取，所以说只支持val变量 } fun main() { println(Example().p) } 也可以设置观察者，实时观察变量的变化： class Example { var p: String by Delegates.observable(\"我是初始值\") { prop, old, new -\u003e println(\"检测到$prop 的值发生变化，旧值：$old -\u003e 新值：$new\") } } fun main() { Example().p = \"你干嘛\" } 属性也可以直接将自己委托给另一个属性： class Example(var a: String) { var p: String by ::a //使用双冒号来委托给其他属性 } fun main() { val example = Example(\"你干嘛\") println(example.p) } 相信各位应该能猜到，这样委托给其他属性，当前属性的值修改，会直接导致其他属性的值也会修改，相反同样它们已经被相互绑定了。 属性也可以被委托给一个Map来进行存储： class User(map: MutableMap\u003cString, Any\u003e) { var name: String by map //直接委托给外部传入的Map集合 var age: Int by map //变量的值从Map中进行存取 override fun toString(): String = \"名称: $name, 年龄: $age\" } fun main() { val map: MutableMap\u003cString, Any\u003e = mutableMapOf( \"name\" to \"John Doe\", \"age\" to 25 ) val user = User(map) println(user) //名称: John Doe, 年龄: 25 map[\"age\"] = 10 //映射的值修改会直接影响变量的值 println(user) //名称: John Doe, 年龄: 10 } 注意，在使用不可变的Map时，只能给val类型变量进行委托，因为不可修改。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"密封类型 有些时候，我们可能会编写一些类给其他人使用，但是我们不希望他们随意继承使用我们提供的类，我们只希望在我们提供的框架内部自己进行使用，这时我们就可以将类或接口设定为密封的。 密封类的所有直接子类在编译时都是已知的。不得在定义密封类的模块和包之外出现其他子类。例如，第三方项目无法在其代码中扩展您的密封类。因此，密封类的每个实例都有一个来自预设好的类型，且该类型在编译该类时是已知的。 package com.test sealed class A //声明密封类很简单，直接添加sealed关键字即可 sealed class B: A() //密封类同一个模块或包中可以随意继承，并且子类也可以是密封的 当我们在其他包中使用这个密封类，在其他包或模块中无法使用： class C: A() //编译错误，不在同一个模块 fun main() { val b = B() //编译错误，不可以实例化 } 密封类将类的使用严格控制在了模块内部，包括密封接口及其实现也是如此：一旦编译了具有密封接口的模块，就不会出现新的实现类。 从某种意义上说，密封类类似于枚举类：枚举类型的值数量也受到限制，由我们自己定义，但每个枚举变量仅作为单个实例存在，而密封类的子类可以有多个实例，每个实例都有自己的状态。密封类本身也是抽象的，它不能直接实例化，并且可以具有abstract成员： sealed class A sealed class B: A() { abstract fun test() } 密封类继承后也可以使其不继续密封，让外部可以正常使用： sealed class A class B: A() class C: A() class D: A() //不添加sealed关键字使其不再密封 但是由于类A是密封的，因此所有继承自A的类只能是我们自己写的，别人无法编写继承A的类，除非我们将某个继承A的类设定为open特性，允许继承。因此，这也进一步证明密封类在一开始就确定了有哪些子类。 由于密封类能够确定，所以在使用when进行类型判断时，也是有限的： fun main() { val a: A = C() when(a) { is B -\u003e println(\"是B\") is C -\u003e println(\"是C\") is D -\u003e println(\"是D\") } } 密封类的应用场景其实远不止这些，由于篇幅有限，这里就不展开讲解了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:10:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"异常机制 在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ 我们来看下面这段代码： fun main() { test(1, 0) //当b为0的时候，还能正常运行吗？ } private fun test(a: Int, b: Int): Int { return a / b //没有任何的判断而是直接做计算 } 1怎么可能去除以0呢，数学上有明确规定，0不能做除数，所以这里得到一个异常： 那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！它们在默认情况下会强行终止我们的程序。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:11:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"异常的使用 我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Throwable类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ 每个异常对象都包含一条消息、一个堆栈跟踪和一个可选原因。 我们自己也可以抛出异常，要抛出异常对象，请使用throw出表达式： fun main() { //Exception继承自Throwable类，作为普通的异常类型 throw Exception(\"牛逼\") } 可以看到，控制台出现了下面的报错： 所以，我们平时看到的那些丰富多彩的异常，其实大部分都是由程序主动抛出的。 我们也可以依葫芦画瓢，自定义我们自己的异常类： class TestException(message: String) : Exception(message) fun main() { throw TestException(\"自定义异常\") } 是不是感觉很简单，异常的出现就是为了方便我们快速判断程序的错误。我们可以在异常打印出来的栈追踪信息中得到当前程序出现问题的位置： 这里指示的很明确，是我们的Main.kt文件第四行代码出现了异常。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:11:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"异常的处理 当程序没有按照我们理想的样子运行而出现异常时（JVM平台下，默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： val array = arrayOf(1, 2, 3) println(array[3]) //数组长度根本没有4，很明显这里会出现异常 现在我们希望能够手动处理这种情况，即使发生异常也要继续下去，我们可以使用try-catch语句块来完成： fun main() { try { //使用try-catch语句进行异常捕获 val array = arrayOf(1, 2, 3) println(array[3]) } catch (e: ArrayIndexOutOfBoundsException) { //因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常 } println(\"程序继续正常运行！\") } 我们可以将代码编写到try语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用catch关键字对指定的异常进行捕获，这里我们捕获的是ArrayIndexOutOfBoundsException数组越界异常： 可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。 注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。 我们可以在catch语句块中对捕获到的异常进行处理： fun main() { try { //使用try-catch语句进行异常捕获 val array = arrayOf(1, 2, 3) println(array[3]) } catch (e: ArrayIndexOutOfBoundsException) { e.printStackTrace(); //打印栈追踪信息 println(\"异常错误信息：\"+e.message); //获取异常的错误信息 } println(\"程序继续正常运行！\") } 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： try { //.... } catch (e: Exception) { //父类型在前，会将子类的也捕获 } catch (e: NullPointerException) { //因为NullPointerException是Exception的子类型，永远都不会进入这里 } catch (e: IndexOutOfBoundsException) { //永远都不会进入这里 } 最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给finally语句块来处理： try { //.... } catch (e: Exception) { } finally { println(\"lbwnb\") //无论是否出现异常，都会在最后执行 } 注意：try语句块至少要配合catch或finally中的一个。 try也可以当做一个表达式使用，这意味着它可以有一个返回值： fun main() { val input = readln() val a: Int? = try { input.toInt() } catch (e: NumberFormatException) { null } println(a) } 针对于空类型，我们也可以在判断为空时直接抛出异常： val s = person.name ?: throw IllegalArgumentException(\"Name required\") ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:11:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["draft"],"content":"Btrfs文件系统介绍 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"1. Btrfs简介 Btrfs 是一种新型的写时复制（CoW）Linux 文件系统，已经并入内核主线。你可以读作 Better File System、B-tree File System、Butter File System 等等，都是正确的。Btrfs 在设计实现高级功能的同时，着重于容错、修复以及易于管理。它由 Oracle、Red Hat、Fujitsu、Intel、SUSE、STRATO 等企业和开发者共同开发。Btrfs 以 GNU GPL 协议授权，同时也欢迎任何人的贡献。 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"2. Btrfs的特性 扩展性相关 B-tree Btrfs 文件系统中所有的 metadata 都由 B-tree 管理。使用 B-tree 的主要好处在于查找、插入和删除操作都很高效。可以说 B-tree 是 Btrfs 的核心 基于 Extent 的文件存储 ✅ 针对 SSD 的优化支持 Btrfs 的 CoW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，Btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 I/O 性能 动态 Inode 分配 支持非常大的单个文件大小 数据一致性相关 ✅ 写时复制（CoW） 比就地修改的文件系统有更大的好处，详细的说明见下文 校验和（Checksum） 保证了数据的可靠性：由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变成了 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。如果最终从磁盘读取出来的数据和 checksum 不相同，Btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，Btrfs 将返回错误。写入磁盘数据之前，Btrfs 计算数据的 checksum。然后将 checksum 和数据同时写入磁盘。 多设备管理相关 ✅ 多设备管理 Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的相关命令将该设备添加到文件系统中 ✅ 子卷（Subvolume） 把文件系统的一部分配置为一个完整的子文件系统 ✅ 快照（Snapshot）和克隆（Clone） 支持快照 支持快照的快照（增量备份） 可以对单个文件进行备份 ✅ 内置支持 RAID，支持条带或 mirror 等常见的 RAID 功能 ✅ 支持热移除、热添加设备 其他特性 ✅ 透明压缩 减小了文件的大小，通过减少文件写入增幅来显著延长闪存介质的寿命。在某些特定的场景下（比如单线程、重负荷的文件 I/O）还提高了性能 延迟分配（Delay allocation） 在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配则是这样一种技术 —— 当用户需要磁盘空间时，先将数据保存在内存中。将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求 —— 一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 I/O 效率 Inline File 系统中往往存在大量的小文件（几百个字节或者更小）。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。Btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。得益于 Inline File 技术，Btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题 目录索引（Directory Index） 当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 B-tree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。然而，Btrfs 使用 B-tree 管理目录项的方式无法同时满足 readdir 的需求。readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件；并且特别的，这些文件要按照 inode number 排序。而 Btrfs 目录项插入 B-tree 时的 Key 并不是 inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，Btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 Key 以 sequence number 作为 B-tree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 Key 在 B-tree 中查找便可以方便的得到一个以 inode number 排序的文件列表 另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 I/O 效率 预分配 很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"Btrfs 与其它文件系统功能比较# Feature Ext 2 / 3 Ext 4 ReiserFS XFS OCFS2 Btrfs Journal (date / metadata) ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚫ ⚪ / ⚫ ⚪ / ⚫ N/A Journal (internal / external) ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚪ N/A Offline extend / shrink ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Online extend / shrink ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Inode allocation map table table B*-tree B+-tree table B-tree Sparse files ⚫ ⚫ ⚫ ⚫ ⚫ ⚫ Tail packing ⚪ ⚫ ⚫ ⚪ ⚪ ⚫ Defragmentation ⚪ ⚫ ⚪ ⚫ ⚪ ⚫ ExtArributes / ACLs ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ Quotas ⚫ ⚫ ⚫ ⚫ ⚫ 🔴 Dump / restore ⚫ ⚫ ⚪ ⚫ ⚪ ⚪ Default block size 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB max. file system size 16 TiB 1 EiB 16 TiB 8 EiB 4 PiB 16 EiB max. file size 2 TiB 1 EiB 1 EiB 8 EiB 4 PiB 16 EiB Support status SLES SLES SLES SLES SLE HA SLES ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:1","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"3. Barfs的简单使用 3.1 创建文件系统 mkfs.btrfs -f /dev/sda1 3.2 挂载文件系统 mount /dev/sda1 /mnt 3.3 创建子卷 btrfs subvolume create subvolume_name 3.4 删除子卷 btrfs subvolume delete subvolume_name # or rm -rf subvolume_name 3.5 创建快照 btrfs subvolume snapshot source destination 3.6 删除快照 btrfs subvolume delete snapshot_name 3.7 查看快照 btrfs subvolume list /mnt 3.8 查看文件系统信息 btrfs filesystem show /mnt 3.9 查看文件系统使用情况 btrfs filesystem df /mnt 3.10 查看文件系统的压缩情况 btrfs filesystem df -c /mnt 3.11 查看文件系统的压缩算法 btrfs filesystem df -c /mnt 3.12 查看子卷信息 btrfs subvolume show /mnt ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"VPN 原理浅谈 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:0:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的应用场景 保护隐私： VPN 通过加密通信，确保你的互联网连接是安全的。这对于在公共 Wi-Fi 网络上浏览互联网时尤其重要，因为公共网络通常更容易受到黑客攻击。 绕过地理限制： 有些网站或服务在特定地区可能不可用，或者内容受到地理限制。使用 VPN 可以改变你的 IP 地址，使你能够绕过这些地理限制，访问受限制的内容。 保护公司内部网络： 公司可以使用 VPN 来建立安全的远程访问通道，员工可以通过 VPN 连接到公司内部网络，以便在远程地点安全地访问公司资源。 匿名上网： VPN 可以隐藏你的真实 IP 地址，提高上网的匿名性。这对于那些希望在互联网上保持相对匿名的用户来说很有用。 绕过审查： 在一些国家，互联网审查可能会限制对特定网站或服务的访问。使用 VPN 可以绕过这些审查，让用户能够自由地访问互联网。 安全远程办公： 对于远程工作者或分布式团队来说，VPN 提供了一个安全的通信渠道，使他们能够远程连接到公司网络并访问必要的资源。 防止数据被窃取： 在使用不安全的网络时，VPN 可以加密你的数据流，防止敏感信息被窃取，确保通信的机密性。 游戏加速： 一些玩家可能使用 VPN 来连接到特定地区的游戏服务器，以获得更好的游戏性能或访问特定地区的游戏内容。 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:1:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的工作原理 涉及到的底层技术 tun/tap: 用于创建虚拟网卡，用于接收和发送数据包, 主要的操作就是在此实现的 iptables： 用于实现数据包的转发 iproute2： 用于实现路由表的管理 tun/tap 概述： tun 设备: TUN设备是一种虚拟网络设备，用于在用户空间和内核空间之间传递网络数据。TUN代表“网络隧道”（Network TUNnel），它允许用户空间的程序通过标准的网络套接字接口发送和接收IP数据包，同时内核会处理网络协议的部分。TUN设备通常用于创建虚拟私有网络（VPN）和其他网络隧道，以在用户空间中运行的程序与内核之间传递网络流量。这对于实现网络隔离、虚拟专用网络、安全隧道等应用场景非常有用。一般来说，使用TUN设备的流程如下： 用户空间程序通过TUN设备发送IP数据包。 内核将接收到的数据包从TUN设备中读取。 用户空间程序可以通过标准的套接字接口监听和处理这些数据包。 tap 设备：TAP设备（Tap虚拟网卡）是一种虚拟网络设备，与TUN设备类似，也用于在用户空间和内核空间之间传递网络数据。TAP代表“网络透明适配器”（Network TAP），与TUN设备不同的是，TAP设备在数据链路层（OSI模型的第二层）工作，而TUN设备在网络层（第三层）工作。主要区别在于： TAP设备：它以太网设备的形式存在，可以处理链路层的数据包。因此，TAP设备可以传输以太网帧，包括处理MAC地址等。TAP设备通常用于需要在二层进行操作的场景，比如虚拟局域网（VLAN）的实现、桥接网络、以太网隧道等。 TUN设备：与TAP不同，TUN设备是在网络层工作的，只能传输IP数据包。TUN设备通常用于实现虚拟私有网络（VPN）等应用，它只关心IP层的数据，而不涉及链路层的细节。 在使用TAP设备时，用户空间程序可以像处理真实的网络接口一样处理TAP设备，包括发送和接收以太网帧。 iptables 简单使用: # 设置从eth0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # 设置从tun0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE # 设置从eth0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 设置从tun0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i tun0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 允许所以数据包转发 iptables -A FORWARD -j ACCEPT iproute2 简单使用 # 设置tun0设备的ip为192.168.1.10/24 ip addr add 192.168.1.10/24 dev tun0 # 添加走到tun0设备的路由 ip route add 192.168 # 为table 100添加一条来自 192.168.1.10的规则 ip rule add from 192.168.1.10 table 100 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:2:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的简单实现","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:3:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"性能 Profiling – 使用 Perf 命令 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:0:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"1. Perf 常用命令 perf top 常用参数 -e：指定性能事件 -a：显示在所有 CPU 上的性能统计信息 -C：显示在指定 CPU 上的性能统计信息 -p：指定进程 PID -t：指定线程 TID -K：隐藏内核统计信息 -U：隐藏用户空间的统计信息 -s：指定待解析的符号信息 ‘‐G’ or‘‐‐call‐graph’ \u003coutput_type,min_percent,call_order\u003e graph: 使用调用树，将每条调用路径进一步折叠。这种显示方式更加直观。 每条调用路径的采样率为绝对值。也就是该条路径占整个采样域的比率。 perf list perf test perf record: 记录一段时间内系统/进程的性能时间 常用参数 -e：选择性能事件 -p：待分析进程的 id -t：待分析线程的 id -a：分析整个系统的性能 -C：只采集指定 CPU 数据 -c：事件的采样周期 -o：指定输出文件，默认为 perf.data -A：以 append 的方式写输出文件 -f：以 OverWrite 的方式写输出文件 -g：记录函数间的调用关系 perf report: 读取 perf record 生成的数据文件，并显示分析数据 常用参数 -i：输入的数据文件 -v：显示每个符号的地址 -d ：只显示指定 dos 的符号 -C：只显示指定 comm 的信息（Comm. 触发事件的进程名） -S：只考虑指定符号 -U：只显示已解析的符号 -g[type,min,order]：显示调用关系，具体等同于 perf top 命令中的-g -c：只显示指定 cpu 采样信息 -M：以指定汇编指令风格显示 –source：以汇编和 source 的形式进行显示 -p：用指定正则表达式过滤调用函数 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:1:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"2. 生成火焰图示例 # 采集数据 perf record -F 99 -p 1234 -g \u003ccommand\u003e -- sleep 30 # 解析数据 perf script -i perf.data \u0026\u003e perf.unfold # 生成火焰图 # 克隆仓库 git clone https://github.com/brendangregg/FlameGraph.git cd FlameGraph # 对perf.unfold文件进行符号折叠 ./stackcollapse-perf.pl perf.unfold \u003e perf.folded # 生成火焰图（svg图） ./flamegraph.pl perf.folded \u003e perf.svg ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:2:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"IP 路由相关命令总结 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:0:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"一，路由策略（使用ip rule命令操作路由策略数据库） 基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。 ip rule命令： Usage: ip rule { add | del } SELECTOR ACTION ip rule { flush | save | restore } ip rule [ list [ SELECTOR ]] SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK[/MASK] ] [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ] [ uidrange NUMBER-NUMBER ] [ ipproto PROTOCOL ] [ sport [ NUMBER | NUMBER-NUMBER ] [ dport [ NUMBER | NUMBER-NUMBER ] ] ACTION := [ table TABLE_ID ] [ protocol PROTO ] [ nat ADDRESS ] [ realms [SRCREALM/]DSTREALM ] [ goto NUMBER ] SUPPRESSOR SUPPRESSOR := [ suppress_prefixlength NUMBER ] [ suppress_ifgroup DEVGROUP ] TABLE_ID := [ local | main | default | NUMBER ] #例子1：通过路由表 table 1 路由来自源地址为192.203.80/24的数据包 ip rule add from 192.203.80/24 table 1 #例子2：把源地址为192.168.1.10的数据报的源地址转换为192.168.2.20，并通过表1进行路由 ip rule add from 193.168.1.10 nat 192.168.2.20 table 1 #实例3：让eht0流量使用table 1 ip rule add dev eth0 table1 在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则： 0：匹配任何条件，查询路由表local(ID 255)，该表local是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0非常特殊，不能被删除或者覆盖。 32766：匹配任何条件，查询路由表main(ID 254)，该表是一个通常的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。 32767：匹配任何条件，查询路由表default(ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。 **注：**不要混淆路由表和策略：规则指向路由表，多个规则可以引用一个路由表，而且某些路由表可以策略指向它。如果系统管理员删除了指向某个路由表的所有规则，这个表没有用了，但是仍然存在，直到里面的所有路由都被删除，它才会消失。 linux 系统中，可以自定义从 1－252个路由表，其中，linux系统维护了4个路由表： 0#表： 系统保留表 253#表： defulte table 没特别指定的默认路由都放在改表 254#表： main table 没指明路由表的所有路由放在该表 255#表： locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改 路由表的查看可有以下二种方法： ip route show table table_number ip route show table table_name 路由表序号和表名的对应关系在 /etc/iproute2/rt_tables文件中，可以手动编辑，路由表添加完毕及时生效，实例如下： #实例1：在一号表中添加默认路由为192.168.1.1 ip route add default via 192.168.1.1 table 1 #实例2：在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2 ip route add 192.168.0.0/24 via 192.168.1.2 table 1 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"二，路由表（使用ip route命令操作静态路由表） 所谓路由表，指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据–路由表，供路由选择时使用，表中包含的信息决定了数据转发的策略。 以一例子来说明：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。 首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关：ip route add default gw 20.0.0.1 之后通过 ip route 添加一个路由表：ip route add table 3 via 10.0.0.1 dev ethX (ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号) 之后添加 ip rule 规则：ip rule add fwmark 3 table 3 （fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表） 之后使用 iptables 给相应的数据打上标记：iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK –set-mark 3 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"Docker 基本命令 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:0:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"1. 使用镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 \u003c域名/IP\u003e[:端口号]。默认地址是 Docker Hub(docker.io)。 仓库名：如之前所说，这里的仓库名是两段式名称，即 \u003c用户名\u003e/\u003c软件名\u003e。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"2. 操作容器 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 -d: 让容器在后台运行 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash, 也可以使用dash或者fish。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"3. 数据管理 创建一个数据卷 docker volume create my-vol 删除数据卷 docker volume rm my-vol 无主的数据卷可能会占据很多空间，要清理请使用以下命令: docker volume prune 查看所有数据卷 docker volume ls 在主机里使用以下命令可以查看指定 数据卷 的信息 docker volume inspect my-vol 查看容器详细信息 docker inspect container_id 挂载主机目录 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\ nginx:alpine 注意: 本地目录的路径必须是绝对路径,使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ nginx:alpine ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["linux","docker"],"content":"Docker 基石-NetworkNamespace ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:0:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"1. veth-pair 是什么 veth-pair 是一对虚拟网卡，通过 veth-pair 可以将两个网络命名空间连接起来，从而实现两个网络命名空间之间的通信。和 tap/tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着 全程只使用 ip 命令进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:1:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2. 使用 veth-pair 和 netns 进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.1 创建两个网络命名空间 ip netns add ns1 ip netns add ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:1","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.2 创建 veth-pair ip link add veth1 type veth peer name veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:2","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.3 将 veth1 移动到 ns1 中 ip link set veth1 netns ns1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:3","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.4 将 veth2 移动到 ns2 中 ip link set veth2 netns ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:4","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.5 启动 veth1 ip netns exec ns1 ip link set dev veth1 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:5","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.6 启动 veth2 ip netns exec ns2 ip link set dev veth2 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:6","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.7 设置 veth1 的 IP 地址 ip netns exec ns1 ip addr add 192.168.1.2/24 dev veth1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:7","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.8 设置 veth2 的 IP 地址 ip netns exec ns2 ip addr add 192.168.1.3/24 dev veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:8","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.9 测试 ip netns exec ns1 ping 192.168.1.3 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:9","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["pytorch"],"content":"torch.fx模块的使用 ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"torch.fx主要有3个组件： 符号追踪器（symbolic tracer) 中间表示（intermediate representation) Python代码生成（Python code generation) import torch # Simple module for demonstration class MyModule(torch.nn.Module): def __init__(self): super().__init__() self.param = torch.nn.Parameter(torch.rand(3, 4)) self.linear = torch.nn.Linear(4, 5) def forward(self, x): return self.linear(x + self.param).clamp(min=0.0, max=1.0) module = MyModule() from torch.fx import symbolic_trace # 符号追踪这个模块 # Symbolic tracing frontend - captures the semantics of the module symbolic_traced : torch.fx.GraphModule = symbolic_trace(module) # 中间表示 # High-level intermediate representation (IR) - Graph representation print(symbolic_traced.graph) \"\"\" graph(): %x : [#users=1] = placeholder[target=x] %param : [#users=1] = get_attr[target=param] %add : [#users=1] = call_function[target=operator.add](args = (%x, %param), kwargs = {}) %linear : [#users=1] = call_module[target=linear](args = (%add,), kwargs = {}) %clamp : [#users=1] = call_method[target=clamp](args = (%linear,), kwargs = {min: 0.0, max: 1.0}) return clamp \"\"\" # 生成代码 # Code generation - valid Python code print(symbolic_traced.code) \"\"\" def forward(self, x): param = self.param add = x + param; x = param = None linear = self.linear(add); add = None clamp = linear.clamp(min = 0.0, max = 1.0); linear = None return clamp \"\"\" ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"使用场景 Replace one op Conv/Batch Norm fusion replace_pattern: Basic usage Quantization Invert Transformation 融合例子: # Works for length 2 patterns with 2 modules def matches_module_pattern(pattern: Iterable[Type], node: fx.Node, modules: Dict[str, Any]): if len(node.args) == 0: return False nodes: Tuple[Any, fx.Node] = (node.args[0], node) for expected_type, current_node in zip(pattern, nodes): if not isinstance(current_node, fx.Node): return False if current_node.op != 'call_module': return False if not isinstance(current_node.target, str): return False if current_node.target not in modules: return False if type(modules[current_node.target]) is not expected_type: return False return True def replace_node_module(node: fx.Node, modules: Dict[str, Any], new_module: torch.nn.Module): assert(isinstance(node.target, str)) parent_name, name = _parent_name(node.target) modules[node.target] = new_module setattr(modules[parent_name], name, new_module) def fuse(model: torch.nn.Module, inplace=False) -\u003e torch.nn.Module: \"\"\" Fuses convolution/BN layers for inference purposes. Will deepcopy your model by default, but can modify the model inplace as well. \"\"\" patterns = [(nn.Conv1d, nn.BatchNorm1d), (nn.Conv2d, nn.BatchNorm2d), (nn.Conv3d, nn.BatchNorm3d)] if not inplace: model = copy.deepcopy(model) fx_model = fx.symbolic_trace(model) modules = dict(fx_model.named_modules()) new_graph = copy.deepcopy(fx_model.graph) for pattern in patterns: for node in new_graph.nodes: # 找到目标Node：args是Conv，target是BN if matches_module_pattern(pattern, node, modules): if len(node.args[0].users) \u003e 1: # Output of conv is used by other nodes continue conv = modules[node.args[0].target] bn = modules[node.target] # 融合BN和Conv fused_conv = fuse_conv_bn_eval(conv, bn) # 替换Node的module，其实就是将融合后的module替换Conv Node的target，背后是模块替换 replace_node_module(node.args[0], modules, fused_conv) # 将所有用到BN Node的替换为Conv Node（已经融合后的Conv） node.replace_all_uses_with(node.args[0]) # 删除BN Node new_graph.erase_node(node) return fx.GraphModule(fx_model, new_graph) from torch.fx.experimental.optimization import fuse from torchvision.models import resnet18 model = resnet18() model.eval() # 必须在eval模型下fuse ''' (layer4): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' fused_model = fuse(model) ''' (layer4): Module( (0): Module( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (downsample): Module( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2)) ) ) (1): Module( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"参考链接: PyTorch新技能解锁：torch.fx - 知乎 (zhihu.com) ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"matplotlib的简单使用 matplotlib结构 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:0:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1. fig,ax,plt 三者的基本概念 fig Figure，就是图的外框，也叫画布，可以包括1-无穷个内框Axes ax Axes，就是图的内框(可以将画布分为多个绘图区域)，里面可以画各种图，最常见的就是二维的统计图或者折线图，也可以画三维图xyz和极坐标图theta-r Axis，就是坐标轴 plt Pyplot为底层面向对象的绘图库提供状态机接口。状态机隐式自动创建图形和轴，以实现所需的绘图。 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:1:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.常用函数说明 matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布 import matplotlib.pyplot as plt plt.plot([1,2,3]) #现在创建一个子图，它表示一个有2行1列的网格的顶部图。 #因为这个子图将与第一个重叠，所以之前创建的图将被删除 plt.subplot(211) plt.plot(range(12)) #创建带有黄色背景的第二个子图 plt.subplot(212, facecolor='y') plt.plot(range(12)) Matplotlib 提供了matplotlib.figure图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。如下所示： from matplotlib import pyplot as plt import numpy as np import math x = np.arange(0, math.pi*2, 0.05) y = np.sin(x) fig = plt.figure() # add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。 ax = fig.add_axes([0,0,1,1]) ax.plot(x,y) ax.set_title(\"sine wave\") ax.set_xlabel('angle') ax.set_ylabel('sine') plt.show() matplotlib.pyplot模块提供了一个 subplots() 函数，它的使用方法和 subplot() 函数类似。其不同之处在于，subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。 import matplotlib.pyplot as plt # 将画布分为2*2的绘图区域 fig,a = plt.subplots(2,2) import numpy as np x = np.arange(1,5) #绘制平方函数 a[0][0].plot(x,x*x) a[0][0].set_title('square') #绘制平方根图像 a[0][1].plot(x,np.sqrt(x)) a[0][1].set_title('square root') #绘制指数函数 a[1][0].plot(x,np.exp(x)) a[1][0].set_title('exp') #绘制对数函数 a[1][1].plot(x,np.log10(x)) a[1][1].set_title('log') plt.show() ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:2:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["c/cpp"],"content":"一、string.h中字符串处理函数 在头文件\u003cstring.h\u003e中定义了两组字符串函数。第一组函数的名字以str开头；第二组函数的名字以mem开头。 只有函数memmove对重叠对象间的拷贝进行了定义，而其他函数都未定义。比较类函数将其变量视为unsigned char类型的数组。 1 strcpy #include \u003cstring.h\u003e char *strcpy(char *str1, const char *str2); 把字符串str2(包括’\\0’)拷贝到字符串str1当中，并返回str1。 2 strncpy #include \u003cstring.h\u003e char *strncpy(char *str1, const char *str2, size_t count); 把字符串str2中最多count个字符拷贝到字符串str1中，并返回str1。如果str2中少于count个字符，那么就用’\\0’来填充，直到满足count个字符为止。 3 strcat #include \u003cstring.h\u003e char *strcat(char *str1, const char *str2); 把str2(包括’\\0’)拷贝到str1的尾部(连接)，并返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 4 strncat #include \u003cstring.h\u003e char *strncat(char *str1, const char *str2, size_t count); 把str2中最多count个字符连接到str1的尾部，并以’\\0’终止str1，返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 注意，最大拷贝字符数是count+1。 5 strcmp #include \u003cstring.h\u003e int strcmp(const char *str1, const char *str2); 按字典顺序比较两个字符串，返回整数值的意义如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 6 strncmp #include \u003cstring.h\u003e int strncmp(const char *str1, const char *str2, size_t count); 同strcmp，除了最多比较count个字符。根据比较结果返回的整数值如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 7 strchr #include \u003cstring.h\u003e char *strchr(const char *str, int ch); 返回指向字符串str中字符ch第一次出现的位置的指针，如果str中不包含ch，则返回NULL。 8 strrchr #include \u003cstring.h\u003e char *strrchr(const char *str, int ch); 返回指向字符串str中字符ch最后一次出现的位置的指针，如果str中不包含ch，则返回NULL。 9 strspn #include \u003cstring.h\u003e size_t strspn(const char *str1, const char *str2); 返回字符串str1中由字符串str2中字符构成的第一个子串的长度。 10 strcspn #include \u003cstring.h\u003e size_t strcspn(const char *str1, const char *str2); 返回字符串str1中由不在字符串str2中字符构成的第一个子串的长度。 11 strpbrk #include \u003cstring.h\u003e char *strpbrk(const char *str1, const char *str2); 返回指向字符串str2中的任意字符第一次出现在字符串str1中的位置的指针；如果str1中没有与str2相同的字符，那么返回NULL。 12 strstr #include \u003cstring.h\u003e char *strstr(const char *str1, const char *str2); 返回指向字符串str2第一次出现在字符串str1中的位置的指针；如果str1中不包含str2，则返回NULL。 13 strlen #include \u003cstring.h\u003e size_t strlen(const char *str); 返回字符串str的长度，’\\0’不算在内。 14 strerror #include \u003cstring.h\u003e char *strerror(int errnum); 返回指向与错误序号errnum对应的错误信息字符串的指针(错误信息的具体内容依赖于实现)。 15 strtok #include \u003cstring.h\u003e char *strtok(char *str1, const char *str2); 在str1中搜索由str2中的分界符界定的单词。 对strtok()的一系列调用将把字符串str1分成许多单词，这些单词以str2中的字符为分界符。第一次调用时str1非空，它搜索str1，找出由非str2中的字符组成的第一个单词，将str1中的下一个字符替换为’\\0’，并返回指向单词的指针。随后的每次strtok()调用(参数str1用NULL代替)，均从前一次结束的位置之后开始，返回下一个由非str2中的字符组成的单词。当str1中没有这样的单词时返回NULL。每次调用时字符串str2可以不同。 如： char *p; p = strtok(\"The summer soldier,the sunshine patriot\", \" \"); printf(\"%s\", p); do { p = strtok(\"\\0\", \", \"); /* 此处str2是逗号和空格 */ if (p) printf(\"|%s\", p); } while (p); 显示结果是：The | summer | soldier | the | sunshine | patriot 16 memcpy #include \u003cstring.h\u003e void *memcpy(void *to, const void *from, size_t count); 把from中的count个字符拷贝到to中。并返回to。 17 memmove #include \u003cstring.h\u003e void *memmove(void *to, const void *from, size_t count); 功能与memcpy类似，不同之处在于，当发生对象重叠时，函数仍能正确执行。 18 memcmp #include \u003cstring.h\u003e int memcmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2的前count个字符，返回值与strcmp的返回值相同。 19 memchr #include \u003cstring.h\u003e void *memchr(const void *buffer, int ch, size_t count); 返回指向ch在buffer中第一次出现的位置指针，如果在buffer的前count个字符当中找不到匹配，则返回NULL。 20 memset #include \u003cstring.h\u003e void *memset(void *buf, int ch, size_t count); 把buf中的前count个字符替换为ch，并返回buf ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"example #include \"malloc.h\" #include \"stdint.h\" #include \"stdio.h\" #include \"stdlib.h\" #include \"string.h\" #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { // malloc and memset and strlen usage char *s = (char *)malloc(sizeof(char) * 10); printf(\"origin strlen(s): %llu\\n\", strlen(s)); memset(s, 'i', 12); printf(\"after memset, strlen(s): %llu\\n\", strlen(s)); int *i = (int *)malloc(sizeof(int) * 10); printf(\"sizeof(i): %llu\\n\", sizeof(i)); // strcpy usage char *s1 = (char *)malloc(sizeof(char) * 10); char s2[] = {\"hello\"}; printf(\"strlen(s1): %llu\\n\", strlen(s1)); printf(\"sizeof(s1): %llu\\n\", sizeof(s1)); printf(\"strlen(s2): %llu\\n\", strlen(s2)); printf(\"sizeof(s2): %llu\\n\", sizeof(s2)); strcpy_s(s1, strlen(s2) + 1, s2); // strncpy_s(s1, strlen(s2)+1, s2, 3); printf(\"s1=%s\\n\", s1); printf(\"*****************************\\n\"); char s3[] = {\"world\"}; // strstr return pointer char *p = strstr(s3, \"ld\"); printf(\"p=%s\\n\", p); // calculate the offset printf(\"%lld\\n\", p-s3); p = strchr(s3, 'o'); printf(\"strchr p=%s\\n\", p); printf(\"strchr offset:%lld\\n\", p-s3); p = strrchr(s3, 'l'); printf(\"strrchr p=%s\\n\", p); printf(\"strrchr offset:%lld\\n\", p-s3); p = strtok(s3, \"or\"); while (p) { printf(\"strtok p=%s\\n\", p); p = strtok(NULL, \"or\"); } printf(\"after strtok, s3=%s\\n\", s3); int a = strcmp(s3, \"world\"); printf(\"strcmp a=%d\\n\", a); a = strncmp(s3, \"world\", 1); printf(\"strncmp a=%d\\n\", a); char s4[] = {\"hello\"}; memmove(s4+1, s4, 1); printf(\"memmove s4=%s\\n\", s4); memcpy(s4, \"hello\", 5); printf(\"memccpy s4=%s\\n\", s4); return 0; } // output: // origin strlen(s): 6 // after memset, strlen(s): 14 // sizeof(i): 8 // strlen(s1): 6 // sizeof(s1): 8 // strlen(s2): 5 // sizeof(s2): 6 // s1=hello // ***************************** // p=ld // 3 // strchr p=orld // strchr offset:1 // strrchr p=ld // strrchr offset:3 // strtok p=w // strtok p=ld // after strtok, s3=w // strcmp a=-1 // strncmp a=0 // memmove s4=hhllo // memccpy s4=hello 二、stdlib.h中字符串与数字相互转换处理函数 1. 数字转化为字符串: ● itoa()：将整型值转换为字符串。 ● ltoa()：将长整型值转换为字符串。 ● ultoa()：将无符号长整型值转换为字符串。 ● gcvt()：将浮点型数转换为字符串，取四舍五入。 ● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。 ● fcvt()：指定位数为转换精度，其余同ecvt()。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int = 435; double num_double = 435.10f; char str_int[30]; char str_double[30]; itoa(num_int, str_int, 10); //把整数num_int转成字符串str_int gcvt(num_double, 8, str_double); //把浮点数num_double转成字符串str_double printf(\"str_int: %s\\n\", str_int); printf(\"str_double: %s\\n\", str_double); return 0; } 程序输出结果： str_int: 435 str_double: 435.10001 代码第11行中的参数10表示按十进制类型进行转换，转换后的结果是“435”，如果按二进制类型进行转换，则结果为“1101110011”。 代码第12行中的参数8表示精确位数，这里得到的结果是“435.10001”。 2. 字符串转化为数字 atof()：将字符串转换为双精度浮点型值。 atoi()：将字符串转换为整型值。 atol()：将字符串转换为长整型值。 strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。 strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。 strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int; double num_double; char str_int[30] = \"435\"; //将要被转换为整型的字符串 char str_double[30] = \"436.55\"; //将要被转换为浮点型的字符串 num_int = atoi(str_int); //转换为整型值 num_double = atof(str_double); //转换为浮点型值 printf(\"num_int: %d\\n\", num_int); printf(\"num_double: %lf\\n\", num_double); return 0; } // 输出结果： // num_int: 435 // num_double: 436.550000 ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"进制互转 // int to binary char tmp[10] = {}; char *conv = itoa(5, tmp, 2); printf(\"itoa to 2: conv=%s\\n\", conv); // int to hex conv = itoa(17, tmp, 16); printf(\"itoa to 16: conv=0x%s\\n\", conv); // hex to 10 int hex = strtol(\"0x11\", NULL, 16); printf(\"strtol: hex=%d\\n\", hex); // binary to 10 int bin = strtol(\"101\", NULL, 2); printf(\"strtol: bin=%d\\n\", bin); // output // itoa to 2: conv=101 // itoa to 16: conv=0x11 // strtol: hex=17 // strtol: bin=5? ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["python"],"content":"介绍 异步IO：就是发起一个IO操作（如：网络请求，文件读写等），这些操作一般是比较耗时的，不用等待它结束，可以继续做其他事情，结束时会发来通知。 协程：又称为微线程，在一个线程中执行，执行函数时可以随时中断，由程序（用户）自身控制，执行效率极高，与多线程比较，没有切换线程的开销和多线程锁机制。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:0:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio中几个重要概念 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1.事件循环 事件循环是每个 asyncio 应用的核心，管理所有的事件，在整个程序运行过程中不断循环执行并追踪事件发生的顺序将它们放在队列中，空闲时调用相应的事件处理者来处理这些事件。 创建事件循环 loop = asyncio.get_event_loop() 获取当前事件循环。 如果当前 OS 线程没有设置当前事件循环并且 set_event_loop() 还没有被调用，asyncio 将创建一个新的事件循环并将其设置为当前循环。 另起一个线程创建事件循环 from threading import Thread import asyncio def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() new_loop = asyncio.new_event_loop() loop_thread = Thread(target=start_thread_loop, args=(new_loop,)) loop_thread.setDaemon(True) # 守护线程 loop_thread.start() ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.Future Future对象表示尚未完成的计算，还未完成的结果，它和task上没有本质上的区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"3.Task 是Future的子类，作用是在运行某个任务的同时可以并发的运行多个任务。 asyncio.Task用于实现协作式多任务的库，且Task对象不能用户手动实例化，通过下面2个函数创建： loop.create_task() 或 asyncio.ensure_future() loop.create_task() ,要在定义loop对象之后，调用将方法对象转化成了task的对象 asyncio.ensure_future() 直接调用asyncio 的ensure_future() 方法，返回的也是task 对象（我们还没有声明 loop 也可以提前定义好 task 对象） ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"4.async/await 关键字 asyncio实现了TCP、UDP、SSL等协议，async定义一个协程，await用于挂起阻塞的异步调用接口。 对于异步io你需要知道的重点，要注意的是，await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。而且await后面的对象需要是一个Awaitable，或者实现了相关的协议。 注意 1. 所有需要异步执行的函数，都需要asyncio中的轮询器去轮询执行，如果函数阻塞，轮询器就会去执行下一个函数。所以所有需要异步执行的函数都需要加入到这个轮询器中。若在协程中需要有延时操作，应该使用 await asyncio.sleep()，而不是使用time.sleep()，因为使用time.sleep()后会释放GIL，阻塞整个主线程，从而阻塞整个事件循环。 创建一个协程 使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行 耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:4","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"简单例子 import asyncio from asyncio import tasks from asyncore import loop async def main(): await asyncio.sleep(2) print('this is main running') async def add_log(): await asyncio.sleep(1) print('add log before running') async def run_background(): await asyncio.sleep(3) print('running task in background') async def parameter_verification(): await asyncio.sleep(1) print('parameter verification before running') if __name__ == '__main__': # running async function method: # first method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) # the sequence of the tasks is not the same as the sequence of the function calling, and the same as define sequence result = asyncio.run(tasks) print(result) print(f'{\"*\" * 20}{\"another method\"}{\"*\" * 20}') # second method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) loop = asyncio.get_event_loop() result = loop.run_until_complete(tasks) print(result) 首先我们引入了 asyncio 这个包，这样我们才可以使用 async 和 await，然后我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。 随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。 可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:2:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"进阶例子 多个任务，定义一个task列表，使用asyncio.gather(*tasks) 或 asyncio.wait(tasks) 接收 import asyncio import time now = lambda: time.time() \"\"\" asyncio.gather主要集中在收集结果上。它等待一堆task并按给定的顺序返回结果。 asyncio.wait等待task。而不是直接给你结果，它提供完成和待处理的任务。你必须手工收集结果。 asyncio.wait(tasks) ps:asyncio.wait([1,2,3]) 也可以使用 asyncio.gather(*tasks) ps: asyncio.gather(1,2,3),前者接受一个task列表，后者接收一堆task。 \"\"\" # 定义一个异步任务 async def do_some_work(x): print(\"waiting:\", x) # 模拟io阻塞 await asyncio.sleep(x) return \"Done after {}s\".format(x) async def main(loop): \"\"\" :param loop: loop.create_task（需要传进loop参数） :return: None \"\"\" coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(4) # asyncio.ensure_future tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] # loop.create_task（需要传进loop参数） # tasks = [ # loop.create_task(coroutine1), # loop.create_task(coroutine2), # loop.create_task(coroutine3) # ] # 返回 完成的 task object dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) # 返回 task 方法的 返回值 # results = await asyncio.gather(*tasks) # for result in results: # print(\"Task ret:\",result) start = now() loop = asyncio.get_event_loop() loop.run_until_complete(main(loop)) print(\"Time:\", now() - start) gather和wait 的区别 把多个协程注册进一个事件循环中的两种方法 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:3:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"使用方式区别 使用asyncio.wait() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 使用asyncio.gather() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) # *接收args参数 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:4:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"接收参数区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.wait 参数必须是list对象 ，list 对象存放多个 task object 用asyncio.ensure_future转为task对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 不转为task对象 loop = asyncio.get_event_loop() tasks=[ coroutine1, coroutine2, coroutine3 ] loop.run_until_complete(asyncio.wait(tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.gather 必须用 * 来接收 list 对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"返回结果区别 asyncio.wait asyncio.wait返回dones和pendings dones：表示已经完成的任务 pendings：表示未完成的任务 我们需要手动去获取结果 dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) asyncio.gather 它的返回值就是 return的结果 ，不用再task.result() 来获取 # 返回 task 方法的 返回值 results = await asyncio.gather(*tasks) for result in results: print(\"Task ret:\",result) 另 asyncio.wait 带有控制功能 【控制运行任务数】：运行第一个任务就返回 FIRST_COMPLETED ：第一个任务完全返回 FIRST_EXCEPTION：产生第一个异常返回 ALL_COMPLETED：所有任务完成返回 （默认选项） import asyncio import random async def coro(tag): print(\"\u003e\", tag) await asyncio.sleep(random.uniform(0.5, 5)) print(\"\u003c\", tag) return tag loop = asyncio.get_event_loop() tasks = [coro(i) for i in range(1, 11)] # 第一次wait 完成情况 print(\"Get first result:\") finished, unfinished = loop.run_until_complete( asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)) # 第一个任务完全返回 for task in finished: print(task.result()) print(\"unfinished:\", len(unfinished)) # 继续第一次未完成任务 print(\"Get more results in 2 seconds:\") finished2, unfinished2 = loop.run_until_complete( asyncio.wait(unfinished, timeout=2)) # 超时2s 返回 for task in finished2: print(task.result()) print(\"unfinished2:\", len(unfinished2)) # 继续第2次未完成任务 print(\"Get all other results:\") finished3, unfinished3 = loop.run_until_complete(asyncio.wait(unfinished2)) # ALL_COMPLETED：所有任务完成返回 （默认项） for task in finished3: print(task.result()) loop.close() 动态添加协程 很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block 相关函数介绍： loop.call_soon_threadsafe() ：与 call_soon()类似，等待此函数返回后马上调用回调函数，返回值是一个 asyncio.Handle 对象，此对象内只有一个方法为 cancel()方法，用来取消回调函数。 loop.call_soon() ： 与call_soon_threadsafe()类似，call_soon_threadsafe() 是线程安全的 loop.call_later()：延迟多少秒后执行回调函数 loop.call_at()：在指定时间执行回调函数，这里的时间统一使用 loop.time() 来替代 time.sleep() asyncio.run_coroutine_threadsafe()： 动态的加入协程，参数为一个回调函数和一个loop对象，返回值为future对象，通过future.result()获取回调函数返回值 动态添加协程同步方式 通过调用 call_soon_threadsafe()函数，传入一个回调函数callback和一个位置参数 注意：同步方式，回调函数 more_work()为普通函数 import asyncio from threading import Thread import time now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() def more_work(x): print('More work {}'.format(x)) time.sleep(x) print('Finished more work {}'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) new_loop.call_soon_threadsafe(more_work, 6) new_loop.call_soon_threadsafe(more_work, 3) print('here') 启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3 异步方式 import asyncio import time from threading import Thread now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() async def do_some_work(x): print('Waiting {}'.format(x)) await asyncio.sleep(x) print('Done after {}s'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop) asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop) 上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。 协程的停止 future对象有几个状态： Pending Running Done Cacelled 创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task import asyncio import time now = lambda: time.time() async def do_some_work(x): print(\"Waiting:\", x) await asyncio.sleep(x) return \"Done after {}s\".format(x) coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(2) tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3), ] start = now() loop = asyncio.get_event_loop() try: loop.run_until_complete(asyncio.wait(tasks)) except KeyboardInterrupt as e: print(asyncio.Task.all_tasks()) for ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["draft"],"content":"SelfAttention和MultiHeadAttention流程简述 ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:0:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["draft"],"content":"1. SelfAttention 1.1 对于每一个输入$I$,初始化3个权重矩阵$W_q,W_k,W_v$. 1.2 输入$I$分别与3个权重矩阵相乘得到$Q,K,V$ 1.3 将$Q$与$K$相乘(矩阵乘法)得到$A$(attention score) 1.4 $A$经过softmax激活得到$A'$ 1.5 将$A’$与$V$相乘得到B 代码示例: In [16]: i = torch.randn(3,4) In [17]: w_query = torch.randn(4, 2) In [18]: w_key = torch.randn(4, 2) In [19]: w_value = torch.randn(4, 2) In [20]: i Out[20]: tensor([[ 0.4313, 1.3749, -0.2489, 1.3275], [-0.6467, 1.6335, 2.8923, 0.9124], [ 0.2326, -0.2314, 0.3554, 0.0892]]) In [21]: w_query Out[21]: tensor([[ 0.3673, -0.8505], [-0.3559, -0.3708], [-1.2093, 0.6634], [ 0.4042, 0.8015]]) In [22]: w_key Out[22]: tensor([[-1.1617, 0.4023], [-0.1249, -0.1605], [-0.8427, 1.1002], [-1.1320, 0.4611]]) In [23]: w_value Out[23]: tensor([[-0.7675, -0.3179], [-1.1910, -0.6937], [-1.4809, -1.5502], [-0.7373, 1.0511]]) In [24]: querys = i @ w_query In [25]: keys = i @ w_key In [26]: values = i @ w_value In [27]: querys Out[27]: tensor([[ 0.5066, 0.0223], [-3.9478, 2.5946], [-0.2259, 0.1952]]) In [28]: keys Out[28]: tensor([[-1.9656, 0.2911], [-2.9229, 3.0806], [-0.6418, 0.5629]]) In [29]: values Out[29]: tensor([[-2.5787, 0.6903], [-6.4049, -4.4522], [-0.4950, -0.3706]]) In [30]: att_scores = querys @ keys.T In [31]: att_scores Out[31]: tensor([[-0.9893, -1.4121, -0.3126], [ 8.5152, 19.5319, 3.9940], [ 0.5009, 1.2617, 0.2549]]) In [32]: att_scores_softmax = torch.nn.functional.softmax(att_scores, dim=-1) In [33]: att_scores_softmax Out[33]: tensor([[2.7604e-01, 1.8087e-01, 5.4310e-01], [1.6426e-05, 9.9998e-01, 1.7865e-07], [2.5498e-01, 5.4565e-01, 1.9937e-01]]) In [34]: outputs = att_scores_softmax @ values In [35]: outputs Out[35]: tensor([[-2.1390, -0.8160], [-6.4048, -4.4521], [-4.2510, -2.3272]]) In [36]: outputs.shape Out[36]: torch.Size([3, 2]) ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:1:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["DeepLearning"],"content":"什么是交叉熵 交叉熵是一个在ML领域经常会被提到的名词。在这篇文章里将对这个概念进行详细的分析。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:0:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"1.什么是信息量？ 假设$x$是一个离散型随机变量，其取值集合为$X$，概率分布函数为$p(x)=Pr(X=x), x \\in X $，我们定义事件的信息量为：$X=x_0$，可以理解为，一个事件发生的概率越大，则它所携带的信息量就越小，而当$p(x_0)=1$时，熵将等于0，也就是说该事件的发生不会导致任何信息量的增加。举个例子，小明平时不爱学习，考试经常不及格，而小王是个勤奋学习的好学生，经常得满分，所以我们可以做如下假设： 事件A：小明考试及格，对应的概率$P(x_A)=0.1$，信息量为$I(x_A)=−log(0.1)=3.3219$ 事件B：小王考试及格，对应的概率$P(x_B)=0.999$，信息量为$I(x_B)=−log(0.999)=0.0014$ 可以看出，结果非常符合直观：小明及格的可能性很低(十次考试只有一次及格)，因此如果某次考试及格了（大家都会说：XXX竟然及格了！），必然会引入较大的信息量，对应的$I$值也较高。而对于小王而言，考试及格是大概率事件，在事件B发生前，大家普遍认为事件B的发生几乎是确定的，因此当某次考试小王及格这个事件发生时并不会引入太多的信息量，相应的$I$值也非常的低。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:1:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"2.什么是熵？ 那么什么又是熵呢？还是通过上边的例子来说明，假设小明的考试结果是一个0-1分布$X_A$只有两个取值{0：不及格，1：及格}，在某次考试结果公布前，小明的考试结果有多大的不确定度呢？你肯定会说：十有八九不及格！因为根据先验知识，小明及格的概率仅有0.1,90%的可能都是不及格的。怎么来度量这个不确定度？求期望！不错，我们对所有可能结果带来的额外信息量求取均值（期望），其结果不就能够衡量出小明考试成绩的不确定度了吗。 即： $H_A(x) = -[p(x_A)log(p(X_A))] + (1-p(x_A))log(1-p(x_A))]=0.4690$ 对应小王的熵： $H_B(x)=−[p(x_B)log(p(x_B))+(1−p(x_B))log(1−p(x_B))]=0.0114$ 虽然小明考试结果的不确定性较低，毕竟十次有9次都不及格，但是也比不上小王（1000次考试只有一次才可能不及格，结果相当的确定） 我们再假设一个成绩相对普通的学生小东，他及格的概率是$P(x_C)=0.5$,即及格与否的概率是一样的，对应的熵： $H_C(x)=−[p(x_C)log(p(x_C))+(1−p(x_C))log(1−p(x_C))]=1$ 其熵为1，他的不确定性比前边两位同学要高很多，在成绩公布之前，很难准确猜测出他的考试结果。 可以看出，熵其实是信息量的期望值，它是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。 对于一个随机变量X而言，它的所有可能取值的信息量的期望$（E[I(x)]$就称为熵。 $X$的熵定义为： $H(X)=Ep \\space log \\frac 1 {p(x)}=−\\sum \\limits_{x \\in X}p(x)logp(x)$ 如果$p(x)$是连续型随机变量的pdf，则熵定义为： $H(X)=−∫_{x∈X}p(x)logp(x)dx$ 为了保证有效性，这里约定当$p(x)→0$时,有$p(x)logp(x)→0$ 当X为0-1分布时，熵与概率p的关系如下图： 可以看出，当两种取值的可能性相等时，不确定度最大（此时没有任何先验知识），这个结论可以推广到多种取值的情况。在图中也可以看出，当p=0或1时，熵为0，即此时X完全确定。 熵的单位随着公式中$log$运算的底数而变化，当底数为2时，单位为“比特”(bit)，底数为e时，单位为“奈特”。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:2:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"3.什么是相对熵？ 相对熵(relative entropy)又称为KL散度（Kullback-Leibler divergence），KL距离，是两个随机分布间距离的度量。记为$D_{KL}(p||q)$。它度量当真实分布为p时，假设分布$q$的无效性。 $$\\begin{split} \\ D_{KL}(p||q) \u0026= Ep[log \\frac {p(x)} {q(x)}] \\ \u0026=\\sum _{x∈X} p(x) log \\frac {p(x)} {q(x)} \\ \u0026=\\sum {x∈X}[p(x)logp(x)−p(x)logq(x)] \\ \u0026=\\sum{x∈X}p(x)logp(x)−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−H(p)−\\sum _{x∈X} p(x)logq(x) \\ \u0026=−H(p)+Ep[−logq(x)] \\ \u0026=Hp(q)−H(p)\\end{split}$$ 并且为了保证连续性，做如下约定： $$0log \\frac 0 0=0，0log \\frac 0 q=0，plog \\frac p 0=∞$$ 显然，当$p=q$时,两者之间的相对熵$D_{KL}(p||q)=0$ 上式最后的$H_p(q)$)表示在p分布下，使用q进行编码需要的bit数，而$H(p)$表示对真实分布p所需要的最小编码bit数。基于此，相对熵的意义就很明确了：$D_{KL}(p||q)$)表示在实分布为$p$的前提下，使用q分布进行编码相对于使用真实分布p进行编码（即最优编码）所多出来的bit数。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:3:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"4. 什么是交叉熵？ 交叉熵容易跟相对熵搞混，二者联系紧密，但又有所区别。假设有两个分布$p，q$则它们在给定样本集上的交叉熵定义如下： $$ CEH(p,q)=Ep[−logq]=−∑\\limits_{x∈X}p(x)logq(x)=H(p)+D_{KL}(p||q) $$ 可以看出，交叉熵与上一节定义的相对熵仅相差了$H(p)$,当$p$已知时，可以把$H(p)$看做一个常数，此时交叉熵与KL距离在行为上是等价的，都反映了分布$p，q$的相似程度。最小化交叉熵等于最小化KL距离。它们都将在$p=q$时取得最小值$H(p)$（p=q时KL距离为0），因此有的工程文献中将最小化KL距离的方法称为Principle of Minimum Cross-Entropy (MCE)或Minxent方法。 特别的，在logistic regression中， p:真实样本分布，服从参数为p的0-1分布，即$X∼B(1,p)$ q:待估计的模型，服从参数为q的0-1分布，即$X∼B(1,q)$ 两者的交叉熵为： $$\\begin{split} CEH(p,q) \u0026=−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−[P_p(x=1)logP_q(x=1)+P_p(x=0)logP_q(x=0)] \\ \u0026=−[plogq+(1−p)log(1−q)] \\ \u0026=−[ylogh_θ(x)+(1−y)log(1−h_θ(x))] \\ \\end{split}$$ 对所有训练样本取均值得： $$−\\frac 1 m \\sum \\limits^{m} \\limits _{i=1m} [y(i)logh_θ(x^{(i)})+(1−y^{(i)})log(1−h_θ(x^{(i)}))]$$ 这个结果与通过最大似然估计方法求出来的结果一致。 转载出处: 交叉熵（Cross-Entropy）_rtygbwwwerr的博客-CSDN博客 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:4:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["Python"],"content":"强大的GAN网络 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:0:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"1. 概要 ​ GAN网络全称generative adversarial network,翻译为生成式对抗网络,是一种非监督式学习机器学习方法。由Ian J,Goodfello 等人于2014年在Generative Adversarial Nets 论文中提出。其中在GAN网络中,有两个模型——生成模型(generative model G),判别模型(discriminative model D). ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:1:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"2. 原理 ​ GAN网络主要运用了博弈论的思想,模型中的2为博弈方分别由生成模型和判别模型担当.生成模型用随机取样作为输入,它的输出结果要尽可能和训练样本尽可能相似,最好的情况就是分辨不出是真实样本还是生成出来的样本.而判别模型就是尽可能判别生成模型生成的结果和真实样本.这样2个网络相互对抗,不断调整参数,最终达到纳什均衡. 这个过程可以表示为: $$ min_G max_DV(D,G) = \\Epsilon_{x\\sim P_{data}(x)}[logD(x)] + \\Epsilon_{z\\sim p_{z}(z)}[log(1-D(G(z)))] $$ 公式解释: 1. 当训练D时,希望这个式子的值越大越好.真实数据希望被D分成1,生成数据希望被分成0\r2. 当训练G时,希望这个式子的值越小越好.希望D分不开真实数据还是生成数据\r零和博弈（zero-sum game），又称零和游戏，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。指参与博弈的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”，双方不存在合作的可能。就像下棋的游戏一样，你走的每一步和对方走的每一步都是向着对自己有利的方向走，然后你和对手轮流走步 每一步都向着自己最大可能能赢的地方走。这就是零和博弈。 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:2:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3. 简单代码实现 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.1 导包 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:1","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.2 加载数据集 # 初始化tensorboard数据保存路径 writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:2","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.3 定义生成模型 class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:3","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.4 定义判别模型 class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:4","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.5 构造模型,定义损失和优化器 z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:5","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.6 训练判别器和生成器 def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:6","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.7 训练网络 epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_step=step) writer.close() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:7","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.8 保存模型 torch.save(D, './model/discriminator.pt') torch.save(G, './model/generator.pt') ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:8","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.9 汇总代码 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torchinfo import summary from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) # 设置drop_last丢弃最后不满一个batch_size的数据 train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) # 添加网络图到tensorboard writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:9","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"参考资料: GAN入门理解及公式推导 - 知乎 (zhihu.com) lyeoni/pytorch-mnist-GAN (github.com) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:10","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Markdown"],"content":"Markdown使用mermaid ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:0:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"0. 符号表示 类元素的可见范围 可见范围 表示方法 private - public + protected # package ~ 类的修饰 符号 类型 \u003c\u003cInterface\u003e\u003e 接口 \u003c\u003cabstract\u003e\u003e 抽象类 \u003c\u003cService\u003e\u003e service类 \u003c\u003cenumeration\u003e\u003e 枚举 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:1:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"1. 泛化 定义: 表示继承关系(子类和父类). 表示:三角实线,指向父类. classDiagram class Animal{ -age: int +sleep(): void } class Dog Animal \u003c|-- Dog ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:2:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"2. 实现 定义: 表示类和接口之间的关系. 表示: 三角虚线,指向接口. classDiagram class Person { + say(): void } class Man Person \u003c|.. Man ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:3:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"3. 组合 定义: 整体与局部的关系,部分不能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 实心菱形实线,实心菱形指向整体. 代码体现: 成员变量 classDiagram class Person{ -brain } class Brain { - weight } Person *-- Brain ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:4:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"4. 聚合 定义: 整体与局部的关系,部分能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 空心菱形实线,空心菱形指向整体. 代码体现: 成员变量 classDiagram class Computer { -keyboard } class Keyboard { -type } Computer o-- Keyboard ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:5:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"5. 关联 定义: 一种拥有的关系, 使一个类知道另一个类的属性和方法,关联可以是单向的,也可以是双向的.双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头. 表示: 普通箭头的实心线,指向被拥有者. 代码体现: 成员变量 classDiagram class Teacher { -students: List\u003cStudent\u003e +teach(): void } class Student { -teacher: List\u003cTeacher\u003e +learn(): void } Teacher \u003c--\u003e Student ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:6:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"6. 依赖 定义: 一种使用关系. 表示: 普通箭头的虚线,箭头指向被使用者 代码体现: 局部变量, 方法的形参, 方法返回值静态方法的调用 classDiagram class Person { +draw(tool: DrawTool): void } class DrawTool { -color } Person \u003c.. DrawTool ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:7:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"7. 各种关系强弱顺序 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:8:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Git","Windows"],"content":"Git for Windows 安装 Pacman ","date":"2022-12-24","objectID":"/git_for_windows/:0:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"1. 下载必要压缩包 curl -o pacman-6.0.1-9-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-6.0.1-9-x86_64.pkg.tar.zst curl -o pacman-mirrors-20221016-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-mirrors-20221016-1-any.pkg.tar.zst curl -o msys2-keyring-1~20221024-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/msys2-keyring-1~20221024-1-any.pkg.tar.zst # 正常来说只需要上面三个包但是由于缺少 zstd 解压工具还需要 zstd 包 curl -o zstd-1.5.2-2-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/zstd-1.5.2-2-x86_64.pkg.tar.zst # 但是又因为 zstd 包也是 zstd 打包又需要另一个不是 zstd 打包的解压工具来解压 curl -o zstd-v1.5.2-win64.zip -L https://github.com/facebook/zstd/releases/download/v1.5.2/zstd-v1.5.2-win64.zip ","date":"2022-12-24","objectID":"/git_for_windows/:1:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"2 .解压并安装: unzip zstd-v1.5.2-win64.zip \"zstd-v1.5.2-win64/zstd.exe\" -d . ./zstd-v1.5.2-win64/zstd.exe -d -o zstd-1.5.2-2-x86_64.pkg.tar zstd-1.5.2-2-x86_64.pkg.tar.zst tar -xvf zstd-1.5.2-2-x86_64.pkg.tar -C / tar -xvf msys2-keyring-1~20221024-1-any.pkg.tar.zst -C / tar -xvf pacman-mirrors-20221016-1-any.pkg.tar.zst -C / tar -xvf pacman-6.0.1-9-x86_64.pkg.tar.zst -C / ","date":"2022-12-24","objectID":"/git_for_windows/:2:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"3. 添加密钥并更新数据库: pacman-key --init \u0026\u0026 pacman-key --populate msys2 pacman-db-upgrade -r /../ pacman -Sy ","date":"2022-12-24","objectID":"/git_for_windows/:3:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"4. 更新元数据: # pacman -S pacman-mirrors-20221016-1 msys2-keyring-1~20221024-1 zstd-1.5.2-2 # pacman -S $(cut -d ' ' -f 1 /etc/package-versions.txt) URL=https://github.com/git-for-windows/git-sdk-64/raw/main cat /etc/package-versions.txt | while read p v; do d=/var/lib/pacman/local/$p-$v mkdir -p $d for f in desc files install mtree; do echo \"$URL$d/$f\" ..... $d/$f curl -sSL \"$URL$d/$f\" -o $d/$f done done curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/desc -o /var/lib/pacman/local/pacman-6.0.1-9/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/files -o /var/lib/pacman/local/pacman-6.0.1-9/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/install -o /var/lib/pacman/local/pacman-6.0.1-9/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/mtree -o /var/lib/pacman/local/pacman-6.0.1-9/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/desc -o /var/lib/pacman/local/pacman-mirrors-20221016-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/files -o /var/lib/pacman/local/pacman-mirrors-20221016-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/install -o /var/lib/pacman/local/pacman-mirrors-20221016-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/mtree -o /var/lib/pacman/local/pacman-mirrors-20221016-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/desc -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/files -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/install -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/mtree -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/desc -o /var/lib/pacman/local/zstd-1.5.2-2/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/files -o /var/lib/pacman/local/zstd-1.5.2-2/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/install -o /var/lib/pacman/local/zstd-1.5.2-2/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/mtree -o /var/lib/pacman/local/zstd-1.5.2-2/mtree ","date":"2022-12-24","objectID":"/git_for_windows/:4:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 安装Fish Shell ","date":"2022-12-24","objectID":"/git_for_windows/:5:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.1 安装必要依赖 pacman -S gcc-libs ","date":"2022-12-24","objectID":"/git_for_windows/:5:1","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.2 安装Fish Shell并启动 pacman -S fish ","date":"2022-12-24","objectID":"/git_for_windows/:5:2","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.3 启动Fish Shell # 在~/.bashrc文件中添加以下内容，设置默认shell为fish if [ -t 1 ]; then exec fish fi ","date":"2022-12-24","objectID":"/git_for_windows/:5:3","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.4 更换Fish Shell 主题 fish_config ","date":"2022-12-24","objectID":"/git_for_windows/:5:4","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 5 Fish Shell 常用命令和基本设置 # 关闭问候语 set -g -x fish_greeting '' set -U fish_greeting # 设置环境变量 #在最后一行加入(注意目录间用空格隔开) set -x PATH /opt/demo/bin /home/guest/bin $PATH # 删除变量 set -e Foo # 配置别名 # Define alias in config file alias rmi=\"rm -i\" # 切换默认shell，git for windows下不可用 echo $SHELL cat /etc/shells chsh -s /usr/bin/fish # 命令替换 echo (date) # 在bash下面 # echo `date` 参考资料: pacman常用命令-昨夜星辰 (hustlei.github.io) Install inside MSYS2 proper · git-for-windows/git Wiki (github.com) Git:給 git for windows 裝個翅膀 (安裝 pacman 及其他工具) @ 傑克! 真是太神奇了! :: 痞客邦 :: (pixnet.net) 在 Windows 的 Git Bash 中使用包管理器 - iris (ginshio.org) Index of /msys/x86_64/ (msys2.org) Releases · facebook/zstd (github.com) Windows 的终端配置(给 git-windows 添加 msys2 包管理器) - zeromake 的个人博客 MSYS2 和 mintty 打造 Windows 下 Linux 工具体验 - Creaink - Build something for life Using fish shell with git bash on windows (github.com) Package management in Git for Windows (Git Bash)? - Stack Overflow Fish Shell | 安装配置指南 - URmyLucky - 博客园 (cnblogs.com) ","date":"2022-12-24","objectID":"/git_for_windows/:5:5","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Rust"],"content":"Rust偏僻知识点 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Cow(Clone on Write) 两个可选值： Borrowed，用于包裹对象的引用（通用引用）； Owned，用于包裹对象的所有者； Cow 提供 对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）； 如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，Cow 提供方法做克隆处理，并避免多次重复克隆。 Cow 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 Cow，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。 它有以下几个要点需要掌握： Cow\u003cT\u003e 能直接调用 T 的不可变方法，因为 Cow 这个枚举，实现了 Deref； 在需要写 T 的时候，可以使用 .to_mut() 方法得到一个具有所有权的值的可变借用；注意，调用 .to_mut() 不一定会产生克隆； 在已经具有所有权的情况下，调用 .to_mut() 有效，但是不会产生新的克隆； 多次调用 .to_mut() 只会产生一次克隆。 在需要写 T 的时候，可以使用 .into_owned() 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象； 如果之前 Cow 中的值是借用状态，调用此操作将执行克隆； 本方法，参数是self类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 Cow 上不能调用多次； 举例:写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。 use std::borrow::Cow; fn remove_spaces\u003c'a\u003e(input: \u0026'a str) -\u003e Cow\u003c'a, str\u003e { if input.contains(' ') { let mut buf = String::with_capacity(input.len()); for c in input.chars() { if c != ' ' { buf.push(c); } } return Cow::Owned(buf); } return Cow::Borrowed(input); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"HRTBS(Higher-Ranked Trait Bounds) HRTBS主要用于解决函数参数含有闭包,并且闭包参数含有引用 语法:for\u003c‘a\u003e T: Trait\u003c‘a\u003e 例如如下代码实际是不能编译通过的,因为编译器不能推断出返回哪个引用 fn call_on_ref_zero\u003cF\u003e(f: F) where F: Fn(\u0026i32, \u0026i32) -\u003e \u0026i32 { let zero = 0; f(\u0026zero, \u0026zero); } 尝试添加生命周期参数,还是不能通过编译,因为zero变量的生命周期是短于’a的. fn call_on_ref_zero\u003c'a, F\u003e(f: F) where F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 我们尝试使用HRTBS试试 fn call_on_ref_zero\u003cF\u003e(f: F) where for\u003c'a\u003e F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 另一个例子 fn foo\u003c'b, F\u003e(f: F) -\u003e \u0026'b str where for\u003c'a\u003e F: Fn(\u0026'a str) -\u003e \u0026'a str, { let s = \"hello\"; f(s) } fn bar(s: \u0026str) -\u003e \u0026str { \u0026s[..1] } fn main() { let s = foo(bar); println!(\"{s}\"); } 最后一个例子: fn foo\u003c'a\u003e(f: Box\u003cdyn Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 第一次调用 f(\u0026x) 时生命周期 'a 等于变量 x 的生命周期；而在第二次调用 f(\u0026y) 时，生命周期 'a 又等于了变量 y 的生命周期；而变量 x 和变量 y 的生命周期显然是不同的。因此无法用一个静态的生命周期来描述 'a ，我们希望的是，闭包 f 在具体调用时绑定具体的生命周期，比如调用 f(\u0026x) 时绑定的是 x 的生命周期，而调用 f(\u0026y) 时绑定的是 y 的生命周期。 使用HRTBS修改如下: fn foo(f: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 这样生命周期 'a 就不再是静态的了，他会随着闭包 f 的调用绑定到不同的生命周期：f(\u0026x) 调用时绑定到 x 的生命周期，f(\u0026y) 调用时绑定到 y 的生命周期。 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"PhantomData PhantomData主要用于无界生命周期(unbounded lifetime)或者需要drop struct非自身字段,例如: use std::marker: struct Vec\u003cT\u003e { data: *const T, // *const是可变的！ len: usize, cap: usize, _marker: marker::PhantomData\u003cT\u003e, } PhantomData模式表 Phantom 类型 'a 'T PhantomData\u003cT\u003e - 协变（可触发drop检查） PhantomData\u003c\u0026'a T\u003e 协变 协变 PhantomData\u003c\u0026'a mut T\u003e 协变 不变 PhantomData\u003c*const T\u003e - 协变 PhantomData\u003c*mut T\u003e - 不变 PhantomData\u003cfn(T)\u003e - 逆变(*) PhantomData\u003cfn() -\u003e T\u003e - 协变 PhantomData\u003cfn(T) -\u003e T\u003e - 不变 PhantomData\u003cCell\u003c\u0026'a ()\u003e\u003e 不变 - (*)如果发生变性的冲突，这个是不变的 我们可以使用泛型结构体来实现对同一种类对象不同子类对象的区分，例如，我们的系统中要设计这样一个功能，将用户分为免费用户和付费用户，而且免费用户在体验免费功能之后，如果想升级成付费用户也是可以的。按照我们常规的思维，可能是定义两个结构体 FreeCustomer 以及 PaidCustomer，但是我们可以通过泛型结构体来实现，例如： struct Customer\u003cT\u003e { id: u64, name: String, } 不过，我们这里的 T 又无处安放，所以又不得不使用 PhantomData，它就像一个占位符，但是又没有大小，可以为我们持有在声明时使用不到的数据： use std::{ marker::PhantomData, sync::atomic::{self, AtomicU64}, }; static NEXT_ID: AtomicU64 = AtomicU64::new(0); struct Customer\u003cT\u003e { id: u64, name: String, phantom: PhantomData\u003cT\u003e, } struct FreeFeature; struct PaidFeature; trait Free { fn feature1(\u0026self); fn feature2(\u0026self); } trait Paid: Free { fn paid_feature(\u0026self); } /// 为 Customer\u003cT\u003e 实现需要的方法 impl\u003cT\u003e Customer\u003cT\u003e { fn new(name: String) -\u003e Self { Self { id: NEXT_ID.fetch_add(1, atomic::Ordering::Relaxed), name, phantom: PhantomData, } } } /// 免费用户可以升级到付费用户 impl Customer\u003cFreeFeature\u003e { fn advance(self, payment: f64) -\u003e Customer\u003cPaidFeature\u003e { println!( \"{}（{}） 将花费 {:.2} 元升级到付费用户\", self.name, self.id, payment ); self.into() } } /// 所有客户都有权使用免费功能 impl\u003cT\u003e Free for Customer\u003cT\u003e { fn feature1(\u0026self) { println!(\"{} 正在使用免费功能一\", self.name) } fn feature2(\u0026self) { println!(\"{} 正在使用免费功能二\", self.name) } } /// 付费用户才能使用的功能 impl Paid for Customer\u003cPaidFeature\u003e { fn paid_feature(\u0026self) { println!(\"{} 正在使用付费功能\", self.name) } } /// 允许使用免费用户转换成付费用户 impl From\u003cCustomer\u003cFreeFeature\u003e\u003e for Customer\u003cPaidFeature\u003e { fn from(c: Customer\u003cFreeFeature\u003e) -\u003e Self { Self::new(c.name) } } #[cfg(test)] mod tests { use super::*; #[test] fn test_customer() { // 一开始是免费用户 let customer = Customer::\u003cFreeFeature\u003e::new(\"MichaelFu\".to_owned()); customer.feature1(); customer.feature2(); // 升级成付费用户，可能使用付费功能和普通功能 let customer = customer.advance(99.99); customer.feature1(); customer.feature2(); customer.paid_feature(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Thread_local thread_local是一种将数据存储到全局变量中的方法，程序中的每个线程都有自己的副本。线程不共享这个数据，所以访问不需要同步,thread_local中声明的变量，在线程结束后会被释放，比如如果有10个线程中使用了该thread_local变量,则这10个线程结束时将有10个该类型的变量被释放。这适用于thread_per_core架构的异步运行时(类似于nginx),而不是tokio这种work-stealing scheduler(任务窃取). 举个例子: use std::borrow::Cow; use std::cell::RefCell; use std::thread; fn main() { thread_local!(static FOO: RefCell\u003cu32\u003e = RefCell::new(1)); FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 2; }); // 每个线程开始时都会拿到线程局部变量的FOO的初始值 let t = thread::spawn(move || { FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 3; }); }); // 等待线程完成 t.join().unwrap(); // 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2 FOO.with(|f| { assert_eq!(*f.borrow(), 2); }); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Barrier(线程屏障) 使用 Barrier 让多个线程都执行到某个点后，才继续一起往后执行： use std::sync::{Arc, Barrier}; use std::thread; fn main() { let mut handles = Vec::with_capacity(5); let barrier = Arc::new(Barrier::new(5)); for _ in 0..5 { let b = barrier.clone(); handles.push(thread::spawn(move|| { println!(\"before wait\"); b.wait(); println!(\"after wait\"); })); } for handle in handles { handle.join().unwrap(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"once_cell和lazy_static once_cell 和 lazy_static 都是 Rust 中用于实现单例模式（Singleton）的库。 once_cell 适用于程序初始化加载配置文件这种场景 LazyCell和LazyLock适用于初始化某个变量,比如说正则的compile,数据库连接等场景. #![feature(once_cell)] use std::cell; use std::collections::HashMap; use std::sync; use std::sync::Once; static INIT: Once = sync::Once::new(); static mut SUM: u64 = 0; fn init_sum() -\u003e u64 { unsafe { INIT.call_once(|| { println!(\"this is first init\"); SUM = (1..100000).sum(); }); SUM } } fn main() { let split_line = \"*\".repeat(100); let first_result = init_sum(); println!(\"first result: {first_result}\"); let second_result = init_sum(); println!(\"second result: {second_result}\"); println!(\"{split_line}\"); let once = cell::OnceCell::\u003cHashMap\u003c\u0026str, \u0026str\u003e\u003e::new(); let dict = once.get_or_init(|| { println!(\"this is hash map init once\"); let mut map = HashMap::new(); map.insert(\"lang\", \"rust\"); map.insert(\"edition\", \"2021\"); map }); println!(\"once dict: {dict:?}\"); let dict_twice = once.get_or_init(|| { println!(\"this is hash map init twice\"); let mut map = HashMap::new(); map.insert(\"lang\", \"python\"); map.insert(\"version\", \"1.10\"); map }); println!(\"twice dict: {dict_twice:?}\"); println!(\"{split_line}\"); let lazy_init = cell::LazyCell::new(|| env!(\"PATH\")); println!(\"lazy_init: {}\", *lazy_init); // thread safe lazy cell let lazy_init_safe = sync::LazyLock::new(|| env!(\"PATH\")); print!(\"lazy_init_safe: {}\", *lazy_init_safe); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"impl A and T: A 在 impl 中被声明的类型参数，至少要满足下面三种形式： impl Foo， T 出现在实现的Self 类型Foo 中 。 impl SomeTrait for Foo ， T出现在要实现的 trait 中 。 impl\u003cT, U\u003e SomeTrait for T where T: AnotherTrait\u003cAssocType=U\u003e ， 出现在 T 的 trait 限定的关联类型中。 参考资料: 【Rust】幽灵数据（PhantomData） | MichaelFu (fudenglong.site) 3.10 PhantomData（幽灵数据） | 第三章、所有权 |《Rust 高级编程 2018》| Rust 技术论坛 (learnku.com) Rust高阶生命周期绑定 (xiaopengli89.github.io) ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["c/c++"],"content":"cmake简易教程 ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"1. 添加头文件目录INCLUDE_DIRECTORIES 它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。 语法： include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"2. 添加需要链接的库文件目录LINK_DIRECTORIES 语法： link_directories(directory1 directory2 ...) 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。 link_directories(\"/home/server/third/lib\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"3. 添加需要链接的库文件路径LINK_LIBRARIES 语法： link_libraries(library1 \u003cdebug | optimized\u003e library2 ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"4. 设置要链接的库文件的名称TARGET_LINK_LIBRARIES 语法： target_link_libraries(\u003ctarget\u003e [item1 [item2 [...]]] [[debug|optimized|general] \u003citem\u003e] ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"5. 查找库所在目录FIND_LIBRARY 语法： find_library (\u003cVAR\u003e name1 [path1 path2 ...]) find_library ( \u003cVAR\u003e name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \"cache documentation string\"] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 例子如下： FIND_LIBRARY(RUNTIME_LIB rt /usr/lib /usr/local/lib NO_DEFAULT_PATH) cmake会在目录中查找，如果所有目录中都没有，值RUNTIME_LIB就会被赋为NO_DEFAULT_PATH ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:5:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"6. 查找源文件和头文件 # 查找指定目录下的所有.cpp与.h文件 并存放到指定变量名SC_FILES中 FILE(GLOB SC_FILES \"*.cpp\" \"*.h\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:6:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"7. 添加源文件目录 使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。 语法： aux_source_directory(\u003cdir\u003e \u003cvariable\u003e) # 生成链接库 add_library (MathFunctions ${DIR_LIB_SRCS}) 参考链接： cmake 添加头文件目录，链接动态、静态库 - 王彬彬 - 博客园 (cnblogs.com) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:7:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"opencv实现抠图和裁剪 ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:0:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"1. 抠图 步骤: 加载图像 转换图像格式(BGR –\u003e HSV) 设置阈值 通过阈值提取部分区域 显示图片 关于HSV可参考：HSL和HSV色彩空间 - 维基百科，自由的百科全书 (wikipedia.org) window_name = 'hsv' img = cv2.imread(r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\") # 设置高低阈值 hsv_low = np.array([0, 0, 0]) hsv_high = np.array([134, 255, 138]) # 将BGR转为HSV dst = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 通过HSV的高低阈值，提取图像部分区域 mask_img = cv2.inRange(dst, hsv_low, hsv_high) # 进行与位运算 img_ = cv2.bitwise_and(img, img, mask=mask_img) cv2.imshow(window_name, img_) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:1:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"2. 裁剪图片 步骤 加载图像 设置鼠标事件 - 鼠标左键单击画点\r- 鼠标右键单击闭合所画的点\r- 鼠标右键双击填充 # 触发鼠标移动事件 # cv2.CV_EVENT_MOUSEMOVE # 触发左键抬起事件 # cv2.CV_EVENT_LBUTTONUP # 触发右键按下事件 # cv2.CV_EVENT_RBUTTONDOWN # 触发右键抬起事件 # cv2.CV_EVENT_RBUTTONUP # 触发左键双击事件 # cv2.CV_EVENT_LBUTTONDBLCLK # 触发右键双击事件 # cv2.CV_EVENT_RBUTTONDBLCLK coordinates = [] window_name = 'draw' def on_mouse_callback(event, x, y, flag, param): # 左键点击,画点 if event == cv2.EVENT_LBUTTONDOWN: xy = f'{x},{y}' coordinates.append((x, y)) cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1) cv2.putText(img, xy, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness=1) cv2.imshow(window_name, img) # 右键单击，画不规则图形 elif event == cv2.EVENT_RBUTTONDOWN: pts = np.array(coordinates, np.int32) # 顶点集 #顶点坐标转为rowsx1x2, row为顶点数 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (255, 255, 255), 2) cv2.imshow(window_name, img) # 右键双击，填充颜色 elif event == cv2.EVENT_RBUTTONDBLCLK: area = np.array(coordinates) # 可以绘制多个图形 cv2.fillPoly(img, [area], (255, 255, 255)) # 绘制凸多边形 # cv2.fillConvexPoly(img, area, (255, 255, 255)) cv2.imshow(window_name, img) coordinates.clear() cv2.namedWindow(window_name) cv2.setMouseCallback(window_name, on_mouse_callback) cv2.imshow(window_name, img) cv2.waitKey(0) cv2.destroyAllWindows() Rust版opencv实现抠图 Cargo.toml [dependencies] opencv = { version = \"0.71\" } src/main.rs use opencv::{ core::{bitwise_and, in_range, Vector, CV_8UC3}, highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, imgproc::{cvt_color, COLOR_BGR2HSV}, prelude::*, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img = imread( r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\", ImreadModes::IMREAD_COLOR as i32, )?; unsafe { let mut lowerb = Vector::from_slice(\u0026[0, 0, 0u8]); let mut upperb = Vector::from_slice(\u0026[134, 255, 138u8]); let mut dst = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut mask_img = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut result = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; cvt_color(\u0026img, \u0026mut dst, COLOR_BGR2HSV, 0)?; in_range(\u0026img, \u0026mut lowerb, \u0026mut upperb, \u0026mut mask_img)?; bitwise_and(\u0026img, \u0026img, \u0026mut result, \u0026mask_img)?; imshow(\"winname\", \u0026result)?; } wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:2:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Rust"],"content":"Rust中使用opencv 因为在macos和linux上安装比较简单，这里只介绍windows上的安装 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:0:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"安装环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 安装opencv 下载地址：Releases - OpenCV 选择windows平台，下载后默认安装即可 设置环境变量 OPENCV_INCLUDE_PATHS OPENCV_LINK_LIBS OPENCV_LINK_PATHS 注意：opencv_world460这个不是固定的，需要根据下载的具体版本设置，我的版本中位于D:\\development\\opencv\\build\\x64\\vc15\\bin目录 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 安装LLVM 下载地址：Releases · llvm/llvm-project (github.com) 根据需要安装32位或者64位，有些版本可能没有这2个选项，可以选择以前的版本，没必要选择最新的版本。下载后默认安装即可，注意需要在添加LLVM到环境变量中 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"简单使用 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 确保安装了Rust环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 新建项目 cargo new opencv-rust-test ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"3. 配置Cargo.toml文件 [dependencies] opencv = { version = \"0.71\" } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:3","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"4. 将opencv_world460.dll文件拷贝到项目根目录(重要！！！) 如果opencv_world460.dll路径添加到环境变量中，应该就不需要将文件拷贝(没有实际测试) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:4","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"5. 编写代码测试环境是否正常 src/main.rs use opencv::{ highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img_path = r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\"; let img = imread(img_path, ImreadModes::IMREAD_COLOR as i32)?; imshow(\"winname\", \u0026img)?; wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:5","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"6. 运行测试 # 使用cargo命令运行看看是否正常显示图片 cargo run ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:6","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"7. 报错解决 主要参考官方文档： twistedfall/opencv-rust: Rust bindings for OpenCV 3 \u0026 4 (github.com) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:7","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Linux"],"content":"管道 ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:0:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"匿名管道(Pipe) 特点 半双工 只能用于具有亲缘关系进程(父子，兄弟) 可以视作特殊文件，读写可以使用write，read函数 #include\"stdio.h\" #include\"unistd.h\" // https://learnku.com/articles/44477 // **特点** // 1. 半双工 // 2. 只能用于具有亲缘关系进程(父子，兄弟) // 3. 可以视作特殊文件，读写可以使用write，read函数 int main() { int fd[2]; pid_t pid; char buf[32]; //创建管道 if (pipe(fd) \u003c 0) { printf(\"Create Pipe Error \\n\"); } //创建子进程 if ((pid = fork()) \u003c 0) { printf(\"Fork Error \\n\"); } else if (pid \u003e 0) { close(fd[0]); // 关闭父进程读端 write(fd[1], \"hello world\", 8); //父进程写端写入 } else { close(fd[1]); // 关闭子进程写端 read(fd[0], buf, 8); // 子进程读取父进程消息 printf(\"Child Recv Msg: %s\", buf); } } ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:1:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"命名管道(FIFO) 特点 和匿名管道不同，FIFO可以在无关进程间通信 FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 fifo_read.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"errno.h\" #include\"fcntl.h\" #include\"sys/stat.h\" int main() { int fd; int len; char buf[1024]; if (mkfifo(\"/home\", 0666) \u003c 0 \u0026\u0026 errno != EEXIST) { perror(\"Create FIFO Failed\"); } if ((fd = open(\"/home\", O_RDONLY)) \u003c 0) { perror(\"Open FIFO Failed\"); exit(1); } while ((len = read(fd, buf, 1024)) \u003e 0) { printf(\"Read Message: %s\", buf); } close(fd); return 0; } fifo_write.c #include\"stdio.h\" #include\"unistd.h\" #include\"stdlib.h\" #include\"fcntl.h\" // O_WRONLY #include\"sys/stat.h\" #include\"time.h\" // ## 命名管道(FIFO) // ** 特点** // 1. 和匿名管道不同，FIFO可以在无关进程间通信 // 2. FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 int main() { int fd; int n, i; char buf[1024]; time_t tp; printf(\"Parent Process PID:\", getpid()); if ((fd = open(\"/home\", O_WRONLY)) \u003c 0) { // 写模式打开FIFO perror(\"Open FIFO Failed\"); exit(1); } for (i = 0; i \u003c 10; ++i) { time(\u0026tp);// 当前系统时间 n = sprintf(buf, \"Process %d's time is %s\", getpid(), ctime(\u0026tp)); printf(\"Send message: %s\", buf); // 写入数据到FIFO中 if (write(fd, buf, n + 1) \u003c 0) { perror(\"Write FIFO Failed\"); close(fd); exit(1); } sleep(1); } close(fd); return 0; } 消息队列 特点 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。 msg_client.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // key值不变，要么确保ftok()的文件不被删除，要么不用ftok()，指定一个固定的key值。 // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } printf(\"Message Queue - Client key is: %d.\\n\", key); // 打开消息队列 if ((msqid = msgget(key, IPC_CREAT | 0777)) == -1) { perror(\"msgget error\"); exit(1); } // 打印消息队列ID和进程ID printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); // 添加消息，类型为888 msg.mtype = 888; sprintf(msg.mtext, \"hello, I'm client %d\", getpid()); //msgid是由msgget函数返回的消息队列标识符。 // __msgp是一个指向准备发送消息的指针，消息的数据结构却有一定的要求， // 指针msg_ptr所指向的消息结构一定要是以一个**长整型**成员变量开始的结构体，接收函数将用这个成员来确定消息的类型 msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); // msgrcv函数type参数有以下几种可能： // type == 0，返回队列中的第一个消息； // type \u003e 0，返回队列中消息类型为 type 的第一个消息； // type \u003c 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。 // 读取类型为999的消息 msgrcv(msqid, \u0026msg, 256, 999, 0); printf(\"Client: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Client: receive msg.mtype is: %d.\\n\", msg.mtype); } msg_server.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } // 打印key值 printf(\"Message Queue - Server key is: %d.\\n\", key); // 创建消息队列 if ((msqid = msgget(key, IPC_CREAT | 0700)) == -1) { perror(\"msgget error\"); exit(1); } printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); for (;;) { // 返回类型为888的第一个消息 msgrcv(msqid, \u0026msg, 256, 888, 0); printf(\"Server: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Server: receive msg.mtype is: %d.\\n\", msg.mtype); msg.mtype = 999; sprintf(msg.mtext, \"hello, I'm server %d\", getpid()); msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); } return 0; } 信号量 特点 是一个计数器 用于实现进程间互斥和同步,不是存储进程间通信数据 示例 #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/sem.h\" union semun { int val; struct semid_ds* buf; unsigned short* array; }; int init_sem(int sem_id, int value) { union semun tmp; tmp.val = value; if (semctl(sem_id, 0, SETVAL, tmp) == -1) { perror(\"Init Semaphore Error\"); return -1; } return 0; } // p操作 // 若信号量值为1，获取资源并将信号值置为-1 // 若信号量值为0，进程挂起等待 int sem_p(int sem_id) { struct sembuf sbuf; sbuf.sem_num = 0; // 序号 sbuf.sem_op = -1; // 操作 sbuf.sem_flg = SEM_UNDO; if (semop(sem_id, \u0026sbuf, 1) == -1) { perror(\"P operation Error\"); return -","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:2:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Python"],"content":"索引 import pandas as pd import numpy as np df = pd.DataFrame(np.arange(50).reshape(-1, 5), columns=list('abcde')) # 根据列标签索引 df['a'] # 或者 df.loc[:,'a'] # 根据列索引 df.iloc[:, 0] # df['a'] == df.loc[:,'a'] == df.iloc[:, 0] 计算 # 所有元素乘法 df * 10 # 指定列相乘 # 注意：不会在原地修改，需要重新赋值 df['a'] = df['a'] * 10 # 指定位置操作 df.iloc[0,3] = 100 # 也可以指定多列操作，生成新列 df['e'] = df['a'] * df['b'] 合并 df_new = pd.DataFrame(np.arange(200, 230).reshape(-1, 2), columns=['z','x']) # 注意：这里因为2个DataFrame行索引没有冲突，索引这里没有问题。 # axis 为0时以行合并(可以是实现数据追加)，为1时以列合并 pd.concat([df, df_new], axis=1) # 当下面的df的行索引不连续时，df_new就会缺少一些行的数据 df = df[df.loc[:, 'a'] % 100 == 0] pd.concat([df, df_new], axis=1) # 如果当出现上面一种情况，而又不想丢掉df_new的数据时可以使用重新索引的方法 df = df.reset_index(drop=True) pd.concat([df, df_new], axis=1) 追加数据 # 不能这样追加，需要列标签相对应 df.append([1, 3, 5, 3,5]) # 新Dataframe需要和df标签对应 new_row = pd.DataFrame(np.full((1,4), 5), columns=list('abcd')) df.append(new_row) # 也可以这样 # pd.concat([df, new_row], axis=0) Apply 使用 # 当Dateframe中不再是存数字时，就不能根据直接对列进行操作生成新列，有些时候还含有复杂的条件判断，这时候既可以使用apply函数 # 注意当新加列时需要设置axis=1 df['f'] = df[['b','c']].apply(lambda x: x[0]*100 if x[0] % 2 == 0 else x[1] - 100, axis=1) 排序 # 根据索引排序,axis=0代表行，axis=1代表列 df.sort_index() # 根据值排序,可根据多个值排序 df.sort_values(by=['a']) # 如果Dataframe含有重复列，重复列的数据又不相同，但又想按值排序，可以参考下面 # 比如说2，4列名相同，想按照第2列的值排序 # sort_col_values = df.iloc[:, 2].to_numpy() # sort_indexs = sort_col_values.argsort() # df = df.iloc[:, sort_indexs] 去重 # 使用函数drop_duplicates，其中subset指定要去重的列名，不能写列索引，即指定的相同列才进行去重，默认按照所有列相同去重，keep参数可以指定保留first，last。inplace选择是否修改原Dataframe # df.drop_duplicates(subset=[], keep='first', inplace=False) # 当Dataframe有重复列名，重复列名数据不相同时，可以将Dataframe拆分，再进行去重，去重后再合并 # 例如：2，4列名重复，需要按照1，2列去重 # 拆分 front = df.iloc[:, :2] back = df.iloc[:, 2:] # 去重 front.drop_duplicates(subset=['a', 'b'], keep='first', inplace=True) back = back.iloc[front.index, :] # 合并,这里能保证行索引能一一对应，所以不用重建索引也行。当时也可以选择重建索引 pd.concat([front, back], axis=1) 字符串操作 在pandas中可以针对需要操作列方便的使用字符串的所有函数 # 举例： # 注意：这里的replace方法默认使用正则表达式，可以添加regex=False来关闭 df['a'].str.replace(regex=False) 分组和聚合 # 对指定列进行聚合计算，agg会返回分组结果，并且列数据为聚合操作后的结果 # 使用以下访问生成聚合结果 lang = df.groupby(by='姓名').agg({'语文': 'sum'}) math = df.groupby(by='姓名').agg({'数学': 'sum'}) english = df.groupby(by='姓名').agg({'英语': 'sum'}) # pd.concat([lang, math, english], axis=1) # 以上等于下面这行。 # df.groupby(by='姓名').sum() # 如果要对不同列进行不同聚合操作，可以使用以下方法： df = df.groupby(by='姓名').agg({'语文': 'sum', '姓名': 'count'}) # 注意：如果使用以上方法会出现重复列，那就需要重命名列名 df = df.rename({'姓名': 'count'}, axis=1) # 使用transform返回DataFrame # df['count'] = df.groupby(by='姓名')['数学'].transform('sum') 读取和保存 # 读取csv提供了许多使用的选项，比如可以指定分隔符，读取部分数据，跳过表头，指定列名读取 # 参考：https://www.gairuo.com/p/pandas-read-csv pd.read_csv( filepath_or_buffer: 'FilePathOrBuffer', sep=\u003cno_default\u003e, delimiter=None, header='infer', names=\u003cno_default\u003e, index_col=None, usecols=None, squeeze=False, prefix=\u003cno_default\u003e, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None, ) # 读取excel # 参考https://www.gairuo.com/p/pandas-read-excel pd.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=Fa","date":"2022-11-12","objectID":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["pandas"],"title":"Pandas使用小结","uri":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["Numpy","Python"],"content":"Numpy 排序函数 numpy.sort(a, axis=-1, kind=None, order=None) 参数: a : 要排序的数组； axis ： 按什么轴进行排序，默认按最后一个轴进行排序； kind ：排序方法，默认是快速排序(不稳定)，可选参数有:{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’} order : 当数组定义了字段属性时，可以按照某个属性进行排序； numpy.argsort(a, axis=-1, kind=None, order=None):numpy.argsort 函数用于将数组排序后，返回数组元素从小到大依次排序的所有元素索引 参数: a : 要排序的数组 axis ： 按什么轴进行排序，默认按最后一个轴进行排序 kind ：排序方法，默认是快速排序 order : 当数组定义了字段属性时，可以按照某个属性进行排序 排序后索引解释： 比如说第一行排序后的结果为：[1, 0, 2] 表示原数组索引为 1 的数现在变为 0，原索引为 0 变为 1，原索引为 2 保持不变,即[0, 1, 2] -\u003e [1, 0, 2] numpy.lexsort(keys, axis=-1): numpy.lexsort 函数用于按照多个条件（键）进行排序，返回排序后索引。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 参数: keys ：序列或元组，要排序的不同的列 axis ：指定次排序的轴(默认为-1，即最后一个轴) 注意：根据数组的 shape 维数指定次排序轴，也就是说如果是二维数组只能设置为 0，因为 1 是著排序轴。如果 shape 为(2,3,5),则 axis 可指定为 0 或者 1 根据行和列排序 ","date":"2022-11-05","objectID":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/:0:0","tags":["numpy","sort"],"title":"Numpy使用排序","uri":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/"},{"categories":["Rust","Openssl","Crypto"],"content":"AES 加密算法 AES(Advanced Encryption Standard)，全称：高级加密标准，是一种最常见的对称加密算法 ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"配置 Rust Toml 文件 [dependencies] openssl = { version = \"0.10\", features = [\"vendored\"] } ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"示例代码 use openssl::symm::{Cipher, Crypter, Mode}; fn main() { let key = \"061cecfd897548208c76c04b6e7fb\".as_bytes(); let crypto_word: \u0026mut Vec\u003cu8\u003e = \u0026mut \"keyword\".as_bytes().to_vec(); let block_size = Cipher::aes_128_cbc().block_size(); // 添加填充 pkcs7_padding(crypto_word, block_size); let mut output = vec![0; 1024]; // 取16位密钥 let mut encrypter = Crypter::new(Cipher::aes_128_ecb(), Mode::Encrypt, \u0026key[..16], None).unwrap(); match encrypter.update(\u0026f, \u0026mut output) { Ok(size) =\u003e { eprintln!(\"size is: {size}\"); println!(\"{:?}\", \u0026output[..size]); println!(\"{:02x?}\", \u0026output[..size]); // 转换为16进制 } Err(_) =\u003e {} }; } fn pkcs7_padding(data: \u0026mut Vec\u003cu8\u003e, block_size: usize) { let padding_num = block_size - data.len() % block_size; let padding = padding_num as u8; data.append(\u0026mut [padding].repeat(padding_num)); } 参考链接： AES 加解密-CBC ECB - 独孤剑—宇枫 - 博客园 (cnblogs.com) AES 加密(3)：AES 加密模式与填充 - 知乎 (zhihu.com) ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["教程"],"content":"安装镜像 下载地址： https://ubuntu.com/download/raspberry-pi 刷入镜像到SD卡 刷入后需要重新拔插SD卡 找到system-boot盘符盘符下network-config文件 根据实际情况修改wifi配置 version: 2 ethernets: eth0: dhcp4: true optional: true #wifis: # wlan0: # dhcp4: true # optional: true # access-points: # myhomewifi: # password: \"S3kr1t\" # myworkwifi: # password: \"correct battery horse staple\" # workssid: # auth: # key-management: eap # method: peap # identity: \"me@example.com\" # password: \"passw0rd\" # ca-certificate: /etc/my_ca.pem 开机查找wifi 查找树莓派ip地址可用方法： 登录路由器后台查看连接设备中树莓派IP 使用Advanced_IP_Scanner软件 连接ssh 初始用户名和密码都是：ubuntu ssh ubuntu@ip 注意：第一次登陆会强制要求修改密码，修改后再次登录即可，密码也不能太短 换源 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改文件内容为: deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-backports main restricted universe multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security multiverse 更新 sudo apt update sudo apt upgrade -y 参考链接： 树莓派折腾记（一）– 安装系统（Ubuntu Server 20.04.1） | 修行的技术阁 (mrxiuxing.com) ","date":"2022-10-24","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/:0:0","tags":["raspberry"],"title":"树莓派安装Ubutnu无显示器网络初次开机","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/"},{"categories":["教程"],"content":"Hugo博客从零到发布 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:0:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"1. 安装 安装hugo: 下载地址：https://github.com/gohugoio/hugo/releases/tag/v0.104.3 注意： 有些主题需要下载extended版本 安装git： 下载地址：https://git-scm.com/ ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:1:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"2. 配置远程仓库，并新建一个空项目(不需要README.md文件)，名字一般和站点名相同 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:2:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 本地部署 新建站点并配置git hugo new site your_site_name # 下载你需要的主题的压缩包放到theme目录下或者使用`git submodule`拉取，例： git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt # 根据主题文档配置config.toml文件，如果只有一个主题可直接在项目根目录下的config.toml文件配置 # 0. 当本地可以正常预览站点时运行，hugo命令打包，生成静态文件 # 1. 使用git初始化站点 # 2. 添加远程仓库 git remote add origin remtoe_url # 3. 拉取远程 # 4. 提交当前代码 # 4. 新建分支(例如：release)，命令如下： git switch -c release # 或者 git checkout -b release # 5. 合并主分支分支public目录到当前分支，命令如下： git checkout master public/** # 6. 移动public下所有内容到项目根目录下，例如： mv public/* . # 7. 再提交当前分支内容 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:3:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 推送到远程 # 使用git推送到远程仓库 git switch master git push -u origin master git switch release git push -u origin release # 将远程仓库默认分支设置为release ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:4:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"4. 使用cloudflare发布 注册一个cloudflare账号：https://dash.cloudflare.com/ 点击Pages，选择创建项目下连接到Git，然后根据需要配置相应信息 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:5:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"Kunpeng Compute安全编程指南 本文档基于C语言提供一些安全编程建议，用于指导开发实践。 数据类型 ","date":"0001-01-01","objectID":"/securecoding/:0:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保有符号整数运算不溢出 【描述】 有符号整数溢出是未定义的行为。出于安全考虑，对外部数据中的有符号整数值在如下场景中使用时，需要确保运算不会导致溢出： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 1)加法 【错误代码示例】(加法) 如下代码示例中，参与加法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = num_a + num_b; ... 【正确代码示例】(加法) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = 0; if (((num_a \u003e 0) \u0026\u0026 (num_b \u003e (INT_MAX - num_a))) || ((num_a \u003c 0) \u0026\u0026 (num_b \u003c (INT_MIN - num_a)))) { ... // 错误处理 } sum = num_a + num_b; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，参与减法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出，进而造成后续的内存复制操作出现缓冲区溢出。 unsigned char *content = ... // 指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 int total_len = ... // 报文总长度 int skip_len = ... // 从消息中解析出来的需要忽略的数据长度 // 用total_len - skip_len 计算剩余数据长度，可能出现整数溢出 (void)memmove(content, content + skip_len, total_len - skip_len); ... 【正确代码示例】(减法) 如下代码示例中，重构为使用size_t类型的变量表示数据长度，并校验外部数据长度是否在合法范围内。 unsigned char *content = ... //指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 size_t total_len = ... // 报文总长度 size_t skip_len = ... // 从消息中解析出来的需要忽略的数据长度 if (skip_len \u003e= total_len || total_len \u003e content_size) { ... // 错误处理 } (void)memmove(content, content + skip_len, total_len - skip_len); ... 3)乘法 【错误代码示例】(乘法) 如下代码示例中，内核代码对来自用户态的数值范围做了校验，但是由于opt是int类型，而校验条件中错误的使用了ULONG_MAX进行限制，导致整数溢出。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (ULONG_MAX / (60 * HZ)))) { // 错误的使用了ULONG_MAX做上限校验 return -EINVAL; } ... = opt * 60 * HZ; // 可能出现整数溢出 ... 【正确代码示例】(乘法) 一种改进方案是将opt的类型修改为unsigned long类型，这种方案适用于修改了变量类型更符合业务逻辑的场景。 unsigned long opt = ... // 将类型重构为 unsigned long 类型。 if (opt \u003e (ULONG_MAX / (60 * HZ))) { return -EINVAL; } ... = opt * 60 * HZ; ... 另一种改进方案是将数值上限修改为INT_MAX。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (INT_MAX / (60 * HZ)))) { // 修改使用INT_MAX作为上限值 return -EINVAL; } ... = opt * 60 * HZ; 4)除法 【错误代码示例】(除法) 如下代码示例中，做除法运算前只检查了是否出现被零除的问题，缺少对数值范围的校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a / num_b; // 可能出现整数溢出 ... 【正确代码示例】(除法) 如下代码示例中，按照最大允许值进行校验，防止整数溢出，在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 5)求余数 【错误代码示例】(求余数) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a % num_b; // 可能出现整数溢出 ... } 【正确代码示例】(求余数) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... } 6)一元减 当操作数等于有符号整数类型的最小值时，在二进制补码一元求反期间会发生溢出。 【错误代码示例】(一元减) 如下代码示例中，计算前未校验数值范围，可能出现整数溢出。 int num_a = ... // 来自外部数据 int result = -num_a; // 可能出现整数溢出 ... 【正确代码示例】(一元减) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int result = 0; if (num_a == LNT_MIN) { ... // 错误处理 } result = -num_a; ... ","date":"0001-01-01","objectID":"/securecoding/:1:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保无符号整数运算不回绕 【描述】 涉及无符号操作数的计算永远不会溢出，因为超出无符号整数类型表示范围的计算结果会按照（结果类型可表示的最大值 + 1）的数值取模。 这种行为更多时候被非正式地称为无符号整数回绕。 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 出于安全考虑，对外部数据中的无符号整数值在如下场景中使用时，需要确保运算不会导致回绕： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 1)加法 【错误代码示例】(加法) 如下代码示例中，校验下一个子报文的长度加上已处理报文的长度是否超过了整体报文的最大长度，在校验条件中的加法运算可能会出现整数回绕，造成绕过该校验的问题。 size_t total_len = ... // 报文的总长度 size_t read_len = 0 // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 从网络报文中解析出来的下一个子报文的长度 if (read_len + pkt_len \u003e total_len) { // 可能出现整数回绕 ... // 错误处理 } ... read_len += pkt_len; ... 【正确代码示例】(加法) 由于read_len变量记录的是已经处理报文的长度，必然会小于total_len，因此将代码中的加法运算修改为减法运算，导致条件绕过。 size_t total_len = ... // 报文的总长度 size_t read_len = 0; // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 来自网络报文 if (pkt_len \u003e total_len - read_len) { ... // 错误处理 } ... read_len += pkt_len; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，校验len合法范围的运算可能会出现整数回绕，导致条件绕过。 size_t len = ... // 来自用户态输入 if (SCTP_SIZE_MAX - len \u003c sizeof(SctpAuthBytes)) { // 减法操作可能出现整数回绕 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); // 可能出现整数回绕 ... 【正确代码示例】(减法) 如下代码示例中，调整减法运算的位置（需要确保编译期间减法表达式的值不翻转），避免整数回绕问题。 size_t len = ... // 来自用户态输入 if (len \u003e SCTP_SIZE_MAX - sizeof(SctpAuthBytes)) { // 确保编译期间减法表达式的值不翻转 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); ... 3)乘法 【错误代码示例】（乘法） 如下代码示例中，使用外部数据计算申请内存长度时未校验，可能出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 unsigned char *buf = (unsigned char *)malloc(width * hight); 无符号整数回绕可能导致分配的内存不足。 【正确代码示例】（乘法） 如下代码是一种解决方案，校验参与乘法运算的整数数值范围，确保不会出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 if (width == 0 || hight == 0) { ... // 错误处理 } if (width \u003e SIZE_MAX / hight) { ... // 错误处理 } unsigned char *buf = (unsigned char *)malloc(width * hight); 【例外】 为正确执行程序，必要时无符号整数可能表现出模态（回绕）。建议将变量声明明确注释为支持模数行为，并且对该整数的每个操作也应明确注释为支持模数行为。 【相关软件CWE编号】 CWE-190 ","date":"0001-01-01","objectID":"/securecoding/:2:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保除法和余数运算不会导致除零错误(被零除) 【描述】 整数的除法和取余运算的第二个操作数值为0会导致程序产生未定义的行为，因此使用时要确保整数的除法和余数运算不会导致除零错误(被零除，下同)。 1)除法 【错误代码示例】(除法) 有符号整数类型的除法运算如果限制不当，会导致溢出。 如下示例对有符号整数进行的除法运算做了防止溢出限制，确保不会导致溢出，但不能防止有符号操作数num_a和num_b之间的除法过程中出现除零错误： int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a / num_b; // 可能出现除零错误 ... 【正确代码示例】(除法) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 2)取余 【错误代码示例】(求余数) 如下代码，同除法的错误代码示例一样，可能出现除零错误，因为许多平台以相同的指令实现求余数和除法运算。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a % num_b; // 可能出现除零错误 ... 【正确代码示例】(求余数) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... 变量 ","date":"0001-01-01","objectID":"/securecoding/:3:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用未经初始化的变量 【描述】 这里的变量，指的是局部动态变量，并且还包括内存堆上申请的内存块。 因为他们的初始值都是不可预料的，所以禁止未经有效初始化就直接读取其值。 void foo( ...) { int data; bar(data); // 错误：未初始化就使用 ... } 如果有不同分支，要确保所有分支都得到初始化后才能使用： #define CUSTOMIZED_SIZE 100 void foo( ...) { int data; if (condition \u003e 0) { data = CUSTOMIZED_SIZE; } bar(data); // 错误：部分分支该值未初始化 ... } ","date":"0001-01-01","objectID":"/securecoding/:4:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"指向资源句柄或描述符的变量，在资源释放后立即赋予新值 【描述】 指向资源句柄或描述符的变量包括指针、文件描述符、socket描述符以及其它指向资源的变量。 以指针为例，当指针成功申请了一段内存之后，在这段内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，那这个指针就是一个悬空指针。 如果再对悬空指针操作，可能会发生重复释放或访问已释放内存的问题，造成安全漏洞。 消减该漏洞的有效方法是将释放后的指针立即设置为一个确定的新值，例如设置为NULL。对于全局性的资源句柄或描述符，在资源释放后，应该马上设置新值，以避免使用其已释放的无效值；对于只在单个函数内使用的资源句柄或描述符，应确保资源释放后其无效值不被再次使用。 【错误代码示例】 如下代码示例中，根据消息类型处理消息，处理完后释放掉body或head指向的内存，但是释放后未将指针设置为NULL。如果还有其他函数再次处理该消息结构体时，可能出现重复释放内存或访问已释放内存的问题。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); } ... EXIT: ... free(msg-\u003ebody); return ret; } 【正确代码示例】 如下代码示例中，立即对释放后的指针设置为NULL，避免重复放指针。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); msg-\u003ebody = NULL; } ... EXIT: ... free(msg-\u003ebody); return ret; } 当free()函数的入参为NULL时，函数不执行任何操作。 【错误代码示例】 如下代码示例中文件描述符关闭后未赋新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); ... close(fd); ... 【正确代码示例】 如下代码示例中，在资源释放后，对应的变量应该立即赋予新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); s = INVALID_SOCKET; ... close(fd); fd = -1; ... 指针和数组 ","date":"0001-01-01","objectID":"/securecoding/:5:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部数据作为数组索引时必须确保在数组大小范围内 【描述】 外部数据作为数组索引对内存进行访问时，必须对数据的大小进行严格的校验，确保数组索引在有效范围内，否则会导致严重的错误。 当一个指针指向数组元素时，可以指向数组最后一个元素的下一个元素的位置，但是不能读写该位置的内存。 【错误代码示例】 如下代码示例中, set_dev_id()函数存在差一错误，当 index 等于 DEV_NUM 时，恰好越界写一个元素； 同样get_dev()函数也存在差一错误，虽然函数执行过程中没有问题，但是当解引用这个函数返回的指针时，行为是未定义的。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_id(size_t index, int id) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } return devs + index; } 【正确代码示例】 如下代码示例中，修改校验索引的条件，避免差一错误。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_Id (size_t index, int id) { if (index \u003e= DEV_NUM) { ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e= DEV_NUM) { ... // 错误处理 } return devs + index; } 【相关软件CWE编号】 CWE-119，CWE-123，CWE-125 ","date":"0001-01-01","objectID":"/securecoding/:6:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止通过对指针变量进行sizeof操作来获取数组大小 【描述】 将指针当做数组进行sizeof操作时，会导致实际的执行结果与预期不符。例如：变量定义 char *p = array，其中array的定义为char array[LEN]，表达式sizeof(p) 得到的结果与 sizeof(char *)相同，并非array的长度。 【错误代码示例】 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了sizeof(buffer)，与预期不符。 char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小 (void)memset(buffer, 0, sizeof(buffer)); 【正确代码示例】 如下代码示例中，将sizeof(buffer)修改为申请的缓冲区大小： char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); (void)memset(buffer, 0, SIZE); // 使用申请的缓冲区大小 字符串 ","date":"0001-01-01","objectID":"/securecoding/:7:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保字符串存储有足够的空间容纳字符数据和null结束符 【描述】 将数据复制到不足以容纳数据的缓冲区，会导致缓冲区溢出。缓冲区溢出经常发生在字符串操作中。为了避免这种错误，截断拷贝的数据以限制字符串的字节长度是一种防御方法，但是最好的措施是确保目标缓冲区的大小足以容纳复制数据和null结束符。当字符串存储在堆空间时， 确保分配内存时已分配了足够的空间。 部分字符串处理函数由于设计时安全考虑不足，或者存在一些隐含的目的缓冲区长度要求，容易被误用，导致缓冲区写溢出。此类典型函数包括不在C标准库函数中的itoa()，realpath()函数。 【错误代码示例】(itoa) 有些函数如itoa(), realpath()需要在对传入的缓冲区指针位置进行写入操作，但函数并没有提供缓冲区长度。因此，在调用这些函数前，必须提供足够的缓冲区。 如下代码示例中，试图将数字转为字符串，但是目标存储空间的预留长度不足： int num = ... char str[8]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【正确代码示例】 如下代码示例中，在对外部数据进行解析并将内容保存到name中，考虑了name的大小： int num = ... char str[13]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【错误代码示例】(realpath) 如下代码示例中，试图将路径标准化，但是目标存储空间的长度不足： #define MAX_PATH_LEN 100 char resolved_path[MAX_PATH_LEN]; / * - realpath函数的存储缓冲区长度是由PATH_MAX常量定义， - 或是由_PC_PATH_MAX系统值配置的，通常都大于100字节 */ char *res = realpath(path, resolved_path); ... 【正确代码示例】 可以将realpath的第二个参数传入NULL, 以让系统自动分配合适的内存。 char *resolved_path = NULL; resolved_path = realpath(path, NULL); if (resolved_path == NULL) { ... // 处理错误 } ... if (resolved_path != NULL) { free(resolved_path); resolved_path = NULL; } ... ","date":"0001-01-01","objectID":"/securecoding/:8:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"对字符串进行存储操作，确保字符串有null结束符 【描述】 部分字符串处理函数操作字符串时，将截断超出指定长度的字符串，如strncpy()函数最多复制n个字符到目的缓冲区，如果源字符串长度大于n，则不会写入null结束符到目的缓冲区，目的缓冲区的内容为n个被复制的字符。使用这类函数时，可能会无意截断导致数据丢失，并在某些情况下会导致软件漏洞。 因此，对字符串进行存储操作，必须确保字符串有null结束符，否则在后续的调用strlen等操作中，可能会导致内存越界访问漏洞。 【错误代码示例】 在如下代码示例中，使用strncpy函数复制字符串时可能会发生截断（发生条件为：strlen(name) \u003e sizeof(file_name) - 1）。当发生截断时，file_name的内容是不完整的，并且缺少 ’ 0 ‘结束符，后续对file_name的操作可能会导致软件漏洞： #define FILE_NAME_LEN 128 char file_name [FILE_NAME_LEN ]; (void)strncpy(file_name, name, sizeof(file_name) - 1); ... 【正确代码示例】 #define FILE_NAME_LEN 128 char file_name[FILE_NAME_LEN ]; if (strlen(name) \u003e FILE_NAME_LEN - 1) { ... // 处理错误 } (void)strcpy(file_name, name); ... 【例外】 程序员的目的是故意截断字符串。 【相关软件CWE编号】 CWE-170，CWE-464 断言 ","date":"0001-01-01","objectID":"/securecoding/:9:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理 【描述】 断言主要用于调试期间，在编译Release版本时将其关闭。因此，断言应该用于防止不正确的程序员假设，而不能用在Release版本上检查程序运行过程中发生的错误。 断言永远不应用于验证是否存在运行时（与逻辑相对）错误，例如 无效的用户输入（包括命令行参数和环境变量） 文件错误（例如，打开，读取或写入文件时出错） 网络错误（包括网络协议错误） 内存不足的情况（例如，malloc()类似的故障） 系统资源耗尽（例如，文件描述符，进程，线程） 系统调用错误（例如，执行文件，锁定或解锁互斥锁时出错） 无效的权限（例如，文件，内存，用户） 例如，防止缓冲区溢出的代码不能使用断言实现，因为该代码必须编译到Release版本的可执行文件中。 如果服务器程序在网运行时由恶意用户触发断言失败，会导致拒绝服务攻击。在这种情况下，更适合使用软故障模式，例如写入日志文件和拒绝请求。 【错误代码示例】 以下代码的所有ASSERT的用法是错误的。例如，错误的使用ASSERT宏来验证内存分配是否成功，因为内存的可用性取决于系统的整体状态，并且在程序运行的任何时候都可能耗尽，所以必须以具有韧性的方式来妥善处理并将程序从内存耗尽中恢复。因此，使用ASSERT宏来验证内存分配是否成功将是不合适的，因为这样做可能导致进程突然终止，从而开启了拒绝服务攻击的可能性。 FILE *fp = fopen(path, \"r\"); ASSERT(fp != NULL); // 错误用法：文件有可能打开失败 char *str = (char *)malloc(MAX_LINE); ASSERT(str != NULL); // 错误用法：内存有可能分配失败 ReadLine(fp, str); char *p = strstr(str, \"age=\"); ASSERT(p != NULL); // 错误用法：文件中不一定存在该字符串 char *end = NULL; long age = strtol(p + 4, \u0026end, 10); ASSERT(age \u003e 0); // 错误用法：文件内容不一定符合预期 【正确代码示例】 下面代码演示了如何重构上面的错误代码: FILE *fp = fopen(path, \"r\"); if (fp == NULL) { ... // 错误处理 } char *str = (char *)malloc(MAX_LINE); if (str == NULL) { ... // 错误处理 } read_line(fp, str); char *p = strstr(str, \"age=\"); if (p == NULL) { ... // 错误处理 } char *end = NULL; long age = strtol(p + 4, \u0026end, 10); if (age \u003c= 0) { ... // 错误处理 } ","date":"0001-01-01","objectID":"/securecoding/:10:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在断言内改变运行环境 【描述】 在程序正式发布阶段，断言不会被编译进去，为了确保调试版和正式版的功能一致性，严禁在断言中使用任何赋值、修改变量、资源操作、内存申请等操作。 例如，以下的断言方式是错误的： ASSERT(p1 = p2); // p1被修改 ASSERT(i++ \u003e 1000); // i被修改 ASSERT(close(fd) == 0); // fd被关闭 函数设计 ","date":"0001-01-01","objectID":"/securecoding/:11:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"数组作为函数参数时，必须同时将其长度作为函数的参数 【描述】 通过函数参数传递数组函数参数必须同时传递数组可容纳元素的个数，而不是以字节为单位的数组最大大小；同样，通过函数参数传递一块内存进行读写操作时，必须同时传递内存块大小，否则函数在访问内存偏移时，无法判断偏移的合法范围，产生越界访问的漏洞。在本规则中所说的\"数组\"不仅局限为数组类型变量，还包括字符串或指向连续内存块的指针。 【错误代码示例】 如下代码示例中，函数pars_msg不知道msg的范围，容易产生内存越界访问漏洞。 int parse_msg(unsigned char *msg) { ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg); ... } 【正确代码示例】 正确的做法是将msg的大小作为参数传递到parse_msg中，如下代码： int parse_msg(unsigned char *msg, size_t msg_len) { ASSERT(msg != NULL); ASSERT(msg_len != 0); ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg, len); ... } ","date":"0001-01-01","objectID":"/securecoding/:12:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"函数的指针参数如果不是用于修改所指向的对象就应该声明为指向const的指针 【描述】 const 指针参数，将限制函数通过该指针修改所指向对象，使代码更牢固、更安全。 示例：如strncmp 的例子，指向的对象不变化的指针参数声明为const。 // 正确：不变参数声明为const int strncmp(const char *s1, const char *s2, size_t n); 注意： 指针参数要不要加const取决于函数设计，而不是看函数实体内有没有发生\"修改对象\"的动作。 ","date":"0001-01-01","objectID":"/securecoding/:13:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，禁止format参数受外部数据控制 【描述】 调用格式化函数时，如果format参数由外部数据提供，或由外部数据拼接而来，会造成字符串格式化漏洞。 攻击者如果能够完全或者部分控制格式字符串内容，可以使被攻击的进程崩溃、查看栈内容、查看内存内容或者在任意内存位置写入数据。结果是，攻击者能够以被攻击进程的权限执行任意代码。 格式化输出函数特别危险，这是因为许多程序员没有意识到它们是具有攻击能力的。比如：格式化输出函数可以使用%n转换符，向指定地址写入一个整数值。 这些格式化函数有： 格式化输出函数: xxxprintf; 格式化输入函数: xxxscanf; 格式化错误消息函数: err(), verr(), errx(), verrx(), warn(), vwarn(), warnx(), vwarnx(), error(), error_at_line(); 格式化日志函数: syslog(), vsyslog(). 【错误代码示例】 如下代码示例中的incorrect_password()函数的功能是在身份验证无效时（指定用户没有找到或者密码不正确），显示一条错误信息。 该函数接受一个源自用户的字符串数据user，而user是未验证的，是外部可控的。 该函数将user构造一条错误信息，然后用C语言标准函数fprintf打印到stderr。 // 调用者需保证入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fprintf(stderr, msg); // msg中有来自未验证的外部数据，存在格式化漏洞 } free(msg); } 示例代码中首先计算了消息的长度，然后分配内存，接着利用snprintf()函数拼接了消息内容。因此消息内容中包含了msg_format的内容和用户的内容。 当入参user中含有用户输入的格式符（如%s,%p,%n等后，fprintf()在执行时，会将msg作为一个格式化字符串来进行解析，而不是直接输出消息内容， 也就是说此时msg中的内容不会被直接打印到stderr中，反而会将一些未知的数据打印到stderr，引发程序未定义的行为。这是一个非常严重的格式化漏洞。 【正确代码示例】 下面是第一种推荐做法，代码中使用fputs()来代替fprintf()函数，fputs()会直接将msg的内容输出到stderr中，而不会去解析它。 // 入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; // 这里加法运算不会整数溢出，因为user有限制 size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fputs(stderr, msg); // 使用fputs函数代替fprintf函数 } free(msg); } 【正确代码示例】 下面是第二种推荐做法，代码中将不受信任的用户输入user作为fprintf()的可选参数之一，用\"%s\"将user以字符串的形式固定下来，然后输出到stderr中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void incorrect_password(const char *user) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; fprintf(stderr, msg_format, user); } 【错误代码示例】 如下代码示例中，使用了POSIX函数syslog()，但是syslog()函数也可能出现格式字符串漏洞。 void foo(void) { char *msg = get_msg(); ... syslog(LOG_INFO, msg); // 存在格式化漏洞 } 【正确代码示例】 下面是推荐做法，代码中将不受信任的用户输入msg作为syslog()的可选参数之一，用\"%s\"将msg以字符串的形式固定下来，然后输出到系统日志中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void foo(void) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; char *msg = get_msg(); ... syslog(LOG_INFO, msg_format, msg); // 这里没有格式化漏洞 } 函数使用 ","date":"0001-01-01","objectID":"/securecoding/:14:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，使用有效的格式字符串 【描述】 格式化输入/输出函数（如fscanf()/fprintf()及相关函数）在format字符串控制下进行转换、格式化、打印其实参。 在创建格式化字符串时的常见错误包括： format中参数个数与实参个数不一致； 使用无效的转换指示符； 使用与转换指示符不兼容的标志字符； 使用与转换指示符不兼容的长度修饰符； format中转换指示符与实参类型不匹配； 使用int以外类型的实参指定宽度或者精度； 不要为格式化输入/输出函数提供未知的或者无效的转换规格，以及标志字符、精度、长度修饰符、转换指示符的无效组合。同样，不要提供与格式化字符串中的转换指示符类型不匹配的实参。这可能会使程序产生未定义行为。 【错误代码示例】 如下代码示例中，printf()的实参infoLevel类型与对应的转换指示符 ’s ‘不匹配，正确的转换指示符要使用 ’d ‘。同样，实参infoMsg类型与对应的转换指示符 ’d ‘不匹配，正确的转换指示符要使用 ’s ‘。 这些用法会使程序产生未定义行为，比如：printf()将把infoLevel实参解释为指针，试图从infoLevel包含的地址中读取一个字符串，从而发生非法访问。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %s, infoMsg: %d\\n\", info_level, info_msg); ... } 【正确代码示例】 正确的做法是确保printf()函数的实参匹配format的转换指示符。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %d, infoMsg: %s\\n\", info_level, info_msg); ... } 【影响】 错误的格式串可能造成内存破坏或者程序异常终止。 ","date":"0001-01-01","objectID":"/securecoding/:15:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用alloca()函数申请栈上内存 【描述】 POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。 请使用malloc从堆中动态分配内存。 【影响】 程序栈的大小非常有限，如果分配导致栈溢出，则程序产生未定义行 ","date":"0001-01-01","objectID":"/securecoding/:16:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用realloc()函数 【描述】 realloc()是一个非常特殊的函数，原型如下： void *realloc(void *ptr, size_t size); 随着参数的不同，其行为也是不同： 当ptr不为NULL，且size不为0时，该函数会重新调整内存大小，并将新的内存指针返回，并保证最小的size的内容不变； 参数ptr为NULL，但size不为0，那么其行为等同于malloc(size)； 参数size为0，则realloc的行为等同于free(ptr)。 由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编程中提供了一些便利性，如果认识不足，使用不当，是却极易引发各种bug。 【错误代码示例】 如下代码示例中，使用realloc不当导致内存泄漏。 代码中希望对ptr的空间进行扩充，当realloc()分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的，如果直接将realloc()的返回值赋给ptr，那么ptr原来指向的内存就会丢失，造成内存泄漏。 // 当realloc()分配内存失败时会返回NULL，导致内存泄漏 char *ptr = (char *)realloc(ptr, NEW_SIZE); if (ptr == NULL) { ...// 错误处理 } 【正确代码示例】 使用malloc()函数代替realloc()函数。 // 使用malloc()函数代替realloc()函数 char *new_ptr = (char *)malloc(NEW_SIZE); if (new_ptr == NULL) { ... // 错误处理 } (void)memcpy(new_ptr, old_ptr, old_size); ... // 返回前，释放old_Ptr 【影响】 使用不当容易造成内存泄漏和双重释放问题。不正确的内存对齐可能导致对象访问异常。 ","date":"0001-01-01","objectID":"/securecoding/:17:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止外部可控数据作为进程启动函数的参数 【描述】 本条款中进程启动函数包括system、popen、execl、execlp、execle、execv、execvp等。 system()、popen()等函数会创建一个新的进程，如果外部可控数据作为这些函数的参数，会导致注入漏洞。 使用execl()、execlp()等函数执行新进程时，如果使用shell启动的新进程，则同样存在命令注入风险。 因此，总是优先考虑使用C标准函数实现需要的功能。如果确实需要使用这些函数，请使用白名单机制确保这些函数的参数不受任何外来数据的影响。 【错误代码示例】 如下代码示例中，使用 system() 函数执行 cmd 命令串来自外部，攻击者可以执行任意命令： char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } system(cmd); 如下代码示例中，使用 system() 函数执行 cmd 命令串的一部分来自外部，攻击者可能输入 ‘some dir;useradd xxx ‘字符串，创建一个xxx的用户： char cmd[MAX_LEN ]; int ret; char *name = get_dir_name_from_remote(); if (name == NULL) { ... // 处理错误 } ret = sprintf(cmd, \"ls %s\", name); ... system(cmd); 使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析器(如/bin/sh)。 int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); 例如，禁止如下使用方式： char *cmd = get_dir_name_from_remote(); execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL); 【正确代码示例】 (使用库函数) 在Linux下实现对当前目录下文件名的打印，可以使用opendir(), readdir(), stat()等函数直接实现ls-l命令的功能，不必使用system()函数。下面是一个简化的ls -l示例版本，列出一个由程序内部指定的文件的信息，该函数仅考虑了不需要重入的情况。 static int OutputFileInfo(const char *file_name) { const char priv[] = {'x', 'w', 'r'}; ASSERT(file_name != NULL); struct stat st; int ret = stat(file_name, \u0026st); if (ret == -1) { return -1; } const struct passwd *pw = getpwuid(st.st_uid); if (pw == NULL) { return -1; } const struct group *gp = getgrgid(st.st_gid); if (gp == NULL) { return -1; } if (S_ISREG(st.st_mode)) { printf(\"-\"); } else if (S_ISDIR(st.st_mode)) { printf(\"d\"); } for (int i = 8; i \u003e= 0; i --) { if ((st.st_mode \u0026 (1 \u003c \u003c i)) != 0) { printf(\"%c\", priv[i % 3]); } else { printf(\"-\"); } } printf(\"%s %s %ld %s\\n\", pw-\u003epw_name, gp-\u003egr_name, st.st_size, file_name); return 0; } 【正确代码示例】 (使用exec系列函数) 可以通过库函数简单实现的功能（如上例），需要避免调用命令处理器来执行外部命令。如果确实需要调用单个命令，应使用exec *函数来实现参数化调用，并对调用的命令实施白名单管理。 pid_t pid; char * const envp[] = { NULL }; ... char *file_name = get_dir_name_from_remote(); if (file_name == NULL) { ... // 处理错误 } ... if ((pid = fork()) \u003c 0) { ... } else if (pid == 0) { // 使用some_tool对指定文件进行加工 execle( \"/bin/some_tool\", \"some_tool\", file_name, NULL, envp); _Exit(-1); } ... int status; waitpid(pid, \u0026status, 0); FILE *fp = fopen(file_name, \"r\"); ... 此时，外部输入的file_name仅作为some_tool命令的参数，没有命令注入的风险。 【正确代码示例】 (使用白名单) 对输入的文件名基于合理的白名单检查，避免命令注入。 char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } // 使用白名单检查命令是否合法，仅允许 \"some_tool_a\", \"some_tool_b\"命令，外部无法随意控制 if (!is_valid_cmd(cmd)) { ... // 处理错误 } system(cmd); ... 【相关软件CWE编号】 CWE-676，CWE-88 ","date":"0001-01-01","objectID":"/securecoding/:18:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在信号处理例程中调用非异步安全函数 【描述】 在信号处理程序中只调用异步安全函数。 除了C语言标准函数以外，其他系统函数也提供了一些的异步安全函数，在信号处理程序中使用这些函数之前，应确保调用的函数在所有可能的执行环境下均是异步安全的。 【错误代码示例】 如下代码示例中，信号处理函数中调用了非异步安全函数printf()： void handler(int num) { printf(\"receive signal = %d \\n\", SIGINT); } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { ... // 程序主循环代码 } return 0; } 【正确代码示例】 如下代码示例中，尽量不在信号处理函数中调用其他函数，仅在信号处理程序中修改volatile sig_atomic_t类型的变量： static volatile sig_atomic_t g_flag = 0; void handler(int num) { g_flag = 1; } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { if (g_flag != 0) { printf(\"receive signal = %d\\n\", SIGINT); } ... // 程序主循环代码 } ... return 0; } 【相关软件CWE编号】 CWE-479 内存 ","date":"0001-01-01","objectID":"/securecoding/:19:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存分配后必须判断是否成功 【描述】 内存分配一旦失败，那么后续的操作会存在未定义的行为风险。比如malloc申请失败返回了空指针，对空指针的解引用是一种未定义行为。 【错误代码示例】 如下代码示例中，调用malloc分配内存之后，没有判断是否成功，直接引用了p。如果malloc失败，它将返回一个空指针并传递给p。当如下代码在内存拷贝中解引用了该空指针p时，程序会出现未定义行为。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm*)malloc(sizeof(*tmb)); tmb-\u003eyear = year; ... return tmb; } 【正确代码示例】 如下代码示例中，在malloc分配内存之后，立即判断其是否成功，消除了上述的风险。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm *)malloc(sizeof(*tmb)); if (tmb == NULL) { ... // 错误处理 } tmb-\u003eyear = year; ... return tmb; } ","date":"0001-01-01","objectID":"/securecoding/:20:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部输入作为内存操作相关函数的复制长度时，需要校验其合法性 【描述】 将数据复制到容量不足以容纳该数据的内存中会导致缓冲区溢出。为了防止此类错误，必须根据目标容量的大小限制被复制的数据大小，或者必须确保目标容量足够大以容纳要复制的数据。 【错误代码示例】 外部输入的数据不一定会直接作为内存复制长度使用，还可能会间接参与内存复制操作。 如下代码示例中，inputTable-\u003ecount来自外部报文，虽然没有直接作为内存复制长度使用，而是作为for循环体的上限使用，间接参与了内存复制操作。由于没有校验其大小，可造成缓冲区溢出： typedef struct { size_t count; int val[MAX_num_bERS]; } ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } 【正确代码示例】 如下代码示例中，对input_table-\u003ecount做了校验。 typedef struct { size_t count; int val[MAX_num_bERS]; }ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... / * - 根据应用场景，对来自外部报文的循环长度input_table-\u003ecount - 与output_table-\u003eval数组大小做校验，避免造成缓冲区溢出 */ if (input_table-\u003ecount \u003e sizeof(output_table-\u003eval) / sizeof(output_table-\u003eval[0]){ return NULL; } for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } ","date":"0001-01-01","objectID":"/securecoding/:21:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存中的敏感信息使用完毕后立即清0 【描述】 内存中的口令、密钥等敏感信息使用完毕后立即清0，避免被攻击者获取或者无意间泄漏给低权限用户。这里所说的内存包括但不限于： 动态分配的内存 静态分配的内存 自动分配（堆栈）内存 内存缓存 磁盘缓存 【错误代码示例】 通常内存在释放前不需要清除内存数据，因为这样在运行时会增加额外开销，所以在这段内存被释放之后，之前的数据还是会保留在其中。如果这段内存中的数据包含敏感信息，则可能会意外泄漏敏感信息。为了防止敏感信息泄漏，必须先清除内存中的敏感信息，然后再释放。 在如下代码示例中，存储在所引用的动态内存中的敏感信息secret被复制到新动态分配的缓冲区newSecret，最终通过free()释放。因为释放前未清除这块内存数据，这块内存可能被重新分配到程序的另一部分，之前存储在newSecret中的敏感信息可能会无意中被泄露。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... free(new_secret); new_secret = NULL; } ... 【正确代码示例】 如下代码示例中，为了防止信息泄漏，应先清除包含敏感信息的动态内存（用 ’ 0 ‘字符填充空间），然后再释放它。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... (void)memset(new_secret, 0, size + 1); free(new_secret); new_secret = NULL; } ... 【正确代码示例】 下面是另外一个涉及敏感信息清理的场景，在代码获取到密码后，将密码保存到password中，进行密码验证，使用完毕后，通过memset对password清0。 int foo(void) { char password [MAX_PWD_LEN ] = {0}; if (!get_password(password, sizeof(password))) { ... // 处理错误 } if (!verify_password(password)) { ... // 处理错误 } ... (void)memset(password, 0, sizeof(password)); ... } 文件 ","date":"0001-01-01","objectID":"/securecoding/:22:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"创建文件时必须显式指定合适的文件访问权限 【描述】 创建文件时，如果不显式指定合适访问权限，可能会让未经授权的用户访问该文件，造成信息泄露，文件数据被篡改，文件中被注入恶意代码等风险。 虽然文件的访问权限也依赖于文件系统，但是当前许多文件创建函数（例如POSIX open函数）都具有设置（或影响）文件访问权限的功能，所以当使用这些函数创建文件时，必须显式指定合适的文件访问权限，以防止意外访问。 【错误代码示例】 使用POSIX open()函数创建文件但未显示指定该文件的访问权限，可能会导致文件创建时具有过高的访问权限，这可能会导致漏洞。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name fd = open(file_name, O_CREAT | O_WRONLY); // 没有显式指定访问权限 if (fd == -1) { ... // 错误处理 } ... } 【正确代码示例】 应该在open的第三个参数中显式指定新创建文件的访问权限。可以根据文件实际的应用情况设置何种访问权限。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name 和指定其访问权限 // 此处根据文件实际需要，显式指定其访问权限 int fd = open(file_name, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR); if (fd == -1) { ... // 错误处理 } ... } ","date":"0001-01-01","objectID":"/securecoding/:23:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对文件路径进行规范化后再使用 【描述】 当文件路径来自外部数据时，必须对其做合法性校验，如果不校验，可能造成系统文件的被任意访问。但是禁止直接对其进行校验，正确做法是在校验之前必须对其进行路径规范化处理，因为： 同一个文件可以通过多种形式的路径来描述和引用，例如既可以是绝对路径，也可以是相对路径；而且路径名、目录名和文件名可能包含使校验变得困难和不准确的字符（如：\".\"、\"..\"）。此外，文件还可以是符号链接，这进一步模糊了文件的实际位置或标识，增加了校验的难度和校验准确性。所以必须先将文件路径规范化，从而更容易校验其路径、目录或文件名，增加校验准确性，如使用realpath函数。 一个简单的案例说明如下： 当文件路径来自外部数据时，需要先将文件路径规范化，如果没有作规范化处理，攻击者就有机会通过恶意构造文件路径进行文件的越权访问。 例如，攻击者可以构造\"../../../etc/passwd\"的方式进行任意文件访问。 【错误代码示例】 在此错误的示例中，argv[1]包含一个源于受污染源的文件名，并且该文件名已打开以进行写入。在使用此文件名操作之前，应该对其进行验证，以确保它引用的是预期的有效文件。 不幸的是，argv[1]引用的文件名可能包含特殊字符，例如目录字符，这使验证变得困难，甚至不可能。而且，argv[1]中可能包含可以指向任意文件路径的符号链接，即使该文件名通过了验证，也会导致该文件名是无效的。 这种场景下，对文件名的直接验证即使被执行也是得不到预期的结果，对fopen()的调用可能会导致访问一个意外的文件。 ... if (!verify_file(input_file_name) { // 没有对input_file_name做规范化，直接做校验 ... // 错误处理 } if (fopen(input_file_name, \"w\") == NULL) { ... // 错误处理 } ... 【正确代码示例】 规范化文件名是具有一定难度的，因为这需要了解底层文件系统。 POSIX realpath()函数可以帮助将路径名转换为规范形式。 对上面的错误代码示例，我们采用如下解决方案： char *real_path_res = NULL; ... // 在校验之前，先对input_file_name做规范化处理 real_path_res = realpath(input_file_name, NULL); if (real_path_res == NULL) { ... // 规范化的错误处理 } // 规范化以后对路径进行校验 if (!verify_file(real_path_res) { ... // 校验的错误处理 } // 使用 if (fopen(real_path_res, \"w\") == NULL) { ... // 实际操作的错误处理 } ... free(real_path_res); real_path_res = NULL; ... 【正确代码示例】 根据我们的实际场景，我们还可以采用的第二套解决方案，说明如下： 如果PATH_MAX被定义为中的一个常量，那么使用非空的resolved_path调用realpath()也是安全的。 在本例中realpath()函数期望resolved_path引用一个字符数组，该字符数组足够大，可以容纳规范化的路径。 如果定义了PATH_MAX，则分配一个大小为PATH_MAX的缓冲区来保存realpath()的结果。正确代码示例如下： char *real_path_res = NULL; char *canonical_file_name = NULL; size_t path_size = 0; ... path_size = (size_t)PATH_MAX; if (verify_path_size(path_size) == TRUE) { canonical_file_name = (char *)malloc(path_size); if (canonical_file_name == NULL) { ... // 错误处理 } real_path_res = realpath(inputFilename, canonical_file_name); } if (real_path_res == NULL) { ... // 错误处理 } if (verify_file(real_path_res) == FALSE) { ... // 错误处理 } if (fopen(real_path_res, \"w\") == NULL ) { ... // 错误处理 } ... free(canonical_file_name); canonical_file_name = NULL; ... 【错误代码示例】 下面的代码场景是从外部获取到文件名称，拼接成文件路径后，直接对文件内容进行读取，导致攻击者可以读取到任意文件的内容： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char *text = read_file_content(untrust_path); 【正确代码示例】 正确的做法是，对路径进行规范化后，再判断路径是否是本程序所认为的合法的路径： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char path[PATH_MAX] = {0}; if (realpath(untrust_path, path) == NULL) { ... // 处理错误 } if (!is_valid_path(path)) { // 检查文件的位置是否正确 ... // 处理错误 } char *text = read_file_content(path); 【例外】 运行于控制台的命令行程序，通过控制台手工输入文件路径，可以作为本条款例外。 int main(int argc, char **argv) { int fd = -1; if (argc == 2) { fd = open(argv[1], O_RDONLY); ... } ... } ","date":"0001-01-01","objectID":"/securecoding/:24:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在共享目录中创建临时文件 【描述】 程序的临时文件应当是程序自身独享的，任何将自身临时文件置于共享目录的做法，将导致其他共享用户获得该程序的额外信息，产生信息泄露。因此，不要在任何共享目录创建仅由程序自身使用的临时文件。 程序员通常会在共享目录中(例如在/tmp和/var/tmp创建临时文件，并且还有可能会定期清除这些临时文件(例如，每晚或重新启动期间)，但也可能不注意清理。 临时文件通常用于辅助保存不能驻留在内存中的数据或存储临时的数据，也可用作进程间通信的一种手段（通过文件系统传输数据）。例如，一个进程在共享目录中创建一个临时文件，该文件名可能使用了众所周知的名称或者一个临时的名称，然后就可以通过该文件在进程间共享信息。这种通过在共享目录中创建临时文件的方法实现进程间共享的做法很危险，因为共享目录中的这些文件很容易被攻击者劫持或操纵。这里有几种缓解策略： 1.使用其他低级IPC（进程间通信）机制，例如套接字或共享内存。 2.使用更高级别的IPC机制，例如远程过程调用。 3.使用仅能由程序本身访问的安全目录(多线程/进程下注意防止条件竞争)。 同时，下面列出了几项临时文件创建使用的方法，产品根据具体场景执行以下一项或者几项，同时产品也可以自定义合适的方法。 1.文件必须具有合适的权限，只有符合权限的用户才能访问 2.创建的文件名是唯一的、或不可预测的 3.仅当文件不存在时才创建打开(原子创建打开) 4.使用独占访问打开，避免竞争条件 5.在程序退出之前移除 同时也需要注意到，当某个目录被开放读/写权限给多个用户或者一组用户时，该共享目录潜在的安全风险远远大于访问该目录中临时文件这个功能的本身。 如果想安全地在共享目录中创建临时文件，而不受威胁是不容易的。例如，用于本地挂载的文件系统的代码在与远程挂载的文件系统一起共享使用时可能会受到攻击。而且上面的函数安全版本还受限于所使用的C运行时库、操作系统和文件系统的版本。唯一安全的解决方案是不要在共享目录中创建临时文件。 【错误代码示例】 如下代码示例，程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。 由于文件名是硬编码的，因此是可预测的，攻击者只需用符号链接替换文件，然后链接所引用的目标文件就会被打开并写入新内容。 void proc_data(const char *file_name) { FILE *fp = fopen(file_name, \"wb+\"); if (fp == NULL) { ... // 错误处理 } ... // 写文件 fclose(fp); } int main(void) { // 不合规：1.在系统共享目录中创建临时文件；2.临时文件名硬编码 char *real_file = \"/tmp/data\"; ... proc_data(real_file); ... return 0; } 【正确案例】 Linux下的/tmp目录是一个所有用户都可以访问的共享目录，不应在该目录下创建仅由程序自身使用的临时文件。 【业界典型漏洞】CVE-2004-2502 其它 ","date":"0001-01-01","objectID":"/securecoding/:25:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在信号处理函数中访问共享对象 【描述】 在信号处理程序中访问和修改共享对象可能会造成竞争条件，使数据处于不确定的状态。 这条规则有两个不适用的场景（C11标准第5.1.2.3章节第5段）是： 1） 读写不需要加锁的原子对象; 2）读写volatile sig_atomic_t类型的对象，因为具有volatile sig_atomic_t类型的对象即使在出现异步中断的时候也可以作为一个原子实体访问，是异步安全的。 此外，在信号处理程序中，如果要调用函数，请仅调用异步信号安全函数。 【错误代码示例】 在这个信号处理过程中，程序打算将p_msg作为共享对象，当产生SIGINT信号时更新共享对象的内容，但是该p_msg变量类型不是volatile sig_atomic_t，所以不是异步安全的。 #define MAX_MSG_SIZE 32 static char g_msg_buf[MAX_MSG_SIZE] = {0}; static char *g_msg = g_msg_buf; void signal_handler(int signum) { // 下面代码操作g_msg不合规，因为不是异步安全的 (void)memset(g_msg, 0, MAX_MSG_SIZE); strcpy(g_msg, \"signal SIGINT received.\"); ... // } int main(void) { strcpy(g_msg, \"No msg yet.\"); // 初始化消息内容 signal(SIGINT, signal_handler); // 设置SIGINT信号对应的处理函数 ... // 程序主循环代码 return 0; } 【正确代码示例】 如下代码示例中，在信号处理函数中仅将volatile sig_atomic_t类型作为共享对象使用。 #define MAX_MSG_SIZE 32 volatile sig_atomic_t g_sig_flag = 0; void signal_handler(int signum) { g_sig_flag = 1; // 合规 } int main(void) { signal(SIGINT, signal_handler); char msg_buf[MAX_MSG_SIZE]; strcpy(msg_buf, \"No msg yet.\"); // 初始化消息内容 ... // 程序主循环代码 if (g_sig_flag == 1) { // 在退出主循环之后，根据sigFlag状态再刷新消息内容 strcpy(msgBuf, \"signal SIGINT received.\"); } return 0; } 【相关软件CWE编号】 CWE-662，CWE-828 ","date":"0001-01-01","objectID":"/securecoding/:26:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁用rand函数产生用于安全用途的伪随机数 【描述】 C语言标准库rand()函数生成的是伪随机数，所以不能保证其产生的随机数序列质量。所以禁止使用rand()函数产生的随机数用于安全用途，必须使用安全的随机数产生方式，如： /dev/random文件。 典型的安全用途场景包括(但不限于)以下几种： 会话标识SessionID的生成； 挑战算法中的随机数生成； 验证码的随机数生成； 用于密码算法用途（例如用于生成IV、盐值、密钥等）的随机数生成。 【错误代码示例】 程序员期望生成一个唯一的不可被猜测的HTTP会话ID，但该ID是通过调用rand()函数产生的数字随机数，它的ID是可猜测的，并且随机性有限。 【正确代码示例】(POSIX) 可以使用/dev/random文件得到随机数。 【影响】 使用rand()函数可能造成可预测的随机数。 内核操作 ","date":"0001-01-01","objectID":"/securecoding/:27:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核mmap接口实现中，确保对映射起始地址和大小进行合法性校验 【描述】 **说明：**Linux内核 mmap接口中，经常使用remap_pfn_range()函数将设备物理内存映射到用户进程空间。如果映射起始地址等参数由用户态控制并缺少合法性校验，将导致用户态可通过映射读写任意内核地址。如果攻击者精心构造传入参数，甚至可在内核中执行任意代码。 【错误代码示例】 如下代码在使用remap_pfn_range()进行内存映射时，未对用户可控的映射起始地址和空间大小进行合法性校验，可导致内核崩溃或任意代码执行。 static int incorrect_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); //错误：未对映射起始地址、空间大小做合法性校验 if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log(\"%s, remap_pfn_range fail\", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } 【正确代码示例】 增加对映射起始地址等参数的合法性校验。 static int correct_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; //修改：添加校验函数，验证映射起始地址、空间大小是否合法 if (!valid_mmap_phys_addr_range(vma-\u003evm_pgoff, size)) { return EINVAL; } vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log( \"%s, remap_pfn_range fail \", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } ","date":"0001-01-01","objectID":"/securecoding/:28:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核程序中必须使用内核专用函数读写用户态缓冲区 【描述】 用户态与内核态之间进行数据交换时，如果在内核中不加任何校验（如校验地址范围、空指针）而直接引用用户态传入指针，当用户态传入非法指针时，可导致内核崩溃、任意地址读写等问题。因此，应当禁止使用memcpy()、sprintf()等危险函数，而是使用内核提供的专用函数：copy_from_user()、copy_to_user()、put_user()和get_user()来读写用户态缓冲区，这些函数内部添加了入参校验功能。 所有禁用函数列表为：memcpy()、bcopy()、memmove()、strcpy()、strncpy()、strcat()、strncat()、sprintf()、vsprintf()、snprintf()、vsnprintf()、sscanf()、vsscanf()。 【错误代码示例】 内核态直接使用用户态传入的buf指针作为snprintf()的参数，当buf为NULL时，可导致内核崩溃。 ssize_t incorrect_show(struct file *file, char__user *buf, size_t size, loff_t *data) { // 错误：直接引用用户态传入指针，如果buf为NULL，则空指针异常导致内核崩溃 return snprintf(buf, size, \"%ld\\n\", debug_level); } 【正确代码示例】 使用copy_to_user()函数代替snprintf()。 ssize_t correct_show(struct file *file, char __user *buf, size_t size, loff_t *data) { int ret = 0; char level_str[MAX_STR_LEN] = {0}; snprintf(level_str, MAX_STR_LEN, \"%ld \\n\", debug_level); if(strlen(level_str) \u003e= size) { return EFAULT; } // 修改：使用专用函数copy_to_user()将数据写入到用户态buf，并注意防止缓冲区溢出 ret = copy_to_user(buf, level_str, strlen(level_str)+1); return ret; } 【错误代码示例】 内核态直接使用用户态传入的指针user_buf作为数据源进行memcpy()操作，当user_buf为NULL时，可导致内核崩溃。 size_t incorrect_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf [128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 错误：直接引用用户态传入指针，如果user_buf为NULL，则可导致内核崩溃 (void)memcpy(buf, user_buf, buf_size); ... } 【正确代码示例】 使用copy_from_user()函数代替memcpy()。 ssize_t correct_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf[128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 修改：使用专用函数copy_from_user()将数据写入到内核态buf，并注意防止缓冲区溢出 if (copy_from_user(buf, user_buf, buf_size)) { return EFAULT; } ... } ","date":"0001-01-01","objectID":"/securecoding/:29:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_from_user()拷贝长度进行校验，防止缓冲区溢出 **说明：**内核态从用户态拷贝数据时通常使用copy_from_user()函数，如果未对拷贝长度做校验或者校验不当，会造成内核缓冲区溢出，导致内核panic或提权。 【错误代码示例】 未校验拷贝长度。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))) {...} // 错误：拷贝长度参数smd_write_arg.size由用户输入，未校验 copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } 【正确代码示例】 添加长度校验。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))){...} // 修改：添加校验 if (smd_write_arg.size \u003e= GSERIAL_BUF_LEN) {......} copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } ","date":"0001-01-01","objectID":"/securecoding/:30:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_to_user()拷贝的数据进行初始化，防止信息泄漏 【描述】 **说明：**内核态使用copy_to_user()向用户态拷贝数据时，当数据未完全初始化（如结构体成员未赋值、字节对齐引起的内存空洞等），会导致栈上指针等敏感信息泄漏。攻击者可利用绕过kaslr等安全机制。 【错误代码示例】 未完全初始化数据结构成员。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; // 错误: info结构体有4个成员，未全部赋值 ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } 【正确代码示例】 全部进行初始化。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; // 修改：使用memset初始化缓冲区，保证不存在因字节对齐或未赋值导致的内存空洞 (void)memset(\u0026info, '0', sizeof(ep_info)); switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } ","date":"0001-01-01","objectID":"/securecoding/:31:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在异常处理中使用BUG_ON宏，避免造成内核panic 【描述】 BUG_ON宏会调用内核的panic()函数，打印错误信息并主动崩溃系统，在正常逻辑处理中（如ioctl接口的cmd参数不识别）不应当使系统崩溃，禁止在此类异常处理场景中使用BUG_ON宏，推荐使用WARN_ON宏。 【错误代码示例】 正常流程中使用了BUG_ON宏 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 错误：系统BUG_ON宏打印调用栈后调用panic()，导致内核拒绝服务，不应在正常流程中使用 BUG_ON(1); return 1; } ... } 【正确代码示例】 去掉BUG_ON宏。 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 修改：去掉BUG_ON调用，或使用WARN_ON return 1; } ... } ","date":"0001-01-01","objectID":"/securecoding/:32:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"在中断处理程序或持有自旋锁的进程上下文代码中，禁止使用会引起进程休眠的函数 【描述】 Linux以进程为调度单位，在Linux中断上下文中，只有更高优先级的中断才能将其打断，系统在中断处理的时候不能进行进程调度。如果中断处理程序处于休眠状态，就会导致内核无法唤醒，从而使得内核处于瘫痪。 自旋锁在使用时，抢占是失效的。若自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其它进程都将因为不能获得CPU（单核CPU）而停止运行，对外表现为系统将不作任何响应，出现挂死。 因此，在中断处理程序或持有自旋锁的进程上下文代码中，应该禁止使用可能会引起休眠（如vmalloc()、msleep()等）、阻塞（如copy_from_user(),copy_to_user()等）或者耗费大量时间（如printk()等）的函数。 ","date":"0001-01-01","objectID":"/securecoding/:33:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"合理使用内核栈，防止内核栈溢出 【描述】 Linux的内核栈大小是固定的（一般32位系统为8K，64位系统为16K，因此资源非常宝贵。不合理的使用内核栈，可能会导致栈溢出，造成系统挂死。因此需要做到以下几点： 在栈上申请内存空间不要超过内核栈大小； 注意函数的嵌套使用次数； 不要定义过多的变量。 【错误代码示例】 以下代码中定义的变量过大，导致栈溢出。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result temp[512]; // 错误: temp数组含有512个元素，总大小为10K，远超内核栈大小 (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something return 0; } ... 代码中数组temp有512个元素，总共10K大小，远超内核的8K，明显的栈溢出。 【正确代码示例】 使用kmalloc()代替之。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result *temp = NULL; temp = (result *)kmalloc(sizeof(result) * 512, GFP_KERNEL); //修改：使用kmalloc()申请内存 ... // check temp is not NULL (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something ... // free temp return 0; } ... ","date":"0001-01-01","objectID":"/securecoding/:34:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"临时关闭地址校验机制后，在操作完成后必须及时恢复 【描述】 SMEP安全机制是指禁止内核执行用户空间的代码（PXN是ARM版本的SMEP）。系统调用（如open()，write()等）本来是提供给用户空间程序访问的。默认情况下，这些函数会对传入的参数地址进行校验，如果入参是非用户空间地址则报错。因此，要在内核程序中使用这些系统调用，就必须使参数地址校验功能失效。set_fs()/get_fs()就用来解决该问题。详细说明见如下代码： ... mmegment_t old_fs; printk(\"Hello, I'm the module that intends to write message to file.\\n\"); if (file == NULL) { file = filp_open(MY_FILE, O_RDWR | O_APPEND | O_CREAT, 0664); } if (IS_ERR(file)) { printk(\"Error occured while opening file %s, exiting ...\\n\", MY_FILE); return 0; } sprintf(buf, \"%s\", \"The Message.\"); old_fs = get_fs(); // get_fs()的作用是获取用户空间地址上限值 // #define get_fs() (current-\u003eaddr_limit set_fs(KERNEL_DS); // set_fs的作用是将地址空间上限扩大到KERNEL_DS，这样内核代码可以调用系统函数 file-\u003ef_op-\u003ewrite(file, (char *)buf, sizeof(buf), \u0026file-\u003ef_pos); // 内核代码可以调用write()函数 set_fs(old_fs); // 使用完后及时恢复原来用户空间地址限制值 ... 通过上述代码，可以了解到最为关键的就是操作完成后，要及时恢复地址校验功能。否则SMEP/PXN安全机制就会失效，使得许多漏洞的利用变得很容易。 【错误代码示例】 在程序错误处理分支，未通过set_fs()恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d]\\n\", path, fd); return; // 错误：在错误处理程序分支未恢复地址校验机制 } sys_close(fd); set_fs(oldfs); ... 【正确代码示例】 在错误处理程序中恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d] \\n\", path, fd); set_fs(oldfs); // 修改：在错误处理程序分支中恢复地址校验机制 return; } sys_close(fd); set_fs(oldfs); ... ","date":"0001-01-01","objectID":"/securecoding/:35:0","tags":null,"title":"","uri":"/securecoding/"}]