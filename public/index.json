[{"categories":["kotlin"],"content":"Kotlin程序设计初级篇 注意： 在开始学习之前，推荐各位小伙伴有一定的编程语言基础，前置课程：《JavaSE 教程》或《C 语言程序设计》如果没有其他语言的基础，在学习Kotlin时会非常吃力，这门语言语法糖多到爆炸。 Kotlin是一种现代但已经成熟的编程语言，旨在让开发人员更快乐。它简洁、安全、可与Java和其他语言互操作，并提供了许多在多个平台之间重用代码的方法。它由JetBrains公司于2011年设计和开发，并在2016年正式发布。Kotlin旨在解决Java语言在编码效率和代码质量方面存在的问题，并且与Java语言完全兼容。Kotlin通过简化语法、提供更强大的功能以及减少样板代码的编写，使得开发者能够更高效地编写清晰、简洁而又安全的代码。 Kotlin语言名字的来源是基于一个古老斯拉夫部落的名字。JetBrains开发Kotlin的初衷是为了在Android开发上取代Java，并且作为一门通用的编程语言。Kotlin通过减少样板代码和增加现代化的语言特性，提供了更好的工具和库来简化Android应用开发。由于Kotlin的设计理念和特性吸引了广泛的开发者关注，它也迅速被接受并得到了广泛的使用。现在，Kotlin已成为一门流行的编程语言，被许多开发者用于Android应用开发、服务器端开发以及其他领域的软件开发中。 官方网站：https://www.jetbrains.com/opensource/kotlin/ Kotlin 是一种现代化的静态类型编程语言，具有以下优势： 与Java互操作性强：Kotlin 可以与现有的 Java 代码无缝地互操作，允许开发者在现有的项目中逐步采用 Kotlin，而不需要重写整个项目。这使得 Kotlin 成为 Android 应用开发的理想选择。 简洁易读：Kotlin 的语法简洁并具有更好的可读性，减少了样板代码的编写。相比 Java，Kotlin 可以使用更少的代码来实现同样的功能，从而提高开发效率。 空安全性：Kotlin 对空值进行了更好的处理。在 Kotlin 中，变量默认是非空的，如果需要使用可能为空的值，需要显式声明类型为可空。这有助于减少空指针异常的发生。 函数式编程支持：Kotlin 支持函数式编程的特性，如高阶函数、lambda 表达式和函数式编程的集合操作等。这些特性可以让开发者编写更简洁、可维护的代码，并提高代码的表达能力。 扩展函数：Kotlin 允许开发者为某个类添加新的方法，而不需要修改该类的源代码。这种扩展函数的特性可以为开发者提供更灵活的方式来扩展现有的类库。 协程支持：Kotlin 引入了协程（coroutine）机制，使得异步操作更易于管理和编写。通过使用协程，开发者可以使用顺序的方式编写并发代码，并避免了回调地狱的问题。 总的来说，Kotlin 是一门功能丰富、可读性高、与 Java 无缝互操作的编程语言，适用于 Android、Web 后端开发等多种场景。 正是因为Kotlin与Java的高度兼容性，再加上简洁、安全、互操作性强等特点，让Kotlin一度成为Android开发的官方指定语言。并且随着时代的发展，现在它不仅仅可以开发安卓应用程序，也可以开发iOS程序，甚至开发Java后端、开发桌面应用程序等。其简洁高效的语法也受到一众开发者追捧。 从下节课开始，我们就来正式学习一下Kotlin语言，Kotlin，启动！ ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:0:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"走进新语言 欢迎大家进入到Kotlin程序设计的学习中，我们将从开发环境配置开始，为各位小伙伴讲解。 编程语言可以被视为人与计算机之间进行交流的方式。它是一种用于编写计算机程序的形式化语言，用于描述计算机任务的操作步骤、算法和数据结构。简单来说，就是以计算机能听懂的语言告诉计算机我们要做什么，然后让计算机来做我们想做的事情，从而解决我们生活中各种各样的问题。 编程语言可以分为多种类型，包括低级语言和高级语言。低级语言（如汇编语言）与计算机硬件更接近，对计算机底层操作进行更精细的控制，但编写和理解起来较为复杂。高级语言（如Java、Python等）则更加易读、易写，并提供了更高层次的抽象，使得程序员能够更专注于问题的解决和算法的设计。而我们这里要学习的Kotlin语言，也属于高级语言的一种，能够使用我们人类更容易理解的语法来编写程序。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"开发环境配置 要开发Kotlin程序，我们首先需要安装Java环境，我们一般使用Kotlin都是在JVM平台上进行开发（Kotlin同样可以开发系统原生程序、JavaScript程序、安卓程序、iOS程序等）因为Java支持跨平台，能在编译后再任意平台上运行，因此，我们将JVM环境中学习Kotlin程序的开发，接下来我们要安装两个环境： Java 8 环境 Kotlin 1.9.0 环境 首先我们来安装Java 8 环境，这里我们需要去下载JDK，这里推荐安装免费的ZuluJDK：https://www.azul.com/downloads/?version=java-8-lts\u0026package=jdk 在这里选择自己的操作系统对应的安装包： 比如Windows下，我们就选择.msi的安装包即可（MacOS、Linux下同样选择对应的即可） 下载完成后，我们直接双击安装： **注意，这里不建议各位小伙伴去修改安装的位置！**新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。 剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以） 我们直接输入java命令即可： 如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。 输入java -version可以查看当前安装的JDK版本： 只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。 接着是Kotlin 1.9.0 环境，我们需要前往：https://github.com/JetBrains/kotlin/releases 下载最新的Kotlin编译器并进行安装： 这里我们可以直接解压然后拖入到刚刚Java安装的同级目录下，我这里是 C:\\Program Files 文件夹，也可以自定义位置，但是不推荐，因为很多小伙伴配环境直接配到自闭。 然后我们需要手动配置一下环境变量，打开系统环境变量配置： 添加路径 C:\\Program Files\\kotlinc\\bin 到Path环境变量下即可，然后我们依然打开CMD查看是否安装成功，输入kotlinc -version来查看安装情况： 这样我们就完成了所有环境的安装，我们可以来体验一下编写并且编译运行一个简单的Kotlin程序，我们新建一个文本文档，命名为Main.txt（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容： fun main() { println(\"Hello, World!\") } 现在看不懂代码没关系，直接用就行，我们后面会一点一点讲解的。 编辑好之后，保存退出，接着我们将文件的后缀名称修改为.kt这是Java源程序文件的后缀名称： 此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径： 我们使用cd命令先进入到这个目录下： 要编译一个Kotlin程序，我们需要使用kotlinc命令来进行，将我们的程序编译为jar包，并包含Kotlin的运行时依赖： kotlinc Main.kt -include-runtime -d Main.jar 执行后，可以看到目录下多出来了一个.jar文件，这是一个打包好的标准Java程序： 接着我们就可以将其交给JVM运行了，我们直接使用java -jar命令即可： 可以看到打印了一个 Hello World! 字样，这样我们的第一个Kotlin程序就成功运行了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"IDEA安装与使用 前面我们介绍了Kotlin开发环境的安装以及成功编译运行了我们的第一个Kotlin应用程序。 但是我们发现，如果我们以后都使用记事本来进行Kotlin程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：IntelliJ IDEA（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好） IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。 下载地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE 我们直接点击下载即可，注意要下载下面的社区版，不要下载到终极版了： 这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，功能更强大，体验更友好） 下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！ 这里勾选一下创建桌面快捷方式就行： 安装完成后，我们直接打开就可以了： 此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可： 我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了： 如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题，我们还可以在下面的设置中开启新UI以及更换各种字体、字体大小等个性化内容。 如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下： 接下来，我们来看看如何使用IDEA编写Kotlin程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目： 此时来到创建页面： 名称： 你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。 位置： 项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。 语言： IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。 构建系统： 在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。 JDK： 就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦） 当然，如果JDK这里没有自动识别到，那么就手动添加一下： 没问题之后，我们直接创建项目： 进入之后，可以看到已经自动帮助我们创建好了一个kt源文件，跟我们之前的例子是一样的。要编译运行我们的Kotlin程序，只需要直接点击左边的三角形（启动按钮）即可： 点击之后，会在下方自动开始构建： 完成之后，就可以在控制台看到输出的内容了： 我们可以看到新增加了一个out目录，这里面就是刚刚编译好的.class文件，这种文件是Java的字节码文件，可以直接运行在JVM中： IDEA非常强大，即使是编译之后的字节码文件，也可以反编译回原代码的样子： 如果我们想写一个新的Kotlin项目，可以退出当前项目重新创建： 此时项目列表中就有我们刚刚创建的Java项目了： 如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习： 会有一个专门的引导教程项目，来教你如何使用各项功能： 熟悉了IDEA的使用之后，下节课我们就可以正式地开始学习Kotlin语言的语法了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"程序代码基本结构 还记得我们之前使用的示例代码吗？ fun main() { println(\"Hello World!\") } 这段代码要实现的功能很简单，就是将 Hello World 这段文本信息输出到控制台。 在编写代码时，注意需要区分大小写，Kotlin语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错： 只要源代码中存在报错的地方，就无法正常完成编译得到字节码文件，强行运行会提示构建失败： 注意这里包括的花括号是成对出现的，并且一一对应。 所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是： fun main() { } 可以看到外面使用花括号前添加了fun main()，这是我们整个程序的入口点，我们的Kotlin程序也是从这里开始从上往下执行的。而其中的println语句就是用于打印其括号中包裹的文本，我们可以看到这个文本信息使用了\"\"进行囊括，否则会报错： println(\"Hello World!\") 这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上。 比如下面的代码，我们就可以实现先打印Hello World!，然后再打印 KFC vivo 50 到控制台： fun main() { println(\"Hello World!\") println(\"KFC vivo 50\") } 效果如下： 注意我们上面编写的打印语句其实是函数的调用（后续会进行讲解）不能写到同一行中，否则编译器会认为是同一句代码，同样会导致编译不通过： 如果实在要写到同一行，那么我们需要在上一句代码最后添加;来表示上一段的结束： 再比如下面的代码： 这里我们尝试在中途换行或是添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意换行或是添加没必要的空格。注意随意换行和空格仅限于可分割区域，比如println本身是一个函数的完整名称，这就不能从中间直接断开，否则语义就完全不一样了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"程序注释编写 我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思： 但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。 这种情况，我们就需要告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了： 添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了： 那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记： 多行可以使用/*和*/的组合来囊括需要编写的注释内容。 当然还有一种方式就是使用/**来进行更加详细的文档注释： 这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。 这样，我们编写Kotlin程序的基本规则就讲解完毕了，从下一个小节开始，我们将先给各位小伙伴介绍我们的基本数据类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:1:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"变量与基本类型 我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。那么，什么是变量呢？我们在数学中其实已经学习过变量了： 变量，指值可以变的量。变量以非数字的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。 比如一个公式 x + 2 = 6 此时x就是一个变量，变量往往代表着某个值，比如这里的x就代表的是4这个值。在Kotlin中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的，在程序中，我们也可以使用变量，并且变量具有类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"计算机中的二进制表示（选学） 进入到变量的学习之前，我们需要先补充一下计算机的底层知识，否则各位小伙伴后面听起来会很困难。 在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。 注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。 十进制的7 -\u003e 在二进制中为 111 = 2^2 + 2^1 + 2^0 现在有4个bit位，最大能够表示多大的数字呢？ 最小：0000 =\u003e 0 最大：1111 =\u003e 23+22+21+20 =\u003e 8 + 4 + 2 + 1 = 15 在Kotlin中，无论是小数还是整数，他们可以带有符号，因此，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）： 最小：1111 =\u003e -(22+21+2^0) =\u003e -7 最大：0111 =\u003e +(22+21+2^0) =\u003e +7 =\u003e 7 现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例： 1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！） 我们得创造一种更好的表示方式！于是我们引入了反码： 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法： 1+(-1) = 0001 + 1110 = 1111 =\u003e -0 （直接相加，这样就简单多了！） 思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下： 正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8） 对补码再求一次补码就可得该补码对应的原码。 比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。 所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算： 1+(-1) = 0001 + 1111 = (1)0000 =\u003e +0 （现在无论你怎么算，也不会有-0了！） 所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Kotlin使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"变量的声明与使用 要声明一个变量，我们需要使用以下格式： var [变量名称] : [数据类型] 这里的数据类型我们会在下节课开始逐步讲解，比如整数就是Int类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像x一样，这个名称我们可以随便起一个，但是注意要满足以下要求： 标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。 变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。 不能有空格、@、#、+、-、/ 等符号。 应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。 不可以是 true 和 false。 不能与Kotlin语言的关键字或是基本数据类型重名 当然各位小伙伴没必要刻意去进行记忆有哪些关键字，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如： 深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。 比如现在我们想要定义一个整数（Int）类型的变量a，那么就可以这样编写： fun main() { var a : Int } 但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量： fun main() { var a : Int = 10 } 不过由于变量在一开始就被赋值为10这个整数，此时类型是确定的，Kotlin的编译器非常聪明，它支持自动推断类型，这里会自动将变量a的类型推断为Int类型，我们可以直接省略掉后面的Int类型： fun main() { var a = 10 } 或者我们可以在使用时再对其进行赋值： fun main() { var a : Int a = 10 } 是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台： fun main() { var a = 10 println(a) } 变量的值也可以在中途进行修改： fun main() { var a = 666 a = 777 println(a) //这里打印得到的就是777 } 变量的值也可以直接指定为其他变量的值： fun main() { var a = 10 var b = a //直接让b等于a，那么a的值就会给到b println(b) //这里输出的就是10了 } 我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）： fun main() { var a = 9 //a初始值为9 a = a + 1 //a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧 println(a) //最后得到的结果就是10了 } 对于那些只读的变量，我们可以将其表示为一个常量，使用val关键字： fun main() { val a = 666 //使用val关键字，表示这是一个常量 a = 777; //常量的值不允许发生修改 } 编译时得到报错： 常量的值只有第一次赋值可以修改，其他任何情况下都不行： fun main() { val a: Int a = 777; } 至此，声明变量和常量我们就介绍完毕了，下一部分我们将介绍常见的一些数据类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数字类型介绍 前面我们了解了如何创建变量，并进行使用，但是我们知道，不同的数据往往对应着不同的类型，比如整数我们使用的就是Int，而这一部分我们将学习更多的基本数据类型。 Kotlin提供了一组表示数字的内置类型，对于整数，有四种不同大小的类型，因此，值范围： 类型 大小（位） 最小值 最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-2^31) 2,147,483,647（2^31-1） Long 64 -9,223,372,036,854,775,808 (-2^63) 9,223,372,036,854,775,807（2^63 - 1） 为什么不同的数据类型有着值范围呢？这是因为我们的计算机底层是采用0和1表示数据的，并且数据的表示位数有限，我们以二进制来计算，就像下面这样： 1 + 1 = 10 可能很多小伙伴会好奇，为什么1 + 1得到的结果是数字十？这是因为二进制中只有0和1，因此只要满二就进一，所以就变成这样的结果了，如果各位是初次学习，可能会不太好理解。 这里以上面的8位大小的Byte类型为例，在计算机底层存储数据时，只有8个bit位（一个bit位就可以表示一个0或1）来存储它，那么它能表示的最大值和最小值就是： 00000000 ~ 11111111 转换为十进制就是 0 ~ 255 不过为了能够表示负数，计算机一般使用补码进行表示，所以，上面的最小值和最大值就变成了-128 ~ 127了。 默认情况下，我们使用的常量数字都是Int类型，除非它的大小已经超出Int类型能够表示的最大范围，在超出Int类型可以表示的最大范围之后，默认为Long类型： val one = 1 // Int val threeBillion = 3000000000 // Long val oneLong = 1L // 我们也可以在数字后面添加大写字母L来表示这是一个Long类型的数值 val oneByte: Byte = 1 //Int类型数据也可以在符合其他类型范围时自动转换 对于一些比较长的数字，我们可能需要使用类似于分隔符一类的东西来方便我们计数，比如： 银行往往把1000000000这种长数字记为1,000,000,000，这样看起来会更直观 在Kotlin中也可以像这样去编写： val a = 1_000_000_000 数字类型不仅可以写成十进制，也可以以十六进制或是二进制表示（Kotlin不支持八进制表示）只需要添加对应的前缀即可，比如一个十六进制数据： val a = 0xAF 因为十六进制中大于等于十的数据没有对应的阿拉伯数字可以表示，所以在计算机中就以ABCDEF来替代这无法表示的6个数字。并且我们需要在数字前面添加0x表示这是16进制的数字，接下来是2进制： val a = 0b1001 //0b前缀表示二进制数据，后面的1010对应着十进制的9 除了整数类型外，Kotlin还为无符号整数提供以下类型： UByte：一个无符号8位整数，范围从0到255 UShort：无符号16位整数，范围从0到65535 UInt：一个无符号32位整数，范围从0到2^32 - 1 ULong：一个无符号64位整数，范围从0到2^64 - 1 为了使无符号整数更易于使用，Kotlin同样提供了用后缀标记，该后缀表示无符号类型（类似于上面的Long类型添加L字母） 使用u或U字母作为后缀表示无符号整数。而具体的类型是根据前面变量的类型确定的，如果变量没有提供类型，编译器将根据数字的大小使用UInt或ULong： val b: UByte = 1u // UByte类型, 由变量提供的类型 val s: UShort = 1u // UShort类型, 由变量提供的类型 val l: ULong = 1u // ULong类型, 由变量提供的类型 val a1 = 42u // UInt类型，根据数字大小自动推断得到 val a2 = 0xFFFF_FFFF_FFFFu // ULong类型，根据数字大小自动推断得到 uL和UL可以将文字直接标记为无符号Long类型： val a = 1UL // ULong类型，直接使用后缀标记 对于小数来说，Kotlin提供符合IEEE 754标准的浮点类型Float和Double，Float为IEEE 754标准中的单精度数据，而`Double位标准中的双精度数据，对于单双精度，本质上就是能够表示的小数位精度，双精度比单精度的小数精度更高。 这些类型的大小不同，并为不同精度的浮点数提供存储： 类型 大小（位） 符号与尾数位数 阶码位数 小数位数 Float 32 24 8 6-7 Double 64 53 11 15-16 我们也可以直接创建小数类型的Double和Float变量，小数部分与整数部分由一个小数点（.）隔开，编译器默认情况下会将所有的小数自动推断为推断Double类型： val pi = 3.1415 // 默认推断为Double类型 val one: Double = 1 // 这种写法是错误的，因为1不是小数，无法编译通过 val one: Double = 1.0 // 但是这种写法就是对的，因为这样表示就是小数，即使小数位是0 由于默认是Double类型，如果我们要明确指定值为Float类型，那么需要添加后缀f或F，并且由于精度问题，如果该值包含超过6-7位小数，则会丢失一部分精度： val e = 2.7182818284 // Double类型的数值 val e: Float = 2.7182818284f // 这里表示为Float会导致精度折损，得到2.7182817 与其他一些语言不同，Kotlin中的数字类型没有隐式转换的操作，例如，一个Double类型的变量无法将其值赋值给Int类型变量： 如果需要将一个整数转换为小数，我们会在后面学习函数之后再给各位小伙伴讲解如何调用函数进行显示类型转换。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"数字类型的运算 Kotlin支持数学上标准的算术运算集，例如：+，-，*，/，% 并且这些运算符都是通过运算符重载实现的具体功能，我们会在后续的章节中讲解Kotlin的运算符重载机制，这里各位小伙伴就当做是普通的运算操作即可。 Kotlin支持运算符重载，运算符重载是一种允许程序员重新定义运算符的语言特性，通过运算符重载，您可以为自定义的类或数据类型定义一些特定操作的行为。 其中加减乘除操作这里就不做介绍了，而%符号用于取余操作，也就是计算前面的数整除后面的数得到的余数： println(1 + 2) //计算1加上2的结果 println(2_500_000_000L - 1L) //计算2500000000减去1的结果 println(3.14 * 2.71) //计算3.14与2.71的乘积 println(10.0 / 3) //计算10除以3得到的结果 println(10 / 3) //10除以3得到的余数为1 以上运算都比较简单，但是注意在除法运算中，只有两个操作数中出现小数，除法的结果才是小数，如果两个操作数都是整数，那么得到的结果也是整数，并且直接丢失小数位（不会四舍五入） println(5 / 2) //结果是2，而不是2.5 同样的，除了直接使用字面量来进行运算，我们也可以将定义的变量参与到运算中： fun main() { val a = 10 println(a / 2) } 注意，在Kotlin中不同的算数运算符，它们的优先级也不一样： println(1 + 2 * 3) 在数学中，乘法运算的优先级比加法运算更高，因此我们需要先计算乘法，再计算加法，而在Kotlin中是一样的，乘法和除法运算符的优先级是高于加法运算符的，所以说上面算出来的结果是7，同样的，我们数学中使用括号来提升某些运算的优先级，在Kotlin中同样可以，比如： println((1 + 1) * 3) //使用小括号来强制提升优先级 有些时候，我们可能想要让某个变量的值增加一定数值，比如下面这样： var a = 10 a = a + 9 //让a等于a+9的结果 对于这种让变量本身加减乘除某个值的情况，可以使用赋值运算符简化： a += 9 //等价于 a = a + 9 a /= 9 //等价于 a = a / 9 a %= 2 //等价于 a = a % 2 如果我们只是希望某个变量自增或自减1，那么我们可以像这样去写： fun main() { var a = 10 a++ //使用两个++表示自增1 println(a) //打印得到11 a-- //使用两个--表示自减1 } 不过，这个双++符号，可以放在变量的前后，都能实现自增操作： var a = 10 ++a //最终效果等价于a++ 但是他们有一个本质区别，就是++在前面，a是先自增再得到结果，而++在后面，是a先得到结果，再进行自增，比如： fun main() { var a = 10 println(a++) //这里++在后面，打印a的值依然是10，但是结束之后a的值就变成11了 println(++a) //这里++在前面，打印a的值是这里先自增之后的结果，就是12了 } 对于新手来说，这个很容易搞混，所以说一定要记清楚。 Kotlin提供了一组整数的位运算操作，可以直接在二进制层面上与数字表示的位进行操作，不过只适用于Int和Long类型的数据： shl(bits)– 有符号左移 shr(bits)– 有符号右移 ushr(bits)– 无符号右移 and(bits)– 按位与 or(bits)– 按位或 xor(bits)– 按位异或 inv()– 取反 这里我们从按位与开始讲解，比如下面的两个数： fun main() { val a = 9 val b = 3 val c = a and b //进行按位与运算 println(c) } 按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0： a = 9 = 1001 b = 3 = 0011 c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0） 同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1： fun main() { val a = 9 val b = 3 val c = a or b println(c) } a = 9 = 1001 b = 3 = 0011 c =11= 1011（只要上下有一个是1或者都是1，那结果就是1） 按位异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况： a = 9 = 1001 b = 3 = 0011 c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0） 按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1： 127 = 01111111 -128 = 10000000 所以说计算的结果就是-128了。 除了以上的四个运算符之外，还有位移运算符，比如： fun main() { val c = 1 shl 2 //shl表示左移运算 println(c) } 1 = 00000001 4 = 00000100（左移两位之后，1跑到前面去了，尾部使用0填充，此时就是4） 我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用*进行乘2的运算之外，我们也可以使用左移操作来完成。 同样的，右移操作就是向右移动每一位咯： fun main() { val c = 8 shr 2 //shr表示右移运算 println(c) } 跟上面一样，右移操作可以快速进行除以2的计算。对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响： fun main() { val c = -8 shr 2 //这里得到的依然是个负数 println(c) } 我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动： fun main() { val c = -1 ushr 1 //无符号右移是ushr，移动会直接考虑符号位 println(c) } 比如： -1 = 11111111 11111111 11111111 11111111 右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位） 此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移操作。 最后我们再总结一下不同运算符的优先级，对应的优先级从上往下依次减弱： 一元运算符：例如 ++、–、+、-、!、~ 乘法和除法运算符：*、/、% 加法和减法运算符：+、- 位移运算符：shl、shr、ushr 按位与运算符：and 按位或运算符：or 按位异或运算符：xor 逻辑运算符：\u0026\u0026、|| 比较运算符：\u003e、\u003e=、\u003c、\u003c=、==、!= 区间运算符：.. 赋值运算符：=、+=、-=、*=、/=、%= 当然，这里列出的部分运算符各位小伙伴可能还没有遇到，不过在后续的学习中，我们会慢慢认识的，届时各位小伙伴可以回顾一下这里。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"布尔类型介绍 布尔类型是Kotlin中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态： true - 真 false - 假 布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true） val a: Boolean = true 如果给一个其他的值，会无法编译通过： 布尔值除了可以直接赋值得到，也可以通过一些关系运算得到，常见的关系运算有大于、小于以及等于，所有的关系运算在下方： 判断两个数是否相等：a == b和a != b 判断数之间大小：a \u003c b，a \u003e b，a \u003c= b，a \u003e= b 判断数是否在指定范围中：a..b，x in a..b，x !in a..b 比如我们想判断变量a和变量b的值是否相同： fun main() { val a = 10 val b = 8 println(a == b) //判断a是否等于b（注意等号要写两个，因为单等号为赋值运算） println(a \u003e= b) //判断a是否大于等于b println(a \u003c b) //判断a是否小于b val c: Boolean = a != b //判断a是否不等于b并将结果赋值给变量c } 可以看到，通过逻辑运算得到的结果，都是true或false，也就是我们这里学习的Boolean类型值。在Kotlin中，我们为了快速判断某个数是否在一个区间内，可以直接使用 a..b 来表示一个数学上[a, b]这样的闭区间，比如我们这里要判断变量a的值是否在1~10之间： fun main() { val a = 10 println(a in 1..10) //这里1..10表示1~10这个闭区间，使用in关键字来进行判断 println(a in 1..\u003c10) //这里1..\u003c10表示1~10这个前闭后开区间，使用in关键字来进行判断 println(a !in 1..10) //相反的，使用!in判断是否不在这个区间 } 对于Boolean类型的变量之间，也有一些逻辑运算符用于进行组合条件判断： ||– 逻辑或运算 \u0026\u0026– 逻辑与运算 !– 取反运算 其中取反运算最好理解，它可以让true变成false，false变为true，比如： fun main() { val a = 10 val b = 20 val c = a \u003e b //这里很明显c应该为false println(!c) //这里进行了取反操作并打印，那么结果就是true了 } 对于逻辑与和逻辑或运算，我们可以像这样去使用： fun main() { val a = 10 val b = 0 println(100 \u003e= a \u0026\u0026 b \u003e= 60) //我们可以使用与运算符连接两个判断表达式，只有两边都为true结果才是true println(100 \u003e= a || b \u003e= 60) //我们可以使用或运算符连接两个判断表达式，只要两边任意一个为true结果就是true } 与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，而或运算就是要求两边只要有一边为真，结果就是真，除非两边同时为false，那么就没戏了。 不过需要注意的是，在与运算中，第一个判断表达式得到了false之后，此时不会再继续运行第二个表达式，而是直接得到结果false（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）同样的，或运算下当发现第一个判断表达式为true时，也不会继续向后执行了，因为结果已经是顶真了。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:5","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"字符类型介绍 字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）字符由Char类型表示，字符值用单引号：'1'囊括： val c: Char = 'A' println(c) 注意，字符只能表示一单个字符，我们之前遇到的字符串跟字符不一样，关于字符串我们会在下节课进行介绍。 我们打印出来的也是单个字符： 那么可能会有小伙伴好奇，字符类型在计算机底层是怎么进行存储的呢？实际上每个字符在计算机中都会对应一个字符码，首先我们需要介绍ASCII码： 比如我们的英文字母A要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，我们可以使用.code来获取某个字符对应的ASCII码，比如下面这样： fun main() { val c: Char = 'A' println(c.code) //这里就会打印字符对应的ASCII码 } 得到结果为： 字符型占据2个字节的空间用于存放数据： char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535 不过，这里的字符表里面不就128个字符吗，那char干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文，这时，我们就需要扩展字符集了。 Unicode是一个用于表示文本字符的标准字符集。它包含了世界上几乎所有的已知字符，包括不同国家和地区的字母、数字、标点符号、符号图形以及特殊的控制字符。 与Unicode不同，ASCII（American Standard Code for Information Interchange）是一个只包含128个字符的字符集。它最初是为了在计算机系统中传输基本英语字符而设计的。ASCII字符集包含了常见的拉丁字母、数字、标点符号以及一些特殊字符。 Unicode采用了一个更加广泛的字符编码方案，包括了不同的字符集编码，比如UTF-8和UTF-16等。UTF-8是一种可变长度的编码方案，它可以用来表示Unicode中的任意字符，且向后兼容ASCII字符集。而UTF-16则是一种固定长度的编码方案，它使用两个字节来表示一个Unicode字符。 与ASCII相比，Unicode的主要优势在于它能够表示各种不同的语言和字符，而不仅仅限于英语字符。这使得Unicode成为全球通用的字符编码标准，为不同国家和地区的语言提供了统一的编码方式。 所以，一个Char就能表示几乎所有国家语言的字符，这样就很方便了。 接着我们来介绍一下转译字符，对于一些我们平时很难直接通过键盘或是输入法打出来的字符，比如一些特殊符号： 这些符号我们没办法直接打出来，但是现在我们又想要表示它们，该怎么做呢？我们可以使用转义来将这些字符对应的Unicode编码转换为对应的字符，只需要在前面加上\\u即可，比如✓这个符号： fun main() { val c = '\\u2713' //符号✓对应的Unicode编码为10003，这里需要转换为16进制表示，结果为0x2713 println(c) } 除了能像这样表示一个特殊字符，我们也可以使用一些其他的转义字符来表示各种东西： \\t – 选项卡 \\b – 退格 \\n – 换行（LF） \\r – 回车（CR） \\' – 单引号 \\\" – 双引号 \\\\ –反斜杠 \\$ – 美元符号 这些转义字符都是为了防止在特殊情况下无法表示某些字符，而给我们的替代方案，后续各位小伙伴在使用时可以回来参考一下。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:6","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"字符串类型介绍 字符串类是一个比较特殊的类型，它用于保存字符串。我们知道，基本类型Char可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列，它的类型名称为String。 字符串通常由双引号\"\"囊括，它可以表示一整串字符： val str: String = \"Hello World\" 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。 如果我们需要再字符串中换行，需要用到转义字符，字符串中同样支持使用转义字符： fun main() { val text = \"Hello\\nWorld\" println(text) } 不过，字符串只能写一行，有时候有点不太够用，可能我们想要打印多行文本，我们除了用\\n转义字符来换行之外，也可以直接使用三个双引号\"\"\"来表示一个原始字符串，但是原始字符串无法使用转义字符： fun main() { val text = \"\"\" 这是第一行 这第二行 别\\n了，没用 真牛逼啊，这功能隔壁Java15才有 \"\"\" println(text) } 效果如下： 可以看到确实是够原始的，把我代码里面的缩进都给打印出来了，这样肯定不是我们希望的样子，我们希望的仅仅是一个简单换行而已，那这里该怎么去处理呢？后面我们在讲解函数之后，会额外补充这里的内容。 有时候为了方便，我们可以将不同的字符串拼接使用： fun main() { val str1 = \"Hello\" val str2 = \"World\" val str = str1 + str2 println(str) //使用 + 来拼接两个字符串，得到的结果就是两个字符串合在一起的结果 } 字符串除了和字符串拼接之外，也可以和其他类型进行拼接： fun main() { val a = 10 val text = \"这是拼接的值\" + a println(text) //打印出来就是与其他类型的拼接结果 } 但是我们需要注意字符串拼接的顺序，只能由字符串拼接其他类型，如果是其他类型拼接字符串，可能会出现问题： 但是现在我们就是希望其他类型的数据拼在最前面，这里应该怎么做呢？我们可以使用字符串模版来完成： fun main() { val a = 10 val text = \"这是拼接的值$a\" //这里的$为模版表达式，可以直接将后面跟着的变量或表达式以字符串形式替换到这个位置 println(text) } 如果要添加到前面： val text = \"$a 这是拼接的值\" //注意这里$a之后必须空格，否则会把后面的整个字符串认为这个变量的名字 出现这种情况除了用空格去解决之外，我们也可以添加一个花括号： val text = \"${a}这是拼接的值\" //添加花括号就可以消除歧义了 val text = \"${a \u003e 0}这是拼接的值\" //花括号中也可以写成表达式 由于美元符用于模版表达式了，所以说如果我们希望在字符串中仅仅表示$这个字符，那么我们需要用到转义： val text = \"\\$这是美元符\" //普通字符串直接使用\\$表示 //原始字符串要套个娃 val str = \"\"\" ${'$'}这是美元符 \"\"\" 至此，关于Kotlin的变量与基本类型的内容我们就暂时告一段落了，不过在后面学习了更多知识后，我们还会回顾这些基本类型，了解他们的更多用法，并且认识我们唯一没有在这一部分介绍的数组类型。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:2:7","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"流程控制 经过前面的学习，我们知道，程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。 在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断，以及实现流程控制。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:0","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"选择结构（if-else） 某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下if语句： if (条件判断) 判断成功执行的代码; if的小括号中需要我们传入一个Boolean类型的结果，可以是一个Boolean变量，也可以是一个判断语句，反正只能接受true和false两种结果，比如下面的这个例子： fun main() { val a = 10 if(a == 12) //只有当a判断等于12时，才会执行下面的打印语句 println(\"Hello World!\") println(\"我是后续的语句\") //if只会对紧跟着的一行代码生效，后续的内容无效 } if会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起，使用花括号囊括）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的，就像下面这样： fun main() { val a = 15 if (a \u003e 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 println(\"a大于10\") println(\"a的值为：$a\") } println(\"我是外层\") } 如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句： fun main() { val a = 15 if (a \u003e 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 println(\"a大于10\") println(\"a的值为：$a\") } else { //当判断不成功时，会执行else代码块中的代码 println(\"a小于10\") println(\"a的值为：$a\") } println(\"我是外层\") } if-else语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。 那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成： fun main() { val score = 2 if (score \u003e= 90) //90分以上才是优秀 println(\"优秀\") else if (score \u003e= 70) //当上一级if判断失败时，会继续判断这一级 println(\"良好\") else if (score \u003e= 60) println(\"及格\") else //当之前所有的if都判断失败时，才会进入到最后的else语句中 println(\"不及格\") } 当然，if分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套： fun main() { val score = 2 if (score \u003c 60) { //先判断不及格 if (score \u003e 30) //在内层再嵌套一个if语句进行进一步的判断 println(\"学习C++\") else println(\"学习Java\") } } 除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用if来进行各种条件判断了。 除了直接执行语句之外，我们也可以将if和else用作结果判断，比如： fun main() { val score = 2 //这里判断socre是否大于60，是就得到Yes，否就得到No，并且可以直接赋值给变量 val res = if (score \u003e 60) \"Yes\" else \"No\" } 这类似于其他语言，如Java和C中的三元运算，不过Kotlin中没有那样的三元运算符，只能使用上面的表达式，对于多行代码块的情况，默认最后一行作为返回的结果： fun main() { val score = 2 val res = if (score \u003e 60) { println(\"不错啊期末没挂科\") \"Yes\" //代码块默认最后一行作为返回结果 } else { println(\"不会有人Java期末还要挂科吧\") \"No\" } } 注意，如果需要这种返回结果的表达式，那么必须要存在else分支，否则不满足条件岂不是没结果了？ ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:1","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"选择结构（when） 前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用when语句来实现，它更适用于多分支的情况： when定义具有多个分支的条件表达式。它类似于类似Java和C语言中的switch语句，它简单的形式看起来像这样： when (目标) { 匹配值1 -\u003e 代码... //我们需要传入一个目标，比如变量，或是计算表达式等 匹配值2 -\u003e 代码... //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 else -\u003e { 代码... //如果以上条件都不满足，就进入else中（可以没有），类似于之前的if-elseif-else } } 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级： fun main() { val c = 'A' when (c) { 'A' -\u003e println(\"去尖子班！准备冲刺985大学！\") 'B' -\u003e println(\"去平行班！准备冲刺一本！\") 'C' -\u003e println(\"去职高深造。\") } } 如果将when用作表达式，则else分支必须存在，除非编译器能推断出所有可能的情况都包含分支条件，比如下面的例子： fun main() { val c = 'A' val numericValue = when (c) { 'B' -\u003e 0 'A' -\u003e 1 else -\u003e 2 //还有其他情况，这里必须添加else，不然其他情况岂不是没返回的东西？ } } 以下情况就可以不需要else语句： fun main() { val c = true val numericValue = when (c) { false -\u003e 0 true -\u003e 1 // 由于Boolean只具备真和假条件，这里的'else' 就不再强制要求 // 这同样适用于比如枚举类等 } } 在when语句中，遇到以下情况，携带else分支是必须的： when分支中仅有一个Boolean类型、枚举 或 密封，以及用于判断的目标变量是可空的情况（后面会讲解） when分支没有包括该判断目标的所有可能的值。 有时候我们可能希望某些值都属于同一个情况，可以使用逗号将其条件组合成一行： when (x) { 0, 1 -\u003e print(\"x == 0 or x == 1\") else -\u003e print(\"otherwise\") } 我们也可以使用任意表达式（不仅仅是常量）作为分支条件，比如之前的if-else案例中我们判断学生成绩： fun main() { val score = 10 val grade = when(score) { //使用in判断目标变量值是否在指定范围内 in 100..90 -\u003e \"优秀\" in 89..80 -\u003e \"良好\" in 79..70 -\u003e \"及格\" in 69..60 -\u003e \"牛逼\" else -\u003e \"不及格\" } } 包括我们之后学习的类型判断is表达式、函数调用等，都可以在这里作为分支条件。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:2","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"循环结构（for） 通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。 我们在某些时候，可能需要批量执行某些代码： fun main() { println(\"大烟杆嘴里塞，我只抽第五代\") //把这句话给我打印三遍 println(\"大烟杆嘴里塞，我只抽第五代\") println(\"大烟杆嘴里塞，我只抽第五代\") } 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？ 现在，要解决这种问题，我们可以使用for循环语句来多次执行： for (遍历出来的单个目标变量 in 可遍历目标) 循环体 这里的可遍历目标有很多，比如： 数组 区间 任何实现了运算符重载函数iterator的类 这里我们只学习了区间，我们来看看如何使用，比如我们要打印一段话3遍： fun main() { for (i in 1..3) //这里直接写入1..3表示1~3这个区间 println(\"大烟杆嘴里塞，我只抽第五代：$i\") } 打印结果为： 可以看到，每一次遍历出来的变量i，其实就是每次遍历的下一个目标，比如这里是1..3的区间，那么得到的依次就是1、2、3这三个结果了，唯一需要注意的是，这里的i是局部的，只在for循环内部可用（包括嵌套的内部）并不是整个main中都可以使用： 默认情况下，每一轮循环都会向后+1，我们也可以自由控制每一轮增加多少，也就是步长： fun main() { for (i in 1..10 step 2) { println(i) } } 这样，打印出来的数据会按照步长进行增长： 那如果我们需要从10到1倒着进行遍历呢？我们可以将..替换为downTo来使用： fun main() { for (i in 10 downTo 1) { println(i) //这里得到的就是10到1倒着排列的范围了 } } 我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值： 调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug） 调试开始时，我们可以看到程序在断点位置暂停了： 此时我们可以观察到当前的变量i的值，也可以直接在下方的调试窗口中查看： 随着循环的进行，i的值也会逐渐自增。 和之前的if一样，for循环同样支持嵌套使用： fun main() { for (i in 0..2) //外层循环执行3次 for (j in 0..2) //内层循环也执行3次 println(\"外层$i，内层$j\") } 上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。 我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字： for (i in 0..2) { if (i == 1) continue //比如我们希望当i等于1时跳过这一轮，不执行后面的打印 println(\"在这么冷的天\") println(\"当前i的值为：$i\") } 我们可以使用continue关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行continue进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。 在某些情况下，我们可能希望提前结束循环： fun main() { for (i in 0..2) { if (i == 1) break //我们希望当i等于1时提前结束 println(\"伞兵一号卢本伟准备就绪！\") println(\"当前i的值为：$i\") } } 我们可以使用break关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。 虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）： fun main() { for (i in 1..3) { for (j in 1..3) { if (i == j) continue //当i == j时加速循环 println(\"$i, $j\") } } } 这里的continue加速的对象并不是外层的for，而是离它最近的内层for循环，break也是同样的规则： fun main() { for (i in 1..3) { for (j in 1..3) { if (i == j) break //当i == j时终止循环 println(\"$i, $j\") } } } 那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记： fun main() { outer@ for (i in 1..3) { //在循环语句前，添加 标签@ 来进行标记 inner@ for (j in 1..3) { if (i == j) break@outer //break后紧跟要结束的循环标记，当i == j时终止外层循环 println(\"$i, $j\") } } } 关于for语句的更多用法，我们会在后续的学习中继续认识。 ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:3","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["kotlin"],"content":"循环结构（while） 前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们给一个可遍历的目标，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如： while(循环条件) 循环体; 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。 fun main() { var i = 100 //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i \u003e 0) { //现在唯一知道的是循环条件，只要大于0那么就可以继续除 println(i) i /= 2 //每次循环都除以2 } } 上面的这种情况就非常适合使用while循环。 和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用： fun main() { var i = 100 while (i \u003e 0) { if (i \u003c 10) break println(i) i /= 2 } } 我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句： fun main() { var i = 0 //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 do { //无论满不满足循环条件，先执行循环体里面的内容 println(\"Hello World!\") i++ } while (i \u003c 10) //再做判断，如果判断成功，开启下一轮循环，否则结束 } 至此，Kotlin程序设计的基础篇内容就讲解完毕了，下一章我们将学习更多Kotlin特性。 ———————————————— 版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。 原文链接：https://www.itbaima.cn/document/t7lnl87f74f3v1ju ","date":"2024-02-28","objectID":"/kotlin%E5%AD%A6%E4%B9%A0/:3:4","tags":["kotlin","android"],"title":"Kotlin学习","uri":"/kotlin%E5%AD%A6%E4%B9%A0/"},{"categories":["draft"],"content":"Btrfs文件系统介绍 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"1. Btrfs简介 Btrfs 是一种新型的写时复制（CoW）Linux 文件系统，已经并入内核主线。你可以读作 Better File System、B-tree File System、Butter File System 等等，都是正确的。Btrfs 在设计实现高级功能的同时，着重于容错、修复以及易于管理。它由 Oracle、Red Hat、Fujitsu、Intel、SUSE、STRATO 等企业和开发者共同开发。Btrfs 以 GNU GPL 协议授权，同时也欢迎任何人的贡献。 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"2. Btrfs的特性 扩展性相关 B-tree Btrfs 文件系统中所有的 metadata 都由 B-tree 管理。使用 B-tree 的主要好处在于查找、插入和删除操作都很高效。可以说 B-tree 是 Btrfs 的核心 基于 Extent 的文件存储 ✅ 针对 SSD 的优化支持 Btrfs 的 CoW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，Btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 I/O 性能 动态 Inode 分配 支持非常大的单个文件大小 数据一致性相关 ✅ 写时复制（CoW） 比就地修改的文件系统有更大的好处，详细的说明见下文 校验和（Checksum） 保证了数据的可靠性：由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变成了 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。如果最终从磁盘读取出来的数据和 checksum 不相同，Btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，Btrfs 将返回错误。写入磁盘数据之前，Btrfs 计算数据的 checksum。然后将 checksum 和数据同时写入磁盘。 多设备管理相关 ✅ 多设备管理 Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的相关命令将该设备添加到文件系统中 ✅ 子卷（Subvolume） 把文件系统的一部分配置为一个完整的子文件系统 ✅ 快照（Snapshot）和克隆（Clone） 支持快照 支持快照的快照（增量备份） 可以对单个文件进行备份 ✅ 内置支持 RAID，支持条带或 mirror 等常见的 RAID 功能 ✅ 支持热移除、热添加设备 其他特性 ✅ 透明压缩 减小了文件的大小，通过减少文件写入增幅来显著延长闪存介质的寿命。在某些特定的场景下（比如单线程、重负荷的文件 I/O）还提高了性能 延迟分配（Delay allocation） 在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配则是这样一种技术 —— 当用户需要磁盘空间时，先将数据保存在内存中。将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求 —— 一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 I/O 效率 Inline File 系统中往往存在大量的小文件（几百个字节或者更小）。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。Btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。得益于 Inline File 技术，Btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题 目录索引（Directory Index） 当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 B-tree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。然而，Btrfs 使用 B-tree 管理目录项的方式无法同时满足 readdir 的需求。readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件；并且特别的，这些文件要按照 inode number 排序。而 Btrfs 目录项插入 B-tree 时的 Key 并不是 inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，Btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 Key 以 sequence number 作为 B-tree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 Key 在 B-tree 中查找便可以方便的得到一个以 inode number 排序的文件列表 另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 I/O 效率 预分配 很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"Btrfs 与其它文件系统功能比较# Feature Ext 2 / 3 Ext 4 ReiserFS XFS OCFS2 Btrfs Journal (date / metadata) ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚫ ⚪ / ⚫ ⚪ / ⚫ N/A Journal (internal / external) ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚪ N/A Offline extend / shrink ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Online extend / shrink ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Inode allocation map table table B*-tree B+-tree table B-tree Sparse files ⚫ ⚫ ⚫ ⚫ ⚫ ⚫ Tail packing ⚪ ⚫ ⚫ ⚪ ⚪ ⚫ Defragmentation ⚪ ⚫ ⚪ ⚫ ⚪ ⚫ ExtArributes / ACLs ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ Quotas ⚫ ⚫ ⚫ ⚫ ⚫ 🔴 Dump / restore ⚫ ⚫ ⚪ ⚫ ⚪ ⚪ Default block size 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB max. file system size 16 TiB 1 EiB 16 TiB 8 EiB 4 PiB 16 EiB max. file size 2 TiB 1 EiB 1 EiB 8 EiB 4 PiB 16 EiB Support status SLES SLES SLES SLES SLE HA SLES ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:1","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"3. Barfs的简单使用 3.1 创建文件系统 mkfs.btrfs -f /dev/sda1 3.2 挂载文件系统 mount /dev/sda1 /mnt 3.3 创建子卷 btrfs subvolume create subvolume_name 3.4 删除子卷 btrfs subvolume delete subvolume_name # or rm -rf subvolume_name 3.5 创建快照 btrfs subvolume snapshot source destination 3.6 删除快照 btrfs subvolume delete snapshot_name 3.7 查看快照 btrfs subvolume list /mnt 3.8 查看文件系统信息 btrfs filesystem show /mnt 3.9 查看文件系统使用情况 btrfs filesystem df /mnt 3.10 查看文件系统的压缩情况 btrfs filesystem df -c /mnt 3.11 查看文件系统的压缩算法 btrfs filesystem df -c /mnt 3.12 查看子卷信息 btrfs subvolume show /mnt ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"VPN 原理浅谈 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:0:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的应用场景 保护隐私： VPN 通过加密通信，确保你的互联网连接是安全的。这对于在公共 Wi-Fi 网络上浏览互联网时尤其重要，因为公共网络通常更容易受到黑客攻击。 绕过地理限制： 有些网站或服务在特定地区可能不可用，或者内容受到地理限制。使用 VPN 可以改变你的 IP 地址，使你能够绕过这些地理限制，访问受限制的内容。 保护公司内部网络： 公司可以使用 VPN 来建立安全的远程访问通道，员工可以通过 VPN 连接到公司内部网络，以便在远程地点安全地访问公司资源。 匿名上网： VPN 可以隐藏你的真实 IP 地址，提高上网的匿名性。这对于那些希望在互联网上保持相对匿名的用户来说很有用。 绕过审查： 在一些国家，互联网审查可能会限制对特定网站或服务的访问。使用 VPN 可以绕过这些审查，让用户能够自由地访问互联网。 安全远程办公： 对于远程工作者或分布式团队来说，VPN 提供了一个安全的通信渠道，使他们能够远程连接到公司网络并访问必要的资源。 防止数据被窃取： 在使用不安全的网络时，VPN 可以加密你的数据流，防止敏感信息被窃取，确保通信的机密性。 游戏加速： 一些玩家可能使用 VPN 来连接到特定地区的游戏服务器，以获得更好的游戏性能或访问特定地区的游戏内容。 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:1:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的工作原理 涉及到的底层技术 tun/tap: 用于创建虚拟网卡，用于接收和发送数据包, 主要的操作就是在此实现的 iptables： 用于实现数据包的转发 iproute2： 用于实现路由表的管理 tun/tap 概述： tun 设备: TUN设备是一种虚拟网络设备，用于在用户空间和内核空间之间传递网络数据。TUN代表“网络隧道”（Network TUNnel），它允许用户空间的程序通过标准的网络套接字接口发送和接收IP数据包，同时内核会处理网络协议的部分。TUN设备通常用于创建虚拟私有网络（VPN）和其他网络隧道，以在用户空间中运行的程序与内核之间传递网络流量。这对于实现网络隔离、虚拟专用网络、安全隧道等应用场景非常有用。一般来说，使用TUN设备的流程如下： 用户空间程序通过TUN设备发送IP数据包。 内核将接收到的数据包从TUN设备中读取。 用户空间程序可以通过标准的套接字接口监听和处理这些数据包。 tap 设备：TAP设备（Tap虚拟网卡）是一种虚拟网络设备，与TUN设备类似，也用于在用户空间和内核空间之间传递网络数据。TAP代表“网络透明适配器”（Network TAP），与TUN设备不同的是，TAP设备在数据链路层（OSI模型的第二层）工作，而TUN设备在网络层（第三层）工作。主要区别在于： TAP设备：它以太网设备的形式存在，可以处理链路层的数据包。因此，TAP设备可以传输以太网帧，包括处理MAC地址等。TAP设备通常用于需要在二层进行操作的场景，比如虚拟局域网（VLAN）的实现、桥接网络、以太网隧道等。 TUN设备：与TAP不同，TUN设备是在网络层工作的，只能传输IP数据包。TUN设备通常用于实现虚拟私有网络（VPN）等应用，它只关心IP层的数据，而不涉及链路层的细节。 在使用TAP设备时，用户空间程序可以像处理真实的网络接口一样处理TAP设备，包括发送和接收以太网帧。 iptables 简单使用: # 设置从eth0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # 设置从tun0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE # 设置从eth0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 设置从tun0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i tun0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 允许所以数据包转发 iptables -A FORWARD -j ACCEPT iproute2 简单使用 # 设置tun0设备的ip为192.168.1.10/24 ip addr add 192.168.1.10/24 dev tun0 # 添加走到tun0设备的路由 ip route add 192.168 # 为table 100添加一条来自 192.168.1.10的规则 ip rule add from 192.168.1.10 table 100 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:2:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的简单实现","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:3:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"性能 Profiling – 使用 Perf 命令 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:0:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"1. Perf 常用命令 perf top 常用参数 -e：指定性能事件 -a：显示在所有 CPU 上的性能统计信息 -C：显示在指定 CPU 上的性能统计信息 -p：指定进程 PID -t：指定线程 TID -K：隐藏内核统计信息 -U：隐藏用户空间的统计信息 -s：指定待解析的符号信息 ‘‐G’ or‘‐‐call‐graph’ \u003coutput_type,min_percent,call_order\u003e graph: 使用调用树，将每条调用路径进一步折叠。这种显示方式更加直观。 每条调用路径的采样率为绝对值。也就是该条路径占整个采样域的比率。 perf list perf test perf record: 记录一段时间内系统/进程的性能时间 常用参数 -e：选择性能事件 -p：待分析进程的 id -t：待分析线程的 id -a：分析整个系统的性能 -C：只采集指定 CPU 数据 -c：事件的采样周期 -o：指定输出文件，默认为 perf.data -A：以 append 的方式写输出文件 -f：以 OverWrite 的方式写输出文件 -g：记录函数间的调用关系 perf report: 读取 perf record 生成的数据文件，并显示分析数据 常用参数 -i：输入的数据文件 -v：显示每个符号的地址 -d ：只显示指定 dos 的符号 -C：只显示指定 comm 的信息（Comm. 触发事件的进程名） -S：只考虑指定符号 -U：只显示已解析的符号 -g[type,min,order]：显示调用关系，具体等同于 perf top 命令中的-g -c：只显示指定 cpu 采样信息 -M：以指定汇编指令风格显示 –source：以汇编和 source 的形式进行显示 -p：用指定正则表达式过滤调用函数 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:1:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"2. 生成火焰图示例 # 采集数据 perf record -F 99 -p 1234 -g \u003ccommand\u003e -- sleep 30 # 解析数据 perf script -i perf.data \u0026\u003e perf.unfold # 生成火焰图 # 克隆仓库 git clone https://github.com/brendangregg/FlameGraph.git cd FlameGraph # 对perf.unfold文件进行符号折叠 ./stackcollapse-perf.pl perf.unfold \u003e perf.folded # 生成火焰图（svg图） ./flamegraph.pl perf.folded \u003e perf.svg ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:2:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"IP 路由相关命令总结 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:0:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"一，路由策略（使用ip rule命令操作路由策略数据库） 基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。 ip rule命令： Usage: ip rule { add | del } SELECTOR ACTION ip rule { flush | save | restore } ip rule [ list [ SELECTOR ]] SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK[/MASK] ] [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ] [ uidrange NUMBER-NUMBER ] [ ipproto PROTOCOL ] [ sport [ NUMBER | NUMBER-NUMBER ] [ dport [ NUMBER | NUMBER-NUMBER ] ] ACTION := [ table TABLE_ID ] [ protocol PROTO ] [ nat ADDRESS ] [ realms [SRCREALM/]DSTREALM ] [ goto NUMBER ] SUPPRESSOR SUPPRESSOR := [ suppress_prefixlength NUMBER ] [ suppress_ifgroup DEVGROUP ] TABLE_ID := [ local | main | default | NUMBER ] #例子1：通过路由表 table 1 路由来自源地址为192.203.80/24的数据包 ip rule add from 192.203.80/24 table 1 #例子2：把源地址为192.168.1.10的数据报的源地址转换为192.168.2.20，并通过表1进行路由 ip rule add from 193.168.1.10 nat 192.168.2.20 table 1 #实例3：让eht0流量使用table 1 ip rule add dev eth0 table1 在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则： 0：匹配任何条件，查询路由表local(ID 255)，该表local是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0非常特殊，不能被删除或者覆盖。 32766：匹配任何条件，查询路由表main(ID 254)，该表是一个通常的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。 32767：匹配任何条件，查询路由表default(ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。 **注：**不要混淆路由表和策略：规则指向路由表，多个规则可以引用一个路由表，而且某些路由表可以策略指向它。如果系统管理员删除了指向某个路由表的所有规则，这个表没有用了，但是仍然存在，直到里面的所有路由都被删除，它才会消失。 linux 系统中，可以自定义从 1－252个路由表，其中，linux系统维护了4个路由表： 0#表： 系统保留表 253#表： defulte table 没特别指定的默认路由都放在改表 254#表： main table 没指明路由表的所有路由放在该表 255#表： locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改 路由表的查看可有以下二种方法： ip route show table table_number ip route show table table_name 路由表序号和表名的对应关系在 /etc/iproute2/rt_tables文件中，可以手动编辑，路由表添加完毕及时生效，实例如下： #实例1：在一号表中添加默认路由为192.168.1.1 ip route add default via 192.168.1.1 table 1 #实例2：在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2 ip route add 192.168.0.0/24 via 192.168.1.2 table 1 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"二，路由表（使用ip route命令操作静态路由表） 所谓路由表，指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据–路由表，供路由选择时使用，表中包含的信息决定了数据转发的策略。 以一例子来说明：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。 首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关：ip route add default gw 20.0.0.1 之后通过 ip route 添加一个路由表：ip route add table 3 via 10.0.0.1 dev ethX (ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号) 之后添加 ip rule 规则：ip rule add fwmark 3 table 3 （fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表） 之后使用 iptables 给相应的数据打上标记：iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK –set-mark 3 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"Docker 基本命令 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:0:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"1. 使用镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 \u003c域名/IP\u003e[:端口号]。默认地址是 Docker Hub(docker.io)。 仓库名：如之前所说，这里的仓库名是两段式名称，即 \u003c用户名\u003e/\u003c软件名\u003e。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"2. 操作容器 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 -d: 让容器在后台运行 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash, 也可以使用dash或者fish。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"3. 数据管理 创建一个数据卷 docker volume create my-vol 删除数据卷 docker volume rm my-vol 无主的数据卷可能会占据很多空间，要清理请使用以下命令: docker volume prune 查看所有数据卷 docker volume ls 在主机里使用以下命令可以查看指定 数据卷 的信息 docker volume inspect my-vol 查看容器详细信息 docker inspect container_id 挂载主机目录 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\ nginx:alpine 注意: 本地目录的路径必须是绝对路径,使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ nginx:alpine ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["linux","docker"],"content":"Docker 基石-NetworkNamespace ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:0:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"1. veth-pair 是什么 veth-pair 是一对虚拟网卡，通过 veth-pair 可以将两个网络命名空间连接起来，从而实现两个网络命名空间之间的通信。和 tap/tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着 全程只使用 ip 命令进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:1:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2. 使用 veth-pair 和 netns 进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.1 创建两个网络命名空间 ip netns add ns1 ip netns add ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:1","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.2 创建 veth-pair ip link add veth1 type veth peer name veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:2","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.3 将 veth1 移动到 ns1 中 ip link set veth1 netns ns1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:3","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.4 将 veth2 移动到 ns2 中 ip link set veth2 netns ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:4","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.5 启动 veth1 ip netns exec ns1 ip link set dev veth1 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:5","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.6 启动 veth2 ip netns exec ns2 ip link set dev veth2 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:6","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.7 设置 veth1 的 IP 地址 ip netns exec ns1 ip addr add 192.168.1.2/24 dev veth1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:7","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.8 设置 veth2 的 IP 地址 ip netns exec ns2 ip addr add 192.168.1.3/24 dev veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:8","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.9 测试 ip netns exec ns1 ping 192.168.1.3 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:9","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["pytorch"],"content":"torch.fx模块的使用 ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"torch.fx主要有3个组件： 符号追踪器（symbolic tracer) 中间表示（intermediate representation) Python代码生成（Python code generation) import torch # Simple module for demonstration class MyModule(torch.nn.Module): def __init__(self): super().__init__() self.param = torch.nn.Parameter(torch.rand(3, 4)) self.linear = torch.nn.Linear(4, 5) def forward(self, x): return self.linear(x + self.param).clamp(min=0.0, max=1.0) module = MyModule() from torch.fx import symbolic_trace # 符号追踪这个模块 # Symbolic tracing frontend - captures the semantics of the module symbolic_traced : torch.fx.GraphModule = symbolic_trace(module) # 中间表示 # High-level intermediate representation (IR) - Graph representation print(symbolic_traced.graph) \"\"\" graph(): %x : [#users=1] = placeholder[target=x] %param : [#users=1] = get_attr[target=param] %add : [#users=1] = call_function[target=operator.add](args = (%x, %param), kwargs = {}) %linear : [#users=1] = call_module[target=linear](args = (%add,), kwargs = {}) %clamp : [#users=1] = call_method[target=clamp](args = (%linear,), kwargs = {min: 0.0, max: 1.0}) return clamp \"\"\" # 生成代码 # Code generation - valid Python code print(symbolic_traced.code) \"\"\" def forward(self, x): param = self.param add = x + param; x = param = None linear = self.linear(add); add = None clamp = linear.clamp(min = 0.0, max = 1.0); linear = None return clamp \"\"\" ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"使用场景 Replace one op Conv/Batch Norm fusion replace_pattern: Basic usage Quantization Invert Transformation 融合例子: # Works for length 2 patterns with 2 modules def matches_module_pattern(pattern: Iterable[Type], node: fx.Node, modules: Dict[str, Any]): if len(node.args) == 0: return False nodes: Tuple[Any, fx.Node] = (node.args[0], node) for expected_type, current_node in zip(pattern, nodes): if not isinstance(current_node, fx.Node): return False if current_node.op != 'call_module': return False if not isinstance(current_node.target, str): return False if current_node.target not in modules: return False if type(modules[current_node.target]) is not expected_type: return False return True def replace_node_module(node: fx.Node, modules: Dict[str, Any], new_module: torch.nn.Module): assert(isinstance(node.target, str)) parent_name, name = _parent_name(node.target) modules[node.target] = new_module setattr(modules[parent_name], name, new_module) def fuse(model: torch.nn.Module, inplace=False) -\u003e torch.nn.Module: \"\"\" Fuses convolution/BN layers for inference purposes. Will deepcopy your model by default, but can modify the model inplace as well. \"\"\" patterns = [(nn.Conv1d, nn.BatchNorm1d), (nn.Conv2d, nn.BatchNorm2d), (nn.Conv3d, nn.BatchNorm3d)] if not inplace: model = copy.deepcopy(model) fx_model = fx.symbolic_trace(model) modules = dict(fx_model.named_modules()) new_graph = copy.deepcopy(fx_model.graph) for pattern in patterns: for node in new_graph.nodes: # 找到目标Node：args是Conv，target是BN if matches_module_pattern(pattern, node, modules): if len(node.args[0].users) \u003e 1: # Output of conv is used by other nodes continue conv = modules[node.args[0].target] bn = modules[node.target] # 融合BN和Conv fused_conv = fuse_conv_bn_eval(conv, bn) # 替换Node的module，其实就是将融合后的module替换Conv Node的target，背后是模块替换 replace_node_module(node.args[0], modules, fused_conv) # 将所有用到BN Node的替换为Conv Node（已经融合后的Conv） node.replace_all_uses_with(node.args[0]) # 删除BN Node new_graph.erase_node(node) return fx.GraphModule(fx_model, new_graph) from torch.fx.experimental.optimization import fuse from torchvision.models import resnet18 model = resnet18() model.eval() # 必须在eval模型下fuse ''' (layer4): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' fused_model = fuse(model) ''' (layer4): Module( (0): Module( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (downsample): Module( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2)) ) ) (1): Module( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"参考链接: PyTorch新技能解锁：torch.fx - 知乎 (zhihu.com) ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"matplotlib的简单使用 matplotlib结构 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:0:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1. fig,ax,plt 三者的基本概念 fig Figure，就是图的外框，也叫画布，可以包括1-无穷个内框Axes ax Axes，就是图的内框(可以将画布分为多个绘图区域)，里面可以画各种图，最常见的就是二维的统计图或者折线图，也可以画三维图xyz和极坐标图theta-r Axis，就是坐标轴 plt Pyplot为底层面向对象的绘图库提供状态机接口。状态机隐式自动创建图形和轴，以实现所需的绘图。 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:1:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.常用函数说明 matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布 import matplotlib.pyplot as plt plt.plot([1,2,3]) #现在创建一个子图，它表示一个有2行1列的网格的顶部图。 #因为这个子图将与第一个重叠，所以之前创建的图将被删除 plt.subplot(211) plt.plot(range(12)) #创建带有黄色背景的第二个子图 plt.subplot(212, facecolor='y') plt.plot(range(12)) Matplotlib 提供了matplotlib.figure图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。如下所示： from matplotlib import pyplot as plt import numpy as np import math x = np.arange(0, math.pi*2, 0.05) y = np.sin(x) fig = plt.figure() # add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。 ax = fig.add_axes([0,0,1,1]) ax.plot(x,y) ax.set_title(\"sine wave\") ax.set_xlabel('angle') ax.set_ylabel('sine') plt.show() matplotlib.pyplot模块提供了一个 subplots() 函数，它的使用方法和 subplot() 函数类似。其不同之处在于，subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。 import matplotlib.pyplot as plt # 将画布分为2*2的绘图区域 fig,a = plt.subplots(2,2) import numpy as np x = np.arange(1,5) #绘制平方函数 a[0][0].plot(x,x*x) a[0][0].set_title('square') #绘制平方根图像 a[0][1].plot(x,np.sqrt(x)) a[0][1].set_title('square root') #绘制指数函数 a[1][0].plot(x,np.exp(x)) a[1][0].set_title('exp') #绘制对数函数 a[1][1].plot(x,np.log10(x)) a[1][1].set_title('log') plt.show() ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:2:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["c/cpp"],"content":"一、string.h中字符串处理函数 在头文件\u003cstring.h\u003e中定义了两组字符串函数。第一组函数的名字以str开头；第二组函数的名字以mem开头。 只有函数memmove对重叠对象间的拷贝进行了定义，而其他函数都未定义。比较类函数将其变量视为unsigned char类型的数组。 1 strcpy #include \u003cstring.h\u003e char *strcpy(char *str1, const char *str2); 把字符串str2(包括’\\0’)拷贝到字符串str1当中，并返回str1。 2 strncpy #include \u003cstring.h\u003e char *strncpy(char *str1, const char *str2, size_t count); 把字符串str2中最多count个字符拷贝到字符串str1中，并返回str1。如果str2中少于count个字符，那么就用’\\0’来填充，直到满足count个字符为止。 3 strcat #include \u003cstring.h\u003e char *strcat(char *str1, const char *str2); 把str2(包括’\\0’)拷贝到str1的尾部(连接)，并返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 4 strncat #include \u003cstring.h\u003e char *strncat(char *str1, const char *str2, size_t count); 把str2中最多count个字符连接到str1的尾部，并以’\\0’终止str1，返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 注意，最大拷贝字符数是count+1。 5 strcmp #include \u003cstring.h\u003e int strcmp(const char *str1, const char *str2); 按字典顺序比较两个字符串，返回整数值的意义如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 6 strncmp #include \u003cstring.h\u003e int strncmp(const char *str1, const char *str2, size_t count); 同strcmp，除了最多比较count个字符。根据比较结果返回的整数值如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 7 strchr #include \u003cstring.h\u003e char *strchr(const char *str, int ch); 返回指向字符串str中字符ch第一次出现的位置的指针，如果str中不包含ch，则返回NULL。 8 strrchr #include \u003cstring.h\u003e char *strrchr(const char *str, int ch); 返回指向字符串str中字符ch最后一次出现的位置的指针，如果str中不包含ch，则返回NULL。 9 strspn #include \u003cstring.h\u003e size_t strspn(const char *str1, const char *str2); 返回字符串str1中由字符串str2中字符构成的第一个子串的长度。 10 strcspn #include \u003cstring.h\u003e size_t strcspn(const char *str1, const char *str2); 返回字符串str1中由不在字符串str2中字符构成的第一个子串的长度。 11 strpbrk #include \u003cstring.h\u003e char *strpbrk(const char *str1, const char *str2); 返回指向字符串str2中的任意字符第一次出现在字符串str1中的位置的指针；如果str1中没有与str2相同的字符，那么返回NULL。 12 strstr #include \u003cstring.h\u003e char *strstr(const char *str1, const char *str2); 返回指向字符串str2第一次出现在字符串str1中的位置的指针；如果str1中不包含str2，则返回NULL。 13 strlen #include \u003cstring.h\u003e size_t strlen(const char *str); 返回字符串str的长度，’\\0’不算在内。 14 strerror #include \u003cstring.h\u003e char *strerror(int errnum); 返回指向与错误序号errnum对应的错误信息字符串的指针(错误信息的具体内容依赖于实现)。 15 strtok #include \u003cstring.h\u003e char *strtok(char *str1, const char *str2); 在str1中搜索由str2中的分界符界定的单词。 对strtok()的一系列调用将把字符串str1分成许多单词，这些单词以str2中的字符为分界符。第一次调用时str1非空，它搜索str1，找出由非str2中的字符组成的第一个单词，将str1中的下一个字符替换为’\\0’，并返回指向单词的指针。随后的每次strtok()调用(参数str1用NULL代替)，均从前一次结束的位置之后开始，返回下一个由非str2中的字符组成的单词。当str1中没有这样的单词时返回NULL。每次调用时字符串str2可以不同。 如： char *p; p = strtok(\"The summer soldier,the sunshine patriot\", \" \"); printf(\"%s\", p); do { p = strtok(\"\\0\", \", \"); /* 此处str2是逗号和空格 */ if (p) printf(\"|%s\", p); } while (p); 显示结果是：The | summer | soldier | the | sunshine | patriot 16 memcpy #include \u003cstring.h\u003e void *memcpy(void *to, const void *from, size_t count); 把from中的count个字符拷贝到to中。并返回to。 17 memmove #include \u003cstring.h\u003e void *memmove(void *to, const void *from, size_t count); 功能与memcpy类似，不同之处在于，当发生对象重叠时，函数仍能正确执行。 18 memcmp #include \u003cstring.h\u003e int memcmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2的前count个字符，返回值与strcmp的返回值相同。 19 memchr #include \u003cstring.h\u003e void *memchr(const void *buffer, int ch, size_t count); 返回指向ch在buffer中第一次出现的位置指针，如果在buffer的前count个字符当中找不到匹配，则返回NULL。 20 memset #include \u003cstring.h\u003e void *memset(void *buf, int ch, size_t count); 把buf中的前count个字符替换为ch，并返回buf ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"example #include \"malloc.h\" #include \"stdint.h\" #include \"stdio.h\" #include \"stdlib.h\" #include \"string.h\" #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { // malloc and memset and strlen usage char *s = (char *)malloc(sizeof(char) * 10); printf(\"origin strlen(s): %llu\\n\", strlen(s)); memset(s, 'i', 12); printf(\"after memset, strlen(s): %llu\\n\", strlen(s)); int *i = (int *)malloc(sizeof(int) * 10); printf(\"sizeof(i): %llu\\n\", sizeof(i)); // strcpy usage char *s1 = (char *)malloc(sizeof(char) * 10); char s2[] = {\"hello\"}; printf(\"strlen(s1): %llu\\n\", strlen(s1)); printf(\"sizeof(s1): %llu\\n\", sizeof(s1)); printf(\"strlen(s2): %llu\\n\", strlen(s2)); printf(\"sizeof(s2): %llu\\n\", sizeof(s2)); strcpy_s(s1, strlen(s2) + 1, s2); // strncpy_s(s1, strlen(s2)+1, s2, 3); printf(\"s1=%s\\n\", s1); printf(\"*****************************\\n\"); char s3[] = {\"world\"}; // strstr return pointer char *p = strstr(s3, \"ld\"); printf(\"p=%s\\n\", p); // calculate the offset printf(\"%lld\\n\", p-s3); p = strchr(s3, 'o'); printf(\"strchr p=%s\\n\", p); printf(\"strchr offset:%lld\\n\", p-s3); p = strrchr(s3, 'l'); printf(\"strrchr p=%s\\n\", p); printf(\"strrchr offset:%lld\\n\", p-s3); p = strtok(s3, \"or\"); while (p) { printf(\"strtok p=%s\\n\", p); p = strtok(NULL, \"or\"); } printf(\"after strtok, s3=%s\\n\", s3); int a = strcmp(s3, \"world\"); printf(\"strcmp a=%d\\n\", a); a = strncmp(s3, \"world\", 1); printf(\"strncmp a=%d\\n\", a); char s4[] = {\"hello\"}; memmove(s4+1, s4, 1); printf(\"memmove s4=%s\\n\", s4); memcpy(s4, \"hello\", 5); printf(\"memccpy s4=%s\\n\", s4); return 0; } // output: // origin strlen(s): 6 // after memset, strlen(s): 14 // sizeof(i): 8 // strlen(s1): 6 // sizeof(s1): 8 // strlen(s2): 5 // sizeof(s2): 6 // s1=hello // ***************************** // p=ld // 3 // strchr p=orld // strchr offset:1 // strrchr p=ld // strrchr offset:3 // strtok p=w // strtok p=ld // after strtok, s3=w // strcmp a=-1 // strncmp a=0 // memmove s4=hhllo // memccpy s4=hello 二、stdlib.h中字符串与数字相互转换处理函数 1. 数字转化为字符串: ● itoa()：将整型值转换为字符串。 ● ltoa()：将长整型值转换为字符串。 ● ultoa()：将无符号长整型值转换为字符串。 ● gcvt()：将浮点型数转换为字符串，取四舍五入。 ● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。 ● fcvt()：指定位数为转换精度，其余同ecvt()。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int = 435; double num_double = 435.10f; char str_int[30]; char str_double[30]; itoa(num_int, str_int, 10); //把整数num_int转成字符串str_int gcvt(num_double, 8, str_double); //把浮点数num_double转成字符串str_double printf(\"str_int: %s\\n\", str_int); printf(\"str_double: %s\\n\", str_double); return 0; } 程序输出结果： str_int: 435 str_double: 435.10001 代码第11行中的参数10表示按十进制类型进行转换，转换后的结果是“435”，如果按二进制类型进行转换，则结果为“1101110011”。 代码第12行中的参数8表示精确位数，这里得到的结果是“435.10001”。 2. 字符串转化为数字 atof()：将字符串转换为双精度浮点型值。 atoi()：将字符串转换为整型值。 atol()：将字符串转换为长整型值。 strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。 strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。 strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int; double num_double; char str_int[30] = \"435\"; //将要被转换为整型的字符串 char str_double[30] = \"436.55\"; //将要被转换为浮点型的字符串 num_int = atoi(str_int); //转换为整型值 num_double = atof(str_double); //转换为浮点型值 printf(\"num_int: %d\\n\", num_int); printf(\"num_double: %lf\\n\", num_double); return 0; } // 输出结果： // num_int: 435 // num_double: 436.550000 ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"进制互转 // int to binary char tmp[10] = {}; char *conv = itoa(5, tmp, 2); printf(\"itoa to 2: conv=%s\\n\", conv); // int to hex conv = itoa(17, tmp, 16); printf(\"itoa to 16: conv=0x%s\\n\", conv); // hex to 10 int hex = strtol(\"0x11\", NULL, 16); printf(\"strtol: hex=%d\\n\", hex); // binary to 10 int bin = strtol(\"101\", NULL, 2); printf(\"strtol: bin=%d\\n\", bin); // output // itoa to 2: conv=101 // itoa to 16: conv=0x11 // strtol: hex=17 // strtol: bin=5? ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["python"],"content":"介绍 异步IO：就是发起一个IO操作（如：网络请求，文件读写等），这些操作一般是比较耗时的，不用等待它结束，可以继续做其他事情，结束时会发来通知。 协程：又称为微线程，在一个线程中执行，执行函数时可以随时中断，由程序（用户）自身控制，执行效率极高，与多线程比较，没有切换线程的开销和多线程锁机制。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:0:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio中几个重要概念 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1.事件循环 事件循环是每个 asyncio 应用的核心，管理所有的事件，在整个程序运行过程中不断循环执行并追踪事件发生的顺序将它们放在队列中，空闲时调用相应的事件处理者来处理这些事件。 创建事件循环 loop = asyncio.get_event_loop() 获取当前事件循环。 如果当前 OS 线程没有设置当前事件循环并且 set_event_loop() 还没有被调用，asyncio 将创建一个新的事件循环并将其设置为当前循环。 另起一个线程创建事件循环 from threading import Thread import asyncio def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() new_loop = asyncio.new_event_loop() loop_thread = Thread(target=start_thread_loop, args=(new_loop,)) loop_thread.setDaemon(True) # 守护线程 loop_thread.start() ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.Future Future对象表示尚未完成的计算，还未完成的结果，它和task上没有本质上的区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"3.Task 是Future的子类，作用是在运行某个任务的同时可以并发的运行多个任务。 asyncio.Task用于实现协作式多任务的库，且Task对象不能用户手动实例化，通过下面2个函数创建： loop.create_task() 或 asyncio.ensure_future() loop.create_task() ,要在定义loop对象之后，调用将方法对象转化成了task的对象 asyncio.ensure_future() 直接调用asyncio 的ensure_future() 方法，返回的也是task 对象（我们还没有声明 loop 也可以提前定义好 task 对象） ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"4.async/await 关键字 asyncio实现了TCP、UDP、SSL等协议，async定义一个协程，await用于挂起阻塞的异步调用接口。 对于异步io你需要知道的重点，要注意的是，await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。而且await后面的对象需要是一个Awaitable，或者实现了相关的协议。 注意 1. 所有需要异步执行的函数，都需要asyncio中的轮询器去轮询执行，如果函数阻塞，轮询器就会去执行下一个函数。所以所有需要异步执行的函数都需要加入到这个轮询器中。若在协程中需要有延时操作，应该使用 await asyncio.sleep()，而不是使用time.sleep()，因为使用time.sleep()后会释放GIL，阻塞整个主线程，从而阻塞整个事件循环。 创建一个协程 使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行 耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:4","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"简单例子 import asyncio from asyncio import tasks from asyncore import loop async def main(): await asyncio.sleep(2) print('this is main running') async def add_log(): await asyncio.sleep(1) print('add log before running') async def run_background(): await asyncio.sleep(3) print('running task in background') async def parameter_verification(): await asyncio.sleep(1) print('parameter verification before running') if __name__ == '__main__': # running async function method: # first method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) # the sequence of the tasks is not the same as the sequence of the function calling, and the same as define sequence result = asyncio.run(tasks) print(result) print(f'{\"*\" * 20}{\"another method\"}{\"*\" * 20}') # second method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) loop = asyncio.get_event_loop() result = loop.run_until_complete(tasks) print(result) 首先我们引入了 asyncio 这个包，这样我们才可以使用 async 和 await，然后我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。 随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。 可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:2:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"进阶例子 多个任务，定义一个task列表，使用asyncio.gather(*tasks) 或 asyncio.wait(tasks) 接收 import asyncio import time now = lambda: time.time() \"\"\" asyncio.gather主要集中在收集结果上。它等待一堆task并按给定的顺序返回结果。 asyncio.wait等待task。而不是直接给你结果，它提供完成和待处理的任务。你必须手工收集结果。 asyncio.wait(tasks) ps:asyncio.wait([1,2,3]) 也可以使用 asyncio.gather(*tasks) ps: asyncio.gather(1,2,3),前者接受一个task列表，后者接收一堆task。 \"\"\" # 定义一个异步任务 async def do_some_work(x): print(\"waiting:\", x) # 模拟io阻塞 await asyncio.sleep(x) return \"Done after {}s\".format(x) async def main(loop): \"\"\" :param loop: loop.create_task（需要传进loop参数） :return: None \"\"\" coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(4) # asyncio.ensure_future tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] # loop.create_task（需要传进loop参数） # tasks = [ # loop.create_task(coroutine1), # loop.create_task(coroutine2), # loop.create_task(coroutine3) # ] # 返回 完成的 task object dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) # 返回 task 方法的 返回值 # results = await asyncio.gather(*tasks) # for result in results: # print(\"Task ret:\",result) start = now() loop = asyncio.get_event_loop() loop.run_until_complete(main(loop)) print(\"Time:\", now() - start) gather和wait 的区别 把多个协程注册进一个事件循环中的两种方法 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:3:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"使用方式区别 使用asyncio.wait() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 使用asyncio.gather() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) # *接收args参数 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:4:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"接收参数区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.wait 参数必须是list对象 ，list 对象存放多个 task object 用asyncio.ensure_future转为task对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 不转为task对象 loop = asyncio.get_event_loop() tasks=[ coroutine1, coroutine2, coroutine3 ] loop.run_until_complete(asyncio.wait(tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.gather 必须用 * 来接收 list 对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"返回结果区别 asyncio.wait asyncio.wait返回dones和pendings dones：表示已经完成的任务 pendings：表示未完成的任务 我们需要手动去获取结果 dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) asyncio.gather 它的返回值就是 return的结果 ，不用再task.result() 来获取 # 返回 task 方法的 返回值 results = await asyncio.gather(*tasks) for result in results: print(\"Task ret:\",result) 另 asyncio.wait 带有控制功能 【控制运行任务数】：运行第一个任务就返回 FIRST_COMPLETED ：第一个任务完全返回 FIRST_EXCEPTION：产生第一个异常返回 ALL_COMPLETED：所有任务完成返回 （默认选项） import asyncio import random async def coro(tag): print(\"\u003e\", tag) await asyncio.sleep(random.uniform(0.5, 5)) print(\"\u003c\", tag) return tag loop = asyncio.get_event_loop() tasks = [coro(i) for i in range(1, 11)] # 第一次wait 完成情况 print(\"Get first result:\") finished, unfinished = loop.run_until_complete( asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)) # 第一个任务完全返回 for task in finished: print(task.result()) print(\"unfinished:\", len(unfinished)) # 继续第一次未完成任务 print(\"Get more results in 2 seconds:\") finished2, unfinished2 = loop.run_until_complete( asyncio.wait(unfinished, timeout=2)) # 超时2s 返回 for task in finished2: print(task.result()) print(\"unfinished2:\", len(unfinished2)) # 继续第2次未完成任务 print(\"Get all other results:\") finished3, unfinished3 = loop.run_until_complete(asyncio.wait(unfinished2)) # ALL_COMPLETED：所有任务完成返回 （默认项） for task in finished3: print(task.result()) loop.close() 动态添加协程 很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block 相关函数介绍： loop.call_soon_threadsafe() ：与 call_soon()类似，等待此函数返回后马上调用回调函数，返回值是一个 asyncio.Handle 对象，此对象内只有一个方法为 cancel()方法，用来取消回调函数。 loop.call_soon() ： 与call_soon_threadsafe()类似，call_soon_threadsafe() 是线程安全的 loop.call_later()：延迟多少秒后执行回调函数 loop.call_at()：在指定时间执行回调函数，这里的时间统一使用 loop.time() 来替代 time.sleep() asyncio.run_coroutine_threadsafe()： 动态的加入协程，参数为一个回调函数和一个loop对象，返回值为future对象，通过future.result()获取回调函数返回值 动态添加协程同步方式 通过调用 call_soon_threadsafe()函数，传入一个回调函数callback和一个位置参数 注意：同步方式，回调函数 more_work()为普通函数 import asyncio from threading import Thread import time now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() def more_work(x): print('More work {}'.format(x)) time.sleep(x) print('Finished more work {}'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) new_loop.call_soon_threadsafe(more_work, 6) new_loop.call_soon_threadsafe(more_work, 3) print('here') 启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3 异步方式 import asyncio import time from threading import Thread now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() async def do_some_work(x): print('Waiting {}'.format(x)) await asyncio.sleep(x) print('Done after {}s'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop) asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop) 上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。 协程的停止 future对象有几个状态： Pending Running Done Cacelled 创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task import asyncio import time now = lambda: time.time() async def do_some_work(x): print(\"Waiting:\", x) await asyncio.sleep(x) return \"Done after {}s\".format(x) coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(2) tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3), ] start = now() loop = asyncio.get_event_loop() try: loop.run_until_complete(asyncio.wait(tasks)) except KeyboardInterrupt as e: print(asyncio.Task.all_tasks()) for ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["draft"],"content":"SelfAttention和MultiHeadAttention流程简述 ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:0:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["draft"],"content":"1. SelfAttention 1.1 对于每一个输入$I$,初始化3个权重矩阵$W_q,W_k,W_v$. 1.2 输入$I$分别与3个权重矩阵相乘得到$Q,K,V$ 1.3 将$Q$与$K$相乘(矩阵乘法)得到$A$(attention score) 1.4 $A$经过softmax激活得到$A'$ 1.5 将$A’$与$V$相乘得到B 代码示例: In [16]: i = torch.randn(3,4) In [17]: w_query = torch.randn(4, 2) In [18]: w_key = torch.randn(4, 2) In [19]: w_value = torch.randn(4, 2) In [20]: i Out[20]: tensor([[ 0.4313, 1.3749, -0.2489, 1.3275], [-0.6467, 1.6335, 2.8923, 0.9124], [ 0.2326, -0.2314, 0.3554, 0.0892]]) In [21]: w_query Out[21]: tensor([[ 0.3673, -0.8505], [-0.3559, -0.3708], [-1.2093, 0.6634], [ 0.4042, 0.8015]]) In [22]: w_key Out[22]: tensor([[-1.1617, 0.4023], [-0.1249, -0.1605], [-0.8427, 1.1002], [-1.1320, 0.4611]]) In [23]: w_value Out[23]: tensor([[-0.7675, -0.3179], [-1.1910, -0.6937], [-1.4809, -1.5502], [-0.7373, 1.0511]]) In [24]: querys = i @ w_query In [25]: keys = i @ w_key In [26]: values = i @ w_value In [27]: querys Out[27]: tensor([[ 0.5066, 0.0223], [-3.9478, 2.5946], [-0.2259, 0.1952]]) In [28]: keys Out[28]: tensor([[-1.9656, 0.2911], [-2.9229, 3.0806], [-0.6418, 0.5629]]) In [29]: values Out[29]: tensor([[-2.5787, 0.6903], [-6.4049, -4.4522], [-0.4950, -0.3706]]) In [30]: att_scores = querys @ keys.T In [31]: att_scores Out[31]: tensor([[-0.9893, -1.4121, -0.3126], [ 8.5152, 19.5319, 3.9940], [ 0.5009, 1.2617, 0.2549]]) In [32]: att_scores_softmax = torch.nn.functional.softmax(att_scores, dim=-1) In [33]: att_scores_softmax Out[33]: tensor([[2.7604e-01, 1.8087e-01, 5.4310e-01], [1.6426e-05, 9.9998e-01, 1.7865e-07], [2.5498e-01, 5.4565e-01, 1.9937e-01]]) In [34]: outputs = att_scores_softmax @ values In [35]: outputs Out[35]: tensor([[-2.1390, -0.8160], [-6.4048, -4.4521], [-4.2510, -2.3272]]) In [36]: outputs.shape Out[36]: torch.Size([3, 2]) ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:1:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["DeepLearning"],"content":"什么是交叉熵 交叉熵是一个在ML领域经常会被提到的名词。在这篇文章里将对这个概念进行详细的分析。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:0:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"1.什么是信息量？ 假设$x$是一个离散型随机变量，其取值集合为$X$，概率分布函数为$p(x)=Pr(X=x), x \\in X $，我们定义事件的信息量为：$X=x_0$，可以理解为，一个事件发生的概率越大，则它所携带的信息量就越小，而当$p(x_0)=1$时，熵将等于0，也就是说该事件的发生不会导致任何信息量的增加。举个例子，小明平时不爱学习，考试经常不及格，而小王是个勤奋学习的好学生，经常得满分，所以我们可以做如下假设： 事件A：小明考试及格，对应的概率$P(x_A)=0.1$，信息量为$I(x_A)=−log(0.1)=3.3219$ 事件B：小王考试及格，对应的概率$P(x_B)=0.999$，信息量为$I(x_B)=−log(0.999)=0.0014$ 可以看出，结果非常符合直观：小明及格的可能性很低(十次考试只有一次及格)，因此如果某次考试及格了（大家都会说：XXX竟然及格了！），必然会引入较大的信息量，对应的$I$值也较高。而对于小王而言，考试及格是大概率事件，在事件B发生前，大家普遍认为事件B的发生几乎是确定的，因此当某次考试小王及格这个事件发生时并不会引入太多的信息量，相应的$I$值也非常的低。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:1:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"2.什么是熵？ 那么什么又是熵呢？还是通过上边的例子来说明，假设小明的考试结果是一个0-1分布$X_A$只有两个取值{0：不及格，1：及格}，在某次考试结果公布前，小明的考试结果有多大的不确定度呢？你肯定会说：十有八九不及格！因为根据先验知识，小明及格的概率仅有0.1,90%的可能都是不及格的。怎么来度量这个不确定度？求期望！不错，我们对所有可能结果带来的额外信息量求取均值（期望），其结果不就能够衡量出小明考试成绩的不确定度了吗。 即： $H_A(x) = -[p(x_A)log(p(X_A))] + (1-p(x_A))log(1-p(x_A))]=0.4690$ 对应小王的熵： $H_B(x)=−[p(x_B)log(p(x_B))+(1−p(x_B))log(1−p(x_B))]=0.0114$ 虽然小明考试结果的不确定性较低，毕竟十次有9次都不及格，但是也比不上小王（1000次考试只有一次才可能不及格，结果相当的确定） 我们再假设一个成绩相对普通的学生小东，他及格的概率是$P(x_C)=0.5$,即及格与否的概率是一样的，对应的熵： $H_C(x)=−[p(x_C)log(p(x_C))+(1−p(x_C))log(1−p(x_C))]=1$ 其熵为1，他的不确定性比前边两位同学要高很多，在成绩公布之前，很难准确猜测出他的考试结果。 可以看出，熵其实是信息量的期望值，它是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。 对于一个随机变量X而言，它的所有可能取值的信息量的期望$（E[I(x)]$就称为熵。 $X$的熵定义为： $H(X)=Ep \\space log \\frac 1 {p(x)}=−\\sum \\limits_{x \\in X}p(x)logp(x)$ 如果$p(x)$是连续型随机变量的pdf，则熵定义为： $H(X)=−∫_{x∈X}p(x)logp(x)dx$ 为了保证有效性，这里约定当$p(x)→0$时,有$p(x)logp(x)→0$ 当X为0-1分布时，熵与概率p的关系如下图： 可以看出，当两种取值的可能性相等时，不确定度最大（此时没有任何先验知识），这个结论可以推广到多种取值的情况。在图中也可以看出，当p=0或1时，熵为0，即此时X完全确定。 熵的单位随着公式中$log$运算的底数而变化，当底数为2时，单位为“比特”(bit)，底数为e时，单位为“奈特”。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:2:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"3.什么是相对熵？ 相对熵(relative entropy)又称为KL散度（Kullback-Leibler divergence），KL距离，是两个随机分布间距离的度量。记为$D_{KL}(p||q)$。它度量当真实分布为p时，假设分布$q$的无效性。 $$\\begin{split} \\ D_{KL}(p||q) \u0026= Ep[log \\frac {p(x)} {q(x)}] \\ \u0026=\\sum _{x∈X} p(x) log \\frac {p(x)} {q(x)} \\ \u0026=\\sum {x∈X}[p(x)logp(x)−p(x)logq(x)] \\ \u0026=\\sum{x∈X}p(x)logp(x)−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−H(p)−\\sum _{x∈X} p(x)logq(x) \\ \u0026=−H(p)+Ep[−logq(x)] \\ \u0026=Hp(q)−H(p)\\end{split}$$ 并且为了保证连续性，做如下约定： $$0log \\frac 0 0=0，0log \\frac 0 q=0，plog \\frac p 0=∞$$ 显然，当$p=q$时,两者之间的相对熵$D_{KL}(p||q)=0$ 上式最后的$H_p(q)$)表示在p分布下，使用q进行编码需要的bit数，而$H(p)$表示对真实分布p所需要的最小编码bit数。基于此，相对熵的意义就很明确了：$D_{KL}(p||q)$)表示在实分布为$p$的前提下，使用q分布进行编码相对于使用真实分布p进行编码（即最优编码）所多出来的bit数。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:3:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"4. 什么是交叉熵？ 交叉熵容易跟相对熵搞混，二者联系紧密，但又有所区别。假设有两个分布$p，q$则它们在给定样本集上的交叉熵定义如下： $$ CEH(p,q)=Ep[−logq]=−∑\\limits_{x∈X}p(x)logq(x)=H(p)+D_{KL}(p||q) $$ 可以看出，交叉熵与上一节定义的相对熵仅相差了$H(p)$,当$p$已知时，可以把$H(p)$看做一个常数，此时交叉熵与KL距离在行为上是等价的，都反映了分布$p，q$的相似程度。最小化交叉熵等于最小化KL距离。它们都将在$p=q$时取得最小值$H(p)$（p=q时KL距离为0），因此有的工程文献中将最小化KL距离的方法称为Principle of Minimum Cross-Entropy (MCE)或Minxent方法。 特别的，在logistic regression中， p:真实样本分布，服从参数为p的0-1分布，即$X∼B(1,p)$ q:待估计的模型，服从参数为q的0-1分布，即$X∼B(1,q)$ 两者的交叉熵为： $$\\begin{split} CEH(p,q) \u0026=−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−[P_p(x=1)logP_q(x=1)+P_p(x=0)logP_q(x=0)] \\ \u0026=−[plogq+(1−p)log(1−q)] \\ \u0026=−[ylogh_θ(x)+(1−y)log(1−h_θ(x))] \\ \\end{split}$$ 对所有训练样本取均值得： $$−\\frac 1 m \\sum \\limits^{m} \\limits _{i=1m} [y(i)logh_θ(x^{(i)})+(1−y^{(i)})log(1−h_θ(x^{(i)}))]$$ 这个结果与通过最大似然估计方法求出来的结果一致。 转载出处: 交叉熵（Cross-Entropy）_rtygbwwwerr的博客-CSDN博客 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:4:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["Python"],"content":"强大的GAN网络 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:0:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"1. 概要 ​ GAN网络全称generative adversarial network,翻译为生成式对抗网络,是一种非监督式学习机器学习方法。由Ian J,Goodfello 等人于2014年在Generative Adversarial Nets 论文中提出。其中在GAN网络中,有两个模型——生成模型(generative model G),判别模型(discriminative model D). ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:1:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"2. 原理 ​ GAN网络主要运用了博弈论的思想,模型中的2为博弈方分别由生成模型和判别模型担当.生成模型用随机取样作为输入,它的输出结果要尽可能和训练样本尽可能相似,最好的情况就是分辨不出是真实样本还是生成出来的样本.而判别模型就是尽可能判别生成模型生成的结果和真实样本.这样2个网络相互对抗,不断调整参数,最终达到纳什均衡. 这个过程可以表示为: $$ min_G max_DV(D,G) = \\Epsilon_{x\\sim P_{data}(x)}[logD(x)] + \\Epsilon_{z\\sim p_{z}(z)}[log(1-D(G(z)))] $$ 公式解释: 1. 当训练D时,希望这个式子的值越大越好.真实数据希望被D分成1,生成数据希望被分成0\r2. 当训练G时,希望这个式子的值越小越好.希望D分不开真实数据还是生成数据\r零和博弈（zero-sum game），又称零和游戏，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。指参与博弈的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”，双方不存在合作的可能。就像下棋的游戏一样，你走的每一步和对方走的每一步都是向着对自己有利的方向走，然后你和对手轮流走步 每一步都向着自己最大可能能赢的地方走。这就是零和博弈。 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:2:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3. 简单代码实现 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.1 导包 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:1","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.2 加载数据集 # 初始化tensorboard数据保存路径 writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:2","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.3 定义生成模型 class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:3","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.4 定义判别模型 class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:4","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.5 构造模型,定义损失和优化器 z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:5","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.6 训练判别器和生成器 def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:6","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.7 训练网络 epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_step=step) writer.close() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:7","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.8 保存模型 torch.save(D, './model/discriminator.pt') torch.save(G, './model/generator.pt') ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:8","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.9 汇总代码 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torchinfo import summary from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) # 设置drop_last丢弃最后不满一个batch_size的数据 train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) # 添加网络图到tensorboard writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:9","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"参考资料: GAN入门理解及公式推导 - 知乎 (zhihu.com) lyeoni/pytorch-mnist-GAN (github.com) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:10","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Markdown"],"content":"Markdown使用mermaid ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:0:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"0. 符号表示 类元素的可见范围 可见范围 表示方法 private - public + protected # package ~ 类的修饰 符号 类型 \u003c\u003cInterface\u003e\u003e 接口 \u003c\u003cabstract\u003e\u003e 抽象类 \u003c\u003cService\u003e\u003e service类 \u003c\u003cenumeration\u003e\u003e 枚举 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:1:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"1. 泛化 定义: 表示继承关系(子类和父类). 表示:三角实线,指向父类. classDiagram class Animal{ -age: int +sleep(): void } class Dog Animal \u003c|-- Dog ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:2:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"2. 实现 定义: 表示类和接口之间的关系. 表示: 三角虚线,指向接口. classDiagram class Person { + say(): void } class Man Person \u003c|.. Man ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:3:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"3. 组合 定义: 整体与局部的关系,部分不能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 实心菱形实线,实心菱形指向整体. 代码体现: 成员变量 classDiagram class Person{ -brain } class Brain { - weight } Person *-- Brain ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:4:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"4. 聚合 定义: 整体与局部的关系,部分能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 空心菱形实线,空心菱形指向整体. 代码体现: 成员变量 classDiagram class Computer { -keyboard } class Keyboard { -type } Computer o-- Keyboard ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:5:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"5. 关联 定义: 一种拥有的关系, 使一个类知道另一个类的属性和方法,关联可以是单向的,也可以是双向的.双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头. 表示: 普通箭头的实心线,指向被拥有者. 代码体现: 成员变量 classDiagram class Teacher { -students: List\u003cStudent\u003e +teach(): void } class Student { -teacher: List\u003cTeacher\u003e +learn(): void } Teacher \u003c--\u003e Student ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:6:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"6. 依赖 定义: 一种使用关系. 表示: 普通箭头的虚线,箭头指向被使用者 代码体现: 局部变量, 方法的形参, 方法返回值静态方法的调用 classDiagram class Person { +draw(tool: DrawTool): void } class DrawTool { -color } Person \u003c.. DrawTool ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:7:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"7. 各种关系强弱顺序 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:8:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Git","Windows"],"content":"Git for Windows 安装 Pacman ","date":"2022-12-24","objectID":"/git_for_windows/:0:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"1. 下载必要压缩包 curl -o pacman-6.0.1-9-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-6.0.1-9-x86_64.pkg.tar.zst curl -o pacman-mirrors-20221016-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-mirrors-20221016-1-any.pkg.tar.zst curl -o msys2-keyring-1~20221024-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/msys2-keyring-1~20221024-1-any.pkg.tar.zst # 正常来说只需要上面三个包但是由于缺少 zstd 解压工具还需要 zstd 包 curl -o zstd-1.5.2-2-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/zstd-1.5.2-2-x86_64.pkg.tar.zst # 但是又因为 zstd 包也是 zstd 打包又需要另一个不是 zstd 打包的解压工具来解压 curl -o zstd-v1.5.2-win64.zip -L https://github.com/facebook/zstd/releases/download/v1.5.2/zstd-v1.5.2-win64.zip ","date":"2022-12-24","objectID":"/git_for_windows/:1:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"2 .解压并安装: unzip zstd-v1.5.2-win64.zip \"zstd-v1.5.2-win64/zstd.exe\" -d . ./zstd-v1.5.2-win64/zstd.exe -d -o zstd-1.5.2-2-x86_64.pkg.tar zstd-1.5.2-2-x86_64.pkg.tar.zst tar -xvf zstd-1.5.2-2-x86_64.pkg.tar -C / tar -xvf msys2-keyring-1~20221024-1-any.pkg.tar.zst -C / tar -xvf pacman-mirrors-20221016-1-any.pkg.tar.zst -C / tar -xvf pacman-6.0.1-9-x86_64.pkg.tar.zst -C / ","date":"2022-12-24","objectID":"/git_for_windows/:2:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"3. 添加密钥并更新数据库: pacman-key --init \u0026\u0026 pacman-key --populate msys2 pacman-db-upgrade -r /../ pacman -Sy ","date":"2022-12-24","objectID":"/git_for_windows/:3:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"4. 更新元数据: # pacman -S pacman-mirrors-20221016-1 msys2-keyring-1~20221024-1 zstd-1.5.2-2 # pacman -S $(cut -d ' ' -f 1 /etc/package-versions.txt) URL=https://github.com/git-for-windows/git-sdk-64/raw/main cat /etc/package-versions.txt | while read p v; do d=/var/lib/pacman/local/$p-$v mkdir -p $d for f in desc files install mtree; do echo \"$URL$d/$f\" ..... $d/$f curl -sSL \"$URL$d/$f\" -o $d/$f done done curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/desc -o /var/lib/pacman/local/pacman-6.0.1-9/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/files -o /var/lib/pacman/local/pacman-6.0.1-9/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/install -o /var/lib/pacman/local/pacman-6.0.1-9/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/mtree -o /var/lib/pacman/local/pacman-6.0.1-9/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/desc -o /var/lib/pacman/local/pacman-mirrors-20221016-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/files -o /var/lib/pacman/local/pacman-mirrors-20221016-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/install -o /var/lib/pacman/local/pacman-mirrors-20221016-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/mtree -o /var/lib/pacman/local/pacman-mirrors-20221016-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/desc -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/files -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/install -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/mtree -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/desc -o /var/lib/pacman/local/zstd-1.5.2-2/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/files -o /var/lib/pacman/local/zstd-1.5.2-2/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/install -o /var/lib/pacman/local/zstd-1.5.2-2/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/mtree -o /var/lib/pacman/local/zstd-1.5.2-2/mtree ","date":"2022-12-24","objectID":"/git_for_windows/:4:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 安装Fish Shell ","date":"2022-12-24","objectID":"/git_for_windows/:5:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.1 安装必要依赖 pacman -S gcc-libs ","date":"2022-12-24","objectID":"/git_for_windows/:5:1","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.2 安装Fish Shell并启动 pacman -S fish ","date":"2022-12-24","objectID":"/git_for_windows/:5:2","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.3 启动Fish Shell # 在~/.bashrc文件中添加以下内容，设置默认shell为fish if [ -t 1 ]; then exec fish fi ","date":"2022-12-24","objectID":"/git_for_windows/:5:3","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.4 更换Fish Shell 主题 fish_config ","date":"2022-12-24","objectID":"/git_for_windows/:5:4","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 5 Fish Shell 常用命令和基本设置 # 关闭问候语 set -g -x fish_greeting '' set -U fish_greeting # 设置环境变量 #在最后一行加入(注意目录间用空格隔开) set -x PATH /opt/demo/bin /home/guest/bin $PATH # 删除变量 set -e Foo # 配置别名 # Define alias in config file alias rmi=\"rm -i\" # 切换默认shell，git for windows下不可用 echo $SHELL cat /etc/shells chsh -s /usr/bin/fish # 命令替换 echo (date) # 在bash下面 # echo `date` 参考资料: pacman常用命令-昨夜星辰 (hustlei.github.io) Install inside MSYS2 proper · git-for-windows/git Wiki (github.com) Git:給 git for windows 裝個翅膀 (安裝 pacman 及其他工具) @ 傑克! 真是太神奇了! :: 痞客邦 :: (pixnet.net) 在 Windows 的 Git Bash 中使用包管理器 - iris (ginshio.org) Index of /msys/x86_64/ (msys2.org) Releases · facebook/zstd (github.com) Windows 的终端配置(给 git-windows 添加 msys2 包管理器) - zeromake 的个人博客 MSYS2 和 mintty 打造 Windows 下 Linux 工具体验 - Creaink - Build something for life Using fish shell with git bash on windows (github.com) Package management in Git for Windows (Git Bash)? - Stack Overflow Fish Shell | 安装配置指南 - URmyLucky - 博客园 (cnblogs.com) ","date":"2022-12-24","objectID":"/git_for_windows/:5:5","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Rust"],"content":"Rust偏僻知识点 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Cow(Clone on Write) 两个可选值： Borrowed，用于包裹对象的引用（通用引用）； Owned，用于包裹对象的所有者； Cow 提供 对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）； 如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，Cow 提供方法做克隆处理，并避免多次重复克隆。 Cow 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 Cow，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。 它有以下几个要点需要掌握： Cow\u003cT\u003e 能直接调用 T 的不可变方法，因为 Cow 这个枚举，实现了 Deref； 在需要写 T 的时候，可以使用 .to_mut() 方法得到一个具有所有权的值的可变借用；注意，调用 .to_mut() 不一定会产生克隆； 在已经具有所有权的情况下，调用 .to_mut() 有效，但是不会产生新的克隆； 多次调用 .to_mut() 只会产生一次克隆。 在需要写 T 的时候，可以使用 .into_owned() 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象； 如果之前 Cow 中的值是借用状态，调用此操作将执行克隆； 本方法，参数是self类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 Cow 上不能调用多次； 举例:写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。 use std::borrow::Cow; fn remove_spaces\u003c'a\u003e(input: \u0026'a str) -\u003e Cow\u003c'a, str\u003e { if input.contains(' ') { let mut buf = String::with_capacity(input.len()); for c in input.chars() { if c != ' ' { buf.push(c); } } return Cow::Owned(buf); } return Cow::Borrowed(input); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"HRTBS(Higher-Ranked Trait Bounds) HRTBS主要用于解决函数参数含有闭包,并且闭包参数含有引用 语法:for\u003c‘a\u003e T: Trait\u003c‘a\u003e 例如如下代码实际是不能编译通过的,因为编译器不能推断出返回哪个引用 fn call_on_ref_zero\u003cF\u003e(f: F) where F: Fn(\u0026i32, \u0026i32) -\u003e \u0026i32 { let zero = 0; f(\u0026zero, \u0026zero); } 尝试添加生命周期参数,还是不能通过编译,因为zero变量的生命周期是短于’a的. fn call_on_ref_zero\u003c'a, F\u003e(f: F) where F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 我们尝试使用HRTBS试试 fn call_on_ref_zero\u003cF\u003e(f: F) where for\u003c'a\u003e F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 另一个例子 fn foo\u003c'b, F\u003e(f: F) -\u003e \u0026'b str where for\u003c'a\u003e F: Fn(\u0026'a str) -\u003e \u0026'a str, { let s = \"hello\"; f(s) } fn bar(s: \u0026str) -\u003e \u0026str { \u0026s[..1] } fn main() { let s = foo(bar); println!(\"{s}\"); } 最后一个例子: fn foo\u003c'a\u003e(f: Box\u003cdyn Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 第一次调用 f(\u0026x) 时生命周期 'a 等于变量 x 的生命周期；而在第二次调用 f(\u0026y) 时，生命周期 'a 又等于了变量 y 的生命周期；而变量 x 和变量 y 的生命周期显然是不同的。因此无法用一个静态的生命周期来描述 'a ，我们希望的是，闭包 f 在具体调用时绑定具体的生命周期，比如调用 f(\u0026x) 时绑定的是 x 的生命周期，而调用 f(\u0026y) 时绑定的是 y 的生命周期。 使用HRTBS修改如下: fn foo(f: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 这样生命周期 'a 就不再是静态的了，他会随着闭包 f 的调用绑定到不同的生命周期：f(\u0026x) 调用时绑定到 x 的生命周期，f(\u0026y) 调用时绑定到 y 的生命周期。 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"PhantomData PhantomData主要用于无界生命周期(unbounded lifetime)或者需要drop struct非自身字段,例如: use std::marker: struct Vec\u003cT\u003e { data: *const T, // *const是可变的！ len: usize, cap: usize, _marker: marker::PhantomData\u003cT\u003e, } PhantomData模式表 Phantom 类型 'a 'T PhantomData\u003cT\u003e - 协变（可触发drop检查） PhantomData\u003c\u0026'a T\u003e 协变 协变 PhantomData\u003c\u0026'a mut T\u003e 协变 不变 PhantomData\u003c*const T\u003e - 协变 PhantomData\u003c*mut T\u003e - 不变 PhantomData\u003cfn(T)\u003e - 逆变(*) PhantomData\u003cfn() -\u003e T\u003e - 协变 PhantomData\u003cfn(T) -\u003e T\u003e - 不变 PhantomData\u003cCell\u003c\u0026'a ()\u003e\u003e 不变 - (*)如果发生变性的冲突，这个是不变的 我们可以使用泛型结构体来实现对同一种类对象不同子类对象的区分，例如，我们的系统中要设计这样一个功能，将用户分为免费用户和付费用户，而且免费用户在体验免费功能之后，如果想升级成付费用户也是可以的。按照我们常规的思维，可能是定义两个结构体 FreeCustomer 以及 PaidCustomer，但是我们可以通过泛型结构体来实现，例如： struct Customer\u003cT\u003e { id: u64, name: String, } 不过，我们这里的 T 又无处安放，所以又不得不使用 PhantomData，它就像一个占位符，但是又没有大小，可以为我们持有在声明时使用不到的数据： use std::{ marker::PhantomData, sync::atomic::{self, AtomicU64}, }; static NEXT_ID: AtomicU64 = AtomicU64::new(0); struct Customer\u003cT\u003e { id: u64, name: String, phantom: PhantomData\u003cT\u003e, } struct FreeFeature; struct PaidFeature; trait Free { fn feature1(\u0026self); fn feature2(\u0026self); } trait Paid: Free { fn paid_feature(\u0026self); } /// 为 Customer\u003cT\u003e 实现需要的方法 impl\u003cT\u003e Customer\u003cT\u003e { fn new(name: String) -\u003e Self { Self { id: NEXT_ID.fetch_add(1, atomic::Ordering::Relaxed), name, phantom: PhantomData, } } } /// 免费用户可以升级到付费用户 impl Customer\u003cFreeFeature\u003e { fn advance(self, payment: f64) -\u003e Customer\u003cPaidFeature\u003e { println!( \"{}（{}） 将花费 {:.2} 元升级到付费用户\", self.name, self.id, payment ); self.into() } } /// 所有客户都有权使用免费功能 impl\u003cT\u003e Free for Customer\u003cT\u003e { fn feature1(\u0026self) { println!(\"{} 正在使用免费功能一\", self.name) } fn feature2(\u0026self) { println!(\"{} 正在使用免费功能二\", self.name) } } /// 付费用户才能使用的功能 impl Paid for Customer\u003cPaidFeature\u003e { fn paid_feature(\u0026self) { println!(\"{} 正在使用付费功能\", self.name) } } /// 允许使用免费用户转换成付费用户 impl From\u003cCustomer\u003cFreeFeature\u003e\u003e for Customer\u003cPaidFeature\u003e { fn from(c: Customer\u003cFreeFeature\u003e) -\u003e Self { Self::new(c.name) } } #[cfg(test)] mod tests { use super::*; #[test] fn test_customer() { // 一开始是免费用户 let customer = Customer::\u003cFreeFeature\u003e::new(\"MichaelFu\".to_owned()); customer.feature1(); customer.feature2(); // 升级成付费用户，可能使用付费功能和普通功能 let customer = customer.advance(99.99); customer.feature1(); customer.feature2(); customer.paid_feature(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Thread_local thread_local是一种将数据存储到全局变量中的方法，程序中的每个线程都有自己的副本。线程不共享这个数据，所以访问不需要同步,thread_local中声明的变量，在线程结束后会被释放，比如如果有10个线程中使用了该thread_local变量,则这10个线程结束时将有10个该类型的变量被释放。这适用于thread_per_core架构的异步运行时(类似于nginx),而不是tokio这种work-stealing scheduler(任务窃取). 举个例子: use std::borrow::Cow; use std::cell::RefCell; use std::thread; fn main() { thread_local!(static FOO: RefCell\u003cu32\u003e = RefCell::new(1)); FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 2; }); // 每个线程开始时都会拿到线程局部变量的FOO的初始值 let t = thread::spawn(move || { FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 3; }); }); // 等待线程完成 t.join().unwrap(); // 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2 FOO.with(|f| { assert_eq!(*f.borrow(), 2); }); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Barrier(线程屏障) 使用 Barrier 让多个线程都执行到某个点后，才继续一起往后执行： use std::sync::{Arc, Barrier}; use std::thread; fn main() { let mut handles = Vec::with_capacity(5); let barrier = Arc::new(Barrier::new(5)); for _ in 0..5 { let b = barrier.clone(); handles.push(thread::spawn(move|| { println!(\"before wait\"); b.wait(); println!(\"after wait\"); })); } for handle in handles { handle.join().unwrap(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"once_cell和lazy_static once_cell 和 lazy_static 都是 Rust 中用于实现单例模式（Singleton）的库。 once_cell 适用于程序初始化加载配置文件这种场景 LazyCell和LazyLock适用于初始化某个变量,比如说正则的compile,数据库连接等场景. #![feature(once_cell)] use std::cell; use std::collections::HashMap; use std::sync; use std::sync::Once; static INIT: Once = sync::Once::new(); static mut SUM: u64 = 0; fn init_sum() -\u003e u64 { unsafe { INIT.call_once(|| { println!(\"this is first init\"); SUM = (1..100000).sum(); }); SUM } } fn main() { let split_line = \"*\".repeat(100); let first_result = init_sum(); println!(\"first result: {first_result}\"); let second_result = init_sum(); println!(\"second result: {second_result}\"); println!(\"{split_line}\"); let once = cell::OnceCell::\u003cHashMap\u003c\u0026str, \u0026str\u003e\u003e::new(); let dict = once.get_or_init(|| { println!(\"this is hash map init once\"); let mut map = HashMap::new(); map.insert(\"lang\", \"rust\"); map.insert(\"edition\", \"2021\"); map }); println!(\"once dict: {dict:?}\"); let dict_twice = once.get_or_init(|| { println!(\"this is hash map init twice\"); let mut map = HashMap::new(); map.insert(\"lang\", \"python\"); map.insert(\"version\", \"1.10\"); map }); println!(\"twice dict: {dict_twice:?}\"); println!(\"{split_line}\"); let lazy_init = cell::LazyCell::new(|| env!(\"PATH\")); println!(\"lazy_init: {}\", *lazy_init); // thread safe lazy cell let lazy_init_safe = sync::LazyLock::new(|| env!(\"PATH\")); print!(\"lazy_init_safe: {}\", *lazy_init_safe); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"impl A and T: A 在 impl 中被声明的类型参数，至少要满足下面三种形式： impl Foo， T 出现在实现的Self 类型Foo 中 。 impl SomeTrait for Foo ， T出现在要实现的 trait 中 。 impl\u003cT, U\u003e SomeTrait for T where T: AnotherTrait\u003cAssocType=U\u003e ， 出现在 T 的 trait 限定的关联类型中。 参考资料: 【Rust】幽灵数据（PhantomData） | MichaelFu (fudenglong.site) 3.10 PhantomData（幽灵数据） | 第三章、所有权 |《Rust 高级编程 2018》| Rust 技术论坛 (learnku.com) Rust高阶生命周期绑定 (xiaopengli89.github.io) ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["c/c++"],"content":"cmake简易教程 ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"1. 添加头文件目录INCLUDE_DIRECTORIES 它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。 语法： include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"2. 添加需要链接的库文件目录LINK_DIRECTORIES 语法： link_directories(directory1 directory2 ...) 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。 link_directories(\"/home/server/third/lib\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"3. 添加需要链接的库文件路径LINK_LIBRARIES 语法： link_libraries(library1 \u003cdebug | optimized\u003e library2 ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"4. 设置要链接的库文件的名称TARGET_LINK_LIBRARIES 语法： target_link_libraries(\u003ctarget\u003e [item1 [item2 [...]]] [[debug|optimized|general] \u003citem\u003e] ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"5. 查找库所在目录FIND_LIBRARY 语法： find_library (\u003cVAR\u003e name1 [path1 path2 ...]) find_library ( \u003cVAR\u003e name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \"cache documentation string\"] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 例子如下： FIND_LIBRARY(RUNTIME_LIB rt /usr/lib /usr/local/lib NO_DEFAULT_PATH) cmake会在目录中查找，如果所有目录中都没有，值RUNTIME_LIB就会被赋为NO_DEFAULT_PATH ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:5:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"6. 查找源文件和头文件 # 查找指定目录下的所有.cpp与.h文件 并存放到指定变量名SC_FILES中 FILE(GLOB SC_FILES \"*.cpp\" \"*.h\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:6:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"7. 添加源文件目录 使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。 语法： aux_source_directory(\u003cdir\u003e \u003cvariable\u003e) # 生成链接库 add_library (MathFunctions ${DIR_LIB_SRCS}) 参考链接： cmake 添加头文件目录，链接动态、静态库 - 王彬彬 - 博客园 (cnblogs.com) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:7:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"opencv实现抠图和裁剪 ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:0:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"1. 抠图 步骤: 加载图像 转换图像格式(BGR –\u003e HSV) 设置阈值 通过阈值提取部分区域 显示图片 关于HSV可参考：HSL和HSV色彩空间 - 维基百科，自由的百科全书 (wikipedia.org) window_name = 'hsv' img = cv2.imread(r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\") # 设置高低阈值 hsv_low = np.array([0, 0, 0]) hsv_high = np.array([134, 255, 138]) # 将BGR转为HSV dst = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 通过HSV的高低阈值，提取图像部分区域 mask_img = cv2.inRange(dst, hsv_low, hsv_high) # 进行与位运算 img_ = cv2.bitwise_and(img, img, mask=mask_img) cv2.imshow(window_name, img_) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:1:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"2. 裁剪图片 步骤 加载图像 设置鼠标事件 - 鼠标左键单击画点\r- 鼠标右键单击闭合所画的点\r- 鼠标右键双击填充 # 触发鼠标移动事件 # cv2.CV_EVENT_MOUSEMOVE # 触发左键抬起事件 # cv2.CV_EVENT_LBUTTONUP # 触发右键按下事件 # cv2.CV_EVENT_RBUTTONDOWN # 触发右键抬起事件 # cv2.CV_EVENT_RBUTTONUP # 触发左键双击事件 # cv2.CV_EVENT_LBUTTONDBLCLK # 触发右键双击事件 # cv2.CV_EVENT_RBUTTONDBLCLK coordinates = [] window_name = 'draw' def on_mouse_callback(event, x, y, flag, param): # 左键点击,画点 if event == cv2.EVENT_LBUTTONDOWN: xy = f'{x},{y}' coordinates.append((x, y)) cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1) cv2.putText(img, xy, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness=1) cv2.imshow(window_name, img) # 右键单击，画不规则图形 elif event == cv2.EVENT_RBUTTONDOWN: pts = np.array(coordinates, np.int32) # 顶点集 #顶点坐标转为rowsx1x2, row为顶点数 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (255, 255, 255), 2) cv2.imshow(window_name, img) # 右键双击，填充颜色 elif event == cv2.EVENT_RBUTTONDBLCLK: area = np.array(coordinates) # 可以绘制多个图形 cv2.fillPoly(img, [area], (255, 255, 255)) # 绘制凸多边形 # cv2.fillConvexPoly(img, area, (255, 255, 255)) cv2.imshow(window_name, img) coordinates.clear() cv2.namedWindow(window_name) cv2.setMouseCallback(window_name, on_mouse_callback) cv2.imshow(window_name, img) cv2.waitKey(0) cv2.destroyAllWindows() Rust版opencv实现抠图 Cargo.toml [dependencies] opencv = { version = \"0.71\" } src/main.rs use opencv::{ core::{bitwise_and, in_range, Vector, CV_8UC3}, highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, imgproc::{cvt_color, COLOR_BGR2HSV}, prelude::*, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img = imread( r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\", ImreadModes::IMREAD_COLOR as i32, )?; unsafe { let mut lowerb = Vector::from_slice(\u0026[0, 0, 0u8]); let mut upperb = Vector::from_slice(\u0026[134, 255, 138u8]); let mut dst = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut mask_img = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut result = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; cvt_color(\u0026img, \u0026mut dst, COLOR_BGR2HSV, 0)?; in_range(\u0026img, \u0026mut lowerb, \u0026mut upperb, \u0026mut mask_img)?; bitwise_and(\u0026img, \u0026img, \u0026mut result, \u0026mask_img)?; imshow(\"winname\", \u0026result)?; } wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:2:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Rust"],"content":"Rust中使用opencv 因为在macos和linux上安装比较简单，这里只介绍windows上的安装 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:0:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"安装环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 安装opencv 下载地址：Releases - OpenCV 选择windows平台，下载后默认安装即可 设置环境变量 OPENCV_INCLUDE_PATHS OPENCV_LINK_LIBS OPENCV_LINK_PATHS 注意：opencv_world460这个不是固定的，需要根据下载的具体版本设置，我的版本中位于D:\\development\\opencv\\build\\x64\\vc15\\bin目录 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 安装LLVM 下载地址：Releases · llvm/llvm-project (github.com) 根据需要安装32位或者64位，有些版本可能没有这2个选项，可以选择以前的版本，没必要选择最新的版本。下载后默认安装即可，注意需要在添加LLVM到环境变量中 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"简单使用 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 确保安装了Rust环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 新建项目 cargo new opencv-rust-test ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"3. 配置Cargo.toml文件 [dependencies] opencv = { version = \"0.71\" } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:3","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"4. 将opencv_world460.dll文件拷贝到项目根目录(重要！！！) 如果opencv_world460.dll路径添加到环境变量中，应该就不需要将文件拷贝(没有实际测试) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:4","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"5. 编写代码测试环境是否正常 src/main.rs use opencv::{ highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img_path = r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\"; let img = imread(img_path, ImreadModes::IMREAD_COLOR as i32)?; imshow(\"winname\", \u0026img)?; wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:5","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"6. 运行测试 # 使用cargo命令运行看看是否正常显示图片 cargo run ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:6","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"7. 报错解决 主要参考官方文档： twistedfall/opencv-rust: Rust bindings for OpenCV 3 \u0026 4 (github.com) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:7","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Linux"],"content":"管道 ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:0:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"匿名管道(Pipe) 特点 半双工 只能用于具有亲缘关系进程(父子，兄弟) 可以视作特殊文件，读写可以使用write，read函数 #include\"stdio.h\" #include\"unistd.h\" // https://learnku.com/articles/44477 // **特点** // 1. 半双工 // 2. 只能用于具有亲缘关系进程(父子，兄弟) // 3. 可以视作特殊文件，读写可以使用write，read函数 int main() { int fd[2]; pid_t pid; char buf[32]; //创建管道 if (pipe(fd) \u003c 0) { printf(\"Create Pipe Error \\n\"); } //创建子进程 if ((pid = fork()) \u003c 0) { printf(\"Fork Error \\n\"); } else if (pid \u003e 0) { close(fd[0]); // 关闭父进程读端 write(fd[1], \"hello world\", 8); //父进程写端写入 } else { close(fd[1]); // 关闭子进程写端 read(fd[0], buf, 8); // 子进程读取父进程消息 printf(\"Child Recv Msg: %s\", buf); } } ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:1:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"命名管道(FIFO) 特点 和匿名管道不同，FIFO可以在无关进程间通信 FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 fifo_read.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"errno.h\" #include\"fcntl.h\" #include\"sys/stat.h\" int main() { int fd; int len; char buf[1024]; if (mkfifo(\"/home\", 0666) \u003c 0 \u0026\u0026 errno != EEXIST) { perror(\"Create FIFO Failed\"); } if ((fd = open(\"/home\", O_RDONLY)) \u003c 0) { perror(\"Open FIFO Failed\"); exit(1); } while ((len = read(fd, buf, 1024)) \u003e 0) { printf(\"Read Message: %s\", buf); } close(fd); return 0; } fifo_write.c #include\"stdio.h\" #include\"unistd.h\" #include\"stdlib.h\" #include\"fcntl.h\" // O_WRONLY #include\"sys/stat.h\" #include\"time.h\" // ## 命名管道(FIFO) // ** 特点** // 1. 和匿名管道不同，FIFO可以在无关进程间通信 // 2. FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 int main() { int fd; int n, i; char buf[1024]; time_t tp; printf(\"Parent Process PID:\", getpid()); if ((fd = open(\"/home\", O_WRONLY)) \u003c 0) { // 写模式打开FIFO perror(\"Open FIFO Failed\"); exit(1); } for (i = 0; i \u003c 10; ++i) { time(\u0026tp);// 当前系统时间 n = sprintf(buf, \"Process %d's time is %s\", getpid(), ctime(\u0026tp)); printf(\"Send message: %s\", buf); // 写入数据到FIFO中 if (write(fd, buf, n + 1) \u003c 0) { perror(\"Write FIFO Failed\"); close(fd); exit(1); } sleep(1); } close(fd); return 0; } 消息队列 特点 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。 msg_client.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // key值不变，要么确保ftok()的文件不被删除，要么不用ftok()，指定一个固定的key值。 // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } printf(\"Message Queue - Client key is: %d.\\n\", key); // 打开消息队列 if ((msqid = msgget(key, IPC_CREAT | 0777)) == -1) { perror(\"msgget error\"); exit(1); } // 打印消息队列ID和进程ID printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); // 添加消息，类型为888 msg.mtype = 888; sprintf(msg.mtext, \"hello, I'm client %d\", getpid()); //msgid是由msgget函数返回的消息队列标识符。 // __msgp是一个指向准备发送消息的指针，消息的数据结构却有一定的要求， // 指针msg_ptr所指向的消息结构一定要是以一个**长整型**成员变量开始的结构体，接收函数将用这个成员来确定消息的类型 msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); // msgrcv函数type参数有以下几种可能： // type == 0，返回队列中的第一个消息； // type \u003e 0，返回队列中消息类型为 type 的第一个消息； // type \u003c 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。 // 读取类型为999的消息 msgrcv(msqid, \u0026msg, 256, 999, 0); printf(\"Client: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Client: receive msg.mtype is: %d.\\n\", msg.mtype); } msg_server.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } // 打印key值 printf(\"Message Queue - Server key is: %d.\\n\", key); // 创建消息队列 if ((msqid = msgget(key, IPC_CREAT | 0700)) == -1) { perror(\"msgget error\"); exit(1); } printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); for (;;) { // 返回类型为888的第一个消息 msgrcv(msqid, \u0026msg, 256, 888, 0); printf(\"Server: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Server: receive msg.mtype is: %d.\\n\", msg.mtype); msg.mtype = 999; sprintf(msg.mtext, \"hello, I'm server %d\", getpid()); msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); } return 0; } 信号量 特点 是一个计数器 用于实现进程间互斥和同步,不是存储进程间通信数据 示例 #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/sem.h\" union semun { int val; struct semid_ds* buf; unsigned short* array; }; int init_sem(int sem_id, int value) { union semun tmp; tmp.val = value; if (semctl(sem_id, 0, SETVAL, tmp) == -1) { perror(\"Init Semaphore Error\"); return -1; } return 0; } // p操作 // 若信号量值为1，获取资源并将信号值置为-1 // 若信号量值为0，进程挂起等待 int sem_p(int sem_id) { struct sembuf sbuf; sbuf.sem_num = 0; // 序号 sbuf.sem_op = -1; // 操作 sbuf.sem_flg = SEM_UNDO; if (semop(sem_id, \u0026sbuf, 1) == -1) { perror(\"P operation Error\"); return -","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:2:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Python"],"content":"索引 import pandas as pd import numpy as np df = pd.DataFrame(np.arange(50).reshape(-1, 5), columns=list('abcde')) # 根据列标签索引 df['a'] # 或者 df.loc[:,'a'] # 根据列索引 df.iloc[:, 0] # df['a'] == df.loc[:,'a'] == df.iloc[:, 0] 计算 # 所有元素乘法 df * 10 # 指定列相乘 # 注意：不会在原地修改，需要重新赋值 df['a'] = df['a'] * 10 # 指定位置操作 df.iloc[0,3] = 100 # 也可以指定多列操作，生成新列 df['e'] = df['a'] * df['b'] 合并 df_new = pd.DataFrame(np.arange(200, 230).reshape(-1, 2), columns=['z','x']) # 注意：这里因为2个DataFrame行索引没有冲突，索引这里没有问题。 # axis 为0时以行合并(可以是实现数据追加)，为1时以列合并 pd.concat([df, df_new], axis=1) # 当下面的df的行索引不连续时，df_new就会缺少一些行的数据 df = df[df.loc[:, 'a'] % 100 == 0] pd.concat([df, df_new], axis=1) # 如果当出现上面一种情况，而又不想丢掉df_new的数据时可以使用重新索引的方法 df = df.reset_index(drop=True) pd.concat([df, df_new], axis=1) 追加数据 # 不能这样追加，需要列标签相对应 df.append([1, 3, 5, 3,5]) # 新Dataframe需要和df标签对应 new_row = pd.DataFrame(np.full((1,4), 5), columns=list('abcd')) df.append(new_row) # 也可以这样 # pd.concat([df, new_row], axis=0) Apply 使用 # 当Dateframe中不再是存数字时，就不能根据直接对列进行操作生成新列，有些时候还含有复杂的条件判断，这时候既可以使用apply函数 # 注意当新加列时需要设置axis=1 df['f'] = df[['b','c']].apply(lambda x: x[0]*100 if x[0] % 2 == 0 else x[1] - 100, axis=1) 排序 # 根据索引排序,axis=0代表行，axis=1代表列 df.sort_index() # 根据值排序,可根据多个值排序 df.sort_values(by=['a']) # 如果Dataframe含有重复列，重复列的数据又不相同，但又想按值排序，可以参考下面 # 比如说2，4列名相同，想按照第2列的值排序 # sort_col_values = df.iloc[:, 2].to_numpy() # sort_indexs = sort_col_values.argsort() # df = df.iloc[:, sort_indexs] 去重 # 使用函数drop_duplicates，其中subset指定要去重的列名，不能写列索引，即指定的相同列才进行去重，默认按照所有列相同去重，keep参数可以指定保留first，last。inplace选择是否修改原Dataframe # df.drop_duplicates(subset=[], keep='first', inplace=False) # 当Dataframe有重复列名，重复列名数据不相同时，可以将Dataframe拆分，再进行去重，去重后再合并 # 例如：2，4列名重复，需要按照1，2列去重 # 拆分 front = df.iloc[:, :2] back = df.iloc[:, 2:] # 去重 front.drop_duplicates(subset=['a', 'b'], keep='first', inplace=True) back = back.iloc[front.index, :] # 合并,这里能保证行索引能一一对应，所以不用重建索引也行。当时也可以选择重建索引 pd.concat([front, back], axis=1) 字符串操作 在pandas中可以针对需要操作列方便的使用字符串的所有函数 # 举例： # 注意：这里的replace方法默认使用正则表达式，可以添加regex=False来关闭 df['a'].str.replace(regex=False) 分组和聚合 # 对指定列进行聚合计算，agg会返回分组结果，并且列数据为聚合操作后的结果 # 使用以下访问生成聚合结果 lang = df.groupby(by='姓名').agg({'语文': 'sum'}) math = df.groupby(by='姓名').agg({'数学': 'sum'}) english = df.groupby(by='姓名').agg({'英语': 'sum'}) # pd.concat([lang, math, english], axis=1) # 以上等于下面这行。 # df.groupby(by='姓名').sum() # 如果要对不同列进行不同聚合操作，可以使用以下方法： df = df.groupby(by='姓名').agg({'语文': 'sum', '姓名': 'count'}) # 注意：如果使用以上方法会出现重复列，那就需要重命名列名 df = df.rename({'姓名': 'count'}, axis=1) # 使用transform返回DataFrame # df['count'] = df.groupby(by='姓名')['数学'].transform('sum') 读取和保存 # 读取csv提供了许多使用的选项，比如可以指定分隔符，读取部分数据，跳过表头，指定列名读取 # 参考：https://www.gairuo.com/p/pandas-read-csv pd.read_csv( filepath_or_buffer: 'FilePathOrBuffer', sep=\u003cno_default\u003e, delimiter=None, header='infer', names=\u003cno_default\u003e, index_col=None, usecols=None, squeeze=False, prefix=\u003cno_default\u003e, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None, ) # 读取excel # 参考https://www.gairuo.com/p/pandas-read-excel pd.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=Fa","date":"2022-11-12","objectID":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["pandas"],"title":"Pandas使用小结","uri":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["Numpy","Python"],"content":"Numpy 排序函数 numpy.sort(a, axis=-1, kind=None, order=None) 参数: a : 要排序的数组； axis ： 按什么轴进行排序，默认按最后一个轴进行排序； kind ：排序方法，默认是快速排序(不稳定)，可选参数有:{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’} order : 当数组定义了字段属性时，可以按照某个属性进行排序； numpy.argsort(a, axis=-1, kind=None, order=None):numpy.argsort 函数用于将数组排序后，返回数组元素从小到大依次排序的所有元素索引 参数: a : 要排序的数组 axis ： 按什么轴进行排序，默认按最后一个轴进行排序 kind ：排序方法，默认是快速排序 order : 当数组定义了字段属性时，可以按照某个属性进行排序 排序后索引解释： 比如说第一行排序后的结果为：[1, 0, 2] 表示原数组索引为 1 的数现在变为 0，原索引为 0 变为 1，原索引为 2 保持不变,即[0, 1, 2] -\u003e [1, 0, 2] numpy.lexsort(keys, axis=-1): numpy.lexsort 函数用于按照多个条件（键）进行排序，返回排序后索引。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 参数: keys ：序列或元组，要排序的不同的列 axis ：指定次排序的轴(默认为-1，即最后一个轴) 注意：根据数组的 shape 维数指定次排序轴，也就是说如果是二维数组只能设置为 0，因为 1 是著排序轴。如果 shape 为(2,3,5),则 axis 可指定为 0 或者 1 根据行和列排序 ","date":"2022-11-05","objectID":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/:0:0","tags":["numpy","sort"],"title":"Numpy使用排序","uri":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/"},{"categories":["Rust","Openssl","Crypto"],"content":"AES 加密算法 AES(Advanced Encryption Standard)，全称：高级加密标准，是一种最常见的对称加密算法 ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"配置 Rust Toml 文件 [dependencies] openssl = { version = \"0.10\", features = [\"vendored\"] } ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"示例代码 use openssl::symm::{Cipher, Crypter, Mode}; fn main() { let key = \"061cecfd897548208c76c04b6e7fb\".as_bytes(); let crypto_word: \u0026mut Vec\u003cu8\u003e = \u0026mut \"keyword\".as_bytes().to_vec(); let block_size = Cipher::aes_128_cbc().block_size(); // 添加填充 pkcs7_padding(crypto_word, block_size); let mut output = vec![0; 1024]; // 取16位密钥 let mut encrypter = Crypter::new(Cipher::aes_128_ecb(), Mode::Encrypt, \u0026key[..16], None).unwrap(); match encrypter.update(\u0026f, \u0026mut output) { Ok(size) =\u003e { eprintln!(\"size is: {size}\"); println!(\"{:?}\", \u0026output[..size]); println!(\"{:02x?}\", \u0026output[..size]); // 转换为16进制 } Err(_) =\u003e {} }; } fn pkcs7_padding(data: \u0026mut Vec\u003cu8\u003e, block_size: usize) { let padding_num = block_size - data.len() % block_size; let padding = padding_num as u8; data.append(\u0026mut [padding].repeat(padding_num)); } 参考链接： AES 加解密-CBC ECB - 独孤剑—宇枫 - 博客园 (cnblogs.com) AES 加密(3)：AES 加密模式与填充 - 知乎 (zhihu.com) ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["教程"],"content":"安装镜像 下载地址： https://ubuntu.com/download/raspberry-pi 刷入镜像到SD卡 刷入后需要重新拔插SD卡 找到system-boot盘符盘符下network-config文件 根据实际情况修改wifi配置 version: 2 ethernets: eth0: dhcp4: true optional: true #wifis: # wlan0: # dhcp4: true # optional: true # access-points: # myhomewifi: # password: \"S3kr1t\" # myworkwifi: # password: \"correct battery horse staple\" # workssid: # auth: # key-management: eap # method: peap # identity: \"me@example.com\" # password: \"passw0rd\" # ca-certificate: /etc/my_ca.pem 开机查找wifi 查找树莓派ip地址可用方法： 登录路由器后台查看连接设备中树莓派IP 使用Advanced_IP_Scanner软件 连接ssh 初始用户名和密码都是：ubuntu ssh ubuntu@ip 注意：第一次登陆会强制要求修改密码，修改后再次登录即可，密码也不能太短 换源 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改文件内容为: deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-backports main restricted universe multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security multiverse 更新 sudo apt update sudo apt upgrade -y 参考链接： 树莓派折腾记（一）– 安装系统（Ubuntu Server 20.04.1） | 修行的技术阁 (mrxiuxing.com) ","date":"2022-10-24","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/:0:0","tags":["raspberry"],"title":"树莓派安装Ubutnu无显示器网络初次开机","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/"},{"categories":["教程"],"content":"Hugo博客从零到发布 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:0:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"1. 安装 安装hugo: 下载地址：https://github.com/gohugoio/hugo/releases/tag/v0.104.3 注意： 有些主题需要下载extended版本 安装git： 下载地址：https://git-scm.com/ ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:1:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"2. 配置远程仓库，并新建一个空项目(不需要README.md文件)，名字一般和站点名相同 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:2:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 本地部署 新建站点并配置git hugo new site your_site_name # 下载你需要的主题的压缩包放到theme目录下或者使用`git submodule`拉取，例： git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt # 根据主题文档配置config.toml文件，如果只有一个主题可直接在项目根目录下的config.toml文件配置 # 0. 当本地可以正常预览站点时运行，hugo命令打包，生成静态文件 # 1. 使用git初始化站点 # 2. 添加远程仓库 git remote add origin remtoe_url # 3. 拉取远程 # 4. 提交当前代码 # 4. 新建分支(例如：release)，命令如下： git switch -c release # 或者 git checkout -b release # 5. 合并主分支分支public目录到当前分支，命令如下： git checkout master public/** # 6. 移动public下所有内容到项目根目录下，例如： mv public/* . # 7. 再提交当前分支内容 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:3:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 推送到远程 # 使用git推送到远程仓库 git switch master git push -u origin master git switch release git push -u origin release # 将远程仓库默认分支设置为release ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:4:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"4. 使用cloudflare发布 注册一个cloudflare账号：https://dash.cloudflare.com/ 点击Pages，选择创建项目下连接到Git，然后根据需要配置相应信息 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:5:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"Kunpeng Compute安全编程指南 本文档基于C语言提供一些安全编程建议，用于指导开发实践。 数据类型 ","date":"0001-01-01","objectID":"/securecoding/:0:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保有符号整数运算不溢出 【描述】 有符号整数溢出是未定义的行为。出于安全考虑，对外部数据中的有符号整数值在如下场景中使用时，需要确保运算不会导致溢出： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 1)加法 【错误代码示例】(加法) 如下代码示例中，参与加法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = num_a + num_b; ... 【正确代码示例】(加法) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = 0; if (((num_a \u003e 0) \u0026\u0026 (num_b \u003e (INT_MAX - num_a))) || ((num_a \u003c 0) \u0026\u0026 (num_b \u003c (INT_MIN - num_a)))) { ... // 错误处理 } sum = num_a + num_b; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，参与减法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出，进而造成后续的内存复制操作出现缓冲区溢出。 unsigned char *content = ... // 指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 int total_len = ... // 报文总长度 int skip_len = ... // 从消息中解析出来的需要忽略的数据长度 // 用total_len - skip_len 计算剩余数据长度，可能出现整数溢出 (void)memmove(content, content + skip_len, total_len - skip_len); ... 【正确代码示例】(减法) 如下代码示例中，重构为使用size_t类型的变量表示数据长度，并校验外部数据长度是否在合法范围内。 unsigned char *content = ... //指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 size_t total_len = ... // 报文总长度 size_t skip_len = ... // 从消息中解析出来的需要忽略的数据长度 if (skip_len \u003e= total_len || total_len \u003e content_size) { ... // 错误处理 } (void)memmove(content, content + skip_len, total_len - skip_len); ... 3)乘法 【错误代码示例】(乘法) 如下代码示例中，内核代码对来自用户态的数值范围做了校验，但是由于opt是int类型，而校验条件中错误的使用了ULONG_MAX进行限制，导致整数溢出。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (ULONG_MAX / (60 * HZ)))) { // 错误的使用了ULONG_MAX做上限校验 return -EINVAL; } ... = opt * 60 * HZ; // 可能出现整数溢出 ... 【正确代码示例】(乘法) 一种改进方案是将opt的类型修改为unsigned long类型，这种方案适用于修改了变量类型更符合业务逻辑的场景。 unsigned long opt = ... // 将类型重构为 unsigned long 类型。 if (opt \u003e (ULONG_MAX / (60 * HZ))) { return -EINVAL; } ... = opt * 60 * HZ; ... 另一种改进方案是将数值上限修改为INT_MAX。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (INT_MAX / (60 * HZ)))) { // 修改使用INT_MAX作为上限值 return -EINVAL; } ... = opt * 60 * HZ; 4)除法 【错误代码示例】(除法) 如下代码示例中，做除法运算前只检查了是否出现被零除的问题，缺少对数值范围的校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a / num_b; // 可能出现整数溢出 ... 【正确代码示例】(除法) 如下代码示例中，按照最大允许值进行校验，防止整数溢出，在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 5)求余数 【错误代码示例】(求余数) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a % num_b; // 可能出现整数溢出 ... } 【正确代码示例】(求余数) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... } 6)一元减 当操作数等于有符号整数类型的最小值时，在二进制补码一元求反期间会发生溢出。 【错误代码示例】(一元减) 如下代码示例中，计算前未校验数值范围，可能出现整数溢出。 int num_a = ... // 来自外部数据 int result = -num_a; // 可能出现整数溢出 ... 【正确代码示例】(一元减) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int result = 0; if (num_a == LNT_MIN) { ... // 错误处理 } result = -num_a; ... ","date":"0001-01-01","objectID":"/securecoding/:1:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保无符号整数运算不回绕 【描述】 涉及无符号操作数的计算永远不会溢出，因为超出无符号整数类型表示范围的计算结果会按照（结果类型可表示的最大值 + 1）的数值取模。 这种行为更多时候被非正式地称为无符号整数回绕。 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 出于安全考虑，对外部数据中的无符号整数值在如下场景中使用时，需要确保运算不会导致回绕： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 1)加法 【错误代码示例】(加法) 如下代码示例中，校验下一个子报文的长度加上已处理报文的长度是否超过了整体报文的最大长度，在校验条件中的加法运算可能会出现整数回绕，造成绕过该校验的问题。 size_t total_len = ... // 报文的总长度 size_t read_len = 0 // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 从网络报文中解析出来的下一个子报文的长度 if (read_len + pkt_len \u003e total_len) { // 可能出现整数回绕 ... // 错误处理 } ... read_len += pkt_len; ... 【正确代码示例】(加法) 由于read_len变量记录的是已经处理报文的长度，必然会小于total_len，因此将代码中的加法运算修改为减法运算，导致条件绕过。 size_t total_len = ... // 报文的总长度 size_t read_len = 0; // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 来自网络报文 if (pkt_len \u003e total_len - read_len) { ... // 错误处理 } ... read_len += pkt_len; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，校验len合法范围的运算可能会出现整数回绕，导致条件绕过。 size_t len = ... // 来自用户态输入 if (SCTP_SIZE_MAX - len \u003c sizeof(SctpAuthBytes)) { // 减法操作可能出现整数回绕 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); // 可能出现整数回绕 ... 【正确代码示例】(减法) 如下代码示例中，调整减法运算的位置（需要确保编译期间减法表达式的值不翻转），避免整数回绕问题。 size_t len = ... // 来自用户态输入 if (len \u003e SCTP_SIZE_MAX - sizeof(SctpAuthBytes)) { // 确保编译期间减法表达式的值不翻转 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); ... 3)乘法 【错误代码示例】（乘法） 如下代码示例中，使用外部数据计算申请内存长度时未校验，可能出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 unsigned char *buf = (unsigned char *)malloc(width * hight); 无符号整数回绕可能导致分配的内存不足。 【正确代码示例】（乘法） 如下代码是一种解决方案，校验参与乘法运算的整数数值范围，确保不会出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 if (width == 0 || hight == 0) { ... // 错误处理 } if (width \u003e SIZE_MAX / hight) { ... // 错误处理 } unsigned char *buf = (unsigned char *)malloc(width * hight); 【例外】 为正确执行程序，必要时无符号整数可能表现出模态（回绕）。建议将变量声明明确注释为支持模数行为，并且对该整数的每个操作也应明确注释为支持模数行为。 【相关软件CWE编号】 CWE-190 ","date":"0001-01-01","objectID":"/securecoding/:2:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保除法和余数运算不会导致除零错误(被零除) 【描述】 整数的除法和取余运算的第二个操作数值为0会导致程序产生未定义的行为，因此使用时要确保整数的除法和余数运算不会导致除零错误(被零除，下同)。 1)除法 【错误代码示例】(除法) 有符号整数类型的除法运算如果限制不当，会导致溢出。 如下示例对有符号整数进行的除法运算做了防止溢出限制，确保不会导致溢出，但不能防止有符号操作数num_a和num_b之间的除法过程中出现除零错误： int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a / num_b; // 可能出现除零错误 ... 【正确代码示例】(除法) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 2)取余 【错误代码示例】(求余数) 如下代码，同除法的错误代码示例一样，可能出现除零错误，因为许多平台以相同的指令实现求余数和除法运算。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a % num_b; // 可能出现除零错误 ... 【正确代码示例】(求余数) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... 变量 ","date":"0001-01-01","objectID":"/securecoding/:3:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用未经初始化的变量 【描述】 这里的变量，指的是局部动态变量，并且还包括内存堆上申请的内存块。 因为他们的初始值都是不可预料的，所以禁止未经有效初始化就直接读取其值。 void foo( ...) { int data; bar(data); // 错误：未初始化就使用 ... } 如果有不同分支，要确保所有分支都得到初始化后才能使用： #define CUSTOMIZED_SIZE 100 void foo( ...) { int data; if (condition \u003e 0) { data = CUSTOMIZED_SIZE; } bar(data); // 错误：部分分支该值未初始化 ... } ","date":"0001-01-01","objectID":"/securecoding/:4:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"指向资源句柄或描述符的变量，在资源释放后立即赋予新值 【描述】 指向资源句柄或描述符的变量包括指针、文件描述符、socket描述符以及其它指向资源的变量。 以指针为例，当指针成功申请了一段内存之后，在这段内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，那这个指针就是一个悬空指针。 如果再对悬空指针操作，可能会发生重复释放或访问已释放内存的问题，造成安全漏洞。 消减该漏洞的有效方法是将释放后的指针立即设置为一个确定的新值，例如设置为NULL。对于全局性的资源句柄或描述符，在资源释放后，应该马上设置新值，以避免使用其已释放的无效值；对于只在单个函数内使用的资源句柄或描述符，应确保资源释放后其无效值不被再次使用。 【错误代码示例】 如下代码示例中，根据消息类型处理消息，处理完后释放掉body或head指向的内存，但是释放后未将指针设置为NULL。如果还有其他函数再次处理该消息结构体时，可能出现重复释放内存或访问已释放内存的问题。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); } ... EXIT: ... free(msg-\u003ebody); return ret; } 【正确代码示例】 如下代码示例中，立即对释放后的指针设置为NULL，避免重复放指针。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); msg-\u003ebody = NULL; } ... EXIT: ... free(msg-\u003ebody); return ret; } 当free()函数的入参为NULL时，函数不执行任何操作。 【错误代码示例】 如下代码示例中文件描述符关闭后未赋新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); ... close(fd); ... 【正确代码示例】 如下代码示例中，在资源释放后，对应的变量应该立即赋予新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); s = INVALID_SOCKET; ... close(fd); fd = -1; ... 指针和数组 ","date":"0001-01-01","objectID":"/securecoding/:5:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部数据作为数组索引时必须确保在数组大小范围内 【描述】 外部数据作为数组索引对内存进行访问时，必须对数据的大小进行严格的校验，确保数组索引在有效范围内，否则会导致严重的错误。 当一个指针指向数组元素时，可以指向数组最后一个元素的下一个元素的位置，但是不能读写该位置的内存。 【错误代码示例】 如下代码示例中, set_dev_id()函数存在差一错误，当 index 等于 DEV_NUM 时，恰好越界写一个元素； 同样get_dev()函数也存在差一错误，虽然函数执行过程中没有问题，但是当解引用这个函数返回的指针时，行为是未定义的。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_id(size_t index, int id) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } return devs + index; } 【正确代码示例】 如下代码示例中，修改校验索引的条件，避免差一错误。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_Id (size_t index, int id) { if (index \u003e= DEV_NUM) { ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e= DEV_NUM) { ... // 错误处理 } return devs + index; } 【相关软件CWE编号】 CWE-119，CWE-123，CWE-125 ","date":"0001-01-01","objectID":"/securecoding/:6:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止通过对指针变量进行sizeof操作来获取数组大小 【描述】 将指针当做数组进行sizeof操作时，会导致实际的执行结果与预期不符。例如：变量定义 char *p = array，其中array的定义为char array[LEN]，表达式sizeof(p) 得到的结果与 sizeof(char *)相同，并非array的长度。 【错误代码示例】 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了sizeof(buffer)，与预期不符。 char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小 (void)memset(buffer, 0, sizeof(buffer)); 【正确代码示例】 如下代码示例中，将sizeof(buffer)修改为申请的缓冲区大小： char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); (void)memset(buffer, 0, SIZE); // 使用申请的缓冲区大小 字符串 ","date":"0001-01-01","objectID":"/securecoding/:7:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保字符串存储有足够的空间容纳字符数据和null结束符 【描述】 将数据复制到不足以容纳数据的缓冲区，会导致缓冲区溢出。缓冲区溢出经常发生在字符串操作中。为了避免这种错误，截断拷贝的数据以限制字符串的字节长度是一种防御方法，但是最好的措施是确保目标缓冲区的大小足以容纳复制数据和null结束符。当字符串存储在堆空间时， 确保分配内存时已分配了足够的空间。 部分字符串处理函数由于设计时安全考虑不足，或者存在一些隐含的目的缓冲区长度要求，容易被误用，导致缓冲区写溢出。此类典型函数包括不在C标准库函数中的itoa()，realpath()函数。 【错误代码示例】(itoa) 有些函数如itoa(), realpath()需要在对传入的缓冲区指针位置进行写入操作，但函数并没有提供缓冲区长度。因此，在调用这些函数前，必须提供足够的缓冲区。 如下代码示例中，试图将数字转为字符串，但是目标存储空间的预留长度不足： int num = ... char str[8]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【正确代码示例】 如下代码示例中，在对外部数据进行解析并将内容保存到name中，考虑了name的大小： int num = ... char str[13]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【错误代码示例】(realpath) 如下代码示例中，试图将路径标准化，但是目标存储空间的长度不足： #define MAX_PATH_LEN 100 char resolved_path[MAX_PATH_LEN]; / * - realpath函数的存储缓冲区长度是由PATH_MAX常量定义， - 或是由_PC_PATH_MAX系统值配置的，通常都大于100字节 */ char *res = realpath(path, resolved_path); ... 【正确代码示例】 可以将realpath的第二个参数传入NULL, 以让系统自动分配合适的内存。 char *resolved_path = NULL; resolved_path = realpath(path, NULL); if (resolved_path == NULL) { ... // 处理错误 } ... if (resolved_path != NULL) { free(resolved_path); resolved_path = NULL; } ... ","date":"0001-01-01","objectID":"/securecoding/:8:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"对字符串进行存储操作，确保字符串有null结束符 【描述】 部分字符串处理函数操作字符串时，将截断超出指定长度的字符串，如strncpy()函数最多复制n个字符到目的缓冲区，如果源字符串长度大于n，则不会写入null结束符到目的缓冲区，目的缓冲区的内容为n个被复制的字符。使用这类函数时，可能会无意截断导致数据丢失，并在某些情况下会导致软件漏洞。 因此，对字符串进行存储操作，必须确保字符串有null结束符，否则在后续的调用strlen等操作中，可能会导致内存越界访问漏洞。 【错误代码示例】 在如下代码示例中，使用strncpy函数复制字符串时可能会发生截断（发生条件为：strlen(name) \u003e sizeof(file_name) - 1）。当发生截断时，file_name的内容是不完整的，并且缺少 ’ 0 ‘结束符，后续对file_name的操作可能会导致软件漏洞： #define FILE_NAME_LEN 128 char file_name [FILE_NAME_LEN ]; (void)strncpy(file_name, name, sizeof(file_name) - 1); ... 【正确代码示例】 #define FILE_NAME_LEN 128 char file_name[FILE_NAME_LEN ]; if (strlen(name) \u003e FILE_NAME_LEN - 1) { ... // 处理错误 } (void)strcpy(file_name, name); ... 【例外】 程序员的目的是故意截断字符串。 【相关软件CWE编号】 CWE-170，CWE-464 断言 ","date":"0001-01-01","objectID":"/securecoding/:9:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理 【描述】 断言主要用于调试期间，在编译Release版本时将其关闭。因此，断言应该用于防止不正确的程序员假设，而不能用在Release版本上检查程序运行过程中发生的错误。 断言永远不应用于验证是否存在运行时（与逻辑相对）错误，例如 无效的用户输入（包括命令行参数和环境变量） 文件错误（例如，打开，读取或写入文件时出错） 网络错误（包括网络协议错误） 内存不足的情况（例如，malloc()类似的故障） 系统资源耗尽（例如，文件描述符，进程，线程） 系统调用错误（例如，执行文件，锁定或解锁互斥锁时出错） 无效的权限（例如，文件，内存，用户） 例如，防止缓冲区溢出的代码不能使用断言实现，因为该代码必须编译到Release版本的可执行文件中。 如果服务器程序在网运行时由恶意用户触发断言失败，会导致拒绝服务攻击。在这种情况下，更适合使用软故障模式，例如写入日志文件和拒绝请求。 【错误代码示例】 以下代码的所有ASSERT的用法是错误的。例如，错误的使用ASSERT宏来验证内存分配是否成功，因为内存的可用性取决于系统的整体状态，并且在程序运行的任何时候都可能耗尽，所以必须以具有韧性的方式来妥善处理并将程序从内存耗尽中恢复。因此，使用ASSERT宏来验证内存分配是否成功将是不合适的，因为这样做可能导致进程突然终止，从而开启了拒绝服务攻击的可能性。 FILE *fp = fopen(path, \"r\"); ASSERT(fp != NULL); // 错误用法：文件有可能打开失败 char *str = (char *)malloc(MAX_LINE); ASSERT(str != NULL); // 错误用法：内存有可能分配失败 ReadLine(fp, str); char *p = strstr(str, \"age=\"); ASSERT(p != NULL); // 错误用法：文件中不一定存在该字符串 char *end = NULL; long age = strtol(p + 4, \u0026end, 10); ASSERT(age \u003e 0); // 错误用法：文件内容不一定符合预期 【正确代码示例】 下面代码演示了如何重构上面的错误代码: FILE *fp = fopen(path, \"r\"); if (fp == NULL) { ... // 错误处理 } char *str = (char *)malloc(MAX_LINE); if (str == NULL) { ... // 错误处理 } read_line(fp, str); char *p = strstr(str, \"age=\"); if (p == NULL) { ... // 错误处理 } char *end = NULL; long age = strtol(p + 4, \u0026end, 10); if (age \u003c= 0) { ... // 错误处理 } ","date":"0001-01-01","objectID":"/securecoding/:10:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在断言内改变运行环境 【描述】 在程序正式发布阶段，断言不会被编译进去，为了确保调试版和正式版的功能一致性，严禁在断言中使用任何赋值、修改变量、资源操作、内存申请等操作。 例如，以下的断言方式是错误的： ASSERT(p1 = p2); // p1被修改 ASSERT(i++ \u003e 1000); // i被修改 ASSERT(close(fd) == 0); // fd被关闭 函数设计 ","date":"0001-01-01","objectID":"/securecoding/:11:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"数组作为函数参数时，必须同时将其长度作为函数的参数 【描述】 通过函数参数传递数组函数参数必须同时传递数组可容纳元素的个数，而不是以字节为单位的数组最大大小；同样，通过函数参数传递一块内存进行读写操作时，必须同时传递内存块大小，否则函数在访问内存偏移时，无法判断偏移的合法范围，产生越界访问的漏洞。在本规则中所说的\"数组\"不仅局限为数组类型变量，还包括字符串或指向连续内存块的指针。 【错误代码示例】 如下代码示例中，函数pars_msg不知道msg的范围，容易产生内存越界访问漏洞。 int parse_msg(unsigned char *msg) { ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg); ... } 【正确代码示例】 正确的做法是将msg的大小作为参数传递到parse_msg中，如下代码： int parse_msg(unsigned char *msg, size_t msg_len) { ASSERT(msg != NULL); ASSERT(msg_len != 0); ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg, len); ... } ","date":"0001-01-01","objectID":"/securecoding/:12:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"函数的指针参数如果不是用于修改所指向的对象就应该声明为指向const的指针 【描述】 const 指针参数，将限制函数通过该指针修改所指向对象，使代码更牢固、更安全。 示例：如strncmp 的例子，指向的对象不变化的指针参数声明为const。 // 正确：不变参数声明为const int strncmp(const char *s1, const char *s2, size_t n); 注意： 指针参数要不要加const取决于函数设计，而不是看函数实体内有没有发生\"修改对象\"的动作。 ","date":"0001-01-01","objectID":"/securecoding/:13:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，禁止format参数受外部数据控制 【描述】 调用格式化函数时，如果format参数由外部数据提供，或由外部数据拼接而来，会造成字符串格式化漏洞。 攻击者如果能够完全或者部分控制格式字符串内容，可以使被攻击的进程崩溃、查看栈内容、查看内存内容或者在任意内存位置写入数据。结果是，攻击者能够以被攻击进程的权限执行任意代码。 格式化输出函数特别危险，这是因为许多程序员没有意识到它们是具有攻击能力的。比如：格式化输出函数可以使用%n转换符，向指定地址写入一个整数值。 这些格式化函数有： 格式化输出函数: xxxprintf; 格式化输入函数: xxxscanf; 格式化错误消息函数: err(), verr(), errx(), verrx(), warn(), vwarn(), warnx(), vwarnx(), error(), error_at_line(); 格式化日志函数: syslog(), vsyslog(). 【错误代码示例】 如下代码示例中的incorrect_password()函数的功能是在身份验证无效时（指定用户没有找到或者密码不正确），显示一条错误信息。 该函数接受一个源自用户的字符串数据user，而user是未验证的，是外部可控的。 该函数将user构造一条错误信息，然后用C语言标准函数fprintf打印到stderr。 // 调用者需保证入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fprintf(stderr, msg); // msg中有来自未验证的外部数据，存在格式化漏洞 } free(msg); } 示例代码中首先计算了消息的长度，然后分配内存，接着利用snprintf()函数拼接了消息内容。因此消息内容中包含了msg_format的内容和用户的内容。 当入参user中含有用户输入的格式符（如%s,%p,%n等后，fprintf()在执行时，会将msg作为一个格式化字符串来进行解析，而不是直接输出消息内容， 也就是说此时msg中的内容不会被直接打印到stderr中，反而会将一些未知的数据打印到stderr，引发程序未定义的行为。这是一个非常严重的格式化漏洞。 【正确代码示例】 下面是第一种推荐做法，代码中使用fputs()来代替fprintf()函数，fputs()会直接将msg的内容输出到stderr中，而不会去解析它。 // 入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; // 这里加法运算不会整数溢出，因为user有限制 size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fputs(stderr, msg); // 使用fputs函数代替fprintf函数 } free(msg); } 【正确代码示例】 下面是第二种推荐做法，代码中将不受信任的用户输入user作为fprintf()的可选参数之一，用\"%s\"将user以字符串的形式固定下来，然后输出到stderr中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void incorrect_password(const char *user) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; fprintf(stderr, msg_format, user); } 【错误代码示例】 如下代码示例中，使用了POSIX函数syslog()，但是syslog()函数也可能出现格式字符串漏洞。 void foo(void) { char *msg = get_msg(); ... syslog(LOG_INFO, msg); // 存在格式化漏洞 } 【正确代码示例】 下面是推荐做法，代码中将不受信任的用户输入msg作为syslog()的可选参数之一，用\"%s\"将msg以字符串的形式固定下来，然后输出到系统日志中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void foo(void) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; char *msg = get_msg(); ... syslog(LOG_INFO, msg_format, msg); // 这里没有格式化漏洞 } 函数使用 ","date":"0001-01-01","objectID":"/securecoding/:14:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，使用有效的格式字符串 【描述】 格式化输入/输出函数（如fscanf()/fprintf()及相关函数）在format字符串控制下进行转换、格式化、打印其实参。 在创建格式化字符串时的常见错误包括： format中参数个数与实参个数不一致； 使用无效的转换指示符； 使用与转换指示符不兼容的标志字符； 使用与转换指示符不兼容的长度修饰符； format中转换指示符与实参类型不匹配； 使用int以外类型的实参指定宽度或者精度； 不要为格式化输入/输出函数提供未知的或者无效的转换规格，以及标志字符、精度、长度修饰符、转换指示符的无效组合。同样，不要提供与格式化字符串中的转换指示符类型不匹配的实参。这可能会使程序产生未定义行为。 【错误代码示例】 如下代码示例中，printf()的实参infoLevel类型与对应的转换指示符 ’s ‘不匹配，正确的转换指示符要使用 ’d ‘。同样，实参infoMsg类型与对应的转换指示符 ’d ‘不匹配，正确的转换指示符要使用 ’s ‘。 这些用法会使程序产生未定义行为，比如：printf()将把infoLevel实参解释为指针，试图从infoLevel包含的地址中读取一个字符串，从而发生非法访问。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %s, infoMsg: %d\\n\", info_level, info_msg); ... } 【正确代码示例】 正确的做法是确保printf()函数的实参匹配format的转换指示符。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %d, infoMsg: %s\\n\", info_level, info_msg); ... } 【影响】 错误的格式串可能造成内存破坏或者程序异常终止。 ","date":"0001-01-01","objectID":"/securecoding/:15:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用alloca()函数申请栈上内存 【描述】 POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。 请使用malloc从堆中动态分配内存。 【影响】 程序栈的大小非常有限，如果分配导致栈溢出，则程序产生未定义行 ","date":"0001-01-01","objectID":"/securecoding/:16:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用realloc()函数 【描述】 realloc()是一个非常特殊的函数，原型如下： void *realloc(void *ptr, size_t size); 随着参数的不同，其行为也是不同： 当ptr不为NULL，且size不为0时，该函数会重新调整内存大小，并将新的内存指针返回，并保证最小的size的内容不变； 参数ptr为NULL，但size不为0，那么其行为等同于malloc(size)； 参数size为0，则realloc的行为等同于free(ptr)。 由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编程中提供了一些便利性，如果认识不足，使用不当，是却极易引发各种bug。 【错误代码示例】 如下代码示例中，使用realloc不当导致内存泄漏。 代码中希望对ptr的空间进行扩充，当realloc()分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的，如果直接将realloc()的返回值赋给ptr，那么ptr原来指向的内存就会丢失，造成内存泄漏。 // 当realloc()分配内存失败时会返回NULL，导致内存泄漏 char *ptr = (char *)realloc(ptr, NEW_SIZE); if (ptr == NULL) { ...// 错误处理 } 【正确代码示例】 使用malloc()函数代替realloc()函数。 // 使用malloc()函数代替realloc()函数 char *new_ptr = (char *)malloc(NEW_SIZE); if (new_ptr == NULL) { ... // 错误处理 } (void)memcpy(new_ptr, old_ptr, old_size); ... // 返回前，释放old_Ptr 【影响】 使用不当容易造成内存泄漏和双重释放问题。不正确的内存对齐可能导致对象访问异常。 ","date":"0001-01-01","objectID":"/securecoding/:17:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止外部可控数据作为进程启动函数的参数 【描述】 本条款中进程启动函数包括system、popen、execl、execlp、execle、execv、execvp等。 system()、popen()等函数会创建一个新的进程，如果外部可控数据作为这些函数的参数，会导致注入漏洞。 使用execl()、execlp()等函数执行新进程时，如果使用shell启动的新进程，则同样存在命令注入风险。 因此，总是优先考虑使用C标准函数实现需要的功能。如果确实需要使用这些函数，请使用白名单机制确保这些函数的参数不受任何外来数据的影响。 【错误代码示例】 如下代码示例中，使用 system() 函数执行 cmd 命令串来自外部，攻击者可以执行任意命令： char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } system(cmd); 如下代码示例中，使用 system() 函数执行 cmd 命令串的一部分来自外部，攻击者可能输入 ‘some dir;useradd xxx ‘字符串，创建一个xxx的用户： char cmd[MAX_LEN ]; int ret; char *name = get_dir_name_from_remote(); if (name == NULL) { ... // 处理错误 } ret = sprintf(cmd, \"ls %s\", name); ... system(cmd); 使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析器(如/bin/sh)。 int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); 例如，禁止如下使用方式： char *cmd = get_dir_name_from_remote(); execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL); 【正确代码示例】 (使用库函数) 在Linux下实现对当前目录下文件名的打印，可以使用opendir(), readdir(), stat()等函数直接实现ls-l命令的功能，不必使用system()函数。下面是一个简化的ls -l示例版本，列出一个由程序内部指定的文件的信息，该函数仅考虑了不需要重入的情况。 static int OutputFileInfo(const char *file_name) { const char priv[] = {'x', 'w', 'r'}; ASSERT(file_name != NULL); struct stat st; int ret = stat(file_name, \u0026st); if (ret == -1) { return -1; } const struct passwd *pw = getpwuid(st.st_uid); if (pw == NULL) { return -1; } const struct group *gp = getgrgid(st.st_gid); if (gp == NULL) { return -1; } if (S_ISREG(st.st_mode)) { printf(\"-\"); } else if (S_ISDIR(st.st_mode)) { printf(\"d\"); } for (int i = 8; i \u003e= 0; i --) { if ((st.st_mode \u0026 (1 \u003c \u003c i)) != 0) { printf(\"%c\", priv[i % 3]); } else { printf(\"-\"); } } printf(\"%s %s %ld %s\\n\", pw-\u003epw_name, gp-\u003egr_name, st.st_size, file_name); return 0; } 【正确代码示例】 (使用exec系列函数) 可以通过库函数简单实现的功能（如上例），需要避免调用命令处理器来执行外部命令。如果确实需要调用单个命令，应使用exec *函数来实现参数化调用，并对调用的命令实施白名单管理。 pid_t pid; char * const envp[] = { NULL }; ... char *file_name = get_dir_name_from_remote(); if (file_name == NULL) { ... // 处理错误 } ... if ((pid = fork()) \u003c 0) { ... } else if (pid == 0) { // 使用some_tool对指定文件进行加工 execle( \"/bin/some_tool\", \"some_tool\", file_name, NULL, envp); _Exit(-1); } ... int status; waitpid(pid, \u0026status, 0); FILE *fp = fopen(file_name, \"r\"); ... 此时，外部输入的file_name仅作为some_tool命令的参数，没有命令注入的风险。 【正确代码示例】 (使用白名单) 对输入的文件名基于合理的白名单检查，避免命令注入。 char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } // 使用白名单检查命令是否合法，仅允许 \"some_tool_a\", \"some_tool_b\"命令，外部无法随意控制 if (!is_valid_cmd(cmd)) { ... // 处理错误 } system(cmd); ... 【相关软件CWE编号】 CWE-676，CWE-88 ","date":"0001-01-01","objectID":"/securecoding/:18:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在信号处理例程中调用非异步安全函数 【描述】 在信号处理程序中只调用异步安全函数。 除了C语言标准函数以外，其他系统函数也提供了一些的异步安全函数，在信号处理程序中使用这些函数之前，应确保调用的函数在所有可能的执行环境下均是异步安全的。 【错误代码示例】 如下代码示例中，信号处理函数中调用了非异步安全函数printf()： void handler(int num) { printf(\"receive signal = %d \\n\", SIGINT); } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { ... // 程序主循环代码 } return 0; } 【正确代码示例】 如下代码示例中，尽量不在信号处理函数中调用其他函数，仅在信号处理程序中修改volatile sig_atomic_t类型的变量： static volatile sig_atomic_t g_flag = 0; void handler(int num) { g_flag = 1; } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { if (g_flag != 0) { printf(\"receive signal = %d\\n\", SIGINT); } ... // 程序主循环代码 } ... return 0; } 【相关软件CWE编号】 CWE-479 内存 ","date":"0001-01-01","objectID":"/securecoding/:19:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存分配后必须判断是否成功 【描述】 内存分配一旦失败，那么后续的操作会存在未定义的行为风险。比如malloc申请失败返回了空指针，对空指针的解引用是一种未定义行为。 【错误代码示例】 如下代码示例中，调用malloc分配内存之后，没有判断是否成功，直接引用了p。如果malloc失败，它将返回一个空指针并传递给p。当如下代码在内存拷贝中解引用了该空指针p时，程序会出现未定义行为。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm*)malloc(sizeof(*tmb)); tmb-\u003eyear = year; ... return tmb; } 【正确代码示例】 如下代码示例中，在malloc分配内存之后，立即判断其是否成功，消除了上述的风险。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm *)malloc(sizeof(*tmb)); if (tmb == NULL) { ... // 错误处理 } tmb-\u003eyear = year; ... return tmb; } ","date":"0001-01-01","objectID":"/securecoding/:20:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部输入作为内存操作相关函数的复制长度时，需要校验其合法性 【描述】 将数据复制到容量不足以容纳该数据的内存中会导致缓冲区溢出。为了防止此类错误，必须根据目标容量的大小限制被复制的数据大小，或者必须确保目标容量足够大以容纳要复制的数据。 【错误代码示例】 外部输入的数据不一定会直接作为内存复制长度使用，还可能会间接参与内存复制操作。 如下代码示例中，inputTable-\u003ecount来自外部报文，虽然没有直接作为内存复制长度使用，而是作为for循环体的上限使用，间接参与了内存复制操作。由于没有校验其大小，可造成缓冲区溢出： typedef struct { size_t count; int val[MAX_num_bERS]; } ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } 【正确代码示例】 如下代码示例中，对input_table-\u003ecount做了校验。 typedef struct { size_t count; int val[MAX_num_bERS]; }ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... / * - 根据应用场景，对来自外部报文的循环长度input_table-\u003ecount - 与output_table-\u003eval数组大小做校验，避免造成缓冲区溢出 */ if (input_table-\u003ecount \u003e sizeof(output_table-\u003eval) / sizeof(output_table-\u003eval[0]){ return NULL; } for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } ","date":"0001-01-01","objectID":"/securecoding/:21:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存中的敏感信息使用完毕后立即清0 【描述】 内存中的口令、密钥等敏感信息使用完毕后立即清0，避免被攻击者获取或者无意间泄漏给低权限用户。这里所说的内存包括但不限于： 动态分配的内存 静态分配的内存 自动分配（堆栈）内存 内存缓存 磁盘缓存 【错误代码示例】 通常内存在释放前不需要清除内存数据，因为这样在运行时会增加额外开销，所以在这段内存被释放之后，之前的数据还是会保留在其中。如果这段内存中的数据包含敏感信息，则可能会意外泄漏敏感信息。为了防止敏感信息泄漏，必须先清除内存中的敏感信息，然后再释放。 在如下代码示例中，存储在所引用的动态内存中的敏感信息secret被复制到新动态分配的缓冲区newSecret，最终通过free()释放。因为释放前未清除这块内存数据，这块内存可能被重新分配到程序的另一部分，之前存储在newSecret中的敏感信息可能会无意中被泄露。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... free(new_secret); new_secret = NULL; } ... 【正确代码示例】 如下代码示例中，为了防止信息泄漏，应先清除包含敏感信息的动态内存（用 ’ 0 ‘字符填充空间），然后再释放它。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... (void)memset(new_secret, 0, size + 1); free(new_secret); new_secret = NULL; } ... 【正确代码示例】 下面是另外一个涉及敏感信息清理的场景，在代码获取到密码后，将密码保存到password中，进行密码验证，使用完毕后，通过memset对password清0。 int foo(void) { char password [MAX_PWD_LEN ] = {0}; if (!get_password(password, sizeof(password))) { ... // 处理错误 } if (!verify_password(password)) { ... // 处理错误 } ... (void)memset(password, 0, sizeof(password)); ... } 文件 ","date":"0001-01-01","objectID":"/securecoding/:22:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"创建文件时必须显式指定合适的文件访问权限 【描述】 创建文件时，如果不显式指定合适访问权限，可能会让未经授权的用户访问该文件，造成信息泄露，文件数据被篡改，文件中被注入恶意代码等风险。 虽然文件的访问权限也依赖于文件系统，但是当前许多文件创建函数（例如POSIX open函数）都具有设置（或影响）文件访问权限的功能，所以当使用这些函数创建文件时，必须显式指定合适的文件访问权限，以防止意外访问。 【错误代码示例】 使用POSIX open()函数创建文件但未显示指定该文件的访问权限，可能会导致文件创建时具有过高的访问权限，这可能会导致漏洞。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name fd = open(file_name, O_CREAT | O_WRONLY); // 没有显式指定访问权限 if (fd == -1) { ... // 错误处理 } ... } 【正确代码示例】 应该在open的第三个参数中显式指定新创建文件的访问权限。可以根据文件实际的应用情况设置何种访问权限。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name 和指定其访问权限 // 此处根据文件实际需要，显式指定其访问权限 int fd = open(file_name, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR); if (fd == -1) { ... // 错误处理 } ... } ","date":"0001-01-01","objectID":"/securecoding/:23:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对文件路径进行规范化后再使用 【描述】 当文件路径来自外部数据时，必须对其做合法性校验，如果不校验，可能造成系统文件的被任意访问。但是禁止直接对其进行校验，正确做法是在校验之前必须对其进行路径规范化处理，因为： 同一个文件可以通过多种形式的路径来描述和引用，例如既可以是绝对路径，也可以是相对路径；而且路径名、目录名和文件名可能包含使校验变得困难和不准确的字符（如：\".\"、\"..\"）。此外，文件还可以是符号链接，这进一步模糊了文件的实际位置或标识，增加了校验的难度和校验准确性。所以必须先将文件路径规范化，从而更容易校验其路径、目录或文件名，增加校验准确性，如使用realpath函数。 一个简单的案例说明如下： 当文件路径来自外部数据时，需要先将文件路径规范化，如果没有作规范化处理，攻击者就有机会通过恶意构造文件路径进行文件的越权访问。 例如，攻击者可以构造\"../../../etc/passwd\"的方式进行任意文件访问。 【错误代码示例】 在此错误的示例中，argv[1]包含一个源于受污染源的文件名，并且该文件名已打开以进行写入。在使用此文件名操作之前，应该对其进行验证，以确保它引用的是预期的有效文件。 不幸的是，argv[1]引用的文件名可能包含特殊字符，例如目录字符，这使验证变得困难，甚至不可能。而且，argv[1]中可能包含可以指向任意文件路径的符号链接，即使该文件名通过了验证，也会导致该文件名是无效的。 这种场景下，对文件名的直接验证即使被执行也是得不到预期的结果，对fopen()的调用可能会导致访问一个意外的文件。 ... if (!verify_file(input_file_name) { // 没有对input_file_name做规范化，直接做校验 ... // 错误处理 } if (fopen(input_file_name, \"w\") == NULL) { ... // 错误处理 } ... 【正确代码示例】 规范化文件名是具有一定难度的，因为这需要了解底层文件系统。 POSIX realpath()函数可以帮助将路径名转换为规范形式。 对上面的错误代码示例，我们采用如下解决方案： char *real_path_res = NULL; ... // 在校验之前，先对input_file_name做规范化处理 real_path_res = realpath(input_file_name, NULL); if (real_path_res == NULL) { ... // 规范化的错误处理 } // 规范化以后对路径进行校验 if (!verify_file(real_path_res) { ... // 校验的错误处理 } // 使用 if (fopen(real_path_res, \"w\") == NULL) { ... // 实际操作的错误处理 } ... free(real_path_res); real_path_res = NULL; ... 【正确代码示例】 根据我们的实际场景，我们还可以采用的第二套解决方案，说明如下： 如果PATH_MAX被定义为中的一个常量，那么使用非空的resolved_path调用realpath()也是安全的。 在本例中realpath()函数期望resolved_path引用一个字符数组，该字符数组足够大，可以容纳规范化的路径。 如果定义了PATH_MAX，则分配一个大小为PATH_MAX的缓冲区来保存realpath()的结果。正确代码示例如下： char *real_path_res = NULL; char *canonical_file_name = NULL; size_t path_size = 0; ... path_size = (size_t)PATH_MAX; if (verify_path_size(path_size) == TRUE) { canonical_file_name = (char *)malloc(path_size); if (canonical_file_name == NULL) { ... // 错误处理 } real_path_res = realpath(inputFilename, canonical_file_name); } if (real_path_res == NULL) { ... // 错误处理 } if (verify_file(real_path_res) == FALSE) { ... // 错误处理 } if (fopen(real_path_res, \"w\") == NULL ) { ... // 错误处理 } ... free(canonical_file_name); canonical_file_name = NULL; ... 【错误代码示例】 下面的代码场景是从外部获取到文件名称，拼接成文件路径后，直接对文件内容进行读取，导致攻击者可以读取到任意文件的内容： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char *text = read_file_content(untrust_path); 【正确代码示例】 正确的做法是，对路径进行规范化后，再判断路径是否是本程序所认为的合法的路径： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char path[PATH_MAX] = {0}; if (realpath(untrust_path, path) == NULL) { ... // 处理错误 } if (!is_valid_path(path)) { // 检查文件的位置是否正确 ... // 处理错误 } char *text = read_file_content(path); 【例外】 运行于控制台的命令行程序，通过控制台手工输入文件路径，可以作为本条款例外。 int main(int argc, char **argv) { int fd = -1; if (argc == 2) { fd = open(argv[1], O_RDONLY); ... } ... } ","date":"0001-01-01","objectID":"/securecoding/:24:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在共享目录中创建临时文件 【描述】 程序的临时文件应当是程序自身独享的，任何将自身临时文件置于共享目录的做法，将导致其他共享用户获得该程序的额外信息，产生信息泄露。因此，不要在任何共享目录创建仅由程序自身使用的临时文件。 程序员通常会在共享目录中(例如在/tmp和/var/tmp创建临时文件，并且还有可能会定期清除这些临时文件(例如，每晚或重新启动期间)，但也可能不注意清理。 临时文件通常用于辅助保存不能驻留在内存中的数据或存储临时的数据，也可用作进程间通信的一种手段（通过文件系统传输数据）。例如，一个进程在共享目录中创建一个临时文件，该文件名可能使用了众所周知的名称或者一个临时的名称，然后就可以通过该文件在进程间共享信息。这种通过在共享目录中创建临时文件的方法实现进程间共享的做法很危险，因为共享目录中的这些文件很容易被攻击者劫持或操纵。这里有几种缓解策略： 1.使用其他低级IPC（进程间通信）机制，例如套接字或共享内存。 2.使用更高级别的IPC机制，例如远程过程调用。 3.使用仅能由程序本身访问的安全目录(多线程/进程下注意防止条件竞争)。 同时，下面列出了几项临时文件创建使用的方法，产品根据具体场景执行以下一项或者几项，同时产品也可以自定义合适的方法。 1.文件必须具有合适的权限，只有符合权限的用户才能访问 2.创建的文件名是唯一的、或不可预测的 3.仅当文件不存在时才创建打开(原子创建打开) 4.使用独占访问打开，避免竞争条件 5.在程序退出之前移除 同时也需要注意到，当某个目录被开放读/写权限给多个用户或者一组用户时，该共享目录潜在的安全风险远远大于访问该目录中临时文件这个功能的本身。 如果想安全地在共享目录中创建临时文件，而不受威胁是不容易的。例如，用于本地挂载的文件系统的代码在与远程挂载的文件系统一起共享使用时可能会受到攻击。而且上面的函数安全版本还受限于所使用的C运行时库、操作系统和文件系统的版本。唯一安全的解决方案是不要在共享目录中创建临时文件。 【错误代码示例】 如下代码示例，程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。 由于文件名是硬编码的，因此是可预测的，攻击者只需用符号链接替换文件，然后链接所引用的目标文件就会被打开并写入新内容。 void proc_data(const char *file_name) { FILE *fp = fopen(file_name, \"wb+\"); if (fp == NULL) { ... // 错误处理 } ... // 写文件 fclose(fp); } int main(void) { // 不合规：1.在系统共享目录中创建临时文件；2.临时文件名硬编码 char *real_file = \"/tmp/data\"; ... proc_data(real_file); ... return 0; } 【正确案例】 Linux下的/tmp目录是一个所有用户都可以访问的共享目录，不应在该目录下创建仅由程序自身使用的临时文件。 【业界典型漏洞】CVE-2004-2502 其它 ","date":"0001-01-01","objectID":"/securecoding/:25:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在信号处理函数中访问共享对象 【描述】 在信号处理程序中访问和修改共享对象可能会造成竞争条件，使数据处于不确定的状态。 这条规则有两个不适用的场景（C11标准第5.1.2.3章节第5段）是： 1） 读写不需要加锁的原子对象; 2）读写volatile sig_atomic_t类型的对象，因为具有volatile sig_atomic_t类型的对象即使在出现异步中断的时候也可以作为一个原子实体访问，是异步安全的。 此外，在信号处理程序中，如果要调用函数，请仅调用异步信号安全函数。 【错误代码示例】 在这个信号处理过程中，程序打算将p_msg作为共享对象，当产生SIGINT信号时更新共享对象的内容，但是该p_msg变量类型不是volatile sig_atomic_t，所以不是异步安全的。 #define MAX_MSG_SIZE 32 static char g_msg_buf[MAX_MSG_SIZE] = {0}; static char *g_msg = g_msg_buf; void signal_handler(int signum) { // 下面代码操作g_msg不合规，因为不是异步安全的 (void)memset(g_msg, 0, MAX_MSG_SIZE); strcpy(g_msg, \"signal SIGINT received.\"); ... // } int main(void) { strcpy(g_msg, \"No msg yet.\"); // 初始化消息内容 signal(SIGINT, signal_handler); // 设置SIGINT信号对应的处理函数 ... // 程序主循环代码 return 0; } 【正确代码示例】 如下代码示例中，在信号处理函数中仅将volatile sig_atomic_t类型作为共享对象使用。 #define MAX_MSG_SIZE 32 volatile sig_atomic_t g_sig_flag = 0; void signal_handler(int signum) { g_sig_flag = 1; // 合规 } int main(void) { signal(SIGINT, signal_handler); char msg_buf[MAX_MSG_SIZE]; strcpy(msg_buf, \"No msg yet.\"); // 初始化消息内容 ... // 程序主循环代码 if (g_sig_flag == 1) { // 在退出主循环之后，根据sigFlag状态再刷新消息内容 strcpy(msgBuf, \"signal SIGINT received.\"); } return 0; } 【相关软件CWE编号】 CWE-662，CWE-828 ","date":"0001-01-01","objectID":"/securecoding/:26:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁用rand函数产生用于安全用途的伪随机数 【描述】 C语言标准库rand()函数生成的是伪随机数，所以不能保证其产生的随机数序列质量。所以禁止使用rand()函数产生的随机数用于安全用途，必须使用安全的随机数产生方式，如： /dev/random文件。 典型的安全用途场景包括(但不限于)以下几种： 会话标识SessionID的生成； 挑战算法中的随机数生成； 验证码的随机数生成； 用于密码算法用途（例如用于生成IV、盐值、密钥等）的随机数生成。 【错误代码示例】 程序员期望生成一个唯一的不可被猜测的HTTP会话ID，但该ID是通过调用rand()函数产生的数字随机数，它的ID是可猜测的，并且随机性有限。 【正确代码示例】(POSIX) 可以使用/dev/random文件得到随机数。 【影响】 使用rand()函数可能造成可预测的随机数。 内核操作 ","date":"0001-01-01","objectID":"/securecoding/:27:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核mmap接口实现中，确保对映射起始地址和大小进行合法性校验 【描述】 **说明：**Linux内核 mmap接口中，经常使用remap_pfn_range()函数将设备物理内存映射到用户进程空间。如果映射起始地址等参数由用户态控制并缺少合法性校验，将导致用户态可通过映射读写任意内核地址。如果攻击者精心构造传入参数，甚至可在内核中执行任意代码。 【错误代码示例】 如下代码在使用remap_pfn_range()进行内存映射时，未对用户可控的映射起始地址和空间大小进行合法性校验，可导致内核崩溃或任意代码执行。 static int incorrect_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); //错误：未对映射起始地址、空间大小做合法性校验 if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log(\"%s, remap_pfn_range fail\", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } 【正确代码示例】 增加对映射起始地址等参数的合法性校验。 static int correct_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; //修改：添加校验函数，验证映射起始地址、空间大小是否合法 if (!valid_mmap_phys_addr_range(vma-\u003evm_pgoff, size)) { return EINVAL; } vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log( \"%s, remap_pfn_range fail \", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } ","date":"0001-01-01","objectID":"/securecoding/:28:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核程序中必须使用内核专用函数读写用户态缓冲区 【描述】 用户态与内核态之间进行数据交换时，如果在内核中不加任何校验（如校验地址范围、空指针）而直接引用用户态传入指针，当用户态传入非法指针时，可导致内核崩溃、任意地址读写等问题。因此，应当禁止使用memcpy()、sprintf()等危险函数，而是使用内核提供的专用函数：copy_from_user()、copy_to_user()、put_user()和get_user()来读写用户态缓冲区，这些函数内部添加了入参校验功能。 所有禁用函数列表为：memcpy()、bcopy()、memmove()、strcpy()、strncpy()、strcat()、strncat()、sprintf()、vsprintf()、snprintf()、vsnprintf()、sscanf()、vsscanf()。 【错误代码示例】 内核态直接使用用户态传入的buf指针作为snprintf()的参数，当buf为NULL时，可导致内核崩溃。 ssize_t incorrect_show(struct file *file, char__user *buf, size_t size, loff_t *data) { // 错误：直接引用用户态传入指针，如果buf为NULL，则空指针异常导致内核崩溃 return snprintf(buf, size, \"%ld\\n\", debug_level); } 【正确代码示例】 使用copy_to_user()函数代替snprintf()。 ssize_t correct_show(struct file *file, char __user *buf, size_t size, loff_t *data) { int ret = 0; char level_str[MAX_STR_LEN] = {0}; snprintf(level_str, MAX_STR_LEN, \"%ld \\n\", debug_level); if(strlen(level_str) \u003e= size) { return EFAULT; } // 修改：使用专用函数copy_to_user()将数据写入到用户态buf，并注意防止缓冲区溢出 ret = copy_to_user(buf, level_str, strlen(level_str)+1); return ret; } 【错误代码示例】 内核态直接使用用户态传入的指针user_buf作为数据源进行memcpy()操作，当user_buf为NULL时，可导致内核崩溃。 size_t incorrect_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf [128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 错误：直接引用用户态传入指针，如果user_buf为NULL，则可导致内核崩溃 (void)memcpy(buf, user_buf, buf_size); ... } 【正确代码示例】 使用copy_from_user()函数代替memcpy()。 ssize_t correct_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf[128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 修改：使用专用函数copy_from_user()将数据写入到内核态buf，并注意防止缓冲区溢出 if (copy_from_user(buf, user_buf, buf_size)) { return EFAULT; } ... } ","date":"0001-01-01","objectID":"/securecoding/:29:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_from_user()拷贝长度进行校验，防止缓冲区溢出 **说明：**内核态从用户态拷贝数据时通常使用copy_from_user()函数，如果未对拷贝长度做校验或者校验不当，会造成内核缓冲区溢出，导致内核panic或提权。 【错误代码示例】 未校验拷贝长度。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))) {...} // 错误：拷贝长度参数smd_write_arg.size由用户输入，未校验 copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } 【正确代码示例】 添加长度校验。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))){...} // 修改：添加校验 if (smd_write_arg.size \u003e= GSERIAL_BUF_LEN) {......} copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } ","date":"0001-01-01","objectID":"/securecoding/:30:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_to_user()拷贝的数据进行初始化，防止信息泄漏 【描述】 **说明：**内核态使用copy_to_user()向用户态拷贝数据时，当数据未完全初始化（如结构体成员未赋值、字节对齐引起的内存空洞等），会导致栈上指针等敏感信息泄漏。攻击者可利用绕过kaslr等安全机制。 【错误代码示例】 未完全初始化数据结构成员。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; // 错误: info结构体有4个成员，未全部赋值 ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } 【正确代码示例】 全部进行初始化。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; // 修改：使用memset初始化缓冲区，保证不存在因字节对齐或未赋值导致的内存空洞 (void)memset(\u0026info, '0', sizeof(ep_info)); switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } ","date":"0001-01-01","objectID":"/securecoding/:31:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在异常处理中使用BUG_ON宏，避免造成内核panic 【描述】 BUG_ON宏会调用内核的panic()函数，打印错误信息并主动崩溃系统，在正常逻辑处理中（如ioctl接口的cmd参数不识别）不应当使系统崩溃，禁止在此类异常处理场景中使用BUG_ON宏，推荐使用WARN_ON宏。 【错误代码示例】 正常流程中使用了BUG_ON宏 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 错误：系统BUG_ON宏打印调用栈后调用panic()，导致内核拒绝服务，不应在正常流程中使用 BUG_ON(1); return 1; } ... } 【正确代码示例】 去掉BUG_ON宏。 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 修改：去掉BUG_ON调用，或使用WARN_ON return 1; } ... } ","date":"0001-01-01","objectID":"/securecoding/:32:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"在中断处理程序或持有自旋锁的进程上下文代码中，禁止使用会引起进程休眠的函数 【描述】 Linux以进程为调度单位，在Linux中断上下文中，只有更高优先级的中断才能将其打断，系统在中断处理的时候不能进行进程调度。如果中断处理程序处于休眠状态，就会导致内核无法唤醒，从而使得内核处于瘫痪。 自旋锁在使用时，抢占是失效的。若自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其它进程都将因为不能获得CPU（单核CPU）而停止运行，对外表现为系统将不作任何响应，出现挂死。 因此，在中断处理程序或持有自旋锁的进程上下文代码中，应该禁止使用可能会引起休眠（如vmalloc()、msleep()等）、阻塞（如copy_from_user(),copy_to_user()等）或者耗费大量时间（如printk()等）的函数。 ","date":"0001-01-01","objectID":"/securecoding/:33:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"合理使用内核栈，防止内核栈溢出 【描述】 Linux的内核栈大小是固定的（一般32位系统为8K，64位系统为16K，因此资源非常宝贵。不合理的使用内核栈，可能会导致栈溢出，造成系统挂死。因此需要做到以下几点： 在栈上申请内存空间不要超过内核栈大小； 注意函数的嵌套使用次数； 不要定义过多的变量。 【错误代码示例】 以下代码中定义的变量过大，导致栈溢出。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result temp[512]; // 错误: temp数组含有512个元素，总大小为10K，远超内核栈大小 (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something return 0; } ... 代码中数组temp有512个元素，总共10K大小，远超内核的8K，明显的栈溢出。 【正确代码示例】 使用kmalloc()代替之。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result *temp = NULL; temp = (result *)kmalloc(sizeof(result) * 512, GFP_KERNEL); //修改：使用kmalloc()申请内存 ... // check temp is not NULL (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something ... // free temp return 0; } ... ","date":"0001-01-01","objectID":"/securecoding/:34:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"临时关闭地址校验机制后，在操作完成后必须及时恢复 【描述】 SMEP安全机制是指禁止内核执行用户空间的代码（PXN是ARM版本的SMEP）。系统调用（如open()，write()等）本来是提供给用户空间程序访问的。默认情况下，这些函数会对传入的参数地址进行校验，如果入参是非用户空间地址则报错。因此，要在内核程序中使用这些系统调用，就必须使参数地址校验功能失效。set_fs()/get_fs()就用来解决该问题。详细说明见如下代码： ... mmegment_t old_fs; printk(\"Hello, I'm the module that intends to write message to file.\\n\"); if (file == NULL) { file = filp_open(MY_FILE, O_RDWR | O_APPEND | O_CREAT, 0664); } if (IS_ERR(file)) { printk(\"Error occured while opening file %s, exiting ...\\n\", MY_FILE); return 0; } sprintf(buf, \"%s\", \"The Message.\"); old_fs = get_fs(); // get_fs()的作用是获取用户空间地址上限值 // #define get_fs() (current-\u003eaddr_limit set_fs(KERNEL_DS); // set_fs的作用是将地址空间上限扩大到KERNEL_DS，这样内核代码可以调用系统函数 file-\u003ef_op-\u003ewrite(file, (char *)buf, sizeof(buf), \u0026file-\u003ef_pos); // 内核代码可以调用write()函数 set_fs(old_fs); // 使用完后及时恢复原来用户空间地址限制值 ... 通过上述代码，可以了解到最为关键的就是操作完成后，要及时恢复地址校验功能。否则SMEP/PXN安全机制就会失效，使得许多漏洞的利用变得很容易。 【错误代码示例】 在程序错误处理分支，未通过set_fs()恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d]\\n\", path, fd); return; // 错误：在错误处理程序分支未恢复地址校验机制 } sys_close(fd); set_fs(oldfs); ... 【正确代码示例】 在错误处理程序中恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d] \\n\", path, fd); set_fs(oldfs); // 修改：在错误处理程序分支中恢复地址校验机制 return; } sys_close(fd); set_fs(oldfs); ... ","date":"0001-01-01","objectID":"/securecoding/:35:0","tags":null,"title":"","uri":"/securecoding/"}]