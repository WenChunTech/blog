[{"categories":["draft"],"content":"Btrfs文件系统介绍 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"1. Btrfs简介 Btrfs 是一种新型的写时复制（CoW）Linux 文件系统，已经并入内核主线。你可以读作 Better File System、B-tree File System、Butter File System 等等，都是正确的。Btrfs 在设计实现高级功能的同时，着重于容错、修复以及易于管理。它由 Oracle、Red Hat、Fujitsu、Intel、SUSE、STRATO 等企业和开发者共同开发。Btrfs 以 GNU GPL 协议授权，同时也欢迎任何人的贡献。 ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"2. Btrfs的特性 扩展性相关 B-tree Btrfs 文件系统中所有的 metadata 都由 B-tree 管理。使用 B-tree 的主要好处在于查找、插入和删除操作都很高效。可以说 B-tree 是 Btrfs 的核心 基于 Extent 的文件存储 ✅ 针对 SSD 的优化支持 Btrfs 的 CoW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，Btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 I/O 性能 动态 Inode 分配 支持非常大的单个文件大小 数据一致性相关 ✅ 写时复制（CoW） 比就地修改的文件系统有更大的好处，详细的说明见下文 校验和（Checksum） 保证了数据的可靠性：由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变成了 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。如果最终从磁盘读取出来的数据和 checksum 不相同，Btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，Btrfs 将返回错误。写入磁盘数据之前，Btrfs 计算数据的 checksum。然后将 checksum 和数据同时写入磁盘。 多设备管理相关 ✅ 多设备管理 Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的相关命令将该设备添加到文件系统中 ✅ 子卷（Subvolume） 把文件系统的一部分配置为一个完整的子文件系统 ✅ 快照（Snapshot）和克隆（Clone） 支持快照 支持快照的快照（增量备份） 可以对单个文件进行备份 ✅ 内置支持 RAID，支持条带或 mirror 等常见的 RAID 功能 ✅ 支持热移除、热添加设备 其他特性 ✅ 透明压缩 减小了文件的大小，通过减少文件写入增幅来显著延长闪存介质的寿命。在某些特定的场景下（比如单线程、重负荷的文件 I/O）还提高了性能 延迟分配（Delay allocation） 在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配则是这样一种技术 —— 当用户需要磁盘空间时，先将数据保存在内存中。将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求 —— 一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 I/O 效率 Inline File 系统中往往存在大量的小文件（几百个字节或者更小）。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。Btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。得益于 Inline File 技术，Btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题 目录索引（Directory Index） 当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 B-tree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。然而，Btrfs 使用 B-tree 管理目录项的方式无法同时满足 readdir 的需求。readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件；并且特别的，这些文件要按照 inode number 排序。而 Btrfs 目录项插入 B-tree 时的 Key 并不是 inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，Btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 Key 以 sequence number 作为 B-tree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 Key 在 B-tree 中查找便可以方便的得到一个以 inode number 排序的文件列表 另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 I/O 效率 预分配 很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"Btrfs 与其它文件系统功能比较# Feature Ext 2 / 3 Ext 4 ReiserFS XFS OCFS2 Btrfs Journal (date / metadata) ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚫ ⚪ / ⚫ ⚪ / ⚫ N/A Journal (internal / external) ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚪ N/A Offline extend / shrink ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚪ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Online extend / shrink ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚪ ⚫ / ⚫ Inode allocation map table table B*-tree B+-tree table B-tree Sparse files ⚫ ⚫ ⚫ ⚫ ⚫ ⚫ Tail packing ⚪ ⚫ ⚫ ⚪ ⚪ ⚫ Defragmentation ⚪ ⚫ ⚪ ⚫ ⚪ ⚫ ExtArributes / ACLs ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ ⚫ / ⚫ Quotas ⚫ ⚫ ⚫ ⚫ ⚫ 🔴 Dump / restore ⚫ ⚫ ⚪ ⚫ ⚪ ⚪ Default block size 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB 4 KiB max. file system size 16 TiB 1 EiB 16 TiB 8 EiB 4 PiB 16 EiB max. file size 2 TiB 1 EiB 1 EiB 8 EiB 4 PiB 16 EiB Support status SLES SLES SLES SLES SLE HA SLES ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:1","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["draft"],"content":"3. Barfs的简单使用 3.1 创建文件系统 mkfs.btrfs -f /dev/sda1 3.2 挂载文件系统 mount /dev/sda1 /mnt 3.3 创建子卷 btrfs subvolume create subvolume_name 3.4 删除子卷 btrfs subvolume delete subvolume_name # or rm -rf subvolume_name 3.5 创建快照 btrfs subvolume snapshot source destination 3.6 删除快照 btrfs subvolume delete snapshot_name 3.7 查看快照 btrfs subvolume list /mnt 3.8 查看文件系统信息 btrfs filesystem show /mnt 3.9 查看文件系统使用情况 btrfs filesystem df /mnt 3.10 查看文件系统的压缩情况 btrfs filesystem df -c /mnt 3.11 查看文件系统的压缩算法 btrfs filesystem df -c /mnt 3.12 查看子卷信息 btrfs subvolume show /mnt ","date":"2024-01-21","objectID":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["draft"],"title":"Btrfs文件系统","uri":"/btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"VPN 原理浅谈 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:0:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的应用场景 保护隐私： VPN 通过加密通信，确保你的互联网连接是安全的。这对于在公共 Wi-Fi 网络上浏览互联网时尤其重要，因为公共网络通常更容易受到黑客攻击。 绕过地理限制： 有些网站或服务在特定地区可能不可用，或者内容受到地理限制。使用 VPN 可以改变你的 IP 地址，使你能够绕过这些地理限制，访问受限制的内容。 保护公司内部网络： 公司可以使用 VPN 来建立安全的远程访问通道，员工可以通过 VPN 连接到公司内部网络，以便在远程地点安全地访问公司资源。 匿名上网： VPN 可以隐藏你的真实 IP 地址，提高上网的匿名性。这对于那些希望在互联网上保持相对匿名的用户来说很有用。 绕过审查： 在一些国家，互联网审查可能会限制对特定网站或服务的访问。使用 VPN 可以绕过这些审查，让用户能够自由地访问互联网。 安全远程办公： 对于远程工作者或分布式团队来说，VPN 提供了一个安全的通信渠道，使他们能够远程连接到公司网络并访问必要的资源。 防止数据被窃取： 在使用不安全的网络时，VPN 可以加密你的数据流，防止敏感信息被窃取，确保通信的机密性。 游戏加速： 一些玩家可能使用 VPN 来连接到特定地区的游戏服务器，以获得更好的游戏性能或访问特定地区的游戏内容。 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:1:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的工作原理 涉及到的底层技术 tun/tap: 用于创建虚拟网卡，用于接收和发送数据包, 主要的操作就是在此实现的 iptables： 用于实现数据包的转发 iproute2： 用于实现路由表的管理 tun/tap 概述： tun 设备: TUN设备是一种虚拟网络设备，用于在用户空间和内核空间之间传递网络数据。TUN代表“网络隧道”（Network TUNnel），它允许用户空间的程序通过标准的网络套接字接口发送和接收IP数据包，同时内核会处理网络协议的部分。TUN设备通常用于创建虚拟私有网络（VPN）和其他网络隧道，以在用户空间中运行的程序与内核之间传递网络流量。这对于实现网络隔离、虚拟专用网络、安全隧道等应用场景非常有用。一般来说，使用TUN设备的流程如下： 用户空间程序通过TUN设备发送IP数据包。 内核将接收到的数据包从TUN设备中读取。 用户空间程序可以通过标准的套接字接口监听和处理这些数据包。 tap 设备：TAP设备（Tap虚拟网卡）是一种虚拟网络设备，与TUN设备类似，也用于在用户空间和内核空间之间传递网络数据。TAP代表“网络透明适配器”（Network TAP），与TUN设备不同的是，TAP设备在数据链路层（OSI模型的第二层）工作，而TUN设备在网络层（第三层）工作。主要区别在于： TAP设备：它以太网设备的形式存在，可以处理链路层的数据包。因此，TAP设备可以传输以太网帧，包括处理MAC地址等。TAP设备通常用于需要在二层进行操作的场景，比如虚拟局域网（VLAN）的实现、桥接网络、以太网隧道等。 TUN设备：与TAP不同，TUN设备是在网络层工作的，只能传输IP数据包。TUN设备通常用于实现虚拟私有网络（VPN）等应用，它只关心IP层的数据，而不涉及链路层的细节。 在使用TAP设备时，用户空间程序可以像处理真实的网络接口一样处理TAP设备，包括发送和接收以太网帧。 iptables 简单使用: # 设置从eth0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # 设置从tun0出去的数据包,动态将内部地址转为外部可访问地址 iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE # 设置从eth0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 设置从tun0进来，状态为RELATED,ESTABLISHED 的数据包，允许进入 iptables -A INPUT -i tun0 -m state --state RELATED,ESTABLISHED -j ACCEPT # 允许所以数据包转发 iptables -A FORWARD -j ACCEPT iproute2 简单使用 # 设置tun0设备的ip为192.168.1.10/24 ip addr add 192.168.1.10/24 dev tun0 # 添加走到tun0设备的路由 ip route add 192.168 # 为table 100添加一条来自 192.168.1.10的规则 ip rule add from 192.168.1.10 table 100 ","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:2:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"VPN 的简单实现","date":"2023-11-05","objectID":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/:3:0","tags":["vpn","tun","linux"],"title":"VPN原理浅谈","uri":"/vpn%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"},{"categories":["linux"],"content":"性能 Profiling – 使用 Perf 命令 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:0:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"1. Perf 常用命令 perf top 常用参数 -e：指定性能事件 -a：显示在所有 CPU 上的性能统计信息 -C：显示在指定 CPU 上的性能统计信息 -p：指定进程 PID -t：指定线程 TID -K：隐藏内核统计信息 -U：隐藏用户空间的统计信息 -s：指定待解析的符号信息 ‘‐G’ or‘‐‐call‐graph’ \u003coutput_type,min_percent,call_order\u003e graph: 使用调用树，将每条调用路径进一步折叠。这种显示方式更加直观。 每条调用路径的采样率为绝对值。也就是该条路径占整个采样域的比率。 perf list perf test perf record: 记录一段时间内系统/进程的性能时间 常用参数 -e：选择性能事件 -p：待分析进程的 id -t：待分析线程的 id -a：分析整个系统的性能 -C：只采集指定 CPU 数据 -c：事件的采样周期 -o：指定输出文件，默认为 perf.data -A：以 append 的方式写输出文件 -f：以 OverWrite 的方式写输出文件 -g：记录函数间的调用关系 perf report: 读取 perf record 生成的数据文件，并显示分析数据 常用参数 -i：输入的数据文件 -v：显示每个符号的地址 -d ：只显示指定 dos 的符号 -C：只显示指定 comm 的信息（Comm. 触发事件的进程名） -S：只考虑指定符号 -U：只显示已解析的符号 -g[type,min,order]：显示调用关系，具体等同于 perf top 命令中的-g -c：只显示指定 cpu 采样信息 -M：以指定汇编指令风格显示 –source：以汇编和 source 的形式进行显示 -p：用指定正则表达式过滤调用函数 ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:1:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"2. 生成火焰图示例 # 采集数据 perf record -F 99 -p 1234 -g \u003ccommand\u003e -- sleep 30 # 解析数据 perf script -i perf.data \u0026\u003e perf.unfold # 生成火焰图 # 克隆仓库 git clone https://github.com/brendangregg/FlameGraph.git cd FlameGraph # 对perf.unfold文件进行符号折叠 ./stackcollapse-perf.pl perf.unfold \u003e perf.folded # 生成火焰图（svg图） ./flamegraph.pl perf.folded \u003e perf.svg ","date":"2023-10-22","objectID":"/perf%E6%80%A7%E8%83%BDprofiling/:2:0","tags":["perf","linux"],"title":"Perf性能Profiling","uri":"/perf%E6%80%A7%E8%83%BDprofiling/"},{"categories":["linux"],"content":"IP 路由相关命令总结 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:0:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"一，路由策略（使用ip rule命令操作路由策略数据库） 基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。 ip rule命令： Usage: ip rule { add | del } SELECTOR ACTION ip rule { flush | save | restore } ip rule [ list [ SELECTOR ]] SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK[/MASK] ] [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ] [ uidrange NUMBER-NUMBER ] [ ipproto PROTOCOL ] [ sport [ NUMBER | NUMBER-NUMBER ] [ dport [ NUMBER | NUMBER-NUMBER ] ] ACTION := [ table TABLE_ID ] [ protocol PROTO ] [ nat ADDRESS ] [ realms [SRCREALM/]DSTREALM ] [ goto NUMBER ] SUPPRESSOR SUPPRESSOR := [ suppress_prefixlength NUMBER ] [ suppress_ifgroup DEVGROUP ] TABLE_ID := [ local | main | default | NUMBER ] #例子1：通过路由表 table 1 路由来自源地址为192.203.80/24的数据包 ip rule add from 192.203.80/24 table 1 #例子2：把源地址为192.168.1.10的数据报的源地址转换为192.168.2.20，并通过表1进行路由 ip rule add from 193.168.1.10 nat 192.168.2.20 table 1 #实例3：让eht0流量使用table 1 ip rule add dev eth0 table1 在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则： 0：匹配任何条件，查询路由表local(ID 255)，该表local是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0非常特殊，不能被删除或者覆盖。 32766：匹配任何条件，查询路由表main(ID 254)，该表是一个通常的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。 32767：匹配任何条件，查询路由表default(ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。 **注：**不要混淆路由表和策略：规则指向路由表，多个规则可以引用一个路由表，而且某些路由表可以策略指向它。如果系统管理员删除了指向某个路由表的所有规则，这个表没有用了，但是仍然存在，直到里面的所有路由都被删除，它才会消失。 linux 系统中，可以自定义从 1－252个路由表，其中，linux系统维护了4个路由表： 0#表： 系统保留表 253#表： defulte table 没特别指定的默认路由都放在改表 254#表： main table 没指明路由表的所有路由放在该表 255#表： locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改 路由表的查看可有以下二种方法： ip route show table table_number ip route show table table_name 路由表序号和表名的对应关系在 /etc/iproute2/rt_tables文件中，可以手动编辑，路由表添加完毕及时生效，实例如下： #实例1：在一号表中添加默认路由为192.168.1.1 ip route add default via 192.168.1.1 table 1 #实例2：在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2 ip route add 192.168.0.0/24 via 192.168.1.2 table 1 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"二，路由表（使用ip route命令操作静态路由表） 所谓路由表，指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据–路由表，供路由选择时使用，表中包含的信息决定了数据转发的策略。 以一例子来说明：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。 首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关：ip route add default gw 20.0.0.1 之后通过 ip route 添加一个路由表：ip route add table 3 via 10.0.0.1 dev ethX (ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号) 之后添加 ip rule 规则：ip rule add fwmark 3 table 3 （fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表） 之后使用 iptables 给相应的数据打上标记：iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK –set-mark 3 ","date":"2023-10-12","objectID":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["route","linux","tun"],"title":"Ip路由相关命令","uri":"/ip%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"Docker 基本命令 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:0:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"1. 使用镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 \u003c域名/IP\u003e[:端口号]。默认地址是 Docker Hub(docker.io)。 仓库名：如之前所说，这里的仓库名是两段式名称，即 \u003c用户名\u003e/\u003c软件名\u003e。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"2. 操作容器 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 -d: 让容器在后台运行 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash, 也可以使用dash或者fish。 ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"3. 数据管理 创建一个数据卷 docker volume create my-vol 删除数据卷 docker volume rm my-vol 无主的数据卷可能会占据很多空间，要清理请使用以下命令: docker volume prune 查看所有数据卷 docker volume ls 在主机里使用以下命令可以查看指定 数据卷 的信息 docker volume inspect my-vol 查看容器详细信息 docker inspect container_id 挂载主机目录 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\ nginx:alpine 注意: 本地目录的路径必须是绝对路径,使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读 docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ nginx:alpine ","date":"2023-09-13","objectID":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker基本命令","uri":"/docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["linux","docker"],"content":"Docker 基石-NetworkNamespace ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:0:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"1. veth-pair 是什么 veth-pair 是一对虚拟网卡，通过 veth-pair 可以将两个网络命名空间连接起来，从而实现两个网络命名空间之间的通信。和 tap/tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着 全程只使用 ip 命令进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:1:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2. 使用 veth-pair 和 netns 进行演示 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:0","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.1 创建两个网络命名空间 ip netns add ns1 ip netns add ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:1","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.2 创建 veth-pair ip link add veth1 type veth peer name veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:2","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.3 将 veth1 移动到 ns1 中 ip link set veth1 netns ns1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:3","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.4 将 veth2 移动到 ns2 中 ip link set veth2 netns ns2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:4","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.5 启动 veth1 ip netns exec ns1 ip link set dev veth1 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:5","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.6 启动 veth2 ip netns exec ns2 ip link set dev veth2 up ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:6","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.7 设置 veth1 的 IP 地址 ip netns exec ns1 ip addr add 192.168.1.2/24 dev veth1 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:7","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.8 设置 veth2 的 IP 地址 ip netns exec ns2 ip addr add 192.168.1.3/24 dev veth2 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:8","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["linux","docker"],"content":"2.9 测试 ip netns exec ns1 ping 192.168.1.3 ","date":"2023-08-31","objectID":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/:2:9","tags":["veth","docker"],"title":"Docker基石 NetworkNamespace","uri":"/docker%E5%9F%BA%E7%9F%B3-networknamespace/"},{"categories":["pytorch"],"content":"torch.fx模块的使用 ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"torch.fx主要有3个组件： 符号追踪器（symbolic tracer) 中间表示（intermediate representation) Python代码生成（Python code generation) import torch # Simple module for demonstration class MyModule(torch.nn.Module): def __init__(self): super().__init__() self.param = torch.nn.Parameter(torch.rand(3, 4)) self.linear = torch.nn.Linear(4, 5) def forward(self, x): return self.linear(x + self.param).clamp(min=0.0, max=1.0) module = MyModule() from torch.fx import symbolic_trace # 符号追踪这个模块 # Symbolic tracing frontend - captures the semantics of the module symbolic_traced : torch.fx.GraphModule = symbolic_trace(module) # 中间表示 # High-level intermediate representation (IR) - Graph representation print(symbolic_traced.graph) \"\"\" graph(): %x : [#users=1] = placeholder[target=x] %param : [#users=1] = get_attr[target=param] %add : [#users=1] = call_function[target=operator.add](args = (%x, %param), kwargs = {}) %linear : [#users=1] = call_module[target=linear](args = (%add,), kwargs = {}) %clamp : [#users=1] = call_method[target=clamp](args = (%linear,), kwargs = {min: 0.0, max: 1.0}) return clamp \"\"\" # 生成代码 # Code generation - valid Python code print(symbolic_traced.code) \"\"\" def forward(self, x): param = self.param add = x + param; x = param = None linear = self.linear(add); add = None clamp = linear.clamp(min = 0.0, max = 1.0); linear = None return clamp \"\"\" ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"使用场景 Replace one op Conv/Batch Norm fusion replace_pattern: Basic usage Quantization Invert Transformation 融合例子: # Works for length 2 patterns with 2 modules def matches_module_pattern(pattern: Iterable[Type], node: fx.Node, modules: Dict[str, Any]): if len(node.args) == 0: return False nodes: Tuple[Any, fx.Node] = (node.args[0], node) for expected_type, current_node in zip(pattern, nodes): if not isinstance(current_node, fx.Node): return False if current_node.op != 'call_module': return False if not isinstance(current_node.target, str): return False if current_node.target not in modules: return False if type(modules[current_node.target]) is not expected_type: return False return True def replace_node_module(node: fx.Node, modules: Dict[str, Any], new_module: torch.nn.Module): assert(isinstance(node.target, str)) parent_name, name = _parent_name(node.target) modules[node.target] = new_module setattr(modules[parent_name], name, new_module) def fuse(model: torch.nn.Module, inplace=False) -\u003e torch.nn.Module: \"\"\" Fuses convolution/BN layers for inference purposes. Will deepcopy your model by default, but can modify the model inplace as well. \"\"\" patterns = [(nn.Conv1d, nn.BatchNorm1d), (nn.Conv2d, nn.BatchNorm2d), (nn.Conv3d, nn.BatchNorm3d)] if not inplace: model = copy.deepcopy(model) fx_model = fx.symbolic_trace(model) modules = dict(fx_model.named_modules()) new_graph = copy.deepcopy(fx_model.graph) for pattern in patterns: for node in new_graph.nodes: # 找到目标Node：args是Conv，target是BN if matches_module_pattern(pattern, node, modules): if len(node.args[0].users) \u003e 1: # Output of conv is used by other nodes continue conv = modules[node.args[0].target] bn = modules[node.target] # 融合BN和Conv fused_conv = fuse_conv_bn_eval(conv, bn) # 替换Node的module，其实就是将融合后的module替换Conv Node的target，背后是模块替换 replace_node_module(node.args[0], modules, fused_conv) # 将所有用到BN Node的替换为Conv Node（已经融合后的Conv） node.replace_all_uses_with(node.args[0]) # 删除BN Node new_graph.erase_node(node) return fx.GraphModule(fx_model, new_graph) from torch.fx.experimental.optimization import fuse from torchvision.models import resnet18 model = resnet18() model.eval() # 必须在eval模型下fuse ''' (layer4): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' fused_model = fuse(model) ''' (layer4): Module( (0): Module( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (downsample): Module( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2)) ) ) (1): Module( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) (fc): Linear(in_features=512, out_features=1000, bias=True) ) ''' ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["pytorch"],"content":"参考链接: PyTorch新技能解锁：torch.fx - 知乎 (zhihu.com) ","date":"2023-07-23","objectID":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["pytorch","torch.fx"],"title":"Torch.fx模块的使用","uri":"/torch.fx%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"matplotlib的简单使用 matplotlib结构 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:0:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1. fig,ax,plt 三者的基本概念 fig Figure，就是图的外框，也叫画布，可以包括1-无穷个内框Axes ax Axes，就是图的内框(可以将画布分为多个绘图区域)，里面可以画各种图，最常见的就是二维的统计图或者折线图，也可以画三维图xyz和极坐标图theta-r Axis，就是坐标轴 plt Pyplot为底层面向对象的绘图库提供状态机接口。状态机隐式自动创建图形和轴，以实现所需的绘图。 ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:1:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.常用函数说明 matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布 import matplotlib.pyplot as plt plt.plot([1,2,3]) #现在创建一个子图，它表示一个有2行1列的网格的顶部图。 #因为这个子图将与第一个重叠，所以之前创建的图将被删除 plt.subplot(211) plt.plot(range(12)) #创建带有黄色背景的第二个子图 plt.subplot(212, facecolor='y') plt.plot(range(12)) Matplotlib 提供了matplotlib.figure图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。如下所示： from matplotlib import pyplot as plt import numpy as np import math x = np.arange(0, math.pi*2, 0.05) y = np.sin(x) fig = plt.figure() # add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。 ax = fig.add_axes([0,0,1,1]) ax.plot(x,y) ax.set_title(\"sine wave\") ax.set_xlabel('angle') ax.set_ylabel('sine') plt.show() matplotlib.pyplot模块提供了一个 subplots() 函数，它的使用方法和 subplot() 函数类似。其不同之处在于，subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。 import matplotlib.pyplot as plt # 将画布分为2*2的绘图区域 fig,a = plt.subplots(2,2) import numpy as np x = np.arange(1,5) #绘制平方函数 a[0][0].plot(x,x*x) a[0][0].set_title('square') #绘制平方根图像 a[0][1].plot(x,np.sqrt(x)) a[0][1].set_title('square root') #绘制指数函数 a[1][0].plot(x,np.exp(x)) a[1][0].set_title('exp') #绘制对数函数 a[1][1].plot(x,np.log10(x)) a[1][1].set_title('log') plt.show() ","date":"2023-07-13","objectID":"/matplotlib%E4%BD%BF%E7%94%A8/:2:0","tags":["python","matplotlib"],"title":"Matplotlib使用","uri":"/matplotlib%E4%BD%BF%E7%94%A8/"},{"categories":["c/cpp"],"content":"一、string.h中字符串处理函数 在头文件\u003cstring.h\u003e中定义了两组字符串函数。第一组函数的名字以str开头；第二组函数的名字以mem开头。 只有函数memmove对重叠对象间的拷贝进行了定义，而其他函数都未定义。比较类函数将其变量视为unsigned char类型的数组。 1 strcpy #include \u003cstring.h\u003e char *strcpy(char *str1, const char *str2); 把字符串str2(包括’\\0’)拷贝到字符串str1当中，并返回str1。 2 strncpy #include \u003cstring.h\u003e char *strncpy(char *str1, const char *str2, size_t count); 把字符串str2中最多count个字符拷贝到字符串str1中，并返回str1。如果str2中少于count个字符，那么就用’\\0’来填充，直到满足count个字符为止。 3 strcat #include \u003cstring.h\u003e char *strcat(char *str1, const char *str2); 把str2(包括’\\0’)拷贝到str1的尾部(连接)，并返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 4 strncat #include \u003cstring.h\u003e char *strncat(char *str1, const char *str2, size_t count); 把str2中最多count个字符连接到str1的尾部，并以’\\0’终止str1，返回str1。其中终止原str1的’\\0’被str2的第一个字符覆盖。 注意，最大拷贝字符数是count+1。 5 strcmp #include \u003cstring.h\u003e int strcmp(const char *str1, const char *str2); 按字典顺序比较两个字符串，返回整数值的意义如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 6 strncmp #include \u003cstring.h\u003e int strncmp(const char *str1, const char *str2, size_t count); 同strcmp，除了最多比较count个字符。根据比较结果返回的整数值如下： 小于0，str1小于str2； 等于0，str1等于str2； 大于0，str1大于str2； 7 strchr #include \u003cstring.h\u003e char *strchr(const char *str, int ch); 返回指向字符串str中字符ch第一次出现的位置的指针，如果str中不包含ch，则返回NULL。 8 strrchr #include \u003cstring.h\u003e char *strrchr(const char *str, int ch); 返回指向字符串str中字符ch最后一次出现的位置的指针，如果str中不包含ch，则返回NULL。 9 strspn #include \u003cstring.h\u003e size_t strspn(const char *str1, const char *str2); 返回字符串str1中由字符串str2中字符构成的第一个子串的长度。 10 strcspn #include \u003cstring.h\u003e size_t strcspn(const char *str1, const char *str2); 返回字符串str1中由不在字符串str2中字符构成的第一个子串的长度。 11 strpbrk #include \u003cstring.h\u003e char *strpbrk(const char *str1, const char *str2); 返回指向字符串str2中的任意字符第一次出现在字符串str1中的位置的指针；如果str1中没有与str2相同的字符，那么返回NULL。 12 strstr #include \u003cstring.h\u003e char *strstr(const char *str1, const char *str2); 返回指向字符串str2第一次出现在字符串str1中的位置的指针；如果str1中不包含str2，则返回NULL。 13 strlen #include \u003cstring.h\u003e size_t strlen(const char *str); 返回字符串str的长度，’\\0’不算在内。 14 strerror #include \u003cstring.h\u003e char *strerror(int errnum); 返回指向与错误序号errnum对应的错误信息字符串的指针(错误信息的具体内容依赖于实现)。 15 strtok #include \u003cstring.h\u003e char *strtok(char *str1, const char *str2); 在str1中搜索由str2中的分界符界定的单词。 对strtok()的一系列调用将把字符串str1分成许多单词，这些单词以str2中的字符为分界符。第一次调用时str1非空，它搜索str1，找出由非str2中的字符组成的第一个单词，将str1中的下一个字符替换为’\\0’，并返回指向单词的指针。随后的每次strtok()调用(参数str1用NULL代替)，均从前一次结束的位置之后开始，返回下一个由非str2中的字符组成的单词。当str1中没有这样的单词时返回NULL。每次调用时字符串str2可以不同。 如： char *p; p = strtok(\"The summer soldier,the sunshine patriot\", \" \"); printf(\"%s\", p); do { p = strtok(\"\\0\", \", \"); /* 此处str2是逗号和空格 */ if (p) printf(\"|%s\", p); } while (p); 显示结果是：The | summer | soldier | the | sunshine | patriot 16 memcpy #include \u003cstring.h\u003e void *memcpy(void *to, const void *from, size_t count); 把from中的count个字符拷贝到to中。并返回to。 17 memmove #include \u003cstring.h\u003e void *memmove(void *to, const void *from, size_t count); 功能与memcpy类似，不同之处在于，当发生对象重叠时，函数仍能正确执行。 18 memcmp #include \u003cstring.h\u003e int memcmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2的前count个字符，返回值与strcmp的返回值相同。 19 memchr #include \u003cstring.h\u003e void *memchr(const void *buffer, int ch, size_t count); 返回指向ch在buffer中第一次出现的位置指针，如果在buffer的前count个字符当中找不到匹配，则返回NULL。 20 memset #include \u003cstring.h\u003e void *memset(void *buf, int ch, size_t count); 把buf中的前count个字符替换为ch，并返回buf ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"example #include \"malloc.h\" #include \"stdint.h\" #include \"stdio.h\" #include \"stdlib.h\" #include \"string.h\" #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { // malloc and memset and strlen usage char *s = (char *)malloc(sizeof(char) * 10); printf(\"origin strlen(s): %llu\\n\", strlen(s)); memset(s, 'i', 12); printf(\"after memset, strlen(s): %llu\\n\", strlen(s)); int *i = (int *)malloc(sizeof(int) * 10); printf(\"sizeof(i): %llu\\n\", sizeof(i)); // strcpy usage char *s1 = (char *)malloc(sizeof(char) * 10); char s2[] = {\"hello\"}; printf(\"strlen(s1): %llu\\n\", strlen(s1)); printf(\"sizeof(s1): %llu\\n\", sizeof(s1)); printf(\"strlen(s2): %llu\\n\", strlen(s2)); printf(\"sizeof(s2): %llu\\n\", sizeof(s2)); strcpy_s(s1, strlen(s2) + 1, s2); // strncpy_s(s1, strlen(s2)+1, s2, 3); printf(\"s1=%s\\n\", s1); printf(\"*****************************\\n\"); char s3[] = {\"world\"}; // strstr return pointer char *p = strstr(s3, \"ld\"); printf(\"p=%s\\n\", p); // calculate the offset printf(\"%lld\\n\", p-s3); p = strchr(s3, 'o'); printf(\"strchr p=%s\\n\", p); printf(\"strchr offset:%lld\\n\", p-s3); p = strrchr(s3, 'l'); printf(\"strrchr p=%s\\n\", p); printf(\"strrchr offset:%lld\\n\", p-s3); p = strtok(s3, \"or\"); while (p) { printf(\"strtok p=%s\\n\", p); p = strtok(NULL, \"or\"); } printf(\"after strtok, s3=%s\\n\", s3); int a = strcmp(s3, \"world\"); printf(\"strcmp a=%d\\n\", a); a = strncmp(s3, \"world\", 1); printf(\"strncmp a=%d\\n\", a); char s4[] = {\"hello\"}; memmove(s4+1, s4, 1); printf(\"memmove s4=%s\\n\", s4); memcpy(s4, \"hello\", 5); printf(\"memccpy s4=%s\\n\", s4); return 0; } // output: // origin strlen(s): 6 // after memset, strlen(s): 14 // sizeof(i): 8 // strlen(s1): 6 // sizeof(s1): 8 // strlen(s2): 5 // sizeof(s2): 6 // s1=hello // ***************************** // p=ld // 3 // strchr p=orld // strchr offset:1 // strrchr p=ld // strrchr offset:3 // strtok p=w // strtok p=ld // after strtok, s3=w // strcmp a=-1 // strncmp a=0 // memmove s4=hhllo // memccpy s4=hello 二、stdlib.h中字符串与数字相互转换处理函数 1. 数字转化为字符串: ● itoa()：将整型值转换为字符串。 ● ltoa()：将长整型值转换为字符串。 ● ultoa()：将无符号长整型值转换为字符串。 ● gcvt()：将浮点型数转换为字符串，取四舍五入。 ● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。 ● fcvt()：指定位数为转换精度，其余同ecvt()。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int = 435; double num_double = 435.10f; char str_int[30]; char str_double[30]; itoa(num_int, str_int, 10); //把整数num_int转成字符串str_int gcvt(num_double, 8, str_double); //把浮点数num_double转成字符串str_double printf(\"str_int: %s\\n\", str_int); printf(\"str_double: %s\\n\", str_double); return 0; } 程序输出结果： str_int: 435 str_double: 435.10001 代码第11行中的参数10表示按十进制类型进行转换，转换后的结果是“435”，如果按二进制类型进行转换，则结果为“1101110011”。 代码第12行中的参数8表示精确位数，这里得到的结果是“435.10001”。 2. 字符串转化为数字 atof()：将字符串转换为双精度浮点型值。 atoi()：将字符串转换为整型值。 atol()：将字符串转换为长整型值。 strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。 strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。 strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。 例子： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e int main () { int num_int; double num_double; char str_int[30] = \"435\"; //将要被转换为整型的字符串 char str_double[30] = \"436.55\"; //将要被转换为浮点型的字符串 num_int = atoi(str_int); //转换为整型值 num_double = atof(str_double); //转换为浮点型值 printf(\"num_int: %d\\n\", num_int); printf(\"num_double: %lf\\n\", num_double); return 0; } // 输出结果： // num_int: 435 // num_double: 436.550000 ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["c/cpp"],"content":"进制互转 // int to binary char tmp[10] = {}; char *conv = itoa(5, tmp, 2); printf(\"itoa to 2: conv=%s\\n\", conv); // int to hex conv = itoa(17, tmp, 16); printf(\"itoa to 16: conv=0x%s\\n\", conv); // hex to 10 int hex = strtol(\"0x11\", NULL, 16); printf(\"strtol: hex=%d\\n\", hex); // binary to 10 int bin = strtol(\"101\", NULL, 2); printf(\"strtol: bin=%d\\n\", bin); // output // itoa to 2: conv=101 // itoa to 16: conv=0x11 // strtol: hex=17 // strtol: bin=5? ","date":"2023-07-09","objectID":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["c/c++"],"title":"C语言常用函数","uri":"/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["python"],"content":"介绍 异步IO：就是发起一个IO操作（如：网络请求，文件读写等），这些操作一般是比较耗时的，不用等待它结束，可以继续做其他事情，结束时会发来通知。 协程：又称为微线程，在一个线程中执行，执行函数时可以随时中断，由程序（用户）自身控制，执行效率极高，与多线程比较，没有切换线程的开销和多线程锁机制。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:0:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio中几个重要概念 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"1.事件循环 事件循环是每个 asyncio 应用的核心，管理所有的事件，在整个程序运行过程中不断循环执行并追踪事件发生的顺序将它们放在队列中，空闲时调用相应的事件处理者来处理这些事件。 创建事件循环 loop = asyncio.get_event_loop() 获取当前事件循环。 如果当前 OS 线程没有设置当前事件循环并且 set_event_loop() 还没有被调用，asyncio 将创建一个新的事件循环并将其设置为当前循环。 另起一个线程创建事件循环 from threading import Thread import asyncio def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() new_loop = asyncio.new_event_loop() loop_thread = Thread(target=start_thread_loop, args=(new_loop,)) loop_thread.setDaemon(True) # 守护线程 loop_thread.start() ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"2.Future Future对象表示尚未完成的计算，还未完成的结果，它和task上没有本质上的区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"3.Task 是Future的子类，作用是在运行某个任务的同时可以并发的运行多个任务。 asyncio.Task用于实现协作式多任务的库，且Task对象不能用户手动实例化，通过下面2个函数创建： loop.create_task() 或 asyncio.ensure_future() loop.create_task() ,要在定义loop对象之后，调用将方法对象转化成了task的对象 asyncio.ensure_future() 直接调用asyncio 的ensure_future() 方法，返回的也是task 对象（我们还没有声明 loop 也可以提前定义好 task 对象） ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"4.async/await 关键字 asyncio实现了TCP、UDP、SSL等协议，async定义一个协程，await用于挂起阻塞的异步调用接口。 对于异步io你需要知道的重点，要注意的是，await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。而且await后面的对象需要是一个Awaitable，或者实现了相关的协议。 注意 1. 所有需要异步执行的函数，都需要asyncio中的轮询器去轮询执行，如果函数阻塞，轮询器就会去执行下一个函数。所以所有需要异步执行的函数都需要加入到这个轮询器中。若在协程中需要有延时操作，应该使用 await asyncio.sleep()，而不是使用time.sleep()，因为使用time.sleep()后会释放GIL，阻塞整个主线程，从而阻塞整个事件循环。 创建一个协程 使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行 耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:1:4","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"简单例子 import asyncio from asyncio import tasks from asyncore import loop async def main(): await asyncio.sleep(2) print('this is main running') async def add_log(): await asyncio.sleep(1) print('add log before running') async def run_background(): await asyncio.sleep(3) print('running task in background') async def parameter_verification(): await asyncio.sleep(1) print('parameter verification before running') if __name__ == '__main__': # running async function method: # first method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) # the sequence of the tasks is not the same as the sequence of the function calling, and the same as define sequence result = asyncio.run(tasks) print(result) print(f'{\"*\" * 20}{\"another method\"}{\"*\" * 20}') # second method: tasks = asyncio.wait([main(), add_log(), run_background(), parameter_verification()]) loop = asyncio.get_event_loop() result = loop.run_until_complete(tasks) print(result) 首先我们引入了 asyncio 这个包，这样我们才可以使用 async 和 await，然后我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。 随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。 可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:2:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"进阶例子 多个任务，定义一个task列表，使用asyncio.gather(*tasks) 或 asyncio.wait(tasks) 接收 import asyncio import time now = lambda: time.time() \"\"\" asyncio.gather主要集中在收集结果上。它等待一堆task并按给定的顺序返回结果。 asyncio.wait等待task。而不是直接给你结果，它提供完成和待处理的任务。你必须手工收集结果。 asyncio.wait(tasks) ps:asyncio.wait([1,2,3]) 也可以使用 asyncio.gather(*tasks) ps: asyncio.gather(1,2,3),前者接受一个task列表，后者接收一堆task。 \"\"\" # 定义一个异步任务 async def do_some_work(x): print(\"waiting:\", x) # 模拟io阻塞 await asyncio.sleep(x) return \"Done after {}s\".format(x) async def main(loop): \"\"\" :param loop: loop.create_task（需要传进loop参数） :return: None \"\"\" coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(4) # asyncio.ensure_future tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] # loop.create_task（需要传进loop参数） # tasks = [ # loop.create_task(coroutine1), # loop.create_task(coroutine2), # loop.create_task(coroutine3) # ] # 返回 完成的 task object dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) # 返回 task 方法的 返回值 # results = await asyncio.gather(*tasks) # for result in results: # print(\"Task ret:\",result) start = now() loop = asyncio.get_event_loop() loop.run_until_complete(main(loop)) print(\"Time:\", now() - start) gather和wait 的区别 把多个协程注册进一个事件循环中的两种方法 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:3:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"使用方式区别 使用asyncio.wait() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 使用asyncio.gather() loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) # *接收args参数 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:4:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"接收参数区别 ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:0","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.wait 参数必须是list对象 ，list 对象存放多个 task object 用asyncio.ensure_future转为task对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 不转为task对象 loop = asyncio.get_event_loop() tasks=[ coroutine1, coroutine2, coroutine3 ] loop.run_until_complete(asyncio.wait(tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:1","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"asyncio.gather 必须用 * 来接收 list 对象 tasks=[ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(*tasks)) ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:2","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["python"],"content":"返回结果区别 asyncio.wait asyncio.wait返回dones和pendings dones：表示已经完成的任务 pendings：表示未完成的任务 我们需要手动去获取结果 dones, pendings = await asyncio.wait(tasks) print(dones, pendings) for task in dones: print(\"Task ret:\", task.result()) asyncio.gather 它的返回值就是 return的结果 ，不用再task.result() 来获取 # 返回 task 方法的 返回值 results = await asyncio.gather(*tasks) for result in results: print(\"Task ret:\",result) 另 asyncio.wait 带有控制功能 【控制运行任务数】：运行第一个任务就返回 FIRST_COMPLETED ：第一个任务完全返回 FIRST_EXCEPTION：产生第一个异常返回 ALL_COMPLETED：所有任务完成返回 （默认选项） import asyncio import random async def coro(tag): print(\"\u003e\", tag) await asyncio.sleep(random.uniform(0.5, 5)) print(\"\u003c\", tag) return tag loop = asyncio.get_event_loop() tasks = [coro(i) for i in range(1, 11)] # 第一次wait 完成情况 print(\"Get first result:\") finished, unfinished = loop.run_until_complete( asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)) # 第一个任务完全返回 for task in finished: print(task.result()) print(\"unfinished:\", len(unfinished)) # 继续第一次未完成任务 print(\"Get more results in 2 seconds:\") finished2, unfinished2 = loop.run_until_complete( asyncio.wait(unfinished, timeout=2)) # 超时2s 返回 for task in finished2: print(task.result()) print(\"unfinished2:\", len(unfinished2)) # 继续第2次未完成任务 print(\"Get all other results:\") finished3, unfinished3 = loop.run_until_complete(asyncio.wait(unfinished2)) # ALL_COMPLETED：所有任务完成返回 （默认项） for task in finished3: print(task.result()) loop.close() 动态添加协程 很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block 相关函数介绍： loop.call_soon_threadsafe() ：与 call_soon()类似，等待此函数返回后马上调用回调函数，返回值是一个 asyncio.Handle 对象，此对象内只有一个方法为 cancel()方法，用来取消回调函数。 loop.call_soon() ： 与call_soon_threadsafe()类似，call_soon_threadsafe() 是线程安全的 loop.call_later()：延迟多少秒后执行回调函数 loop.call_at()：在指定时间执行回调函数，这里的时间统一使用 loop.time() 来替代 time.sleep() asyncio.run_coroutine_threadsafe()： 动态的加入协程，参数为一个回调函数和一个loop对象，返回值为future对象，通过future.result()获取回调函数返回值 动态添加协程同步方式 通过调用 call_soon_threadsafe()函数，传入一个回调函数callback和一个位置参数 注意：同步方式，回调函数 more_work()为普通函数 import asyncio from threading import Thread import time now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() def more_work(x): print('More work {}'.format(x)) time.sleep(x) print('Finished more work {}'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) new_loop.call_soon_threadsafe(more_work, 6) new_loop.call_soon_threadsafe(more_work, 3) print('here') 启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3 异步方式 import asyncio import time from threading import Thread now = lambda: time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() async def do_some_work(x): print('Waiting {}'.format(x)) await asyncio.sleep(x) print('Done after {}s'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop) asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop) 上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。 协程的停止 future对象有几个状态： Pending Running Done Cacelled 创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task import asyncio import time now = lambda: time.time() async def do_some_work(x): print(\"Waiting:\", x) await asyncio.sleep(x) return \"Done after {}s\".format(x) coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(2) tasks = [ asyncio.ensure_future(coroutine1), asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3), ] start = now() loop = asyncio.get_event_loop() try: loop.run_until_complete(asyncio.wait(tasks)) except KeyboardInterrupt as e: print(asyncio.Task.all_tasks()) for ","date":"2023-05-28","objectID":"/asyncio%E4%BD%BF%E7%94%A8/:5:3","tags":["async"],"title":"Asyncio使用","uri":"/asyncio%E4%BD%BF%E7%94%A8/"},{"categories":["draft"],"content":"SelfAttention和MultiHeadAttention流程简述 ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:0:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["draft"],"content":"1. SelfAttention 1.1 对于每一个输入$I$,初始化3个权重矩阵$W_q,W_k,W_v$. 1.2 输入$I$分别与3个权重矩阵相乘得到$Q,K,V$ 1.3 将$Q$与$K$相乘(矩阵乘法)得到$A$(attention score) 1.4 $A$经过softmax激活得到$A'$ 1.5 将$A’$与$V$相乘得到B 代码示例: In [16]: i = torch.randn(3,4) In [17]: w_query = torch.randn(4, 2) In [18]: w_key = torch.randn(4, 2) In [19]: w_value = torch.randn(4, 2) In [20]: i Out[20]: tensor([[ 0.4313, 1.3749, -0.2489, 1.3275], [-0.6467, 1.6335, 2.8923, 0.9124], [ 0.2326, -0.2314, 0.3554, 0.0892]]) In [21]: w_query Out[21]: tensor([[ 0.3673, -0.8505], [-0.3559, -0.3708], [-1.2093, 0.6634], [ 0.4042, 0.8015]]) In [22]: w_key Out[22]: tensor([[-1.1617, 0.4023], [-0.1249, -0.1605], [-0.8427, 1.1002], [-1.1320, 0.4611]]) In [23]: w_value Out[23]: tensor([[-0.7675, -0.3179], [-1.1910, -0.6937], [-1.4809, -1.5502], [-0.7373, 1.0511]]) In [24]: querys = i @ w_query In [25]: keys = i @ w_key In [26]: values = i @ w_value In [27]: querys Out[27]: tensor([[ 0.5066, 0.0223], [-3.9478, 2.5946], [-0.2259, 0.1952]]) In [28]: keys Out[28]: tensor([[-1.9656, 0.2911], [-2.9229, 3.0806], [-0.6418, 0.5629]]) In [29]: values Out[29]: tensor([[-2.5787, 0.6903], [-6.4049, -4.4522], [-0.4950, -0.3706]]) In [30]: att_scores = querys @ keys.T In [31]: att_scores Out[31]: tensor([[-0.9893, -1.4121, -0.3126], [ 8.5152, 19.5319, 3.9940], [ 0.5009, 1.2617, 0.2549]]) In [32]: att_scores_softmax = torch.nn.functional.softmax(att_scores, dim=-1) In [33]: att_scores_softmax Out[33]: tensor([[2.7604e-01, 1.8087e-01, 5.4310e-01], [1.6426e-05, 9.9998e-01, 1.7865e-07], [2.5498e-01, 5.4565e-01, 1.9937e-01]]) In [34]: outputs = att_scores_softmax @ values In [35]: outputs Out[35]: tensor([[-2.1390, -0.8160], [-6.4048, -4.4521], [-4.2510, -2.3272]]) In [36]: outputs.shape Out[36]: torch.Size([3, 2]) ","date":"2023-05-07","objectID":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/:1:0","tags":["draft"],"title":"SelfAttention和MultiHeadAttention流程简述","uri":"/selfattention%E5%92%8Cmultiheadattention%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"categories":["DeepLearning"],"content":"什么是交叉熵 交叉熵是一个在ML领域经常会被提到的名词。在这篇文章里将对这个概念进行详细的分析。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:0:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"1.什么是信息量？ 假设$x$是一个离散型随机变量，其取值集合为$X$，概率分布函数为$p(x)=Pr(X=x), x \\in X $，我们定义事件的信息量为：$X=x_0$，可以理解为，一个事件发生的概率越大，则它所携带的信息量就越小，而当$p(x_0)=1$时，熵将等于0，也就是说该事件的发生不会导致任何信息量的增加。举个例子，小明平时不爱学习，考试经常不及格，而小王是个勤奋学习的好学生，经常得满分，所以我们可以做如下假设： 事件A：小明考试及格，对应的概率$P(x_A)=0.1$，信息量为$I(x_A)=−log(0.1)=3.3219$ 事件B：小王考试及格，对应的概率$P(x_B)=0.999$，信息量为$I(x_B)=−log(0.999)=0.0014$ 可以看出，结果非常符合直观：小明及格的可能性很低(十次考试只有一次及格)，因此如果某次考试及格了（大家都会说：XXX竟然及格了！），必然会引入较大的信息量，对应的$I$值也较高。而对于小王而言，考试及格是大概率事件，在事件B发生前，大家普遍认为事件B的发生几乎是确定的，因此当某次考试小王及格这个事件发生时并不会引入太多的信息量，相应的$I$值也非常的低。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:1:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"2.什么是熵？ 那么什么又是熵呢？还是通过上边的例子来说明，假设小明的考试结果是一个0-1分布$X_A$只有两个取值{0：不及格，1：及格}，在某次考试结果公布前，小明的考试结果有多大的不确定度呢？你肯定会说：十有八九不及格！因为根据先验知识，小明及格的概率仅有0.1,90%的可能都是不及格的。怎么来度量这个不确定度？求期望！不错，我们对所有可能结果带来的额外信息量求取均值（期望），其结果不就能够衡量出小明考试成绩的不确定度了吗。 即： $H_A(x) = -[p(x_A)log(p(X_A))] + (1-p(x_A))log(1-p(x_A))]=0.4690$ 对应小王的熵： $H_B(x)=−[p(x_B)log(p(x_B))+(1−p(x_B))log(1−p(x_B))]=0.0114$ 虽然小明考试结果的不确定性较低，毕竟十次有9次都不及格，但是也比不上小王（1000次考试只有一次才可能不及格，结果相当的确定） 我们再假设一个成绩相对普通的学生小东，他及格的概率是$P(x_C)=0.5$,即及格与否的概率是一样的，对应的熵： $H_C(x)=−[p(x_C)log(p(x_C))+(1−p(x_C))log(1−p(x_C))]=1$ 其熵为1，他的不确定性比前边两位同学要高很多，在成绩公布之前，很难准确猜测出他的考试结果。 可以看出，熵其实是信息量的期望值，它是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。 对于一个随机变量X而言，它的所有可能取值的信息量的期望$（E[I(x)]$就称为熵。 $X$的熵定义为： $H(X)=Ep \\space log \\frac 1 {p(x)}=−\\sum \\limits_{x \\in X}p(x)logp(x)$ 如果$p(x)$是连续型随机变量的pdf，则熵定义为： $H(X)=−∫_{x∈X}p(x)logp(x)dx$ 为了保证有效性，这里约定当$p(x)→0$时,有$p(x)logp(x)→0$ 当X为0-1分布时，熵与概率p的关系如下图： 可以看出，当两种取值的可能性相等时，不确定度最大（此时没有任何先验知识），这个结论可以推广到多种取值的情况。在图中也可以看出，当p=0或1时，熵为0，即此时X完全确定。 熵的单位随着公式中$log$运算的底数而变化，当底数为2时，单位为“比特”(bit)，底数为e时，单位为“奈特”。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:2:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"3.什么是相对熵？ 相对熵(relative entropy)又称为KL散度（Kullback-Leibler divergence），KL距离，是两个随机分布间距离的度量。记为$D_{KL}(p||q)$。它度量当真实分布为p时，假设分布$q$的无效性。 $$\\begin{split} \\ D_{KL}(p||q) \u0026= Ep[log \\frac {p(x)} {q(x)}] \\ \u0026=\\sum _{x∈X} p(x) log \\frac {p(x)} {q(x)} \\ \u0026=\\sum {x∈X}[p(x)logp(x)−p(x)logq(x)] \\ \u0026=\\sum{x∈X}p(x)logp(x)−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−H(p)−\\sum _{x∈X} p(x)logq(x) \\ \u0026=−H(p)+Ep[−logq(x)] \\ \u0026=Hp(q)−H(p)\\end{split}$$ 并且为了保证连续性，做如下约定： $$0log \\frac 0 0=0，0log \\frac 0 q=0，plog \\frac p 0=∞$$ 显然，当$p=q$时,两者之间的相对熵$D_{KL}(p||q)=0$ 上式最后的$H_p(q)$)表示在p分布下，使用q进行编码需要的bit数，而$H(p)$表示对真实分布p所需要的最小编码bit数。基于此，相对熵的意义就很明确了：$D_{KL}(p||q)$)表示在实分布为$p$的前提下，使用q分布进行编码相对于使用真实分布p进行编码（即最优编码）所多出来的bit数。 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:3:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["DeepLearning"],"content":"4. 什么是交叉熵？ 交叉熵容易跟相对熵搞混，二者联系紧密，但又有所区别。假设有两个分布$p，q$则它们在给定样本集上的交叉熵定义如下： $$ CEH(p,q)=Ep[−logq]=−∑\\limits_{x∈X}p(x)logq(x)=H(p)+D_{KL}(p||q) $$ 可以看出，交叉熵与上一节定义的相对熵仅相差了$H(p)$,当$p$已知时，可以把$H(p)$看做一个常数，此时交叉熵与KL距离在行为上是等价的，都反映了分布$p，q$的相似程度。最小化交叉熵等于最小化KL距离。它们都将在$p=q$时取得最小值$H(p)$（p=q时KL距离为0），因此有的工程文献中将最小化KL距离的方法称为Principle of Minimum Cross-Entropy (MCE)或Minxent方法。 特别的，在logistic regression中， p:真实样本分布，服从参数为p的0-1分布，即$X∼B(1,p)$ q:待估计的模型，服从参数为q的0-1分布，即$X∼B(1,q)$ 两者的交叉熵为： $$\\begin{split} CEH(p,q) \u0026=−\\sum _{x∈X}p(x)logq(x) \\ \u0026=−[P_p(x=1)logP_q(x=1)+P_p(x=0)logP_q(x=0)] \\ \u0026=−[plogq+(1−p)log(1−q)] \\ \u0026=−[ylogh_θ(x)+(1−y)log(1−h_θ(x))] \\ \\end{split}$$ 对所有训练样本取均值得： $$−\\frac 1 m \\sum \\limits^{m} \\limits _{i=1m} [y(i)logh_θ(x^{(i)})+(1−y^{(i)})log(1−h_θ(x^{(i)}))]$$ 这个结果与通过最大似然估计方法求出来的结果一致。 转载出处: 交叉熵（Cross-Entropy）_rtygbwwwerr的博客-CSDN博客 ","date":"2023-02-28","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/:4:0","tags":["DeepLearning"],"title":"什么是交叉熵","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%86%B5/"},{"categories":["Python"],"content":"强大的GAN网络 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:0:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"1. 概要 ​ GAN网络全称generative adversarial network,翻译为生成式对抗网络,是一种非监督式学习机器学习方法。由Ian J,Goodfello 等人于2014年在Generative Adversarial Nets 论文中提出。其中在GAN网络中,有两个模型——生成模型(generative model G),判别模型(discriminative model D). ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:1:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"2. 原理 ​ GAN网络主要运用了博弈论的思想,模型中的2为博弈方分别由生成模型和判别模型担当.生成模型用随机取样作为输入,它的输出结果要尽可能和训练样本尽可能相似,最好的情况就是分辨不出是真实样本还是生成出来的样本.而判别模型就是尽可能判别生成模型生成的结果和真实样本.这样2个网络相互对抗,不断调整参数,最终达到纳什均衡. 这个过程可以表示为: $$ min_G max_DV(D,G) = \\Epsilon_{x\\sim P_{data}(x)}[logD(x)] + \\Epsilon_{z\\sim p_{z}(z)}[log(1-D(G(z)))] $$ 公式解释: 1. 当训练D时,希望这个式子的值越大越好.真实数据希望被D分成1,生成数据希望被分成0\r2. 当训练G时,希望这个式子的值越小越好.希望D分不开真实数据还是生成数据\r零和博弈（zero-sum game），又称零和游戏，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。指参与博弈的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”，双方不存在合作的可能。就像下棋的游戏一样，你走的每一步和对方走的每一步都是向着对自己有利的方向走，然后你和对手轮流走步 每一步都向着自己最大可能能赢的地方走。这就是零和博弈。 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:2:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3. 简单代码实现 ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:0","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.1 导包 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:1","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.2 加载数据集 # 初始化tensorboard数据保存路径 writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:2","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.3 定义生成模型 class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:3","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.4 定义判别模型 class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:4","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.5 构造模型,定义损失和优化器 z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:5","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.6 训练判别器和生成器 def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:6","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.7 训练网络 epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_step=step) writer.close() ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:7","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.8 保存模型 torch.save(D, './model/discriminator.pt') torch.save(G, './model/generator.pt') ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:8","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"3.9 汇总代码 import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import DataLoader from torch import optim import torchvision from torchvision import transforms from torchinfo import summary from torch.utils.tensorboard import SummaryWriter import matplotlib.pyplot as plt writer = SummaryWriter('./logs') device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") batch_size = 32 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=(0.5, ), std=(0.5, ))]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, download=False, transform=transform) # 设置drop_last丢弃最后不满一个batch_size的数据 train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True, drop_last=True) class Generator(nn.Module): def __init__(self, g_input_dim, g_output_dim): super(Generator, self).__init__() self.fc1 = nn.Linear(g_input_dim, 256) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*2) self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.leaky_relu(self.fc2(x), 0.2) x = F.leaky_relu(self.fc3(x), 0.2) return torch.tanh(self.fc4(x)) class Discriminator(nn.Module): def __init__(self, d_input_dim): super(Discriminator, self).__init__() self.fc1 = nn.Linear(d_input_dim, 1024) self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//2) self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//2) self.fc4 = nn.Linear(self.fc3.out_features, 1) # forward method def forward(self, x): x = F.leaky_relu(self.fc1(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc2(x), 0.2) x = F.dropout(x, 0.3) x = F.leaky_relu(self.fc3(x), 0.2) x = F.dropout(x, 0.3) return torch.sigmoid(self.fc4(x)) z_dim = 100 mnist_dim = train_dataset.train_data.size(1) * train_dataset.train_data.size(2) # build network G = Generator(g_input_dim = z_dim, g_output_dim = mnist_dim).to(device) D = Discriminator(mnist_dim).to(device) # 添加网络图到tensorboard writer.add_graph(G, input_to_model=torch.randn(batch_size, z_dim)) writer.add_graph(D, input_to_model=torch.randn(batch_size, mnist_dim)) # optimizer lr = 0.0002 g_optimizer = optim.Adam(G.parameters(), lr = lr) d_optimizer = optim.Adam(D.parameters(), lr = lr) # loss criterion = nn.BCELoss() def d_train(x): D.zero_grad() x_real, y_real = x.view(-1, mnist_dim).to(device), torch.ones(batch_size, 1).to(device) print(x_real.shape, y_real.shape) d_output = D(x_real) print(d_output.shape, y_real.shape) d_real_loss = criterion(d_output, y_real) d_real_score = d_output z = torch.randn(batch_size, z_dim).to(device) x_fake, y_fake = G(z), torch.zeros(batch_size, 1).to(device) d_output = D(x_fake) d_fake_loss = criterion(d_output, y_fake) d_fake_score = d_output d_loss = d_real_loss + d_fake_loss d_loss.backward() d_optimizer.step() return d_loss.item() def g_train(x): G.zero_grad() z = torch.randn(batch_size, z_dim).to(device) y = torch.ones(batch_size, 1).to(device) g_output = G(z) d_output = D(g_output) g_loss = criterion(d_output, y) g_loss.backward() g_optimizer.step() return g_loss.item() epochs = 10 step = 0 for epoch in range(epochs): d_losses, g_losses = [], [] for batch_idx, (x, _) in enumerate(train_loader): step += 1 d_losses.append(d_train(x)) g_losses.append(g_train(x)) print('[%d/%d]: [%d/%d]: loss_d: %.3f, loss_g: %.3f' % ( epoch, epochs,batch_idx, len(train_loader), torch.mean(torch.FloatTensor(d_losses)), torch.mean(torch.FloatTensor(g_losses)))) writer.add_scalar('g_loss', torch.mean(torch.FloatTensor(g_losses)), step) writer.add_scalar('d_loss', torch.mean(torch.FloatTensor(d_losses)), step) if batch_idx % 10 == 0: with torch.no_grad(): test_z = torch.randn(batch_size, z_dim).to(device) generated = G(test_z) img = img = torchvision.utils.make_grid(generated.view(generated.size(0), 1, 28, 28)) writer.add_image(f'mnist_{epoch}_{batch_idx}', img, global_","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:9","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Python"],"content":"参考资料: GAN入门理解及公式推导 - 知乎 (zhihu.com) lyeoni/pytorch-mnist-GAN (github.com) ","date":"2023-02-25","objectID":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/:3:10","tags":["deeplearning","gan"],"title":"强大的GAN网络","uri":"/%E5%BC%BA%E5%A4%A7%E7%9A%84gan%E7%BD%91%E7%BB%9C/"},{"categories":["Markdown"],"content":"Markdown使用mermaid ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:0:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"0. 符号表示 类元素的可见范围 可见范围 表示方法 private - public + protected # package ~ 类的修饰 符号 类型 \u003c\u003cInterface\u003e\u003e 接口 \u003c\u003cabstract\u003e\u003e 抽象类 \u003c\u003cService\u003e\u003e service类 \u003c\u003cenumeration\u003e\u003e 枚举 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:1:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"1. 泛化 定义: 表示继承关系(子类和父类). 表示:三角实线,指向父类. classDiagram class Animal{ -age: int +sleep(): void } class Dog Animal \u003c|-- Dog ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:2:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"2. 实现 定义: 表示类和接口之间的关系. 表示: 三角虚线,指向接口. classDiagram class Person { + say(): void } class Man Person \u003c|.. Man ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:3:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"3. 组合 定义: 整体与局部的关系,部分不能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 实心菱形实线,实心菱形指向整体. 代码体现: 成员变量 classDiagram class Person{ -brain } class Brain { - weight } Person *-- Brain ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:4:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"4. 聚合 定义: 整体与局部的关系,部分能离开整体单独存在,称为强聚合,属于关联关系的一种. 表示: 空心菱形实线,空心菱形指向整体. 代码体现: 成员变量 classDiagram class Computer { -keyboard } class Keyboard { -type } Computer o-- Keyboard ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:5:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"5. 关联 定义: 一种拥有的关系, 使一个类知道另一个类的属性和方法,关联可以是单向的,也可以是双向的.双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头. 表示: 普通箭头的实心线,指向被拥有者. 代码体现: 成员变量 classDiagram class Teacher { -students: List\u003cStudent\u003e +teach(): void } class Student { -teacher: List\u003cTeacher\u003e +learn(): void } Teacher \u003c--\u003e Student ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:6:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"6. 依赖 定义: 一种使用关系. 表示: 普通箭头的虚线,箭头指向被使用者 代码体现: 局部变量, 方法的形参, 方法返回值静态方法的调用 classDiagram class Person { +draw(tool: DrawTool): void } class DrawTool { -color } Person \u003c.. DrawTool ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:7:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Markdown"],"content":"7. 各种关系强弱顺序 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 ","date":"2023-02-19","objectID":"/markdown%E4%BD%BF%E7%94%A8mermaid/:8:0","tags":["markdown","mermaid"],"title":"Markdown使用mermaid","uri":"/markdown%E4%BD%BF%E7%94%A8mermaid/"},{"categories":["Git","Windows"],"content":"Git for Windows 安装 Pacman ","date":"2022-12-24","objectID":"/git_for_windows/:0:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"1. 下载必要压缩包 curl -o pacman-6.0.1-9-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-6.0.1-9-x86_64.pkg.tar.zst curl -o pacman-mirrors-20221016-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/pacman-mirrors-20221016-1-any.pkg.tar.zst curl -o msys2-keyring-1~20221024-1-any.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/msys2-keyring-1~20221024-1-any.pkg.tar.zst # 正常来说只需要上面三个包但是由于缺少 zstd 解压工具还需要 zstd 包 curl -o zstd-1.5.2-2-x86_64.pkg.tar.zst -L https://repo.msys2.org/msys/x86_64/zstd-1.5.2-2-x86_64.pkg.tar.zst # 但是又因为 zstd 包也是 zstd 打包又需要另一个不是 zstd 打包的解压工具来解压 curl -o zstd-v1.5.2-win64.zip -L https://github.com/facebook/zstd/releases/download/v1.5.2/zstd-v1.5.2-win64.zip ","date":"2022-12-24","objectID":"/git_for_windows/:1:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"2 .解压并安装: unzip zstd-v1.5.2-win64.zip \"zstd-v1.5.2-win64/zstd.exe\" -d . ./zstd-v1.5.2-win64/zstd.exe -d -o zstd-1.5.2-2-x86_64.pkg.tar zstd-1.5.2-2-x86_64.pkg.tar.zst tar -xvf zstd-1.5.2-2-x86_64.pkg.tar -C / tar -xvf msys2-keyring-1~20221024-1-any.pkg.tar.zst -C / tar -xvf pacman-mirrors-20221016-1-any.pkg.tar.zst -C / tar -xvf pacman-6.0.1-9-x86_64.pkg.tar.zst -C / ","date":"2022-12-24","objectID":"/git_for_windows/:2:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"3. 添加密钥并更新数据库: pacman-key --init \u0026\u0026 pacman-key --populate msys2 pacman-db-upgrade -r /../ pacman -Sy ","date":"2022-12-24","objectID":"/git_for_windows/:3:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"4. 更新元数据: # pacman -S pacman-mirrors-20221016-1 msys2-keyring-1~20221024-1 zstd-1.5.2-2 # pacman -S $(cut -d ' ' -f 1 /etc/package-versions.txt) URL=https://github.com/git-for-windows/git-sdk-64/raw/main cat /etc/package-versions.txt | while read p v; do d=/var/lib/pacman/local/$p-$v mkdir -p $d for f in desc files install mtree; do echo \"$URL$d/$f\" ..... $d/$f curl -sSL \"$URL$d/$f\" -o $d/$f done done curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/desc -o /var/lib/pacman/local/pacman-6.0.1-9/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/files -o /var/lib/pacman/local/pacman-6.0.1-9/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/install -o /var/lib/pacman/local/pacman-6.0.1-9/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-6.0.1-9/mtree -o /var/lib/pacman/local/pacman-6.0.1-9/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/desc -o /var/lib/pacman/local/pacman-mirrors-20221016-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/files -o /var/lib/pacman/local/pacman-mirrors-20221016-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/install -o /var/lib/pacman/local/pacman-mirrors-20221016-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/pacman-mirrors-20221016-1/mtree -o /var/lib/pacman/local/pacman-mirrors-20221016-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/desc -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/files -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/install -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/msys2-keyring-1~20221024-1/mtree -o /var/lib/pacman/local/msys2-keyring-1~20221024-1/mtree curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/desc -o /var/lib/pacman/local/zstd-1.5.2-2/desc curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/files -o /var/lib/pacman/local/zstd-1.5.2-2/files curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/install -o /var/lib/pacman/local/zstd-1.5.2-2/install curl -sSL https://github.com/git-for-windows/git-sdk-64/raw/main/zstd-1.5.2-2/mtree -o /var/lib/pacman/local/zstd-1.5.2-2/mtree ","date":"2022-12-24","objectID":"/git_for_windows/:4:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 安装Fish Shell ","date":"2022-12-24","objectID":"/git_for_windows/:5:0","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.1 安装必要依赖 pacman -S gcc-libs ","date":"2022-12-24","objectID":"/git_for_windows/:5:1","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.2 安装Fish Shell并启动 pacman -S fish ","date":"2022-12-24","objectID":"/git_for_windows/:5:2","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.3 启动Fish Shell # 在~/.bashrc文件中添加以下内容，设置默认shell为fish if [ -t 1 ]; then exec fish fi ","date":"2022-12-24","objectID":"/git_for_windows/:5:3","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5.4 更换Fish Shell 主题 fish_config ","date":"2022-12-24","objectID":"/git_for_windows/:5:4","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Git","Windows"],"content":"5. 5 Fish Shell 常用命令和基本设置 # 关闭问候语 set -g -x fish_greeting '' set -U fish_greeting # 设置环境变量 #在最后一行加入(注意目录间用空格隔开) set -x PATH /opt/demo/bin /home/guest/bin $PATH # 删除变量 set -e Foo # 配置别名 # Define alias in config file alias rmi=\"rm -i\" # 切换默认shell，git for windows下不可用 echo $SHELL cat /etc/shells chsh -s /usr/bin/fish # 命令替换 echo (date) # 在bash下面 # echo `date` 参考资料: pacman常用命令-昨夜星辰 (hustlei.github.io) Install inside MSYS2 proper · git-for-windows/git Wiki (github.com) Git:給 git for windows 裝個翅膀 (安裝 pacman 及其他工具) @ 傑克! 真是太神奇了! :: 痞客邦 :: (pixnet.net) 在 Windows 的 Git Bash 中使用包管理器 - iris (ginshio.org) Index of /msys/x86_64/ (msys2.org) Releases · facebook/zstd (github.com) Windows 的终端配置(给 git-windows 添加 msys2 包管理器) - zeromake 的个人博客 MSYS2 和 mintty 打造 Windows 下 Linux 工具体验 - Creaink - Build something for life Using fish shell with git bash on windows (github.com) Package management in Git for Windows (Git Bash)? - Stack Overflow Fish Shell | 安装配置指南 - URmyLucky - 博客园 (cnblogs.com) ","date":"2022-12-24","objectID":"/git_for_windows/:5:5","tags":["git","pacman","msys2"],"title":"Git for Windows 安装 Pacman","uri":"/git_for_windows/"},{"categories":["Rust"],"content":"Rust偏僻知识点 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Cow(Clone on Write) 两个可选值： Borrowed，用于包裹对象的引用（通用引用）； Owned，用于包裹对象的所有者； Cow 提供 对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）； 如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，Cow 提供方法做克隆处理，并避免多次重复克隆。 Cow 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 Cow，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。 它有以下几个要点需要掌握： Cow\u003cT\u003e 能直接调用 T 的不可变方法，因为 Cow 这个枚举，实现了 Deref； 在需要写 T 的时候，可以使用 .to_mut() 方法得到一个具有所有权的值的可变借用；注意，调用 .to_mut() 不一定会产生克隆； 在已经具有所有权的情况下，调用 .to_mut() 有效，但是不会产生新的克隆； 多次调用 .to_mut() 只会产生一次克隆。 在需要写 T 的时候，可以使用 .into_owned() 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象； 如果之前 Cow 中的值是借用状态，调用此操作将执行克隆； 本方法，参数是self类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 Cow 上不能调用多次； 举例:写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。 use std::borrow::Cow; fn remove_spaces\u003c'a\u003e(input: \u0026'a str) -\u003e Cow\u003c'a, str\u003e { if input.contains(' ') { let mut buf = String::with_capacity(input.len()); for c in input.chars() { if c != ' ' { buf.push(c); } } return Cow::Owned(buf); } return Cow::Borrowed(input); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"HRTBS(Higher-Ranked Trait Bounds) HRTBS主要用于解决函数参数含有闭包,并且闭包参数含有引用 语法:for\u003c‘a\u003e T: Trait\u003c‘a\u003e 例如如下代码实际是不能编译通过的,因为编译器不能推断出返回哪个引用 fn call_on_ref_zero\u003cF\u003e(f: F) where F: Fn(\u0026i32, \u0026i32) -\u003e \u0026i32 { let zero = 0; f(\u0026zero, \u0026zero); } 尝试添加生命周期参数,还是不能通过编译,因为zero变量的生命周期是短于’a的. fn call_on_ref_zero\u003c'a, F\u003e(f: F) where F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 我们尝试使用HRTBS试试 fn call_on_ref_zero\u003cF\u003e(f: F) where for\u003c'a\u003e F: Fn(\u0026'a i32, \u0026'a i32) -\u003e \u0026'a i32 { let zero = 0; f(\u0026zero, \u0026zero); } 另一个例子 fn foo\u003c'b, F\u003e(f: F) -\u003e \u0026'b str where for\u003c'a\u003e F: Fn(\u0026'a str) -\u003e \u0026'a str, { let s = \"hello\"; f(s) } fn bar(s: \u0026str) -\u003e \u0026str { \u0026s[..1] } fn main() { let s = foo(bar); println!(\"{s}\"); } 最后一个例子: fn foo\u003c'a\u003e(f: Box\u003cdyn Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 第一次调用 f(\u0026x) 时生命周期 'a 等于变量 x 的生命周期；而在第二次调用 f(\u0026y) 时，生命周期 'a 又等于了变量 y 的生命周期；而变量 x 和变量 y 的生命周期显然是不同的。因此无法用一个静态的生命周期来描述 'a ，我们希望的是，闭包 f 在具体调用时绑定具体的生命周期，比如调用 f(\u0026x) 时绑定的是 x 的生命周期，而调用 f(\u0026y) 时绑定的是 y 的生命周期。 使用HRTBS修改如下: fn foo(f: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a i32)\u003e) { let x = 1; f(\u0026x); { let y = 2; f(\u0026y); } } 这样生命周期 'a 就不再是静态的了，他会随着闭包 f 的调用绑定到不同的生命周期：f(\u0026x) 调用时绑定到 x 的生命周期，f(\u0026y) 调用时绑定到 y 的生命周期。 ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"PhantomData PhantomData主要用于无界生命周期(unbounded lifetime)或者需要drop struct非自身字段,例如: use std::marker: struct Vec\u003cT\u003e { data: *const T, // *const是可变的！ len: usize, cap: usize, _marker: marker::PhantomData\u003cT\u003e, } PhantomData模式表 Phantom 类型 'a 'T PhantomData\u003cT\u003e - 协变（可触发drop检查） PhantomData\u003c\u0026'a T\u003e 协变 协变 PhantomData\u003c\u0026'a mut T\u003e 协变 不变 PhantomData\u003c*const T\u003e - 协变 PhantomData\u003c*mut T\u003e - 不变 PhantomData\u003cfn(T)\u003e - 逆变(*) PhantomData\u003cfn() -\u003e T\u003e - 协变 PhantomData\u003cfn(T) -\u003e T\u003e - 不变 PhantomData\u003cCell\u003c\u0026'a ()\u003e\u003e 不变 - (*)如果发生变性的冲突，这个是不变的 我们可以使用泛型结构体来实现对同一种类对象不同子类对象的区分，例如，我们的系统中要设计这样一个功能，将用户分为免费用户和付费用户，而且免费用户在体验免费功能之后，如果想升级成付费用户也是可以的。按照我们常规的思维，可能是定义两个结构体 FreeCustomer 以及 PaidCustomer，但是我们可以通过泛型结构体来实现，例如： struct Customer\u003cT\u003e { id: u64, name: String, } 不过，我们这里的 T 又无处安放，所以又不得不使用 PhantomData，它就像一个占位符，但是又没有大小，可以为我们持有在声明时使用不到的数据： use std::{ marker::PhantomData, sync::atomic::{self, AtomicU64}, }; static NEXT_ID: AtomicU64 = AtomicU64::new(0); struct Customer\u003cT\u003e { id: u64, name: String, phantom: PhantomData\u003cT\u003e, } struct FreeFeature; struct PaidFeature; trait Free { fn feature1(\u0026self); fn feature2(\u0026self); } trait Paid: Free { fn paid_feature(\u0026self); } /// 为 Customer\u003cT\u003e 实现需要的方法 impl\u003cT\u003e Customer\u003cT\u003e { fn new(name: String) -\u003e Self { Self { id: NEXT_ID.fetch_add(1, atomic::Ordering::Relaxed), name, phantom: PhantomData, } } } /// 免费用户可以升级到付费用户 impl Customer\u003cFreeFeature\u003e { fn advance(self, payment: f64) -\u003e Customer\u003cPaidFeature\u003e { println!( \"{}（{}） 将花费 {:.2} 元升级到付费用户\", self.name, self.id, payment ); self.into() } } /// 所有客户都有权使用免费功能 impl\u003cT\u003e Free for Customer\u003cT\u003e { fn feature1(\u0026self) { println!(\"{} 正在使用免费功能一\", self.name) } fn feature2(\u0026self) { println!(\"{} 正在使用免费功能二\", self.name) } } /// 付费用户才能使用的功能 impl Paid for Customer\u003cPaidFeature\u003e { fn paid_feature(\u0026self) { println!(\"{} 正在使用付费功能\", self.name) } } /// 允许使用免费用户转换成付费用户 impl From\u003cCustomer\u003cFreeFeature\u003e\u003e for Customer\u003cPaidFeature\u003e { fn from(c: Customer\u003cFreeFeature\u003e) -\u003e Self { Self::new(c.name) } } #[cfg(test)] mod tests { use super::*; #[test] fn test_customer() { // 一开始是免费用户 let customer = Customer::\u003cFreeFeature\u003e::new(\"MichaelFu\".to_owned()); customer.feature1(); customer.feature2(); // 升级成付费用户，可能使用付费功能和普通功能 let customer = customer.advance(99.99); customer.feature1(); customer.feature2(); customer.paid_feature(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Thread_local thread_local是一种将数据存储到全局变量中的方法，程序中的每个线程都有自己的副本。线程不共享这个数据，所以访问不需要同步,thread_local中声明的变量，在线程结束后会被释放，比如如果有10个线程中使用了该thread_local变量,则这10个线程结束时将有10个该类型的变量被释放。这适用于thread_per_core架构的异步运行时(类似于nginx),而不是tokio这种work-stealing scheduler(任务窃取). 举个例子: use std::borrow::Cow; use std::cell::RefCell; use std::thread; fn main() { thread_local!(static FOO: RefCell\u003cu32\u003e = RefCell::new(1)); FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 2; }); // 每个线程开始时都会拿到线程局部变量的FOO的初始值 let t = thread::spawn(move || { FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 3; }); }); // 等待线程完成 t.join().unwrap(); // 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2 FOO.with(|f| { assert_eq!(*f.borrow(), 2); }); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"Barrier(线程屏障) 使用 Barrier 让多个线程都执行到某个点后，才继续一起往后执行： use std::sync::{Arc, Barrier}; use std::thread; fn main() { let mut handles = Vec::with_capacity(5); let barrier = Arc::new(Barrier::new(5)); for _ in 0..5 { let b = barrier.clone(); handles.push(thread::spawn(move|| { println!(\"before wait\"); b.wait(); println!(\"after wait\"); })); } for handle in handles { handle.join().unwrap(); } } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"once_cell和lazy_static once_cell 和 lazy_static 都是 Rust 中用于实现单例模式（Singleton）的库。 once_cell 适用于程序初始化加载配置文件这种场景 LazyCell和LazyLock适用于初始化某个变量,比如说正则的compile,数据库连接等场景. #![feature(once_cell)] use std::cell; use std::collections::HashMap; use std::sync; use std::sync::Once; static INIT: Once = sync::Once::new(); static mut SUM: u64 = 0; fn init_sum() -\u003e u64 { unsafe { INIT.call_once(|| { println!(\"this is first init\"); SUM = (1..100000).sum(); }); SUM } } fn main() { let split_line = \"*\".repeat(100); let first_result = init_sum(); println!(\"first result: {first_result}\"); let second_result = init_sum(); println!(\"second result: {second_result}\"); println!(\"{split_line}\"); let once = cell::OnceCell::\u003cHashMap\u003c\u0026str, \u0026str\u003e\u003e::new(); let dict = once.get_or_init(|| { println!(\"this is hash map init once\"); let mut map = HashMap::new(); map.insert(\"lang\", \"rust\"); map.insert(\"edition\", \"2021\"); map }); println!(\"once dict: {dict:?}\"); let dict_twice = once.get_or_init(|| { println!(\"this is hash map init twice\"); let mut map = HashMap::new(); map.insert(\"lang\", \"python\"); map.insert(\"version\", \"1.10\"); map }); println!(\"twice dict: {dict_twice:?}\"); println!(\"{split_line}\"); let lazy_init = cell::LazyCell::new(|| env!(\"PATH\")); println!(\"lazy_init: {}\", *lazy_init); // thread safe lazy cell let lazy_init_safe = sync::LazyLock::new(|| env!(\"PATH\")); print!(\"lazy_init_safe: {}\", *lazy_init_safe); } ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"impl A and T: A 在 impl 中被声明的类型参数，至少要满足下面三种形式： impl Foo， T 出现在实现的Self 类型Foo 中 。 impl SomeTrait for Foo ， T出现在要实现的 trait 中 。 impl\u003cT, U\u003e SomeTrait for T where T: AnotherTrait\u003cAssocType=U\u003e ， 出现在 T 的 trait 限定的关联类型中。 参考资料: 【Rust】幽灵数据（PhantomData） | MichaelFu (fudenglong.site) 3.10 PhantomData（幽灵数据） | 第三章、所有权 |《Rust 高级编程 2018》| Rust 技术论坛 (learnku.com) Rust高阶生命周期绑定 (xiaopengli89.github.io) ","date":"2022-12-13","objectID":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":["Rust"],"title":"Rust偏僻知识点","uri":"/rust%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["c/c++"],"content":"cmake简易教程 ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"1. 添加头文件目录INCLUDE_DIRECTORIES 它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。 语法： include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"2. 添加需要链接的库文件目录LINK_DIRECTORIES 语法： link_directories(directory1 directory2 ...) 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。 link_directories(\"/home/server/third/lib\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"3. 添加需要链接的库文件路径LINK_LIBRARIES 语法： link_libraries(library1 \u003cdebug | optimized\u003e library2 ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"4. 设置要链接的库文件的名称TARGET_LINK_LIBRARIES 语法： target_link_libraries(\u003ctarget\u003e [item1 [item2 [...]]] [[debug|optimized|general] \u003citem\u003e] ...) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"5. 查找库所在目录FIND_LIBRARY 语法： find_library (\u003cVAR\u003e name1 [path1 path2 ...]) find_library ( \u003cVAR\u003e name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \"cache documentation string\"] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 例子如下： FIND_LIBRARY(RUNTIME_LIB rt /usr/lib /usr/local/lib NO_DEFAULT_PATH) cmake会在目录中查找，如果所有目录中都没有，值RUNTIME_LIB就会被赋为NO_DEFAULT_PATH ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:5:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"6. 查找源文件和头文件 # 查找指定目录下的所有.cpp与.h文件 并存放到指定变量名SC_FILES中 FILE(GLOB SC_FILES \"*.cpp\" \"*.h\") ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:6:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["c/c++"],"content":"7. 添加源文件目录 使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。 语法： aux_source_directory(\u003cdir\u003e \u003cvariable\u003e) # 生成链接库 add_library (MathFunctions ${DIR_LIB_SRCS}) 参考链接： cmake 添加头文件目录，链接动态、静态库 - 王彬彬 - 博客园 (cnblogs.com) ","date":"2022-12-10","objectID":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:7:0","tags":["cmake"],"title":"Cmake简易教程","uri":"/cmake%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"opencv实现抠图和裁剪 ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:0:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"1. 抠图 步骤: 加载图像 转换图像格式(BGR –\u003e HSV) 设置阈值 通过阈值提取部分区域 显示图片 关于HSV可参考：HSL和HSV色彩空间 - 维基百科，自由的百科全书 (wikipedia.org) window_name = 'hsv' img = cv2.imread(r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\") # 设置高低阈值 hsv_low = np.array([0, 0, 0]) hsv_high = np.array([134, 255, 138]) # 将BGR转为HSV dst = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 通过HSV的高低阈值，提取图像部分区域 mask_img = cv2.inRange(dst, hsv_low, hsv_high) # 进行与位运算 img_ = cv2.bitwise_and(img, img, mask=mask_img) cv2.imshow(window_name, img_) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:1:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Python"],"content":"2. 裁剪图片 步骤 加载图像 设置鼠标事件 - 鼠标左键单击画点\r- 鼠标右键单击闭合所画的点\r- 鼠标右键双击填充 # 触发鼠标移动事件 # cv2.CV_EVENT_MOUSEMOVE # 触发左键抬起事件 # cv2.CV_EVENT_LBUTTONUP # 触发右键按下事件 # cv2.CV_EVENT_RBUTTONDOWN # 触发右键抬起事件 # cv2.CV_EVENT_RBUTTONUP # 触发左键双击事件 # cv2.CV_EVENT_LBUTTONDBLCLK # 触发右键双击事件 # cv2.CV_EVENT_RBUTTONDBLCLK coordinates = [] window_name = 'draw' def on_mouse_callback(event, x, y, flag, param): # 左键点击,画点 if event == cv2.EVENT_LBUTTONDOWN: xy = f'{x},{y}' coordinates.append((x, y)) cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1) cv2.putText(img, xy, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness=1) cv2.imshow(window_name, img) # 右键单击，画不规则图形 elif event == cv2.EVENT_RBUTTONDOWN: pts = np.array(coordinates, np.int32) # 顶点集 #顶点坐标转为rowsx1x2, row为顶点数 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (255, 255, 255), 2) cv2.imshow(window_name, img) # 右键双击，填充颜色 elif event == cv2.EVENT_RBUTTONDBLCLK: area = np.array(coordinates) # 可以绘制多个图形 cv2.fillPoly(img, [area], (255, 255, 255)) # 绘制凸多边形 # cv2.fillConvexPoly(img, area, (255, 255, 255)) cv2.imshow(window_name, img) coordinates.clear() cv2.namedWindow(window_name) cv2.setMouseCallback(window_name, on_mouse_callback) cv2.imshow(window_name, img) cv2.waitKey(0) cv2.destroyAllWindows() Rust版opencv实现抠图 Cargo.toml [dependencies] opencv = { version = \"0.71\" } src/main.rs use opencv::{ core::{bitwise_and, in_range, Vector, CV_8UC3}, highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, imgproc::{cvt_color, COLOR_BGR2HSV}, prelude::*, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img = imread( r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\", ImreadModes::IMREAD_COLOR as i32, )?; unsafe { let mut lowerb = Vector::from_slice(\u0026[0, 0, 0u8]); let mut upperb = Vector::from_slice(\u0026[134, 255, 138u8]); let mut dst = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut mask_img = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; let mut result = Mat::new_nd(img.dims(), \u0026img.size().unwrap().width, CV_8UC3)?; cvt_color(\u0026img, \u0026mut dst, COLOR_BGR2HSV, 0)?; in_range(\u0026img, \u0026mut lowerb, \u0026mut upperb, \u0026mut mask_img)?; bitwise_and(\u0026img, \u0026img, \u0026mut result, \u0026mask_img)?; imshow(\"winname\", \u0026result)?; } wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/:2:0","tags":["opencv"],"title":"Opencv抠图和裁剪图片","uri":"/opencv%E6%8A%A0%E5%9B%BE%E5%92%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/"},{"categories":["Rust"],"content":"Rust中使用opencv 因为在macos和linux上安装比较简单，这里只介绍windows上的安装 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:0:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"安装环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 安装opencv 下载地址：Releases - OpenCV 选择windows平台，下载后默认安装即可 设置环境变量 OPENCV_INCLUDE_PATHS OPENCV_LINK_LIBS OPENCV_LINK_PATHS 注意：opencv_world460这个不是固定的，需要根据下载的具体版本设置，我的版本中位于D:\\development\\opencv\\build\\x64\\vc15\\bin目录 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 安装LLVM 下载地址：Releases · llvm/llvm-project (github.com) 根据需要安装32位或者64位，有些版本可能没有这2个选项，可以选择以前的版本，没必要选择最新的版本。下载后默认安装即可，注意需要在添加LLVM到环境变量中 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:1:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"简单使用 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:0","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"1. 确保安装了Rust环境 ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:1","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"2. 新建项目 cargo new opencv-rust-test ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:2","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"3. 配置Cargo.toml文件 [dependencies] opencv = { version = \"0.71\" } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:3","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"4. 将opencv_world460.dll文件拷贝到项目根目录(重要！！！) 如果opencv_world460.dll路径添加到环境变量中，应该就不需要将文件拷贝(没有实际测试) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:4","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"5. 编写代码测试环境是否正常 src/main.rs use opencv::{ highgui::{destroy_all_windows, imshow, wait_key}, imgcodecs::{imread, ImreadModes}, }; fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let img_path = r\"D:\\picture\\other\\2E3246E873376135DC6F202D1456B37E.jpg\"; let img = imread(img_path, ImreadModes::IMREAD_COLOR as i32)?; imshow(\"winname\", \u0026img)?; wait_key(0)?; destroy_all_windows()?; Ok(()) } ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:5","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"6. 运行测试 # 使用cargo命令运行看看是否正常显示图片 cargo run ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:6","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Rust"],"content":"7. 报错解决 主要参考官方文档： twistedfall/opencv-rust: Rust bindings for OpenCV 3 \u0026 4 (github.com) ","date":"2022-12-04","objectID":"/rust%E4%BD%BF%E7%94%A8opencv/:2:7","tags":["opencv"],"title":"Rust使用opencv","uri":"/rust%E4%BD%BF%E7%94%A8opencv/"},{"categories":["Linux"],"content":"管道 ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:0:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"匿名管道(Pipe) 特点 半双工 只能用于具有亲缘关系进程(父子，兄弟) 可以视作特殊文件，读写可以使用write，read函数 #include\"stdio.h\" #include\"unistd.h\" // https://learnku.com/articles/44477 // **特点** // 1. 半双工 // 2. 只能用于具有亲缘关系进程(父子，兄弟) // 3. 可以视作特殊文件，读写可以使用write，read函数 int main() { int fd[2]; pid_t pid; char buf[32]; //创建管道 if (pipe(fd) \u003c 0) { printf(\"Create Pipe Error \\n\"); } //创建子进程 if ((pid = fork()) \u003c 0) { printf(\"Fork Error \\n\"); } else if (pid \u003e 0) { close(fd[0]); // 关闭父进程读端 write(fd[1], \"hello world\", 8); //父进程写端写入 } else { close(fd[1]); // 关闭子进程写端 read(fd[0], buf, 8); // 子进程读取父进程消息 printf(\"Child Recv Msg: %s\", buf); } } ","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:1:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Linux"],"content":"命名管道(FIFO) 特点 和匿名管道不同，FIFO可以在无关进程间通信 FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 fifo_read.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"errno.h\" #include\"fcntl.h\" #include\"sys/stat.h\" int main() { int fd; int len; char buf[1024]; if (mkfifo(\"/home\", 0666) \u003c 0 \u0026\u0026 errno != EEXIST) { perror(\"Create FIFO Failed\"); } if ((fd = open(\"/home\", O_RDONLY)) \u003c 0) { perror(\"Open FIFO Failed\"); exit(1); } while ((len = read(fd, buf, 1024)) \u003e 0) { printf(\"Read Message: %s\", buf); } close(fd); return 0; } fifo_write.c #include\"stdio.h\" #include\"unistd.h\" #include\"stdlib.h\" #include\"fcntl.h\" // O_WRONLY #include\"sys/stat.h\" #include\"time.h\" // ## 命名管道(FIFO) // ** 特点** // 1. 和匿名管道不同，FIFO可以在无关进程间通信 // 2. FIFO有路径名与之关联，以一种特殊文件形式存在于文件系统中 int main() { int fd; int n, i; char buf[1024]; time_t tp; printf(\"Parent Process PID:\", getpid()); if ((fd = open(\"/home\", O_WRONLY)) \u003c 0) { // 写模式打开FIFO perror(\"Open FIFO Failed\"); exit(1); } for (i = 0; i \u003c 10; ++i) { time(\u0026tp);// 当前系统时间 n = sprintf(buf, \"Process %d's time is %s\", getpid(), ctime(\u0026tp)); printf(\"Send message: %s\", buf); // 写入数据到FIFO中 if (write(fd, buf, n + 1) \u003c 0) { perror(\"Write FIFO Failed\"); close(fd); exit(1); } sleep(1); } close(fd); return 0; } 消息队列 特点 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。 msg_client.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // key值不变，要么确保ftok()的文件不被删除，要么不用ftok()，指定一个固定的key值。 // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } printf(\"Message Queue - Client key is: %d.\\n\", key); // 打开消息队列 if ((msqid = msgget(key, IPC_CREAT | 0777)) == -1) { perror(\"msgget error\"); exit(1); } // 打印消息队列ID和进程ID printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); // 添加消息，类型为888 msg.mtype = 888; sprintf(msg.mtext, \"hello, I'm client %d\", getpid()); //msgid是由msgget函数返回的消息队列标识符。 // __msgp是一个指向准备发送消息的指针，消息的数据结构却有一定的要求， // 指针msg_ptr所指向的消息结构一定要是以一个**长整型**成员变量开始的结构体，接收函数将用这个成员来确定消息的类型 msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); // msgrcv函数type参数有以下几种可能： // type == 0，返回队列中的第一个消息； // type \u003e 0，返回队列中消息类型为 type 的第一个消息； // type \u003c 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。 // 读取类型为999的消息 msgrcv(msqid, \u0026msg, 256, 999, 0); printf(\"Client: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Client: receive msg.mtype is: %d.\\n\", msg.mtype); } msg_server.c #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/msg.h\" #define MSG_FILE \"/etc/passwd\" // 结构体第一个字段一定为长整型 struct msg_from { long mtype; char mtext[256]; }; int main() { int msqid; key_t key; struct msg_from msg; // 获取key值 if ((key = ftok(MSG_FILE, 'z')) \u003c 0) { perror(\"ftok error\"); exit(1); } // 打印key值 printf(\"Message Queue - Server key is: %d.\\n\", key); // 创建消息队列 if ((msqid = msgget(key, IPC_CREAT | 0700)) == -1) { perror(\"msgget error\"); exit(1); } printf(\"My msqid is: %d.\\n\", msqid); printf(\"My pid is: %d.\\n\", getpid()); for (;;) { // 返回类型为888的第一个消息 msgrcv(msqid, \u0026msg, 256, 888, 0); printf(\"Server: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Server: receive msg.mtype is: %d.\\n\", msg.mtype); msg.mtype = 999; sprintf(msg.mtext, \"hello, I'm server %d\", getpid()); msgsnd(msqid, \u0026msg, sizeof(msg.mtext), 0); } return 0; } 信号量 特点 是一个计数器 用于实现进程间互斥和同步,不是存储进程间通信数据 示例 #include\"stdio.h\" #include\"stdlib.h\" #include\"unistd.h\" #include\"sys/sem.h\" union semun { int val; struct semid_ds* buf; unsigned short* array; }; int init_sem(int sem_id, int value) { union semun tmp; tmp.val = value; if (semctl(sem_id, 0, SETVAL, tmp) == -1) { perror(\"Init Semaphore Error\"); return -1; } return 0; } // p操作 // 若信号量值为1，获取资源并将信号值置为-1 // 若信号量值为0，进程挂起等待 int sem_p(int sem_id) { struct sembuf sbuf; sbuf.sem_num = 0; // 序号 sbuf.sem_op = -1; // 操作 sbuf.sem_flg = SEM_UNDO; if (semop(sem_id, \u0026sbuf, 1) == -1) { perror(\"P operation Error\"); return -","date":"2022-11-20","objectID":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/:2:0","tags":["ipc"],"title":"Linux进程间通信","uri":"/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"categories":["Python"],"content":"索引 import pandas as pd import numpy as np df = pd.DataFrame(np.arange(50).reshape(-1, 5), columns=list('abcde')) # 根据列标签索引 df['a'] # 或者 df.loc[:,'a'] # 根据列索引 df.iloc[:, 0] # df['a'] == df.loc[:,'a'] == df.iloc[:, 0] 计算 # 所有元素乘法 df * 10 # 指定列相乘 # 注意：不会在原地修改，需要重新赋值 df['a'] = df['a'] * 10 # 指定位置操作 df.iloc[0,3] = 100 # 也可以指定多列操作，生成新列 df['e'] = df['a'] * df['b'] 合并 df_new = pd.DataFrame(np.arange(200, 230).reshape(-1, 2), columns=['z','x']) # 注意：这里因为2个DataFrame行索引没有冲突，索引这里没有问题。 # axis 为0时以行合并(可以是实现数据追加)，为1时以列合并 pd.concat([df, df_new], axis=1) # 当下面的df的行索引不连续时，df_new就会缺少一些行的数据 df = df[df.loc[:, 'a'] % 100 == 0] pd.concat([df, df_new], axis=1) # 如果当出现上面一种情况，而又不想丢掉df_new的数据时可以使用重新索引的方法 df = df.reset_index(drop=True) pd.concat([df, df_new], axis=1) 追加数据 # 不能这样追加，需要列标签相对应 df.append([1, 3, 5, 3,5]) # 新Dataframe需要和df标签对应 new_row = pd.DataFrame(np.full((1,4), 5), columns=list('abcd')) df.append(new_row) # 也可以这样 # pd.concat([df, new_row], axis=0) Apply 使用 # 当Dateframe中不再是存数字时，就不能根据直接对列进行操作生成新列，有些时候还含有复杂的条件判断，这时候既可以使用apply函数 # 注意当新加列时需要设置axis=1 df['f'] = df[['b','c']].apply(lambda x: x[0]*100 if x[0] % 2 == 0 else x[1] - 100, axis=1) 排序 # 根据索引排序,axis=0代表行，axis=1代表列 df.sort_index() # 根据值排序,可根据多个值排序 df.sort_values(by=['a']) # 如果Dataframe含有重复列，重复列的数据又不相同，但又想按值排序，可以参考下面 # 比如说2，4列名相同，想按照第2列的值排序 # sort_col_values = df.iloc[:, 2].to_numpy() # sort_indexs = sort_col_values.argsort() # df = df.iloc[:, sort_indexs] 去重 # 使用函数drop_duplicates，其中subset指定要去重的列名，不能写列索引，即指定的相同列才进行去重，默认按照所有列相同去重，keep参数可以指定保留first，last。inplace选择是否修改原Dataframe # df.drop_duplicates(subset=[], keep='first', inplace=False) # 当Dataframe有重复列名，重复列名数据不相同时，可以将Dataframe拆分，再进行去重，去重后再合并 # 例如：2，4列名重复，需要按照1，2列去重 # 拆分 front = df.iloc[:, :2] back = df.iloc[:, 2:] # 去重 front.drop_duplicates(subset=['a', 'b'], keep='first', inplace=True) back = back.iloc[front.index, :] # 合并,这里能保证行索引能一一对应，所以不用重建索引也行。当时也可以选择重建索引 pd.concat([front, back], axis=1) 字符串操作 在pandas中可以针对需要操作列方便的使用字符串的所有函数 # 举例： # 注意：这里的replace方法默认使用正则表达式，可以添加regex=False来关闭 df['a'].str.replace(regex=False) 分组和聚合 # 对指定列进行聚合计算，agg会返回分组结果，并且列数据为聚合操作后的结果 # 使用以下访问生成聚合结果 lang = df.groupby(by='姓名').agg({'语文': 'sum'}) math = df.groupby(by='姓名').agg({'数学': 'sum'}) english = df.groupby(by='姓名').agg({'英语': 'sum'}) # pd.concat([lang, math, english], axis=1) # 以上等于下面这行。 # df.groupby(by='姓名').sum() # 如果要对不同列进行不同聚合操作，可以使用以下方法： df = df.groupby(by='姓名').agg({'语文': 'sum', '姓名': 'count'}) # 注意：如果使用以上方法会出现重复列，那就需要重命名列名 df = df.rename({'姓名': 'count'}, axis=1) # 使用transform返回DataFrame # df['count'] = df.groupby(by='姓名')['数学'].transform('sum') 读取和保存 # 读取csv提供了许多使用的选项，比如可以指定分隔符，读取部分数据，跳过表头，指定列名读取 # 参考：https://www.gairuo.com/p/pandas-read-csv pd.read_csv( filepath_or_buffer: 'FilePathOrBuffer', sep=\u003cno_default\u003e, delimiter=None, header='infer', names=\u003cno_default\u003e, index_col=None, usecols=None, squeeze=False, prefix=\u003cno_default\u003e, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None, ) # 读取excel # 参考https://www.gairuo.com/p/pandas-read-excel pd.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=Fa","date":"2022-11-12","objectID":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["pandas"],"title":"Pandas使用小结","uri":"/pandas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["Numpy","Python"],"content":"Numpy 排序函数 numpy.sort(a, axis=-1, kind=None, order=None) 参数: a : 要排序的数组； axis ： 按什么轴进行排序，默认按最后一个轴进行排序； kind ：排序方法，默认是快速排序(不稳定)，可选参数有:{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’} order : 当数组定义了字段属性时，可以按照某个属性进行排序； numpy.argsort(a, axis=-1, kind=None, order=None):numpy.argsort 函数用于将数组排序后，返回数组元素从小到大依次排序的所有元素索引 参数: a : 要排序的数组 axis ： 按什么轴进行排序，默认按最后一个轴进行排序 kind ：排序方法，默认是快速排序 order : 当数组定义了字段属性时，可以按照某个属性进行排序 排序后索引解释： 比如说第一行排序后的结果为：[1, 0, 2] 表示原数组索引为 1 的数现在变为 0，原索引为 0 变为 1，原索引为 2 保持不变,即[0, 1, 2] -\u003e [1, 0, 2] numpy.lexsort(keys, axis=-1): numpy.lexsort 函数用于按照多个条件（键）进行排序，返回排序后索引。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 参数: keys ：序列或元组，要排序的不同的列 axis ：指定次排序的轴(默认为-1，即最后一个轴) 注意：根据数组的 shape 维数指定次排序轴，也就是说如果是二维数组只能设置为 0，因为 1 是著排序轴。如果 shape 为(2,3,5),则 axis 可指定为 0 或者 1 根据行和列排序 ","date":"2022-11-05","objectID":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/:0:0","tags":["numpy","sort"],"title":"Numpy使用排序","uri":"/numpy%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F/"},{"categories":["Rust","Openssl","Crypto"],"content":"AES 加密算法 AES(Advanced Encryption Standard)，全称：高级加密标准，是一种最常见的对称加密算法 ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"配置 Rust Toml 文件 [dependencies] openssl = { version = \"0.10\", features = [\"vendored\"] } ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Rust","Openssl","Crypto"],"content":"示例代码 use openssl::symm::{Cipher, Crypter, Mode}; fn main() { let key = \"061cecfd897548208c76c04b6e7fb\".as_bytes(); let crypto_word: \u0026mut Vec\u003cu8\u003e = \u0026mut \"keyword\".as_bytes().to_vec(); let block_size = Cipher::aes_128_cbc().block_size(); // 添加填充 pkcs7_padding(crypto_word, block_size); let mut output = vec![0; 1024]; // 取16位密钥 let mut encrypter = Crypter::new(Cipher::aes_128_ecb(), Mode::Encrypt, \u0026key[..16], None).unwrap(); match encrypter.update(\u0026f, \u0026mut output) { Ok(size) =\u003e { eprintln!(\"size is: {size}\"); println!(\"{:?}\", \u0026output[..size]); println!(\"{:02x?}\", \u0026output[..size]); // 转换为16进制 } Err(_) =\u003e {} }; } fn pkcs7_padding(data: \u0026mut Vec\u003cu8\u003e, block_size: usize) { let padding_num = block_size - data.len() % block_size; let padding = padding_num as u8; data.append(\u0026mut [padding].repeat(padding_num)); } 参考链接： AES 加解密-CBC ECB - 独孤剑—宇枫 - 博客园 (cnblogs.com) AES 加密(3)：AES 加密模式与填充 - 知乎 (zhihu.com) ","date":"2022-10-31","objectID":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["rust","openssl","aes"],"title":"Rust使用openssl加密算法","uri":"/rust%E4%BD%BF%E7%94%A8openssl%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["教程"],"content":"安装镜像 下载地址： https://ubuntu.com/download/raspberry-pi 刷入镜像到SD卡 刷入后需要重新拔插SD卡 找到system-boot盘符盘符下network-config文件 根据实际情况修改wifi配置 version: 2 ethernets: eth0: dhcp4: true optional: true #wifis: # wlan0: # dhcp4: true # optional: true # access-points: # myhomewifi: # password: \"S3kr1t\" # myworkwifi: # password: \"correct battery horse staple\" # workssid: # auth: # key-management: eap # method: peap # identity: \"me@example.com\" # password: \"passw0rd\" # ca-certificate: /etc/my_ca.pem 开机查找wifi 查找树莓派ip地址可用方法： 登录路由器后台查看连接设备中树莓派IP 使用Advanced_IP_Scanner软件 连接ssh 初始用户名和密码都是：ubuntu ssh ubuntu@ip 注意：第一次登陆会强制要求修改密码，修改后再次登录即可，密码也不能太短 换源 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改文件内容为: deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-updates multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-backports main restricted universe multiverse deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security main restricted deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security universe deb http://mirrors.cloud.tencent.com/ubuntu-ports jammy-security multiverse 更新 sudo apt update sudo apt upgrade -y 参考链接： 树莓派折腾记（一）– 安装系统（Ubuntu Server 20.04.1） | 修行的技术阁 (mrxiuxing.com) ","date":"2022-10-24","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/:0:0","tags":["raspberry"],"title":"树莓派安装Ubutnu无显示器网络初次开机","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ubutnu%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA/"},{"categories":["教程"],"content":"Hugo博客从零到发布 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:0:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"1. 安装 安装hugo: 下载地址：https://github.com/gohugoio/hugo/releases/tag/v0.104.3 注意： 有些主题需要下载extended版本 安装git： 下载地址：https://git-scm.com/ ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:1:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"2. 配置远程仓库，并新建一个空项目(不需要README.md文件)，名字一般和站点名相同 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:2:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 本地部署 新建站点并配置git hugo new site your_site_name # 下载你需要的主题的压缩包放到theme目录下或者使用`git submodule`拉取，例： git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt # 根据主题文档配置config.toml文件，如果只有一个主题可直接在项目根目录下的config.toml文件配置 # 0. 当本地可以正常预览站点时运行，hugo命令打包，生成静态文件 # 1. 使用git初始化站点 # 2. 添加远程仓库 git remote add origin remtoe_url # 3. 拉取远程 # 4. 提交当前代码 # 4. 新建分支(例如：release)，命令如下： git switch -c release # 或者 git checkout -b release # 5. 合并主分支分支public目录到当前分支，命令如下： git checkout master public/** # 6. 移动public下所有内容到项目根目录下，例如： mv public/* . # 7. 再提交当前分支内容 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:3:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"3. 推送到远程 # 使用git推送到远程仓库 git switch master git push -u origin master git switch release git push -u origin release # 将远程仓库默认分支设置为release ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:4:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":["教程"],"content":"4. 使用cloudflare发布 注册一个cloudflare账号：https://dash.cloudflare.com/ 点击Pages，选择创建项目下连接到Git，然后根据需要配置相应信息 ","date":"2022-10-22","objectID":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/:5:0","tags":["hugo","cloudflare"],"title":"Hugo静态博客部署","uri":"/hugo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"Kunpeng Compute安全编程指南 本文档基于C语言提供一些安全编程建议，用于指导开发实践。 数据类型 ","date":"0001-01-01","objectID":"/securecoding/:0:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保有符号整数运算不溢出 【描述】 有符号整数溢出是未定义的行为。出于安全考虑，对外部数据中的有符号整数值在如下场景中使用时，需要确保运算不会导致溢出： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 1)加法 【错误代码示例】(加法) 如下代码示例中，参与加法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = num_a + num_b; ... 【正确代码示例】(加法) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int sum = 0; if (((num_a \u003e 0) \u0026\u0026 (num_b \u003e (INT_MAX - num_a))) || ((num_a \u003c 0) \u0026\u0026 (num_b \u003c (INT_MIN - num_a)))) { ... // 错误处理 } sum = num_a + num_b; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，参与减法运算的整数是外部数据，在使用前未做校验，可能出现整数溢出，进而造成后续的内存复制操作出现缓冲区溢出。 unsigned char *content = ... // 指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 int total_len = ... // 报文总长度 int skip_len = ... // 从消息中解析出来的需要忽略的数据长度 // 用total_len - skip_len 计算剩余数据长度，可能出现整数溢出 (void)memmove(content, content + skip_len, total_len - skip_len); ... 【正确代码示例】(减法) 如下代码示例中，重构为使用size_t类型的变量表示数据长度，并校验外部数据长度是否在合法范围内。 unsigned char *content = ... //指向报文头的指针 size_t content_size = ... // 缓冲区的总长度 size_t total_len = ... // 报文总长度 size_t skip_len = ... // 从消息中解析出来的需要忽略的数据长度 if (skip_len \u003e= total_len || total_len \u003e content_size) { ... // 错误处理 } (void)memmove(content, content + skip_len, total_len - skip_len); ... 3)乘法 【错误代码示例】(乘法) 如下代码示例中，内核代码对来自用户态的数值范围做了校验，但是由于opt是int类型，而校验条件中错误的使用了ULONG_MAX进行限制，导致整数溢出。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (ULONG_MAX / (60 * HZ)))) { // 错误的使用了ULONG_MAX做上限校验 return -EINVAL; } ... = opt * 60 * HZ; // 可能出现整数溢出 ... 【正确代码示例】(乘法) 一种改进方案是将opt的类型修改为unsigned long类型，这种方案适用于修改了变量类型更符合业务逻辑的场景。 unsigned long opt = ... // 将类型重构为 unsigned long 类型。 if (opt \u003e (ULONG_MAX / (60 * HZ))) { return -EINVAL; } ... = opt * 60 * HZ; ... 另一种改进方案是将数值上限修改为INT_MAX。 int opt = ... // 来自用户态 if ((opt \u003c 0) || (opt \u003e (INT_MAX / (60 * HZ)))) { // 修改使用INT_MAX作为上限值 return -EINVAL; } ... = opt * 60 * HZ; 4)除法 【错误代码示例】(除法) 如下代码示例中，做除法运算前只检查了是否出现被零除的问题，缺少对数值范围的校验，可能出现整数溢出。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a / num_b; // 可能出现整数溢出 ... 【正确代码示例】(除法) 如下代码示例中，按照最大允许值进行校验，防止整数溢出，在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 5)求余数 【错误代码示例】(求余数) int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if (num_b == 0) { ... // 对除数为0的错误处理 } result = num_a % num_b; // 可能出现整数溢出 ... } 【正确代码示例】(求余数) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; // 检查除数为0及除法溢出错误 if ((num_b == 0) || ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... } 6)一元减 当操作数等于有符号整数类型的最小值时，在二进制补码一元求反期间会发生溢出。 【错误代码示例】(一元减) 如下代码示例中，计算前未校验数值范围，可能出现整数溢出。 int num_a = ... // 来自外部数据 int result = -num_a; // 可能出现整数溢出 ... 【正确代码示例】(一元减) 如下代码示例中，按照最大允许值进行校验，防止整数溢出。在编程时可根据具体业务场景做更严格的值域校验。 int num_a = ... // 来自外部数据 int result = 0; if (num_a == LNT_MIN) { ... // 错误处理 } result = -num_a; ... ","date":"0001-01-01","objectID":"/securecoding/:1:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保无符号整数运算不回绕 【描述】 涉及无符号操作数的计算永远不会溢出，因为超出无符号整数类型表示范围的计算结果会按照（结果类型可表示的最大值 + 1）的数值取模。 这种行为更多时候被非正式地称为无符号整数回绕。 在精度低于int的整数类型上进行运算时，需要考虑整数提升。程序员还需要掌握整数转换规则，包括隐式转换规则，以便设计安全的算术运算。 出于安全考虑，对外部数据中的无符号整数值在如下场景中使用时，需要确保运算不会导致回绕： 指针运算的整数操作数(指针偏移值) 数组索引 变长数组的长度(及长度运算表达式) 内存拷贝的长度 内存分配函数的参数 循环判断条件 1)加法 【错误代码示例】(加法) 如下代码示例中，校验下一个子报文的长度加上已处理报文的长度是否超过了整体报文的最大长度，在校验条件中的加法运算可能会出现整数回绕，造成绕过该校验的问题。 size_t total_len = ... // 报文的总长度 size_t read_len = 0 // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 从网络报文中解析出来的下一个子报文的长度 if (read_len + pkt_len \u003e total_len) { // 可能出现整数回绕 ... // 错误处理 } ... read_len += pkt_len; ... 【正确代码示例】(加法) 由于read_len变量记录的是已经处理报文的长度，必然会小于total_len，因此将代码中的加法运算修改为减法运算，导致条件绕过。 size_t total_len = ... // 报文的总长度 size_t read_len = 0; // 记录已经处理报文的长度 ... size_t pkt_len = parse_pkt_len(); // 来自网络报文 if (pkt_len \u003e total_len - read_len) { ... // 错误处理 } ... read_len += pkt_len; ... 2)减法 【错误代码示例】(减法) 如下代码示例中，校验len合法范围的运算可能会出现整数回绕，导致条件绕过。 size_t len = ... // 来自用户态输入 if (SCTP_SIZE_MAX - len \u003c sizeof(SctpAuthBytes)) { // 减法操作可能出现整数回绕 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); // 可能出现整数回绕 ... 【正确代码示例】(减法) 如下代码示例中，调整减法运算的位置（需要确保编译期间减法表达式的值不翻转），避免整数回绕问题。 size_t len = ... // 来自用户态输入 if (len \u003e SCTP_SIZE_MAX - sizeof(SctpAuthBytes)) { // 确保编译期间减法表达式的值不翻转 ... // 错误处理 } ... = kmalloc(sizeof(SctpAuthBytes) + len, gfp); ... 3)乘法 【错误代码示例】（乘法） 如下代码示例中，使用外部数据计算申请内存长度时未校验，可能出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 unsigned char *buf = (unsigned char *)malloc(width * hight); 无符号整数回绕可能导致分配的内存不足。 【正确代码示例】（乘法） 如下代码是一种解决方案，校验参与乘法运算的整数数值范围，确保不会出现整数回绕。 size_t width = ... // 来自外部数据 size_t hight = ... // 来自外部数据 if (width == 0 || hight == 0) { ... // 错误处理 } if (width \u003e SIZE_MAX / hight) { ... // 错误处理 } unsigned char *buf = (unsigned char *)malloc(width * hight); 【例外】 为正确执行程序，必要时无符号整数可能表现出模态（回绕）。建议将变量声明明确注释为支持模数行为，并且对该整数的每个操作也应明确注释为支持模数行为。 【相关软件CWE编号】 CWE-190 ","date":"0001-01-01","objectID":"/securecoding/:2:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保除法和余数运算不会导致除零错误(被零除) 【描述】 整数的除法和取余运算的第二个操作数值为0会导致程序产生未定义的行为，因此使用时要确保整数的除法和余数运算不会导致除零错误(被零除，下同)。 1)除法 【错误代码示例】(除法) 有符号整数类型的除法运算如果限制不当，会导致溢出。 如下示例对有符号整数进行的除法运算做了防止溢出限制，确保不会导致溢出，但不能防止有符号操作数num_a和num_b之间的除法过程中出现除零错误： int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a / num_b; // 可能出现除零错误 ... 【正确代码示例】(除法) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a / num_b; ... 2)取余 【错误代码示例】(求余数) 如下代码，同除法的错误代码示例一样，可能出现除零错误，因为许多平台以相同的指令实现求余数和除法运算。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_a == INT_MIN) \u0026\u0026 (num_b == -1)) { ... // 错误处理 } result = num_a % num_b; // 可能出现除零错误 ... 【正确代码示例】(求余数) 如下代码示例中，添加num_b是否为0的校验，防止除零错误。 int num_a = ... // 来自外部数据 int num_b = ... // 来自外部数据 int result = 0; if ((num_b == 0) | | ((num_a == INT_MIN) \u0026\u0026 (num_b == -1))) { ... // 错误处理 } result = num_a % num_b; ... 变量 ","date":"0001-01-01","objectID":"/securecoding/:3:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用未经初始化的变量 【描述】 这里的变量，指的是局部动态变量，并且还包括内存堆上申请的内存块。 因为他们的初始值都是不可预料的，所以禁止未经有效初始化就直接读取其值。 void foo( ...) { int data; bar(data); // 错误：未初始化就使用 ... } 如果有不同分支，要确保所有分支都得到初始化后才能使用： #define CUSTOMIZED_SIZE 100 void foo( ...) { int data; if (condition \u003e 0) { data = CUSTOMIZED_SIZE; } bar(data); // 错误：部分分支该值未初始化 ... } ","date":"0001-01-01","objectID":"/securecoding/:4:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"指向资源句柄或描述符的变量，在资源释放后立即赋予新值 【描述】 指向资源句柄或描述符的变量包括指针、文件描述符、socket描述符以及其它指向资源的变量。 以指针为例，当指针成功申请了一段内存之后，在这段内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，那这个指针就是一个悬空指针。 如果再对悬空指针操作，可能会发生重复释放或访问已释放内存的问题，造成安全漏洞。 消减该漏洞的有效方法是将释放后的指针立即设置为一个确定的新值，例如设置为NULL。对于全局性的资源句柄或描述符，在资源释放后，应该马上设置新值，以避免使用其已释放的无效值；对于只在单个函数内使用的资源句柄或描述符，应确保资源释放后其无效值不被再次使用。 【错误代码示例】 如下代码示例中，根据消息类型处理消息，处理完后释放掉body或head指向的内存，但是释放后未将指针设置为NULL。如果还有其他函数再次处理该消息结构体时，可能出现重复释放内存或访问已释放内存的问题。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); } ... EXIT: ... free(msg-\u003ebody); return ret; } 【正确代码示例】 如下代码示例中，立即对释放后的指针设置为NULL，避免重复放指针。 int foo(void) { SomeStruct *msg = NULL; ... // 初始化msg-\u003etype，分配 msg-\u003ebody 的内存空间 if (msg-\u003etype == MESSAGE_A) { ... free(msg-\u003ebody); msg-\u003ebody = NULL; } ... EXIT: ... free(msg-\u003ebody); return ret; } 当free()函数的入参为NULL时，函数不执行任何操作。 【错误代码示例】 如下代码示例中文件描述符关闭后未赋新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); ... close(fd); ... 【正确代码示例】 如下代码示例中，在资源释放后，对应的变量应该立即赋予新值。 SOCKET s = INVALID_SOCKET; int fd = -1; ... closesocket(s); s = INVALID_SOCKET; ... close(fd); fd = -1; ... 指针和数组 ","date":"0001-01-01","objectID":"/securecoding/:5:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部数据作为数组索引时必须确保在数组大小范围内 【描述】 外部数据作为数组索引对内存进行访问时，必须对数据的大小进行严格的校验，确保数组索引在有效范围内，否则会导致严重的错误。 当一个指针指向数组元素时，可以指向数组最后一个元素的下一个元素的位置，但是不能读写该位置的内存。 【错误代码示例】 如下代码示例中, set_dev_id()函数存在差一错误，当 index 等于 DEV_NUM 时，恰好越界写一个元素； 同样get_dev()函数也存在差一错误，虽然函数执行过程中没有问题，但是当解引用这个函数返回的指针时，行为是未定义的。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_id(size_t index, int id) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e DEV_NUM) { // 错误：差一错误。 ... // 错误处理 } return devs + index; } 【正确代码示例】 如下代码示例中，修改校验索引的条件，避免差一错误。 #define DEV_NUM 10 #define MAX_NAME_LEN 128 typedef struct { int id; char name[MAX_NAME_LEN]; } Dev; static Dev devs[DEV_NUM]; int set_dev_Id (size_t index, int id) { if (index \u003e= DEV_NUM) { ... // 错误处理 } devs[index].id = id; return 0; } static Dev *get_dev(size_t index) { if (index \u003e= DEV_NUM) { ... // 错误处理 } return devs + index; } 【相关软件CWE编号】 CWE-119，CWE-123，CWE-125 ","date":"0001-01-01","objectID":"/securecoding/:6:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止通过对指针变量进行sizeof操作来获取数组大小 【描述】 将指针当做数组进行sizeof操作时，会导致实际的执行结果与预期不符。例如：变量定义 char *p = array，其中array的定义为char array[LEN]，表达式sizeof(p) 得到的结果与 sizeof(char *)相同，并非array的长度。 【错误代码示例】 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了sizeof(buffer)，与预期不符。 char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小 (void)memset(buffer, 0, sizeof(buffer)); 【正确代码示例】 如下代码示例中，将sizeof(buffer)修改为申请的缓冲区大小： char path[MAX_PATH]; char *buffer = (char *)malloc(SIZE); ... (void)memset(path, 0, sizeof(path)); (void)memset(buffer, 0, SIZE); // 使用申请的缓冲区大小 字符串 ","date":"0001-01-01","objectID":"/securecoding/:7:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"确保字符串存储有足够的空间容纳字符数据和null结束符 【描述】 将数据复制到不足以容纳数据的缓冲区，会导致缓冲区溢出。缓冲区溢出经常发生在字符串操作中。为了避免这种错误，截断拷贝的数据以限制字符串的字节长度是一种防御方法，但是最好的措施是确保目标缓冲区的大小足以容纳复制数据和null结束符。当字符串存储在堆空间时， 确保分配内存时已分配了足够的空间。 部分字符串处理函数由于设计时安全考虑不足，或者存在一些隐含的目的缓冲区长度要求，容易被误用，导致缓冲区写溢出。此类典型函数包括不在C标准库函数中的itoa()，realpath()函数。 【错误代码示例】(itoa) 有些函数如itoa(), realpath()需要在对传入的缓冲区指针位置进行写入操作，但函数并没有提供缓冲区长度。因此，在调用这些函数前，必须提供足够的缓冲区。 如下代码示例中，试图将数字转为字符串，但是目标存储空间的预留长度不足： int num = ... char str[8]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【正确代码示例】 如下代码示例中，在对外部数据进行解析并将内容保存到name中，考虑了name的大小： int num = ... char str[13]; itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节 【错误代码示例】(realpath) 如下代码示例中，试图将路径标准化，但是目标存储空间的长度不足： #define MAX_PATH_LEN 100 char resolved_path[MAX_PATH_LEN]; / * - realpath函数的存储缓冲区长度是由PATH_MAX常量定义， - 或是由_PC_PATH_MAX系统值配置的，通常都大于100字节 */ char *res = realpath(path, resolved_path); ... 【正确代码示例】 可以将realpath的第二个参数传入NULL, 以让系统自动分配合适的内存。 char *resolved_path = NULL; resolved_path = realpath(path, NULL); if (resolved_path == NULL) { ... // 处理错误 } ... if (resolved_path != NULL) { free(resolved_path); resolved_path = NULL; } ... ","date":"0001-01-01","objectID":"/securecoding/:8:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"对字符串进行存储操作，确保字符串有null结束符 【描述】 部分字符串处理函数操作字符串时，将截断超出指定长度的字符串，如strncpy()函数最多复制n个字符到目的缓冲区，如果源字符串长度大于n，则不会写入null结束符到目的缓冲区，目的缓冲区的内容为n个被复制的字符。使用这类函数时，可能会无意截断导致数据丢失，并在某些情况下会导致软件漏洞。 因此，对字符串进行存储操作，必须确保字符串有null结束符，否则在后续的调用strlen等操作中，可能会导致内存越界访问漏洞。 【错误代码示例】 在如下代码示例中，使用strncpy函数复制字符串时可能会发生截断（发生条件为：strlen(name) \u003e sizeof(file_name) - 1）。当发生截断时，file_name的内容是不完整的，并且缺少 ’ 0 ‘结束符，后续对file_name的操作可能会导致软件漏洞： #define FILE_NAME_LEN 128 char file_name [FILE_NAME_LEN ]; (void)strncpy(file_name, name, sizeof(file_name) - 1); ... 【正确代码示例】 #define FILE_NAME_LEN 128 char file_name[FILE_NAME_LEN ]; if (strlen(name) \u003e FILE_NAME_LEN - 1) { ... // 处理错误 } (void)strcpy(file_name, name); ... 【例外】 程序员的目的是故意截断字符串。 【相关软件CWE编号】 CWE-170，CWE-464 断言 ","date":"0001-01-01","objectID":"/securecoding/:9:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理 【描述】 断言主要用于调试期间，在编译Release版本时将其关闭。因此，断言应该用于防止不正确的程序员假设，而不能用在Release版本上检查程序运行过程中发生的错误。 断言永远不应用于验证是否存在运行时（与逻辑相对）错误，例如 无效的用户输入（包括命令行参数和环境变量） 文件错误（例如，打开，读取或写入文件时出错） 网络错误（包括网络协议错误） 内存不足的情况（例如，malloc()类似的故障） 系统资源耗尽（例如，文件描述符，进程，线程） 系统调用错误（例如，执行文件，锁定或解锁互斥锁时出错） 无效的权限（例如，文件，内存，用户） 例如，防止缓冲区溢出的代码不能使用断言实现，因为该代码必须编译到Release版本的可执行文件中。 如果服务器程序在网运行时由恶意用户触发断言失败，会导致拒绝服务攻击。在这种情况下，更适合使用软故障模式，例如写入日志文件和拒绝请求。 【错误代码示例】 以下代码的所有ASSERT的用法是错误的。例如，错误的使用ASSERT宏来验证内存分配是否成功，因为内存的可用性取决于系统的整体状态，并且在程序运行的任何时候都可能耗尽，所以必须以具有韧性的方式来妥善处理并将程序从内存耗尽中恢复。因此，使用ASSERT宏来验证内存分配是否成功将是不合适的，因为这样做可能导致进程突然终止，从而开启了拒绝服务攻击的可能性。 FILE *fp = fopen(path, \"r\"); ASSERT(fp != NULL); // 错误用法：文件有可能打开失败 char *str = (char *)malloc(MAX_LINE); ASSERT(str != NULL); // 错误用法：内存有可能分配失败 ReadLine(fp, str); char *p = strstr(str, \"age=\"); ASSERT(p != NULL); // 错误用法：文件中不一定存在该字符串 char *end = NULL; long age = strtol(p + 4, \u0026end, 10); ASSERT(age \u003e 0); // 错误用法：文件内容不一定符合预期 【正确代码示例】 下面代码演示了如何重构上面的错误代码: FILE *fp = fopen(path, \"r\"); if (fp == NULL) { ... // 错误处理 } char *str = (char *)malloc(MAX_LINE); if (str == NULL) { ... // 错误处理 } read_line(fp, str); char *p = strstr(str, \"age=\"); if (p == NULL) { ... // 错误处理 } char *end = NULL; long age = strtol(p + 4, \u0026end, 10); if (age \u003c= 0) { ... // 错误处理 } ","date":"0001-01-01","objectID":"/securecoding/:10:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在断言内改变运行环境 【描述】 在程序正式发布阶段，断言不会被编译进去，为了确保调试版和正式版的功能一致性，严禁在断言中使用任何赋值、修改变量、资源操作、内存申请等操作。 例如，以下的断言方式是错误的： ASSERT(p1 = p2); // p1被修改 ASSERT(i++ \u003e 1000); // i被修改 ASSERT(close(fd) == 0); // fd被关闭 函数设计 ","date":"0001-01-01","objectID":"/securecoding/:11:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"数组作为函数参数时，必须同时将其长度作为函数的参数 【描述】 通过函数参数传递数组函数参数必须同时传递数组可容纳元素的个数，而不是以字节为单位的数组最大大小；同样，通过函数参数传递一块内存进行读写操作时，必须同时传递内存块大小，否则函数在访问内存偏移时，无法判断偏移的合法范围，产生越界访问的漏洞。在本规则中所说的\"数组\"不仅局限为数组类型变量，还包括字符串或指向连续内存块的指针。 【错误代码示例】 如下代码示例中，函数pars_msg不知道msg的范围，容易产生内存越界访问漏洞。 int parse_msg(unsigned char *msg) { ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg); ... } 【正确代码示例】 正确的做法是将msg的大小作为参数传递到parse_msg中，如下代码： int parse_msg(unsigned char *msg, size_t msg_len) { ASSERT(msg != NULL); ASSERT(msg_len != 0); ... } void foo(void) { size_t len = get_msg_len(); ... unsigned char *msg = (unsigned char *)malloc(len); ... parse_msg(msg, len); ... } ","date":"0001-01-01","objectID":"/securecoding/:12:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"函数的指针参数如果不是用于修改所指向的对象就应该声明为指向const的指针 【描述】 const 指针参数，将限制函数通过该指针修改所指向对象，使代码更牢固、更安全。 示例：如strncmp 的例子，指向的对象不变化的指针参数声明为const。 // 正确：不变参数声明为const int strncmp(const char *s1, const char *s2, size_t n); 注意： 指针参数要不要加const取决于函数设计，而不是看函数实体内有没有发生\"修改对象\"的动作。 ","date":"0001-01-01","objectID":"/securecoding/:13:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，禁止format参数受外部数据控制 【描述】 调用格式化函数时，如果format参数由外部数据提供，或由外部数据拼接而来，会造成字符串格式化漏洞。 攻击者如果能够完全或者部分控制格式字符串内容，可以使被攻击的进程崩溃、查看栈内容、查看内存内容或者在任意内存位置写入数据。结果是，攻击者能够以被攻击进程的权限执行任意代码。 格式化输出函数特别危险，这是因为许多程序员没有意识到它们是具有攻击能力的。比如：格式化输出函数可以使用%n转换符，向指定地址写入一个整数值。 这些格式化函数有： 格式化输出函数: xxxprintf; 格式化输入函数: xxxscanf; 格式化错误消息函数: err(), verr(), errx(), verrx(), warn(), vwarn(), warnx(), vwarnx(), error(), error_at_line(); 格式化日志函数: syslog(), vsyslog(). 【错误代码示例】 如下代码示例中的incorrect_password()函数的功能是在身份验证无效时（指定用户没有找到或者密码不正确），显示一条错误信息。 该函数接受一个源自用户的字符串数据user，而user是未验证的，是外部可控的。 该函数将user构造一条错误信息，然后用C语言标准函数fprintf打印到stderr。 // 调用者需保证入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fprintf(stderr, msg); // msg中有来自未验证的外部数据，存在格式化漏洞 } free(msg); } 示例代码中首先计算了消息的长度，然后分配内存，接着利用snprintf()函数拼接了消息内容。因此消息内容中包含了msg_format的内容和用户的内容。 当入参user中含有用户输入的格式符（如%s,%p,%n等后，fprintf()在执行时，会将msg作为一个格式化字符串来进行解析，而不是直接输出消息内容， 也就是说此时msg中的内容不会被直接打印到stderr中，反而会将一些未知的数据打印到stderr，引发程序未定义的行为。这是一个非常严重的格式化漏洞。 【正确代码示例】 下面是第一种推荐做法，代码中使用fputs()来代替fprintf()函数，fputs()会直接将msg的内容输出到stderr中，而不会去解析它。 // 入参user的长度被限制为256个字节或者更少 void incorrect_password(const char *user) { int ret = -1; static const char msg_format[] = \"%s cannot be authenticated.\\n\"; // 这里加法运算不会整数溢出，因为user有限制 size_t len = strlen(user) + 1 + sizeof(msg_format); char *msg = (char *)malloc(len); if (msg == NULL) { ... // 错误处理 } ret = snprintf(msg, msg_format, user); if (ret == -1) { ... // 错误处理 } else { fputs(stderr, msg); // 使用fputs函数代替fprintf函数 } free(msg); } 【正确代码示例】 下面是第二种推荐做法，代码中将不受信任的用户输入user作为fprintf()的可选参数之一，用\"%s\"将user以字符串的形式固定下来，然后输出到stderr中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void incorrect_password(const char *user) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; fprintf(stderr, msg_format, user); } 【错误代码示例】 如下代码示例中，使用了POSIX函数syslog()，但是syslog()函数也可能出现格式字符串漏洞。 void foo(void) { char *msg = get_msg(); ... syslog(LOG_INFO, msg); // 存在格式化漏洞 } 【正确代码示例】 下面是推荐做法，代码中将不受信任的用户输入msg作为syslog()的可选参数之一，用\"%s\"将msg以字符串的形式固定下来，然后输出到系统日志中，而不作为格式字符串的一部分，这样就消除了格式字符串漏洞出现的可能性。 void foo(void) { static const char msg_format[] = \"%s cannot be authenticated.\\n\"; char *msg = get_msg(); ... syslog(LOG_INFO, msg_format, msg); // 这里没有格式化漏洞 } 函数使用 ","date":"0001-01-01","objectID":"/securecoding/:14:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"调用格式化输入/输出函数时，使用有效的格式字符串 【描述】 格式化输入/输出函数（如fscanf()/fprintf()及相关函数）在format字符串控制下进行转换、格式化、打印其实参。 在创建格式化字符串时的常见错误包括： format中参数个数与实参个数不一致； 使用无效的转换指示符； 使用与转换指示符不兼容的标志字符； 使用与转换指示符不兼容的长度修饰符； format中转换指示符与实参类型不匹配； 使用int以外类型的实参指定宽度或者精度； 不要为格式化输入/输出函数提供未知的或者无效的转换规格，以及标志字符、精度、长度修饰符、转换指示符的无效组合。同样，不要提供与格式化字符串中的转换指示符类型不匹配的实参。这可能会使程序产生未定义行为。 【错误代码示例】 如下代码示例中，printf()的实参infoLevel类型与对应的转换指示符 ’s ‘不匹配，正确的转换指示符要使用 ’d ‘。同样，实参infoMsg类型与对应的转换指示符 ’d ‘不匹配，正确的转换指示符要使用 ’s ‘。 这些用法会使程序产生未定义行为，比如：printf()将把infoLevel实参解释为指针，试图从infoLevel包含的地址中读取一个字符串，从而发生非法访问。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %s, infoMsg: %d\\n\", info_level, info_msg); ... } 【正确代码示例】 正确的做法是确保printf()函数的实参匹配format的转换指示符。 void foo(void) { const char *info_msg = \"Information seed to user.\"; int info_level = 3; ... printf(\"infoLevel: %d, infoMsg: %s\\n\", info_level, info_msg); ... } 【影响】 错误的格式串可能造成内存破坏或者程序异常终止。 ","date":"0001-01-01","objectID":"/securecoding/:15:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用alloca()函数申请栈上内存 【描述】 POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。 请使用malloc从堆中动态分配内存。 【影响】 程序栈的大小非常有限，如果分配导致栈溢出，则程序产生未定义行 ","date":"0001-01-01","objectID":"/securecoding/:16:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止使用realloc()函数 【描述】 realloc()是一个非常特殊的函数，原型如下： void *realloc(void *ptr, size_t size); 随着参数的不同，其行为也是不同： 当ptr不为NULL，且size不为0时，该函数会重新调整内存大小，并将新的内存指针返回，并保证最小的size的内容不变； 参数ptr为NULL，但size不为0，那么其行为等同于malloc(size)； 参数size为0，则realloc的行为等同于free(ptr)。 由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编程中提供了一些便利性，如果认识不足，使用不当，是却极易引发各种bug。 【错误代码示例】 如下代码示例中，使用realloc不当导致内存泄漏。 代码中希望对ptr的空间进行扩充，当realloc()分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的，如果直接将realloc()的返回值赋给ptr，那么ptr原来指向的内存就会丢失，造成内存泄漏。 // 当realloc()分配内存失败时会返回NULL，导致内存泄漏 char *ptr = (char *)realloc(ptr, NEW_SIZE); if (ptr == NULL) { ...// 错误处理 } 【正确代码示例】 使用malloc()函数代替realloc()函数。 // 使用malloc()函数代替realloc()函数 char *new_ptr = (char *)malloc(NEW_SIZE); if (new_ptr == NULL) { ... // 错误处理 } (void)memcpy(new_ptr, old_ptr, old_size); ... // 返回前，释放old_Ptr 【影响】 使用不当容易造成内存泄漏和双重释放问题。不正确的内存对齐可能导致对象访问异常。 ","date":"0001-01-01","objectID":"/securecoding/:17:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止外部可控数据作为进程启动函数的参数 【描述】 本条款中进程启动函数包括system、popen、execl、execlp、execle、execv、execvp等。 system()、popen()等函数会创建一个新的进程，如果外部可控数据作为这些函数的参数，会导致注入漏洞。 使用execl()、execlp()等函数执行新进程时，如果使用shell启动的新进程，则同样存在命令注入风险。 因此，总是优先考虑使用C标准函数实现需要的功能。如果确实需要使用这些函数，请使用白名单机制确保这些函数的参数不受任何外来数据的影响。 【错误代码示例】 如下代码示例中，使用 system() 函数执行 cmd 命令串来自外部，攻击者可以执行任意命令： char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } system(cmd); 如下代码示例中，使用 system() 函数执行 cmd 命令串的一部分来自外部，攻击者可能输入 ‘some dir;useradd xxx ‘字符串，创建一个xxx的用户： char cmd[MAX_LEN ]; int ret; char *name = get_dir_name_from_remote(); if (name == NULL) { ... // 处理错误 } ret = sprintf(cmd, \"ls %s\", name); ... system(cmd); 使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析器(如/bin/sh)。 int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); 例如，禁止如下使用方式： char *cmd = get_dir_name_from_remote(); execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL); 【正确代码示例】 (使用库函数) 在Linux下实现对当前目录下文件名的打印，可以使用opendir(), readdir(), stat()等函数直接实现ls-l命令的功能，不必使用system()函数。下面是一个简化的ls -l示例版本，列出一个由程序内部指定的文件的信息，该函数仅考虑了不需要重入的情况。 static int OutputFileInfo(const char *file_name) { const char priv[] = {'x', 'w', 'r'}; ASSERT(file_name != NULL); struct stat st; int ret = stat(file_name, \u0026st); if (ret == -1) { return -1; } const struct passwd *pw = getpwuid(st.st_uid); if (pw == NULL) { return -1; } const struct group *gp = getgrgid(st.st_gid); if (gp == NULL) { return -1; } if (S_ISREG(st.st_mode)) { printf(\"-\"); } else if (S_ISDIR(st.st_mode)) { printf(\"d\"); } for (int i = 8; i \u003e= 0; i --) { if ((st.st_mode \u0026 (1 \u003c \u003c i)) != 0) { printf(\"%c\", priv[i % 3]); } else { printf(\"-\"); } } printf(\"%s %s %ld %s\\n\", pw-\u003epw_name, gp-\u003egr_name, st.st_size, file_name); return 0; } 【正确代码示例】 (使用exec系列函数) 可以通过库函数简单实现的功能（如上例），需要避免调用命令处理器来执行外部命令。如果确实需要调用单个命令，应使用exec *函数来实现参数化调用，并对调用的命令实施白名单管理。 pid_t pid; char * const envp[] = { NULL }; ... char *file_name = get_dir_name_from_remote(); if (file_name == NULL) { ... // 处理错误 } ... if ((pid = fork()) \u003c 0) { ... } else if (pid == 0) { // 使用some_tool对指定文件进行加工 execle( \"/bin/some_tool\", \"some_tool\", file_name, NULL, envp); _Exit(-1); } ... int status; waitpid(pid, \u0026status, 0); FILE *fp = fopen(file_name, \"r\"); ... 此时，外部输入的file_name仅作为some_tool命令的参数，没有命令注入的风险。 【正确代码示例】 (使用白名单) 对输入的文件名基于合理的白名单检查，避免命令注入。 char *cmd = get_cmd_from_remote(); if (cmd == NULL) { ... // 处理错误 } // 使用白名单检查命令是否合法，仅允许 \"some_tool_a\", \"some_tool_b\"命令，外部无法随意控制 if (!is_valid_cmd(cmd)) { ... // 处理错误 } system(cmd); ... 【相关软件CWE编号】 CWE-676，CWE-88 ","date":"0001-01-01","objectID":"/securecoding/:18:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在信号处理例程中调用非异步安全函数 【描述】 在信号处理程序中只调用异步安全函数。 除了C语言标准函数以外，其他系统函数也提供了一些的异步安全函数，在信号处理程序中使用这些函数之前，应确保调用的函数在所有可能的执行环境下均是异步安全的。 【错误代码示例】 如下代码示例中，信号处理函数中调用了非异步安全函数printf()： void handler(int num) { printf(\"receive signal = %d \\n\", SIGINT); } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { ... // 程序主循环代码 } return 0; } 【正确代码示例】 如下代码示例中，尽量不在信号处理函数中调用其他函数，仅在信号处理程序中修改volatile sig_atomic_t类型的变量： static volatile sig_atomic_t g_flag = 0; void handler(int num) { g_flag = 1; } int main(int argc, char **argv) { if (signal(SIGINT, handler) == SIG_ERR) { ... // 错误处理 } while (true) { if (g_flag != 0) { printf(\"receive signal = %d\\n\", SIGINT); } ... // 程序主循环代码 } ... return 0; } 【相关软件CWE编号】 CWE-479 内存 ","date":"0001-01-01","objectID":"/securecoding/:19:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存分配后必须判断是否成功 【描述】 内存分配一旦失败，那么后续的操作会存在未定义的行为风险。比如malloc申请失败返回了空指针，对空指针的解引用是一种未定义行为。 【错误代码示例】 如下代码示例中，调用malloc分配内存之后，没有判断是否成功，直接引用了p。如果malloc失败，它将返回一个空指针并传递给p。当如下代码在内存拷贝中解引用了该空指针p时，程序会出现未定义行为。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm*)malloc(sizeof(*tmb)); tmb-\u003eyear = year; ... return tmb; } 【正确代码示例】 如下代码示例中，在malloc分配内存之后，立即判断其是否成功，消除了上述的风险。 struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { struct tm *tmb = (struct tm *)malloc(sizeof(*tmb)); if (tmb == NULL) { ... // 错误处理 } tmb-\u003eyear = year; ... return tmb; } ","date":"0001-01-01","objectID":"/securecoding/:20:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"外部输入作为内存操作相关函数的复制长度时，需要校验其合法性 【描述】 将数据复制到容量不足以容纳该数据的内存中会导致缓冲区溢出。为了防止此类错误，必须根据目标容量的大小限制被复制的数据大小，或者必须确保目标容量足够大以容纳要复制的数据。 【错误代码示例】 外部输入的数据不一定会直接作为内存复制长度使用，还可能会间接参与内存复制操作。 如下代码示例中，inputTable-\u003ecount来自外部报文，虽然没有直接作为内存复制长度使用，而是作为for循环体的上限使用，间接参与了内存复制操作。由于没有校验其大小，可造成缓冲区溢出： typedef struct { size_t count; int val[MAX_num_bERS]; } ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } 【正确代码示例】 如下代码示例中，对input_table-\u003ecount做了校验。 typedef struct { size_t count; int val[MAX_num_bERS]; }ValueTable; ValueTable *value_table_dup(const ValueTable *input_table) { ValueTable *output_table = ... // 分配内存 ... / * - 根据应用场景，对来自外部报文的循环长度input_table-\u003ecount - 与output_table-\u003eval数组大小做校验，避免造成缓冲区溢出 */ if (input_table-\u003ecount \u003e sizeof(output_table-\u003eval) / sizeof(output_table-\u003eval[0]){ return NULL; } for (size_t i = 0; i \u003c input_table-\u003ecount; i++) { output_table-\u003eval[i] = input_table-\u003eval[i]; } ... } ","date":"0001-01-01","objectID":"/securecoding/:21:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内存中的敏感信息使用完毕后立即清0 【描述】 内存中的口令、密钥等敏感信息使用完毕后立即清0，避免被攻击者获取或者无意间泄漏给低权限用户。这里所说的内存包括但不限于： 动态分配的内存 静态分配的内存 自动分配（堆栈）内存 内存缓存 磁盘缓存 【错误代码示例】 通常内存在释放前不需要清除内存数据，因为这样在运行时会增加额外开销，所以在这段内存被释放之后，之前的数据还是会保留在其中。如果这段内存中的数据包含敏感信息，则可能会意外泄漏敏感信息。为了防止敏感信息泄漏，必须先清除内存中的敏感信息，然后再释放。 在如下代码示例中，存储在所引用的动态内存中的敏感信息secret被复制到新动态分配的缓冲区newSecret，最终通过free()释放。因为释放前未清除这块内存数据，这块内存可能被重新分配到程序的另一部分，之前存储在newSecret中的敏感信息可能会无意中被泄露。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... free(new_secret); new_secret = NULL; } ... 【正确代码示例】 如下代码示例中，为了防止信息泄漏，应先清除包含敏感信息的动态内存（用 ’ 0 ‘字符填充空间），然后再释放它。 char *secret = NULL; / * - 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符， - 并且以null终止的字节字符串 */ size_t size = strlen(secret); char *new_secret = NULL; new_secret = (char *)malloc(size + 1); if (new_secret == NULL) { ... // 错误处理 } else { strcpy(new_secret, secret); ... // 处理 new_secret ... (void)memset(new_secret, 0, size + 1); free(new_secret); new_secret = NULL; } ... 【正确代码示例】 下面是另外一个涉及敏感信息清理的场景，在代码获取到密码后，将密码保存到password中，进行密码验证，使用完毕后，通过memset对password清0。 int foo(void) { char password [MAX_PWD_LEN ] = {0}; if (!get_password(password, sizeof(password))) { ... // 处理错误 } if (!verify_password(password)) { ... // 处理错误 } ... (void)memset(password, 0, sizeof(password)); ... } 文件 ","date":"0001-01-01","objectID":"/securecoding/:22:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"创建文件时必须显式指定合适的文件访问权限 【描述】 创建文件时，如果不显式指定合适访问权限，可能会让未经授权的用户访问该文件，造成信息泄露，文件数据被篡改，文件中被注入恶意代码等风险。 虽然文件的访问权限也依赖于文件系统，但是当前许多文件创建函数（例如POSIX open函数）都具有设置（或影响）文件访问权限的功能，所以当使用这些函数创建文件时，必须显式指定合适的文件访问权限，以防止意外访问。 【错误代码示例】 使用POSIX open()函数创建文件但未显示指定该文件的访问权限，可能会导致文件创建时具有过高的访问权限，这可能会导致漏洞。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name fd = open(file_name, O_CREAT | O_WRONLY); // 没有显式指定访问权限 if (fd == -1) { ... // 错误处理 } ... } 【正确代码示例】 应该在open的第三个参数中显式指定新创建文件的访问权限。可以根据文件实际的应用情况设置何种访问权限。 void foo(void) { int fd = -1; char *file_name = NULL; ... // 初始化 file_name 和指定其访问权限 // 此处根据文件实际需要，显式指定其访问权限 int fd = open(file_name, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR); if (fd == -1) { ... // 错误处理 } ... } ","date":"0001-01-01","objectID":"/securecoding/:23:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对文件路径进行规范化后再使用 【描述】 当文件路径来自外部数据时，必须对其做合法性校验，如果不校验，可能造成系统文件的被任意访问。但是禁止直接对其进行校验，正确做法是在校验之前必须对其进行路径规范化处理，因为： 同一个文件可以通过多种形式的路径来描述和引用，例如既可以是绝对路径，也可以是相对路径；而且路径名、目录名和文件名可能包含使校验变得困难和不准确的字符（如：\".\"、\"..\"）。此外，文件还可以是符号链接，这进一步模糊了文件的实际位置或标识，增加了校验的难度和校验准确性。所以必须先将文件路径规范化，从而更容易校验其路径、目录或文件名，增加校验准确性，如使用realpath函数。 一个简单的案例说明如下： 当文件路径来自外部数据时，需要先将文件路径规范化，如果没有作规范化处理，攻击者就有机会通过恶意构造文件路径进行文件的越权访问。 例如，攻击者可以构造\"../../../etc/passwd\"的方式进行任意文件访问。 【错误代码示例】 在此错误的示例中，argv[1]包含一个源于受污染源的文件名，并且该文件名已打开以进行写入。在使用此文件名操作之前，应该对其进行验证，以确保它引用的是预期的有效文件。 不幸的是，argv[1]引用的文件名可能包含特殊字符，例如目录字符，这使验证变得困难，甚至不可能。而且，argv[1]中可能包含可以指向任意文件路径的符号链接，即使该文件名通过了验证，也会导致该文件名是无效的。 这种场景下，对文件名的直接验证即使被执行也是得不到预期的结果，对fopen()的调用可能会导致访问一个意外的文件。 ... if (!verify_file(input_file_name) { // 没有对input_file_name做规范化，直接做校验 ... // 错误处理 } if (fopen(input_file_name, \"w\") == NULL) { ... // 错误处理 } ... 【正确代码示例】 规范化文件名是具有一定难度的，因为这需要了解底层文件系统。 POSIX realpath()函数可以帮助将路径名转换为规范形式。 对上面的错误代码示例，我们采用如下解决方案： char *real_path_res = NULL; ... // 在校验之前，先对input_file_name做规范化处理 real_path_res = realpath(input_file_name, NULL); if (real_path_res == NULL) { ... // 规范化的错误处理 } // 规范化以后对路径进行校验 if (!verify_file(real_path_res) { ... // 校验的错误处理 } // 使用 if (fopen(real_path_res, \"w\") == NULL) { ... // 实际操作的错误处理 } ... free(real_path_res); real_path_res = NULL; ... 【正确代码示例】 根据我们的实际场景，我们还可以采用的第二套解决方案，说明如下： 如果PATH_MAX被定义为中的一个常量，那么使用非空的resolved_path调用realpath()也是安全的。 在本例中realpath()函数期望resolved_path引用一个字符数组，该字符数组足够大，可以容纳规范化的路径。 如果定义了PATH_MAX，则分配一个大小为PATH_MAX的缓冲区来保存realpath()的结果。正确代码示例如下： char *real_path_res = NULL; char *canonical_file_name = NULL; size_t path_size = 0; ... path_size = (size_t)PATH_MAX; if (verify_path_size(path_size) == TRUE) { canonical_file_name = (char *)malloc(path_size); if (canonical_file_name == NULL) { ... // 错误处理 } real_path_res = realpath(inputFilename, canonical_file_name); } if (real_path_res == NULL) { ... // 错误处理 } if (verify_file(real_path_res) == FALSE) { ... // 错误处理 } if (fopen(real_path_res, \"w\") == NULL ) { ... // 错误处理 } ... free(canonical_file_name); canonical_file_name = NULL; ... 【错误代码示例】 下面的代码场景是从外部获取到文件名称，拼接成文件路径后，直接对文件内容进行读取，导致攻击者可以读取到任意文件的内容： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char *text = read_file_content(untrust_path); 【正确代码示例】 正确的做法是，对路径进行规范化后，再判断路径是否是本程序所认为的合法的路径： char *file_name = get_msg_from_remote(); ... sprintf(untrust_path, \"/tmp/%s\", file_name); char path[PATH_MAX] = {0}; if (realpath(untrust_path, path) == NULL) { ... // 处理错误 } if (!is_valid_path(path)) { // 检查文件的位置是否正确 ... // 处理错误 } char *text = read_file_content(path); 【例外】 运行于控制台的命令行程序，通过控制台手工输入文件路径，可以作为本条款例外。 int main(int argc, char **argv) { int fd = -1; if (argc == 2) { fd = open(argv[1], O_RDONLY); ... } ... } ","date":"0001-01-01","objectID":"/securecoding/:24:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在共享目录中创建临时文件 【描述】 程序的临时文件应当是程序自身独享的，任何将自身临时文件置于共享目录的做法，将导致其他共享用户获得该程序的额外信息，产生信息泄露。因此，不要在任何共享目录创建仅由程序自身使用的临时文件。 程序员通常会在共享目录中(例如在/tmp和/var/tmp创建临时文件，并且还有可能会定期清除这些临时文件(例如，每晚或重新启动期间)，但也可能不注意清理。 临时文件通常用于辅助保存不能驻留在内存中的数据或存储临时的数据，也可用作进程间通信的一种手段（通过文件系统传输数据）。例如，一个进程在共享目录中创建一个临时文件，该文件名可能使用了众所周知的名称或者一个临时的名称，然后就可以通过该文件在进程间共享信息。这种通过在共享目录中创建临时文件的方法实现进程间共享的做法很危险，因为共享目录中的这些文件很容易被攻击者劫持或操纵。这里有几种缓解策略： 1.使用其他低级IPC（进程间通信）机制，例如套接字或共享内存。 2.使用更高级别的IPC机制，例如远程过程调用。 3.使用仅能由程序本身访问的安全目录(多线程/进程下注意防止条件竞争)。 同时，下面列出了几项临时文件创建使用的方法，产品根据具体场景执行以下一项或者几项，同时产品也可以自定义合适的方法。 1.文件必须具有合适的权限，只有符合权限的用户才能访问 2.创建的文件名是唯一的、或不可预测的 3.仅当文件不存在时才创建打开(原子创建打开) 4.使用独占访问打开，避免竞争条件 5.在程序退出之前移除 同时也需要注意到，当某个目录被开放读/写权限给多个用户或者一组用户时，该共享目录潜在的安全风险远远大于访问该目录中临时文件这个功能的本身。 如果想安全地在共享目录中创建临时文件，而不受威胁是不容易的。例如，用于本地挂载的文件系统的代码在与远程挂载的文件系统一起共享使用时可能会受到攻击。而且上面的函数安全版本还受限于所使用的C运行时库、操作系统和文件系统的版本。唯一安全的解决方案是不要在共享目录中创建临时文件。 【错误代码示例】 如下代码示例，程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。 由于文件名是硬编码的，因此是可预测的，攻击者只需用符号链接替换文件，然后链接所引用的目标文件就会被打开并写入新内容。 void proc_data(const char *file_name) { FILE *fp = fopen(file_name, \"wb+\"); if (fp == NULL) { ... // 错误处理 } ... // 写文件 fclose(fp); } int main(void) { // 不合规：1.在系统共享目录中创建临时文件；2.临时文件名硬编码 char *real_file = \"/tmp/data\"; ... proc_data(real_file); ... return 0; } 【正确案例】 Linux下的/tmp目录是一个所有用户都可以访问的共享目录，不应在该目录下创建仅由程序自身使用的临时文件。 【业界典型漏洞】CVE-2004-2502 其它 ","date":"0001-01-01","objectID":"/securecoding/:25:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"不要在信号处理函数中访问共享对象 【描述】 在信号处理程序中访问和修改共享对象可能会造成竞争条件，使数据处于不确定的状态。 这条规则有两个不适用的场景（C11标准第5.1.2.3章节第5段）是： 1） 读写不需要加锁的原子对象; 2）读写volatile sig_atomic_t类型的对象，因为具有volatile sig_atomic_t类型的对象即使在出现异步中断的时候也可以作为一个原子实体访问，是异步安全的。 此外，在信号处理程序中，如果要调用函数，请仅调用异步信号安全函数。 【错误代码示例】 在这个信号处理过程中，程序打算将p_msg作为共享对象，当产生SIGINT信号时更新共享对象的内容，但是该p_msg变量类型不是volatile sig_atomic_t，所以不是异步安全的。 #define MAX_MSG_SIZE 32 static char g_msg_buf[MAX_MSG_SIZE] = {0}; static char *g_msg = g_msg_buf; void signal_handler(int signum) { // 下面代码操作g_msg不合规，因为不是异步安全的 (void)memset(g_msg, 0, MAX_MSG_SIZE); strcpy(g_msg, \"signal SIGINT received.\"); ... // } int main(void) { strcpy(g_msg, \"No msg yet.\"); // 初始化消息内容 signal(SIGINT, signal_handler); // 设置SIGINT信号对应的处理函数 ... // 程序主循环代码 return 0; } 【正确代码示例】 如下代码示例中，在信号处理函数中仅将volatile sig_atomic_t类型作为共享对象使用。 #define MAX_MSG_SIZE 32 volatile sig_atomic_t g_sig_flag = 0; void signal_handler(int signum) { g_sig_flag = 1; // 合规 } int main(void) { signal(SIGINT, signal_handler); char msg_buf[MAX_MSG_SIZE]; strcpy(msg_buf, \"No msg yet.\"); // 初始化消息内容 ... // 程序主循环代码 if (g_sig_flag == 1) { // 在退出主循环之后，根据sigFlag状态再刷新消息内容 strcpy(msgBuf, \"signal SIGINT received.\"); } return 0; } 【相关软件CWE编号】 CWE-662，CWE-828 ","date":"0001-01-01","objectID":"/securecoding/:26:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁用rand函数产生用于安全用途的伪随机数 【描述】 C语言标准库rand()函数生成的是伪随机数，所以不能保证其产生的随机数序列质量。所以禁止使用rand()函数产生的随机数用于安全用途，必须使用安全的随机数产生方式，如： /dev/random文件。 典型的安全用途场景包括(但不限于)以下几种： 会话标识SessionID的生成； 挑战算法中的随机数生成； 验证码的随机数生成； 用于密码算法用途（例如用于生成IV、盐值、密钥等）的随机数生成。 【错误代码示例】 程序员期望生成一个唯一的不可被猜测的HTTP会话ID，但该ID是通过调用rand()函数产生的数字随机数，它的ID是可猜测的，并且随机性有限。 【正确代码示例】(POSIX) 可以使用/dev/random文件得到随机数。 【影响】 使用rand()函数可能造成可预测的随机数。 内核操作 ","date":"0001-01-01","objectID":"/securecoding/:27:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核mmap接口实现中，确保对映射起始地址和大小进行合法性校验 【描述】 **说明：**Linux内核 mmap接口中，经常使用remap_pfn_range()函数将设备物理内存映射到用户进程空间。如果映射起始地址等参数由用户态控制并缺少合法性校验，将导致用户态可通过映射读写任意内核地址。如果攻击者精心构造传入参数，甚至可在内核中执行任意代码。 【错误代码示例】 如下代码在使用remap_pfn_range()进行内存映射时，未对用户可控的映射起始地址和空间大小进行合法性校验，可导致内核崩溃或任意代码执行。 static int incorrect_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); //错误：未对映射起始地址、空间大小做合法性校验 if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log(\"%s, remap_pfn_range fail\", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } 【正确代码示例】 增加对映射起始地址等参数的合法性校验。 static int correct_mmap(struct file *file, struct vm_area_struct *vma) { unsigned long size; size = vma-\u003evm_end - vma-\u003evm_start; //修改：添加校验函数，验证映射起始地址、空间大小是否合法 if (!valid_mmap_phys_addr_range(vma-\u003evm_pgoff, size)) { return EINVAL; } vma-\u003evm_page_prot = pgprot_noncached(vma-\u003evm_page_prot); if (remap_pfn_range(vma, vma-\u003evm_start, vma-\u003evm_pgoff, size, vma-\u003evm_page_prot)) { err_log( \"%s, remap_pfn_range fail \", __func__); return EFAULT; } else { vma-\u003evm_flags \u0026= ~VM_IO; } return EOK; } ","date":"0001-01-01","objectID":"/securecoding/:28:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"内核程序中必须使用内核专用函数读写用户态缓冲区 【描述】 用户态与内核态之间进行数据交换时，如果在内核中不加任何校验（如校验地址范围、空指针）而直接引用用户态传入指针，当用户态传入非法指针时，可导致内核崩溃、任意地址读写等问题。因此，应当禁止使用memcpy()、sprintf()等危险函数，而是使用内核提供的专用函数：copy_from_user()、copy_to_user()、put_user()和get_user()来读写用户态缓冲区，这些函数内部添加了入参校验功能。 所有禁用函数列表为：memcpy()、bcopy()、memmove()、strcpy()、strncpy()、strcat()、strncat()、sprintf()、vsprintf()、snprintf()、vsnprintf()、sscanf()、vsscanf()。 【错误代码示例】 内核态直接使用用户态传入的buf指针作为snprintf()的参数，当buf为NULL时，可导致内核崩溃。 ssize_t incorrect_show(struct file *file, char__user *buf, size_t size, loff_t *data) { // 错误：直接引用用户态传入指针，如果buf为NULL，则空指针异常导致内核崩溃 return snprintf(buf, size, \"%ld\\n\", debug_level); } 【正确代码示例】 使用copy_to_user()函数代替snprintf()。 ssize_t correct_show(struct file *file, char __user *buf, size_t size, loff_t *data) { int ret = 0; char level_str[MAX_STR_LEN] = {0}; snprintf(level_str, MAX_STR_LEN, \"%ld \\n\", debug_level); if(strlen(level_str) \u003e= size) { return EFAULT; } // 修改：使用专用函数copy_to_user()将数据写入到用户态buf，并注意防止缓冲区溢出 ret = copy_to_user(buf, level_str, strlen(level_str)+1); return ret; } 【错误代码示例】 内核态直接使用用户态传入的指针user_buf作为数据源进行memcpy()操作，当user_buf为NULL时，可导致内核崩溃。 size_t incorrect_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf [128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 错误：直接引用用户态传入指针，如果user_buf为NULL，则可导致内核崩溃 (void)memcpy(buf, user_buf, buf_size); ... } 【正确代码示例】 使用copy_from_user()函数代替memcpy()。 ssize_t correct_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) { ... char buf[128] = {0}; int buf_size = 0; buf_size = min(count, (sizeof(buf)-1)); // 修改：使用专用函数copy_from_user()将数据写入到内核态buf，并注意防止缓冲区溢出 if (copy_from_user(buf, user_buf, buf_size)) { return EFAULT; } ... } ","date":"0001-01-01","objectID":"/securecoding/:29:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_from_user()拷贝长度进行校验，防止缓冲区溢出 **说明：**内核态从用户态拷贝数据时通常使用copy_from_user()函数，如果未对拷贝长度做校验或者校验不当，会造成内核缓冲区溢出，导致内核panic或提权。 【错误代码示例】 未校验拷贝长度。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))) {...} // 错误：拷贝长度参数smd_write_arg.size由用户输入，未校验 copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } 【正确代码示例】 添加长度校验。 static long gser_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { char smd_write_buf[GSERIAL_BUF_LEN]; switch (cmd) { case GSERIAL_SMD_WRITE: if (copy_from_user(\u0026smd_write_arg, argp, sizeof(smd_write_arg))){...} // 修改：添加校验 if (smd_write_arg.size \u003e= GSERIAL_BUF_LEN) {......} copy_from_user(smd_write_buf, smd_write_arg.buf, smd_write_arg.size); ... } } ","date":"0001-01-01","objectID":"/securecoding/:30:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"必须对copy_to_user()拷贝的数据进行初始化，防止信息泄漏 【描述】 **说明：**内核态使用copy_to_user()向用户态拷贝数据时，当数据未完全初始化（如结构体成员未赋值、字节对齐引起的内存空洞等），会导致栈上指针等敏感信息泄漏。攻击者可利用绕过kaslr等安全机制。 【错误代码示例】 未完全初始化数据结构成员。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; // 错误: info结构体有4个成员，未全部赋值 ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } 【正确代码示例】 全部进行初始化。 static long rmnet_ctrl_ioctl(struct file *fp, unsigned cmd, unsigned long arg) { struct ep_info info; // 修改：使用memset初始化缓冲区，保证不存在因字节对齐或未赋值导致的内存空洞 (void)memset(\u0026info, '0', sizeof(ep_info)); switch (cmd) { case FRMNET_CTRL_EP_LOOKUP: info.ph_ep_info.ep_type = DATA_EP_TYPE_HSUSB; info.ipa_ep_pair.cons_pipe_num = port-\u003eipa_cons_idx; info.ipa_ep_pair.prod_pipe_num = port-\u003eipa_prod_idx; ret = copy_to_user((void __user *)arg, \u0026info, sizeof(info)); ... } } ","date":"0001-01-01","objectID":"/securecoding/:31:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"禁止在异常处理中使用BUG_ON宏，避免造成内核panic 【描述】 BUG_ON宏会调用内核的panic()函数，打印错误信息并主动崩溃系统，在正常逻辑处理中（如ioctl接口的cmd参数不识别）不应当使系统崩溃，禁止在此类异常处理场景中使用BUG_ON宏，推荐使用WARN_ON宏。 【错误代码示例】 正常流程中使用了BUG_ON宏 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 错误：系统BUG_ON宏打印调用栈后调用panic()，导致内核拒绝服务，不应在正常流程中使用 BUG_ON(1); return 1; } ... } 【正确代码示例】 去掉BUG_ON宏。 / * 判断Q6侧设置定时器是否繁忙，1-忙，0-不忙 */ static unsigned int is_modem_set_timer_busy(special_timer *smem_ptr) { int i = 0; if (smem_ptr == NULL) { printk(KERN_EMERG\"%s:smem_ptr NULL!\\n\", __FUNCTION__); // 修改：去掉BUG_ON调用，或使用WARN_ON return 1; } ... } ","date":"0001-01-01","objectID":"/securecoding/:32:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"在中断处理程序或持有自旋锁的进程上下文代码中，禁止使用会引起进程休眠的函数 【描述】 Linux以进程为调度单位，在Linux中断上下文中，只有更高优先级的中断才能将其打断，系统在中断处理的时候不能进行进程调度。如果中断处理程序处于休眠状态，就会导致内核无法唤醒，从而使得内核处于瘫痪。 自旋锁在使用时，抢占是失效的。若自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其它进程都将因为不能获得CPU（单核CPU）而停止运行，对外表现为系统将不作任何响应，出现挂死。 因此，在中断处理程序或持有自旋锁的进程上下文代码中，应该禁止使用可能会引起休眠（如vmalloc()、msleep()等）、阻塞（如copy_from_user(),copy_to_user()等）或者耗费大量时间（如printk()等）的函数。 ","date":"0001-01-01","objectID":"/securecoding/:33:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"合理使用内核栈，防止内核栈溢出 【描述】 Linux的内核栈大小是固定的（一般32位系统为8K，64位系统为16K，因此资源非常宝贵。不合理的使用内核栈，可能会导致栈溢出，造成系统挂死。因此需要做到以下几点： 在栈上申请内存空间不要超过内核栈大小； 注意函数的嵌套使用次数； 不要定义过多的变量。 【错误代码示例】 以下代码中定义的变量过大，导致栈溢出。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result temp[512]; // 错误: temp数组含有512个元素，总大小为10K，远超内核栈大小 (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something return 0; } ... 代码中数组temp有512个元素，总共10K大小，远超内核的8K，明显的栈溢出。 【正确代码示例】 使用kmalloc()代替之。 ... struct result { char name[4]; unsigned int a; unsigned int b; unsigned int c; unsigned int d; }; // 结构体result的大小为20字节 int foo() { struct result *temp = NULL; temp = (result *)kmalloc(sizeof(result) * 512, GFP_KERNEL); //修改：使用kmalloc()申请内存 ... // check temp is not NULL (void)memset(temp, 0, sizeof(result) * 512); ... // use temp do something ... // free temp return 0; } ... ","date":"0001-01-01","objectID":"/securecoding/:34:0","tags":null,"title":"","uri":"/securecoding/"},{"categories":null,"content":"临时关闭地址校验机制后，在操作完成后必须及时恢复 【描述】 SMEP安全机制是指禁止内核执行用户空间的代码（PXN是ARM版本的SMEP）。系统调用（如open()，write()等）本来是提供给用户空间程序访问的。默认情况下，这些函数会对传入的参数地址进行校验，如果入参是非用户空间地址则报错。因此，要在内核程序中使用这些系统调用，就必须使参数地址校验功能失效。set_fs()/get_fs()就用来解决该问题。详细说明见如下代码： ... mmegment_t old_fs; printk(\"Hello, I'm the module that intends to write message to file.\\n\"); if (file == NULL) { file = filp_open(MY_FILE, O_RDWR | O_APPEND | O_CREAT, 0664); } if (IS_ERR(file)) { printk(\"Error occured while opening file %s, exiting ...\\n\", MY_FILE); return 0; } sprintf(buf, \"%s\", \"The Message.\"); old_fs = get_fs(); // get_fs()的作用是获取用户空间地址上限值 // #define get_fs() (current-\u003eaddr_limit set_fs(KERNEL_DS); // set_fs的作用是将地址空间上限扩大到KERNEL_DS，这样内核代码可以调用系统函数 file-\u003ef_op-\u003ewrite(file, (char *)buf, sizeof(buf), \u0026file-\u003ef_pos); // 内核代码可以调用write()函数 set_fs(old_fs); // 使用完后及时恢复原来用户空间地址限制值 ... 通过上述代码，可以了解到最为关键的就是操作完成后，要及时恢复地址校验功能。否则SMEP/PXN安全机制就会失效，使得许多漏洞的利用变得很容易。 【错误代码示例】 在程序错误处理分支，未通过set_fs()恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d]\\n\", path, fd); return; // 错误：在错误处理程序分支未恢复地址校验机制 } sys_close(fd); set_fs(oldfs); ... 【正确代码示例】 在错误处理程序中恢复地址校验功能。 ... oldfs = get_fs(); set_fs(KERNEL_DS); /* 在时间戳目录下面创建done文件 */ fd = sys_open(path, O_CREAT | O_WRONLY, FILE_LIMIT); if (fd \u003c 0) { BB_PRINT_ERR(\"sys_mkdir[%s] error, fd is[%d] \\n\", path, fd); set_fs(oldfs); // 修改：在错误处理程序分支中恢复地址校验机制 return; } sys_close(fd); set_fs(oldfs); ... ","date":"0001-01-01","objectID":"/securecoding/:35:0","tags":null,"title":"","uri":"/securecoding/"}]